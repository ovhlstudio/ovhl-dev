---
type: packages-snapshot
purpose: External Library Documentation & Context
---

# ğŸ“¦ OVHL EXTERNAL PACKAGES CONTEXT

> **ğŸ¤– INSTRUCTIONS FOR AI:**
> 
> This document contains the **FULL SOURCE CODE** of all external libraries used in the OVHL Framework (e.g., Fusion, OnyxUI, Promise, TopbarPlus).
> 
> **YOUR GOAL:**
> 1.  **Analyze APIs:** Read these files to understand exactly what functions, properties, and components are available.
> 2.  **Identify Patterns:** Learn how these libraries are intended to be used (e.g., Fusion scopes, Onyx theming, Promise chaining).
> 3.  **Source of Truth:** When writing code for OVHL, **ONLY** use the APIs defined in this document. Do not hallucinate methods that do not exist here.
> 4.  **Resolve Imports:** Use the file paths provided here to understand where `require()` calls are pointing.

---

# ğŸ“‚ Directory Structure
```
ğŸ“¦ Packages/
  â”œâ”€â”€ ğŸ“ _Index/
    â”œâ”€â”€ ğŸ“ 1foreverhd_topbarplus@3.4.0/
      â”œâ”€â”€ ğŸ“ topbarplus/
        â”œâ”€â”€ ğŸ“‹ default.project.json
        â”œâ”€â”€ ğŸ“„ LICENSE
        â”œâ”€â”€ ğŸ“ src/
          â”œâ”€â”€ ğŸŒ™ Attribute.lua
          â”œâ”€â”€ ğŸ“ Elements/
            â”œâ”€â”€ ğŸŒ™ Caption.lua
            â”œâ”€â”€ ğŸŒ™ Container.lua
            â”œâ”€â”€ ğŸŒ™ Dropdown.lua
            â”œâ”€â”€ ğŸŒ™ Indicator.lua
            â”œâ”€â”€ ğŸŒ™ Menu.lua
            â”œâ”€â”€ ğŸŒ™ Notice.lua
            â”œâ”€â”€ ğŸŒ™ Selection.lua
            â”œâ”€â”€ ğŸŒ™ Widget.lua
          â”œâ”€â”€ ğŸ“ Features/
            â”œâ”€â”€ ğŸŒ™ Gamepad.lua
            â”œâ”€â”€ ğŸŒ™ Overflow.lua
            â”œâ”€â”€ ğŸ“ Themes/
              â”œâ”€â”€ ğŸŒ™ Classic.lua
              â”œâ”€â”€ ğŸŒ™ Default.lua
              â”œâ”€â”€ ğŸŒ™ init.lua
          â”œâ”€â”€ ğŸŒ™ init.lua
          â”œâ”€â”€ ğŸ“ Packages/
            â”œâ”€â”€ ğŸŒ™ GoodSignal.lua
            â”œâ”€â”€ ğŸŒ™ Janitor.lua
          â”œâ”€â”€ ğŸŒ™ Reference.lua
          â”œâ”€â”€ ğŸŒ™ Types.lua
          â”œâ”€â”€ ğŸŒ™ Utility.lua
          â”œâ”€â”€ ğŸŒ™ VERSION.lua
        â”œâ”€â”€ âš™ï¸ wally.toml
    â”œâ”€â”€ ğŸ“ csqrl_colour-utils@1.4.1/
      â”œâ”€â”€ ğŸ“ colour-utils/
        â”œâ”€â”€ ğŸ“‹ default.project.json
        â”œâ”€â”€ ğŸ“ src/
          â”œâ”€â”€ ğŸ“ APCA/
            â”œâ”€â”€ ğŸŒ™ Const.lua
            â”œâ”€â”€ ğŸŒ™ GetContrastRatio.lua
            â”œâ”€â”€ ğŸŒ™ init.lua
          â”œâ”€â”€ ğŸ“ Blend/
            â”œâ”€â”€ ğŸŒ™ _Filter.lua
            â”œâ”€â”€ ğŸŒ™ Burn.lua
            â”œâ”€â”€ ğŸŒ™ Dodge.lua
            â”œâ”€â”€ ğŸŒ™ init.lua
            â”œâ”€â”€ ğŸŒ™ Multiply.lua
            â”œâ”€â”€ ğŸŒ™ Overlay.lua
            â”œâ”€â”€ ğŸŒ™ Screen.lua
            â”œâ”€â”€ ğŸŒ™ Transparency.lua
          â”œâ”€â”€ ğŸ“ Blind/
            â”œâ”€â”€ ğŸŒ™ Enum.lua
            â”œâ”€â”€ ğŸŒ™ init.lua
            â”œâ”€â”€ ğŸ“ Simulate/
              â”œâ”€â”€ ğŸŒ™ Configs.lua
              â”œâ”€â”€ ğŸŒ™ init.lua
          â”œâ”€â”€ ğŸŒ™ Darken.lua
          â”œâ”€â”€ ğŸŒ™ Desaturate.lua
          â”œâ”€â”€ ğŸŒ™ Emphasize.lua
          â”œâ”€â”€ ğŸŒ™ GetContrastRatioCompat.lua
          â”œâ”€â”€ ğŸŒ™ GetLuminance.lua
          â”œâ”€â”€ ğŸŒ™ GetPerceivedBrightness.lua
          â”œâ”€â”€ ğŸ“ Hex/
            â”œâ”€â”€ ğŸŒ™ init.lua
          â”œâ”€â”€ ğŸ“ HSL/
            â”œâ”€â”€ ğŸŒ™ init.lua
          â”œâ”€â”€ ğŸŒ™ init.lua
          â”œâ”€â”€ ğŸ“ Int/
            â”œâ”€â”€ ğŸŒ™ init.lua
          â”œâ”€â”€ ğŸŒ™ Invert.lua
          â”œâ”€â”€ ğŸŒ™ isDark.lua
          â”œâ”€â”€ ğŸŒ™ isLight.lua
          â”œâ”€â”€ ğŸ“ LAB/
            â”œâ”€â”€ ğŸŒ™ Constants.lua
            â”œâ”€â”€ ğŸŒ™ FromLAB.lua
            â”œâ”€â”€ ğŸŒ™ init.lua
            â”œâ”€â”€ ğŸŒ™ Lerp.lua
            â”œâ”€â”€ ğŸŒ™ ToLAB.lua
          â”œâ”€â”€ ğŸ“ LCH/
            â”œâ”€â”€ ğŸŒ™ Constants.lua
            â”œâ”€â”€ ğŸŒ™ FromLCH.lua
            â”œâ”€â”€ ğŸŒ™ init.lua
            â”œâ”€â”€ ğŸŒ™ ToLCH.lua
          â”œâ”€â”€ ğŸŒ™ Lighten.lua
          â”œâ”€â”€ ğŸ“ Palette/
            â”œâ”€â”€ ğŸŒ™ Analogous.lua
            â”œâ”€â”€ ğŸŒ™ Complementary.lua
            â”œâ”€â”€ ğŸŒ™ init.lua
            â”œâ”€â”€ ğŸŒ™ Monochromatic.lua
            â”œâ”€â”€ ğŸŒ™ Nearest.lua
            â”œâ”€â”€ ğŸŒ™ SplitComplementary.lua
            â”œâ”€â”€ ğŸŒ™ Tailwind.lua
            â”œâ”€â”€ ğŸŒ™ Tetradic.lua
            â”œâ”€â”€ ğŸŒ™ Triadic.lua
            â”œâ”€â”€ ğŸŒ™ Vibrant.lua
          â”œâ”€â”€ ğŸŒ™ Rotate.lua
          â”œâ”€â”€ ğŸŒ™ Saturate.lua
          â”œâ”€â”€ ğŸ“ Util/
            â”œâ”€â”€ ğŸŒ™ Array.lua
            â”œâ”€â”€ ğŸŒ™ Assert.lua
            â”œâ”€â”€ ğŸŒ™ BasicallyIdentical.lua
            â”œâ”€â”€ ğŸŒ™ ClampColor.lua
            â”œâ”€â”€ ğŸŒ™ DeprecateWarnOnce.lua
            â”œâ”€â”€ ğŸŒ™ init.lua
            â”œâ”€â”€ ğŸŒ™ isNaN.lua
            â”œâ”€â”€ ğŸŒ™ Schema.lua
            â”œâ”€â”€ ğŸŒ™ Types.lua
          â”œâ”€â”€ ğŸ“ WCAG/
            â”œâ”€â”€ ğŸŒ™ GetContrastingColor.lua
            â”œâ”€â”€ ğŸŒ™ GetContrastRatio.lua
            â”œâ”€â”€ ğŸŒ™ init.lua
        â”œâ”€â”€ ğŸ“„ wally.lock
        â”œâ”€â”€ âš™ï¸ wally.toml
    â”œâ”€â”€ ğŸ“ elttob_fusion@0.3.0/
      â”œâ”€â”€ ğŸ“ fusion/
        â”œâ”€â”€ ğŸ“‹ default.project.json
        â”œâ”€â”€ ğŸ“ src/
          â”œâ”€â”€ ğŸ“ Animation/
            â”œâ”€â”€ ğŸŒ™ ExternalTime.luau
            â”œâ”€â”€ ğŸŒ™ getTweenDuration.luau
            â”œâ”€â”€ ğŸŒ™ getTweenRatio.luau
            â”œâ”€â”€ ğŸŒ™ lerpType.luau
            â”œâ”€â”€ ğŸŒ™ packType.luau
            â”œâ”€â”€ ğŸŒ™ Spring.luau
            â”œâ”€â”€ ğŸŒ™ springCoefficients.luau
            â”œâ”€â”€ ğŸŒ™ Stopwatch.luau
            â”œâ”€â”€ ğŸŒ™ Tween.luau
            â”œâ”€â”€ ğŸŒ™ unpackType.luau
          â”œâ”€â”€ ğŸ“ Colour/
            â”œâ”€â”€ ğŸŒ™ Oklab.luau
            â”œâ”€â”€ ğŸŒ™ sRGB.luau
          â”œâ”€â”€ ğŸŒ™ External.luau
          â”œâ”€â”€ ğŸŒ™ ExternalDebug.luau
          â”œâ”€â”€ ğŸ“ Graph/
            â”œâ”€â”€ ğŸŒ™ castToGraph.luau
            â”œâ”€â”€ ğŸŒ™ change.luau
            â”œâ”€â”€ ğŸŒ™ depend.luau
            â”œâ”€â”€ ğŸŒ™ evaluate.luau
            â”œâ”€â”€ ğŸŒ™ Observer.luau
          â”œâ”€â”€ ğŸŒ™ init.luau
          â”œâ”€â”€ ğŸ“ Instances/
            â”œâ”€â”€ ğŸŒ™ applyInstanceProps.luau
            â”œâ”€â”€ ğŸŒ™ Attribute.luau
            â”œâ”€â”€ ğŸŒ™ AttributeChange.luau
            â”œâ”€â”€ ğŸŒ™ AttributeOut.luau
            â”œâ”€â”€ ğŸŒ™ Child.luau
            â”œâ”€â”€ ğŸŒ™ Children.luau
            â”œâ”€â”€ ğŸŒ™ defaultProps.luau
            â”œâ”€â”€ ğŸŒ™ Hydrate.luau
            â”œâ”€â”€ ğŸŒ™ New.luau
            â”œâ”€â”€ ğŸŒ™ OnChange.luau
            â”œâ”€â”€ ğŸŒ™ OnEvent.luau
            â”œâ”€â”€ ğŸŒ™ Out.luau
          â”œâ”€â”€ ğŸ“ Logging/
            â”œâ”€â”€ ğŸŒ™ formatError.luau
            â”œâ”€â”€ ğŸŒ™ messages.luau
            â”œâ”€â”€ ğŸŒ™ parseError.luau
          â”œâ”€â”€ ğŸ“ Memory/
            â”œâ”€â”€ ğŸŒ™ checkLifetime.luau
            â”œâ”€â”€ ğŸŒ™ deriveScope.luau
            â”œâ”€â”€ ğŸŒ™ deriveScopeImpl.luau
            â”œâ”€â”€ ğŸŒ™ doCleanup.luau
            â”œâ”€â”€ ğŸŒ™ innerScope.luau
            â”œâ”€â”€ ğŸŒ™ legacyCleanup.luau
            â”œâ”€â”€ ğŸŒ™ needsDestruction.luau
            â”œâ”€â”€ ğŸŒ™ poisonScope.luau
            â”œâ”€â”€ ğŸŒ™ scoped.luau
            â”œâ”€â”€ ğŸŒ™ scopePool.luau
            â”œâ”€â”€ ğŸŒ™ whichLivesLonger.luau
          â”œâ”€â”€ ğŸŒ™ RobloxExternal.luau
          â”œâ”€â”€ ğŸ“ State/
            â”œâ”€â”€ ğŸŒ™ castToState.luau
            â”œâ”€â”€ ğŸŒ™ Computed.luau
            â”œâ”€â”€ ğŸ“ For/
              â”œâ”€â”€ ğŸŒ™ Disassembly.luau
              â”œâ”€â”€ ğŸŒ™ ForTypes.luau
              â”œâ”€â”€ ğŸŒ™ init.luau
            â”œâ”€â”€ ğŸŒ™ ForKeys.luau
            â”œâ”€â”€ ğŸŒ™ ForPairs.luau
            â”œâ”€â”€ ğŸŒ™ ForValues.luau
            â”œâ”€â”€ ğŸŒ™ peek.luau
            â”œâ”€â”€ ğŸŒ™ updateAll.luau
            â”œâ”€â”€ ğŸŒ™ Value.luau
          â”œâ”€â”€ ğŸŒ™ Types.luau
          â”œâ”€â”€ ğŸ“ Utility/
            â”œâ”€â”€ ğŸŒ™ Contextual.luau
            â”œâ”€â”€ ğŸŒ™ isSimilar.luau
            â”œâ”€â”€ ğŸŒ™ merge.luau
            â”œâ”€â”€ ğŸŒ™ nameOf.luau
            â”œâ”€â”€ ğŸŒ™ never.luau
            â”œâ”€â”€ ğŸŒ™ nicknames.luau
            â”œâ”€â”€ ğŸŒ™ Safe.luau
            â”œâ”€â”€ ğŸŒ™ xtypeof.luau
        â”œâ”€â”€ âš™ï¸ wally.toml
    â”œâ”€â”€ ğŸ“ evaera_promise@4.0.0/
      â”œâ”€â”€ ğŸ“ promise/
        â”œâ”€â”€ âš™ï¸ aftman.toml
        â”œâ”€â”€ ğŸ“„ CHANGELOG.md
        â”œâ”€â”€ ğŸ“‹ default.project.json
        â”œâ”€â”€ ğŸ“ docs/
          â”œâ”€â”€ ğŸ“„ Examples.md
          â”œâ”€â”€ ğŸ“„ Installation.md
          â”œâ”€â”€ ğŸ“„ intro.md
          â”œâ”€â”€ ğŸ“„ Tour.md
          â”œâ”€â”€ ğŸ“„ WhyUsePromises.md
        â”œâ”€â”€ âš™ï¸ foreman.toml
        â”œâ”€â”€ ğŸ“ lib/
          â”œâ”€â”€ ğŸŒ™ init.lua
        â”œâ”€â”€ ğŸ“„ LICENSE
        â”œâ”€â”€ ğŸ“ modules/
          â”œâ”€â”€ ğŸ“ testez/
            â”œâ”€â”€ ğŸ“„ .editorconfig
            â”œâ”€â”€ ğŸ“„ .git
            â”œâ”€â”€ ğŸ“ .github/
              â”œâ”€â”€ ğŸ“ workflows/
                â”œâ”€â”€ ğŸ“„ ci.yml
                â”œâ”€â”€ ğŸ“„ clabot.yml
                â”œâ”€â”€ ğŸ“„ release.yml
            â”œâ”€â”€ ğŸ“„ .gitignore
            â”œâ”€â”€ ğŸ“„ .gitmodules
            â”œâ”€â”€ ğŸ“„ .luacheckrc
            â”œâ”€â”€ ğŸ“„ Cargo.lock
            â”œâ”€â”€ âš™ï¸ Cargo.toml
            â”œâ”€â”€ ğŸ“„ CHANGELOG.md
            â”œâ”€â”€ ğŸ“„ CONTRIBUTING.md
            â”œâ”€â”€ ğŸ“‹ default.project.json
            â”œâ”€â”€ ğŸ“„ DESIGN.md
            â”œâ”€â”€ ğŸ“ docs/
              â”œâ”€â”€ ğŸ“„ api-reference.md
              â”œâ”€â”€ ğŸ“ getting-started/
                â”œâ”€â”€ ğŸ“„ debugging-tests.md
                â”œâ”€â”€ ğŸ“„ installation.md
                â”œâ”€â”€ ğŸ“„ running-tests.md
                â”œâ”€â”€ ğŸ“„ writing-tests.md
              â”œâ”€â”€ ğŸ“„ index.md
              â”œâ”€â”€ ğŸ“„ requirements.txt
            â”œâ”€â”€ âš™ï¸ foreman.toml
            â”œâ”€â”€ ğŸ“„ LICENSE
            â”œâ”€â”€ ğŸ“„ mkdocs.yml
            â”œâ”€â”€ ğŸ“ modules/
              â”œâ”€â”€ ğŸ“ lemur/
                â”œâ”€â”€ ğŸ“„ .editorconfig
                â”œâ”€â”€ ğŸ“„ .git
                â”œâ”€â”€ ğŸ“„ .gitignore
                â”œâ”€â”€ ğŸ“„ .luacheckrc
                â”œâ”€â”€ ğŸ“„ .luacov
                â”œâ”€â”€ ğŸ“„ .travis.yml
                â”œâ”€â”€ ğŸ“„ CHANGELOG.md
                â”œâ”€â”€ ğŸ“„ FEATURES.md
                â”œâ”€â”€ ğŸŒ™ init.lua
                â”œâ”€â”€ ğŸ“ lib/
                  â”œâ”€â”€ ğŸŒ™ assign.lua
                  â”œâ”€â”€ ğŸŒ™ baste.lua
                  â”œâ”€â”€ ğŸŒ™ createEnum.lua
                  â”œâ”€â”€ ğŸŒ™ createEnum_spec.lua
                  â”œâ”€â”€ ğŸŒ™ createEnumGroup.lua
                  â”œâ”€â”€ ğŸŒ™ createEnumGroup_spec.lua
                  â”œâ”€â”€ ğŸŒ™ createEnvironment.lua
                  â”œâ”€â”€ ğŸŒ™ createSettings.lua
                  â”œâ”€â”€ ğŸŒ™ createSettings_spec.lua
                  â”œâ”€â”€ ğŸ“ Enum/
                    â”œâ”€â”€ ğŸŒ™ ConnectionState.lua
                    â”œâ”€â”€ ğŸŒ™ CreatorType.lua
                    â”œâ”€â”€ ğŸŒ™ DataStoreRequestType.lua
                    â”œâ”€â”€ ğŸŒ™ EasingDirection.lua
                    â”œâ”€â”€ ğŸŒ™ EasingStyle.lua
                    â”œâ”€â”€ ğŸŒ™ FillDirection.lua
                    â”œâ”€â”€ ğŸŒ™ Font.lua
                    â”œâ”€â”€ ğŸŒ™ HorizontalAlignment.lua
                    â”œâ”€â”€ ğŸŒ™ HttpContentType.lua
                    â”œâ”€â”€ ğŸŒ™ InfoType.lua
                    â”œâ”€â”€ ğŸŒ™ init.lua
                    â”œâ”€â”€ ğŸŒ™ KeyCode.lua
                    â”œâ”€â”€ ğŸŒ™ MouseBehavior.lua
                    â”œâ”€â”€ ğŸŒ™ Platform.lua
                    â”œâ”€â”€ ğŸŒ™ PlaybackState.lua
                    â”œâ”€â”€ ğŸŒ™ ScaleType.lua
                    â”œâ”€â”€ ğŸŒ™ ScrollBarInset.lua
                    â”œâ”€â”€ ğŸŒ™ ScrollingDirection.lua
                    â”œâ”€â”€ ğŸŒ™ SizeConstraint.lua
                    â”œâ”€â”€ ğŸŒ™ SortOrder.lua
                    â”œâ”€â”€ ğŸŒ™ TextTruncate.lua
                    â”œâ”€â”€ ğŸŒ™ TextXAlignment.lua
                    â”œâ”€â”€ ğŸŒ™ TextYAlignment.lua
                    â”œâ”€â”€ ğŸŒ™ ThumbnailSize.lua
                    â”œâ”€â”€ ğŸŒ™ ThumbnailType.lua
                    â”œâ”€â”€ ğŸŒ™ UserInputType.lua
                    â”œâ”€â”€ ğŸŒ™ VerticalAlignment.lua
                    â”œâ”€â”€ ğŸŒ™ VerticalScrollBarPosition.lua
                    â”œâ”€â”€ ğŸŒ™ VirtualInputMode.lua
                    â”œâ”€â”€ ğŸŒ™ ZIndexBehavior.lua
                  â”œâ”€â”€ ğŸŒ™ fs.lua
                  â”œâ”€â”€ ğŸŒ™ fs_spec.lua
                  â”œâ”€â”€ ğŸ“ functions/
                    â”œâ”€â”€ ğŸŒ™ init.lua
                    â”œâ”€â”€ ğŸ“ settings/
                      â”œâ”€â”€ ğŸŒ™ RenderSettings.lua
                      â”œâ”€â”€ ğŸŒ™ RenderSettings_spec.lua
                    â”œâ”€â”€ ğŸŒ™ tick.lua
                    â”œâ”€â”€ ğŸŒ™ tick_spec.lua
                    â”œâ”€â”€ ğŸŒ™ typeof.lua
                    â”œâ”€â”€ ğŸŒ™ typeof_spec.lua
                    â”œâ”€â”€ ğŸŒ™ warn.lua
                    â”œâ”€â”€ ğŸŒ™ warn_spec.lua
                  â”œâ”€â”€ ğŸŒ™ Habitat.lua
                  â”œâ”€â”€ ğŸŒ™ init.lua
                  â”œâ”€â”€ ğŸŒ™ init_spec.lua
                  â”œâ”€â”€ ğŸŒ™ Instance.lua
                  â”œâ”€â”€ ğŸŒ™ Instance_spec.lua
                  â”œâ”€â”€ ğŸŒ™ InstanceProperty.lua
                  â”œâ”€â”€ ğŸ“ instances/
                    â”œâ”€â”€ ğŸŒ™ AnalyticsService.lua
                    â”œâ”€â”€ ğŸŒ™ AnalyticsService_spec.lua
                    â”œâ”€â”€ ğŸŒ™ BaseInstance.lua
                    â”œâ”€â”€ ğŸŒ™ BaseInstance_spec.lua
                    â”œâ”€â”€ ğŸŒ™ BindableEvent.lua
                    â”œâ”€â”€ ğŸŒ™ BindableEvent_spec.lua
                    â”œâ”€â”€ ğŸŒ™ BoolValue.lua
                    â”œâ”€â”€ ğŸŒ™ BoolValue_spec.lua
                    â”œâ”€â”€ ğŸŒ™ Camera.lua
                    â”œâ”€â”€ ğŸŒ™ Camera_spec.lua
                    â”œâ”€â”€ ğŸŒ™ Configuration.lua
                    â”œâ”€â”€ ğŸŒ™ Configuration_spec.lua
                    â”œâ”€â”€ ğŸŒ™ ContentProvider.lua
                    â”œâ”€â”€ ğŸŒ™ ContentProvider_spec.lua
                    â”œâ”€â”€ ğŸŒ™ ContextActionService.lua
                    â”œâ”€â”€ ğŸŒ™ ContextActionService_spec.lua
                    â”œâ”€â”€ ğŸŒ™ CoreGui.lua
                    â”œâ”€â”€ ğŸŒ™ CoreGui_spec.lua
                    â”œâ”€â”€ ğŸŒ™ CorePackages.lua
                    â”œâ”€â”€ ğŸŒ™ CorePackages_spec.lua
                    â”œâ”€â”€ ğŸŒ™ Folder.lua
                    â”œâ”€â”€ ğŸŒ™ Folder_spec.lua
                    â”œâ”€â”€ ğŸŒ™ Frame.lua
                    â”œâ”€â”€ ğŸŒ™ Frame_spec.lua
                    â”œâ”€â”€ ğŸŒ™ Game.lua
                    â”œâ”€â”€ ğŸŒ™ Game_spec.lua
                    â”œâ”€â”€ ğŸŒ™ GuiButton.lua
                    â”œâ”€â”€ ğŸŒ™ GuiButton_spec.lua
                    â”œâ”€â”€ ğŸŒ™ GuiObject.lua
                    â”œâ”€â”€ ğŸŒ™ GuiObject_spec.lua
                    â”œâ”€â”€ ğŸŒ™ GuiService.lua
                    â”œâ”€â”€ ğŸŒ™ GuiService_spec.lua
                    â”œâ”€â”€ ğŸŒ™ HttpRbxApiService.lua
                    â”œâ”€â”€ ğŸŒ™ HttpRbxApiService_spec.lua
                    â”œâ”€â”€ ğŸŒ™ HttpService.lua
                    â”œâ”€â”€ ğŸŒ™ HttpService_spec.lua
                    â”œâ”€â”€ ğŸŒ™ Humanoid.lua
                    â”œâ”€â”€ ğŸŒ™ Humanoid_spec.lua
                    â”œâ”€â”€ ğŸŒ™ ImageButton.lua
                    â”œâ”€â”€ ğŸŒ™ ImageButton_spec.lua
                    â”œâ”€â”€ ğŸŒ™ ImageLabel.lua
                    â”œâ”€â”€ ğŸŒ™ ImageLabel_spec.lua
                    â”œâ”€â”€ ğŸŒ™ init.lua
                    â”œâ”€â”€ ğŸŒ™ InsertService.lua
                    â”œâ”€â”€ ğŸŒ™ InsertService_spec.lua
                    â”œâ”€â”€ ğŸŒ™ IntValue.lua
                    â”œâ”€â”€ ğŸŒ™ IntValue_spec.lua
                    â”œâ”€â”€ ğŸŒ™ LocalizationService.lua
                    â”œâ”€â”€ ğŸŒ™ LocalizationService_spec.lua
                    â”œâ”€â”€ ğŸŒ™ LocalizationTable.lua
                    â”œâ”€â”€ ğŸŒ™ LocalizationTable_spec.lua
                    â”œâ”€â”€ ğŸŒ™ LocalScript.lua
                    â”œâ”€â”€ ğŸŒ™ LocalScript_spec.lua
                    â”œâ”€â”€ ğŸŒ™ MarketplaceService.lua
                    â”œâ”€â”€ ğŸŒ™ MarketplaceService_spec.lua
                    â”œâ”€â”€ ğŸŒ™ Model.lua
                    â”œâ”€â”€ ğŸŒ™ Model_spec.lua
                    â”œâ”€â”€ ğŸŒ™ ModuleScript.lua
                    â”œâ”€â”€ ğŸŒ™ ModuleScript_spec.lua
                    â”œâ”€â”€ ğŸŒ™ NotificationService.lua
                    â”œâ”€â”€ ğŸŒ™ NotificationService_spec.lua
                    â”œâ”€â”€ ğŸŒ™ NumberValue.lua
                    â”œâ”€â”€ ğŸŒ™ NumberValue_spec.lua
                    â”œâ”€â”€ ğŸŒ™ ObjectValue.lua
                    â”œâ”€â”€ ğŸŒ™ ObjectValue_spec.lua
                    â”œâ”€â”€ ğŸŒ™ ParticleEffect.lua
                    â”œâ”€â”€ ğŸŒ™ ParticleEffect_spec.lua
                    â”œâ”€â”€ ğŸŒ™ Player.lua
                    â”œâ”€â”€ ğŸŒ™ Player_spec.lua
                    â”œâ”€â”€ ğŸŒ™ Players.lua
                    â”œâ”€â”€ ğŸŒ™ Players_spec.lua
                    â”œâ”€â”€ ğŸŒ™ ReplicatedFirst.lua
                    â”œâ”€â”€ ğŸŒ™ ReplicatedFirst_spec.lua
                    â”œâ”€â”€ ğŸŒ™ ReplicatedStorage.lua
                    â”œâ”€â”€ ğŸŒ™ ReplicatedStorage_spec.lua
                    â”œâ”€â”€ ğŸŒ™ RunService.lua
                    â”œâ”€â”€ ğŸŒ™ RunService_spec.lua
                    â”œâ”€â”€ ğŸŒ™ ScreenGui.lua
                    â”œâ”€â”€ ğŸŒ™ ScreenGui_spec.lua
                    â”œâ”€â”€ ğŸŒ™ Script.lua
                    â”œâ”€â”€ ğŸŒ™ Script_spec.lua
                    â”œâ”€â”€ ğŸŒ™ ScrollingFrame.lua
                    â”œâ”€â”€ ğŸŒ™ ScrollingFrame_spec.lua
                    â”œâ”€â”€ ğŸŒ™ ServerScriptService.lua
                    â”œâ”€â”€ ğŸŒ™ ServerScriptService_spec.lua
                    â”œâ”€â”€ ğŸŒ™ ServerStorage.lua
                    â”œâ”€â”€ ğŸŒ™ ServerStorage_spec.lua
                    â”œâ”€â”€ ğŸŒ™ StarterCharacterScripts.lua
                    â”œâ”€â”€ ğŸŒ™ StarterCharacterScripts_spec.lua
                    â”œâ”€â”€ ğŸŒ™ StarterPlayer.lua
                    â”œâ”€â”€ ğŸŒ™ StarterPlayer_spec.lua
                    â”œâ”€â”€ ğŸŒ™ StarterPlayerScripts.lua
                    â”œâ”€â”€ ğŸŒ™ StarterPlayerScripts_spec.lua
                    â”œâ”€â”€ ğŸŒ™ Stats.lua
                    â”œâ”€â”€ ğŸŒ™ Stats_spec.lua
                    â”œâ”€â”€ ğŸŒ™ StringValue.lua
                    â”œâ”€â”€ ğŸŒ™ StringValue_spec.lua
                    â”œâ”€â”€ ğŸŒ™ TestService.lua
                    â”œâ”€â”€ ğŸŒ™ TestService_spec.lua
                    â”œâ”€â”€ ğŸŒ™ TextButton.lua
                    â”œâ”€â”€ ğŸŒ™ TextButton_spec.lua
                    â”œâ”€â”€ ğŸŒ™ TextLabel.lua
                    â”œâ”€â”€ ğŸŒ™ TextLabel_spec.lua
                    â”œâ”€â”€ ğŸŒ™ TextService.lua
                    â”œâ”€â”€ ğŸŒ™ TextService_spec.lua
                    â”œâ”€â”€ ğŸŒ™ TweenService.lua
                    â”œâ”€â”€ ğŸŒ™ TweenService_spec.lua
                    â”œâ”€â”€ ğŸŒ™ UIGridStyleLayout.lua
                    â”œâ”€â”€ ğŸŒ™ UIGridStyleLayout_spec.lua
                    â”œâ”€â”€ ğŸŒ™ UIListLayout.lua
                    â”œâ”€â”€ ğŸŒ™ UIListLayout_spec.lua
                    â”œâ”€â”€ ğŸŒ™ UIPadding.lua
                    â”œâ”€â”€ ğŸŒ™ UIPadding_spec.lua
                    â”œâ”€â”€ ğŸŒ™ UITextSizeConstraint.lua
                    â”œâ”€â”€ ğŸŒ™ UITextSizeContstraint_spec.lua
                    â”œâ”€â”€ ğŸŒ™ UserInputService.lua
                    â”œâ”€â”€ ğŸŒ™ UserInputService_spec.lua
                    â”œâ”€â”€ ğŸŒ™ VirtualInputManager.lua
                    â”œâ”€â”€ ğŸŒ™ VirtualInputManager_spec.lua
                    â”œâ”€â”€ ğŸŒ™ Workspace.lua
                    â”œâ”€â”€ ğŸŒ™ Workspace_spec.lua
                  â”œâ”€â”€ ğŸŒ™ json.lua
                  â”œâ”€â”€ ğŸ“ libs/
                    â”œâ”€â”€ ğŸŒ™ bit32.lua
                    â”œâ”€â”€ ğŸŒ™ bit32_spec.lua
                    â”œâ”€â”€ ğŸŒ™ init.lua
                    â”œâ”€â”€ ğŸŒ™ math.lua
                    â”œâ”€â”€ ğŸŒ™ math_spec.lua
                    â”œâ”€â”€ ğŸŒ™ string.lua
                    â”œâ”€â”€ ğŸŒ™ string_spec.lua
                  â”œâ”€â”€ ğŸŒ™ Signal.lua
                  â”œâ”€â”€ ğŸŒ™ Signal_spec.lua
                  â”œâ”€â”€ ğŸ“ taskFunctions/
                    â”œâ”€â”€ ğŸŒ™ delay.lua
                    â”œâ”€â”€ ğŸŒ™ delay_spec.lua
                    â”œâ”€â”€ ğŸŒ™ init.lua
                    â”œâ”€â”€ ğŸŒ™ spawn.lua
                    â”œâ”€â”€ ğŸŒ™ spawn_spec.lua
                    â”œâ”€â”€ ğŸŒ™ wait.lua
                    â”œâ”€â”€ ğŸŒ™ wait_spec.lua
                  â”œâ”€â”€ ğŸŒ™ TaskScheduler.lua
                  â”œâ”€â”€ ğŸŒ™ typeKey.lua
                  â”œâ”€â”€ ğŸ“ types/
                    â”œâ”€â”€ ğŸŒ™ Color3.lua
                    â”œâ”€â”€ ğŸŒ™ Color3_spec.lua
                    â”œâ”€â”€ ğŸŒ™ init.lua
                    â”œâ”€â”€ ğŸŒ™ Rect.lua
                    â”œâ”€â”€ ğŸŒ™ Rect_spec.lua
                    â”œâ”€â”€ ğŸŒ™ UDim.lua
                    â”œâ”€â”€ ğŸŒ™ UDim_spec.lua
                    â”œâ”€â”€ ğŸŒ™ UDim2.lua
                    â”œâ”€â”€ ğŸŒ™ UDim2_spec.lua
                    â”œâ”€â”€ ğŸŒ™ Vector2.lua
                    â”œâ”€â”€ ğŸŒ™ Vector2_spec.lua
                    â”œâ”€â”€ ğŸŒ™ Vector3.lua
                    â”œâ”€â”€ ğŸŒ™ Vector3_spec.lua
                  â”œâ”€â”€ ğŸŒ™ validateType.lua
                  â”œâ”€â”€ ğŸŒ™ validateType_spec.lua
                â”œâ”€â”€ ğŸ“„ LICENSE.md
                â”œâ”€â”€ ğŸ“„ README.md
                â”œâ”€â”€ ğŸ“„ run-tests
                â”œâ”€â”€ ğŸ“ spec/
                  â”œâ”€â”€ ğŸŒ™ load_spec.lua
                  â”œâ”€â”€ ğŸ“ require/
                    â”œâ”€â”€ ğŸŒ™ a.lua
                    â”œâ”€â”€ ğŸŒ™ b.lua
                    â”œâ”€â”€ ğŸ“ bar/
                      â”œâ”€â”€ ğŸŒ™ baz.lua
                    â”œâ”€â”€ ğŸŒ™ cacheme.lua
                    â”œâ”€â”€ ğŸŒ™ foo.lua
                  â”œâ”€â”€ ğŸŒ™ require_spec.lua
                  â”œâ”€â”€ ğŸ“ test-project/
                    â”œâ”€â”€ ğŸŒ™ bar.lua
                    â”œâ”€â”€ ğŸ“ normal-folder/
                      â”œâ”€â”€ ğŸŒ™ ack.lua
                    â”œâ”€â”€ ğŸ“ usurp/
                      â”œâ”€â”€ ğŸŒ™ foo.lua
                      â”œâ”€â”€ ğŸŒ™ init.lua
            â”œâ”€â”€ ğŸ“„ README.md
            â”œâ”€â”€ âš™ï¸ rotriever.toml
            â”œâ”€â”€ ğŸ“ src/
              â”œâ”€â”€ ğŸŒ™ Context.lua
              â”œâ”€â”€ ğŸŒ™ Expectation.lua
              â”œâ”€â”€ ğŸŒ™ init.lua
              â”œâ”€â”€ ğŸŒ™ LifecycleHooks.lua
              â”œâ”€â”€ ğŸ“ Reporters/
                â”œâ”€â”€ ğŸŒ™ TeamCityReporter.lua
                â”œâ”€â”€ ğŸŒ™ TextReporter.lua
                â”œâ”€â”€ ğŸŒ™ TextReporterQuiet.lua
              â”œâ”€â”€ ğŸŒ™ TestBootstrap.lua
              â”œâ”€â”€ ğŸŒ™ TestEnum.lua
              â”œâ”€â”€ ğŸŒ™ TestPlan.lua
              â”œâ”€â”€ ğŸŒ™ TestPlanner.lua
              â”œâ”€â”€ ğŸŒ™ TestResults.lua
              â”œâ”€â”€ ğŸŒ™ TestRunner.lua
              â”œâ”€â”€ ğŸŒ™ TestSession.lua
            â”œâ”€â”€ ğŸ“ test/
              â”œâ”€â”€ ğŸŒ™ lemur.lua
              â”œâ”€â”€ ğŸ“„ roblox-cli.sh
              â”œâ”€â”€ ğŸŒ™ runner.server.lua
            â”œâ”€â”€ ğŸ“ testez-cli/
              â”œâ”€â”€ ğŸ“„ build.rs
              â”œâ”€â”€ âš™ï¸ Cargo.toml
              â”œâ”€â”€ ğŸ“„ README.md
              â”œâ”€â”€ ğŸ“ src/
                â”œâ”€â”€ ğŸ“„ bundled_libraries.rs
                â”œâ”€â”€ ğŸ“„ cli.rs
                â”œâ”€â”€ ğŸ“„ dependencies.rs
                â”œâ”€â”€ ğŸ“„ fs.rs
                â”œâ”€â”€ ğŸŒ™ lemur-entry.lua
                â”œâ”€â”€ ğŸ“„ main.rs
                â”œâ”€â”€ ğŸ“„ source.rs
                â”œâ”€â”€ ğŸ“ targets/
                  â”œâ”€â”€ ğŸ“„ lemur.rs
                  â”œâ”€â”€ ğŸ“„ mod.rs
                  â”œâ”€â”€ ğŸ“„ roblox_cli.rs
                â”œâ”€â”€ ğŸ“„ test_place.rs
                â”œâ”€â”€ ğŸŒ™ test-runner.lua
                â”œâ”€â”€ ğŸ“ tools/
                  â”œâ”€â”€ ğŸ“„ lua.rs
                  â”œâ”€â”€ ğŸ“„ mod.rs
                  â”œâ”€â”€ ğŸ“„ roblox_cli.rs
                  â”œâ”€â”€ ğŸ“„ rojo.rs
                â”œâ”€â”€ ğŸ“„ vfs.rs
            â”œâ”€â”€ ğŸ“‹ test-place.project.json
            â”œâ”€â”€ ğŸ“ tests/
              â”œâ”€â”€ ğŸŒ™ api.lua
              â”œâ”€â”€ ğŸŒ™ Context.lua
              â”œâ”€â”€ ğŸŒ™ Expectation.lua
              â”œâ”€â”€ ğŸ“ failing/
              â”œâ”€â”€ ğŸŒ™ lifecycleHooks.lua
              â”œâ”€â”€ ğŸ“ passing/
              â”œâ”€â”€ ğŸŒ™ planner.lua
              â”œâ”€â”€ ğŸ“ planning/
              â”œâ”€â”€ ğŸŒ™ specTests.lua
        â”œâ”€â”€ âš™ï¸ moonwave.toml
        â”œâ”€â”€ ğŸ“„ README.md
        â”œâ”€â”€ âš™ï¸ rotriever.toml
        â”œâ”€â”€ ğŸŒ™ runTests.server.lua
        â”œâ”€â”€ âš™ï¸ selene.toml
        â”œâ”€â”€ ğŸ“‹ test.project.json
        â”œâ”€â”€ âš™ï¸ testez.toml
        â”œâ”€â”€ âš™ï¸ wally.toml
    â”œâ”€â”€ ğŸ“ imavafe_onyx-ui@1.0.2/
      â”œâ”€â”€ ğŸŒ™ ColorUtils.lua
      â”œâ”€â”€ ğŸŒ™ Fusion.lua
      â”œâ”€â”€ ğŸ“ onyx-ui/
        â”œâ”€â”€ ğŸ“‹ default.project.json
        â”œâ”€â”€ ğŸ“ src/
          â”œâ”€â”€ ğŸ“ Components/
            â”œâ”€â”€ ğŸŒ™ AutoScaler.luau
            â”œâ”€â”€ ğŸŒ™ AutoScaler.story.luau
            â”œâ”€â”€ ğŸŒ™ Avatar.luau
            â”œâ”€â”€ ğŸŒ™ Avatar.story.luau
            â”œâ”€â”€ ğŸŒ™ Badge.luau
            â”œâ”€â”€ ğŸŒ™ Badge.story.luau
            â”œâ”€â”€ ğŸŒ™ Base.luau
            â”œâ”€â”€ ğŸŒ™ Base.story.luau
            â”œâ”€â”€ ğŸŒ™ BaseButton.luau
            â”œâ”€â”€ ğŸŒ™ Button.luau
            â”œâ”€â”€ ğŸŒ™ Button.story.luau
            â”œâ”€â”€ ğŸŒ™ Card.luau
            â”œâ”€â”€ ğŸŒ™ Card.story.luau
            â”œâ”€â”€ ğŸŒ™ Checkbox.luau
            â”œâ”€â”€ ğŸŒ™ Checkbox.story.luau
            â”œâ”€â”€ ğŸŒ™ Divider.luau
            â”œâ”€â”€ ğŸŒ™ Divider.story.luau
            â”œâ”€â”€ ğŸŒ™ Frame.luau
            â”œâ”€â”€ ğŸŒ™ Group.luau
            â”œâ”€â”€ ğŸŒ™ Heading.luau
            â”œâ”€â”€ ğŸŒ™ Heading.story.luau
            â”œâ”€â”€ ğŸŒ™ Icon.luau
            â”œâ”€â”€ ğŸŒ™ Icon.story.luau
            â”œâ”€â”€ ğŸŒ™ IconButton.luau
            â”œâ”€â”€ ğŸŒ™ IconButton.story.luau
            â”œâ”€â”€ ğŸŒ™ IconSwap.luau
            â”œâ”€â”€ ğŸŒ™ IconSwap.story.luau
            â”œâ”€â”€ ğŸŒ™ IconText.luau
            â”œâ”€â”€ ğŸŒ™ IconText.story.luau
            â”œâ”€â”€ ğŸŒ™ Image.luau
            â”œâ”€â”€ ğŸŒ™ Image.story.luau
            â”œâ”€â”€ ğŸŒ™ init.luau
            â”œâ”€â”€ ğŸŒ™ ProgressBar.luau
            â”œâ”€â”€ ğŸŒ™ ProgressBar.story.luau
            â”œâ”€â”€ ğŸŒ™ Scroller.luau
            â”œâ”€â”€ ğŸŒ™ Scroller.story.luau
            â”œâ”€â”€ ğŸŒ™ Slider.luau
            â”œâ”€â”€ ğŸŒ™ Slider.story.luau
            â”œâ”€â”€ ğŸŒ™ Switch.luau
            â”œâ”€â”€ ğŸŒ™ Switch.story.luau
            â”œâ”€â”€ ğŸŒ™ Tabs.luau
            â”œâ”€â”€ ğŸŒ™ Tabs.story.luau
            â”œâ”€â”€ ğŸŒ™ Text.luau
            â”œâ”€â”€ ğŸŒ™ Text.story.luau
            â”œâ”€â”€ ğŸŒ™ TextArea.luau
            â”œâ”€â”€ ğŸŒ™ TextArea.story.luau
            â”œâ”€â”€ ğŸŒ™ TextInput.luau
            â”œâ”€â”€ ğŸŒ™ TextInput.story.luau
            â”œâ”€â”€ ğŸŒ™ TextSwap.luau
            â”œâ”€â”€ ğŸŒ™ TextSwap.story.luau
            â”œâ”€â”€ ğŸŒ™ TitleBar.luau
            â”œâ”€â”€ ğŸŒ™ TitleBar.story.luau
          â”œâ”€â”€ ğŸŒ™ init.luau
          â”œâ”€â”€ ğŸŒ™ OnyxUI.storybook.luau
          â”œâ”€â”€ ğŸ“ Themer/
            â”œâ”€â”€ ğŸŒ™ init.luau
            â”œâ”€â”€ ğŸŒ™ NewTheme.luau
            â”œâ”€â”€ ğŸŒ™ OnyxNight.luau
            â”œâ”€â”€ ğŸŒ™ ThemeSpec.luau
          â”œâ”€â”€ ğŸ“ Util/
            â”œâ”€â”€ ğŸŒ™ Colors.luau
            â”œâ”€â”€ ğŸŒ™ CombineProps.luau
            â”œâ”€â”€ ğŸŒ™ Emphasize.luau
            â”œâ”€â”€ ğŸŒ™ EnsureValue.luau
            â”œâ”€â”€ ğŸŒ™ Fallback.luau
            â”œâ”€â”€ ğŸŒ™ init.luau
            â”œâ”€â”€ ğŸŒ™ Unit.luau
            â”œâ”€â”€ ğŸŒ™ ViewportSize.luau
        â”œâ”€â”€ ğŸ“„ wally.lock
        â”œâ”€â”€ âš™ï¸ wally.toml
  â”œâ”€â”€ ğŸŒ™ Fusion.lua
  â”œâ”€â”€ ğŸŒ™ onyx-ui.lua
  â”œâ”€â”€ ğŸŒ™ Promise.lua
  â”œâ”€â”€ ğŸŒ™ topbarplus.lua
```

# ğŸ“š Library Source Code

## ğŸŒ™ `Packages/_Index/1foreverhd_topbarplus@3.4.0/topbarplus/src/Attribute.lua`
<details>
<summary>View Source (34 lines)</summary>

```lua
   1 | --[[
   2 | 
   3 | 	TopbarPlus was developed by ForeverHD and is possible thanks to HD Admin.
   4 | 
   5 | 	By using TopbarPlus in your experience or application, you agree to either:
   6 | 		1. Keep Attribute unchanged, or
   7 | 		2. If an experience, to credit TopbarPlus in your description, or in a
   8 | 		   devforum post linked from your experience's description.
   9 | 
  10 | 	v3 has involved over 350 hours of work to develop, so please consider supporting
  11 | 	its development by reporting any issues or feedback you have at its repository:
  12 | 	https://github.com/1ForeverHD/TopbarPlus
  13 | 
  14 | 	You can get in touch with me on Discord via the social link here:
  15 | 	https://create.roblox.com/store/asset/92368439343389/TopbarPlus
  16 | 
  17 | 	Many thanks! ~Ben, June 10th 2025
  18 | 	
  19 | ]]
  20 | 
  21 | task.defer(function()
  22 | 	local RunService = game:GetService("RunService")
  23 | 	local VERSION = require(script.Parent.VERSION)
  24 | 	local appVersion = VERSION.getAppVersion()
  25 | 	local latestVersion = VERSION.getLatestVersion()
  26 | 	local isOutdated = not VERSION.isUpToDate()
  27 | 	if not RunService:IsStudio() then
  28 | 		print(`ğŸ Running TopbarPlus {appVersion} by @ForeverHD & HD Admin`)
  29 | 	end
  30 | 	if isOutdated then
  31 | 		warn(`A new version of TopbarPlus ({latestVersion}) is available: https://devforum.roblox.com/t/topbarplus/1017485`)
  32 | 	end
  33 | end)
  34 | 
  35 | return {}
```
</details>

## ğŸŒ™ `Packages/_Index/1foreverhd_topbarplus@3.4.0/topbarplus/src/Elements/Caption.lua`
<details>
<summary>View Source (315 lines)</summary>

```lua
   1 | local CAPTION_COLOR = Color3.fromRGB(39, 41, 48)
   2 | local TEXT_SIZE = 15
   3 | return function(icon)
   4 | 
   5 | 	-- Credit to lolmansReturn and Canary Software for
   6 | 	-- retrieving these values
   7 | 	local clickRegion = icon:getInstance("ClickRegion")
   8 | 	local caption = Instance.new("CanvasGroup")
   9 | 	caption.Name = "Caption"
  10 | 	caption.AnchorPoint = Vector2.new(0.5, 0)
  11 | 	caption.BackgroundTransparency = 1
  12 | 	caption.BorderSizePixel = 0
  13 | 	caption.GroupTransparency = 1
  14 | 	caption.Position = UDim2.fromOffset(0, 0)
  15 | 	caption.Visible = true
  16 | 	caption.ZIndex = 30
  17 | 	caption.Parent = clickRegion
  18 | 
  19 | 	local box = Instance.new("Frame")
  20 | 	box.Name = "Box"
  21 | 	box.AutomaticSize = Enum.AutomaticSize.XY
  22 | 	box.BackgroundColor3 = CAPTION_COLOR
  23 | 	box.Position = UDim2.fromOffset(4, 7)
  24 | 	box.ZIndex = 12
  25 | 	box.Parent = caption
  26 | 
  27 | 	local header = Instance.new("TextLabel")
  28 | 	header.Name = "Header"
  29 | 	header.FontFace = Font.new(
  30 | 		"rbxasset://fonts/families/BuilderSans.json",
  31 | 		Enum.FontWeight.Medium,
  32 | 		Enum.FontStyle.Normal
  33 | 	)
  34 | 	header.Text = "Caption"
  35 | 	header.TextColor3 = Color3.fromRGB(255, 255, 255)
  36 | 	header.TextSize = TEXT_SIZE
  37 | 	header.TextTruncate = Enum.TextTruncate.None
  38 | 	header.TextWrapped = false
  39 | 	header.TextXAlignment = Enum.TextXAlignment.Left
  40 | 	header.AutomaticSize = Enum.AutomaticSize.X
  41 | 	header.BackgroundTransparency = 1
  42 | 	header.LayoutOrder = 1
  43 | 	header.Size = UDim2.fromOffset(0, 16)
  44 | 	header.ZIndex = 18
  45 | 	header.Parent = box
  46 | 
  47 | 	local layout = Instance.new("UIListLayout")
  48 | 	layout.Name = "Layout"
  49 | 	layout.Padding = UDim.new(0, 8)
  50 | 	layout.SortOrder = Enum.SortOrder.LayoutOrder
  51 | 	layout.Parent = box
  52 | 
  53 | 	local UICorner = Instance.new("UICorner")
  54 | 	UICorner.Name = "CaptionCorner"
  55 | 	UICorner.Parent = box
  56 | 
  57 | 	local padding = Instance.new("UIPadding")
  58 | 	padding.Name = "Padding"
  59 | 	padding.PaddingBottom = UDim.new(0, 12)
  60 | 	padding.PaddingLeft = UDim.new(0, 12)
  61 | 	padding.PaddingRight = UDim.new(0, 12)
  62 | 	padding.PaddingTop = UDim.new(0, 12)
  63 | 	padding.Parent = box
  64 | 
  65 | 	local hotkeys = Instance.new("Frame")
  66 | 	hotkeys.Name = "Hotkeys"
  67 | 	hotkeys.AutomaticSize = Enum.AutomaticSize.Y
  68 | 	hotkeys.BackgroundTransparency = 1
  69 | 	hotkeys.LayoutOrder = 3
  70 | 	hotkeys.Size = UDim2.fromScale(1, 0)
  71 | 	hotkeys.Visible = false
  72 | 	hotkeys.Parent = box
  73 | 
  74 | 	local layout1 = Instance.new("UIListLayout")
  75 | 	layout1.Name = "Layout1"
  76 | 	layout1.Padding = UDim.new(0, 6)
  77 | 	layout1.FillDirection = Enum.FillDirection.Vertical
  78 | 	layout1.HorizontalAlignment = Enum.HorizontalAlignment.Center
  79 | 	layout1.HorizontalFlex = Enum.UIFlexAlignment.None
  80 | 	layout1.ItemLineAlignment = Enum.ItemLineAlignment.Automatic
  81 | 	layout1.VerticalFlex = Enum.UIFlexAlignment.None
  82 | 	layout1.SortOrder = Enum.SortOrder.LayoutOrder
  83 | 	layout1.Parent = hotkeys
  84 | 
  85 | 	local keyTag1 = Instance.new("ImageLabel")
  86 | 	keyTag1.Name = "Key1"
  87 | 	keyTag1.Image = "rbxasset://textures/ui/Controls/key_single.png"
  88 | 	keyTag1.ImageTransparency = 0.7
  89 | 	keyTag1.ScaleType = Enum.ScaleType.Slice
  90 | 	keyTag1.SliceCenter = Rect.new(5, 5, 23, 24)
  91 | 	keyTag1.AutomaticSize = Enum.AutomaticSize.X
  92 | 	keyTag1.BackgroundTransparency = 1
  93 | 	keyTag1.LayoutOrder = 1
  94 | 	keyTag1.Size = UDim2.fromOffset(0, 30)
  95 | 	keyTag1.ZIndex = 15
  96 | 	keyTag1.Parent = hotkeys
  97 | 
  98 | 	local inset = Instance.new("UIPadding")
  99 | 	inset.Name = "Inset"
 100 | 	inset.PaddingLeft = UDim.new(0, 8)
 101 | 	inset.PaddingRight = UDim.new(0, 8)
 102 | 	inset.Parent = keyTag1
 103 | 
 104 | 	local labelContent = Instance.new("TextLabel")
 105 | 	labelContent.AutoLocalize = false
 106 | 	labelContent.Name = "LabelContent"
 107 | 	labelContent.FontFace = Font.new(
 108 | 		"rbxasset://fonts/families/GothamSSm.json",
 109 | 		Enum.FontWeight.Medium,
 110 | 		Enum.FontStyle.Normal
 111 | 	)
 112 | 	labelContent.Text = ""
 113 | 	labelContent.TextColor3 = Color3.fromRGB(189, 190, 190)
 114 | 	labelContent.TextSize = TEXT_SIZE
 115 | 	labelContent.AutomaticSize = Enum.AutomaticSize.X
 116 | 	labelContent.BackgroundTransparency = 1
 117 | 	labelContent.Position = UDim2.fromOffset(0, -1)
 118 | 	labelContent.Size = UDim2.fromScale(1, 1)
 119 | 	labelContent.ZIndex = 16
 120 | 	labelContent.Parent = keyTag1
 121 | 	
 122 | 	local caret = Instance.new("ImageLabel")
 123 | 	caret.Name = "Caret"
 124 | 	caret.Image = "rbxassetid://101906294438076"
 125 | 	caret.ImageColor3 = CAPTION_COLOR
 126 | 	caret.AnchorPoint = Vector2.new(0, 0.5)
 127 | 	caret.BackgroundTransparency = 1
 128 | 	caret.Position = UDim2.new(0, 0, 0, 4)
 129 | 	caret.Size = UDim2.fromOffset(16, 8)
 130 | 	caret.ZIndex = 12
 131 | 	caret.Parent = caption
 132 | 
 133 | 	local dropShadow = Instance.new("ImageLabel")
 134 | 	dropShadow.Visible = true
 135 | 	dropShadow.Name = "DropShadow"
 136 | 	dropShadow.Image = "rbxassetid://124920646932671"
 137 | 	dropShadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
 138 | 	dropShadow.ImageTransparency = 0.45
 139 | 	dropShadow.ScaleType = Enum.ScaleType.Slice
 140 | 	dropShadow.SliceCenter = Rect.new(12, 12, 13, 13)
 141 | 	dropShadow.BackgroundTransparency = 1
 142 | 	dropShadow.Position = UDim2.fromOffset(0, 5)
 143 | 	dropShadow.Size = UDim2.new(1, 0, 0, 48)
 144 | 	dropShadow.Parent = caption
 145 | 	box:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
 146 | 		dropShadow.Size = UDim2.new(1, 0, 0, box.AbsoluteSize.Y + 8)
 147 | 	end)
 148 | 	
 149 | 	-- It's important we match the sizes as this is not
 150 | 	-- handles within clipOutside (as it assumes the sizes
 151 | 	-- are already the same)
 152 | 	local captionJanitor = icon.captionJanitor
 153 | 	local _, captionClone = icon:clipOutside(caption)
 154 | 	captionClone.AutomaticSize = Enum.AutomaticSize.None
 155 | 	local function matchSize()
 156 | 		local absolute = caption.AbsoluteSize
 157 | 		captionClone.Size = UDim2.fromOffset(absolute.X, absolute.Y)
 158 | 	end
 159 | 	captionJanitor:add(caption:GetPropertyChangedSignal("AbsoluteSize"):Connect(matchSize))
 160 | 	matchSize()
 161 | 	
 162 | 	
 163 | 	
 164 | 	-- This handles the appearing/disappearing/positioning of the caption
 165 | 	local isCompletelyEnabled = false
 166 | 	local captionHeader = caption.Box.Header
 167 | 	local UserInputService = game:GetService("UserInputService")
 168 | 	local function updateHotkey(keyCodeEnum)
 169 | 		local hasKeyboard = UserInputService.KeyboardEnabled
 170 | 		local text = caption:GetAttribute("CaptionText") or ""
 171 | 		local hideHeader = text == "_hotkey_"
 172 | 		if not hasKeyboard and hideHeader then
 173 | 			icon:setCaption()
 174 | 			return
 175 | 		end
 176 | 		captionHeader.Text = text
 177 | 		captionHeader.Visible = not hideHeader
 178 | 		if keyCodeEnum then
 179 | 			labelContent.Text = keyCodeEnum.Name
 180 | 			hotkeys.Visible = true
 181 | 		end
 182 | 		if not hasKeyboard then
 183 | 			hotkeys.Visible = false
 184 | 		end
 185 | 	end
 186 | 	caption:GetAttributeChangedSignal("CaptionText"):Connect(updateHotkey)
 187 | 
 188 | 	local EASING_STYLE = Enum.EasingStyle.Quad
 189 | 	local TWEEN_SPEED = 0.2
 190 | 	local TWEEN_INFO_IN = TweenInfo.new(TWEEN_SPEED, EASING_STYLE, Enum.EasingDirection.In)
 191 | 	local TWEEN_INFO_OUT = TweenInfo.new(TWEEN_SPEED, EASING_STYLE, Enum.EasingDirection.Out)
 192 | 	local TweenService = game:GetService("TweenService")
 193 | 	local RunService = game:GetService("RunService")
 194 | 	local function getCaptionPosition(customEnabled)
 195 | 		local enabled = if customEnabled ~= nil then customEnabled else isCompletelyEnabled
 196 | 		local yOut = 2
 197 | 		local yIn = yOut + 8
 198 | 		local yOffset = if enabled then yIn else yOut
 199 | 		return UDim2.new(0.5, 0, 1, yOffset)
 200 | 	end
 201 | 	local function updatePosition(forcedEnabled)
 202 | 		
 203 | 		-- Ignore changes if not enabled to reduce redundant calls
 204 | 		if not isCompletelyEnabled then
 205 | 			return
 206 | 		end
 207 | 		
 208 | 		-- Currently the one thing which isn't accounted for are the bounds of the screen
 209 | 		-- This would be an issue if someone sets a long caption text for the left or
 210 | 		-- right most icon
 211 | 		local enabled = if forcedEnabled ~= nil then forcedEnabled else isCompletelyEnabled
 212 | 		local startPosition = getCaptionPosition(not enabled)
 213 | 		local endPosition = getCaptionPosition(enabled)
 214 | 		
 215 | 		-- It's essential we reset the carets position to prevent the x sizing bounds
 216 | 		-- of the caption from infinitely scaling up
 217 | 		if enabled then
 218 | 			local caretY = caret.Position.Y.Offset
 219 | 			caret.Position = UDim2.fromOffset(0, caretY)
 220 | 			caption.AutomaticSize = Enum.AutomaticSize.XY
 221 | 			caption.Size = UDim2.fromOffset(32, 53)
 222 | 		else
 223 | 			local absolute = caption.AbsoluteSize
 224 | 			caption.AutomaticSize = Enum.AutomaticSize.Y
 225 | 			caption.Size = UDim2.fromOffset(absolute.X, absolute.Y)
 226 | 		end
 227 | 		
 228 | 		-- We initially default to the opposite state
 229 | 		local previousCaretX
 230 | 		local function updateCaret()
 231 | 			local caretX = clickRegion.AbsolutePosition.X - caption.AbsolutePosition.X + clickRegion.AbsoluteSize.X/2 - caret.AbsoluteSize.X/2
 232 | 			local caretY = caret.Position.Y.Offset
 233 | 			local newCaretPosition = UDim2.fromOffset(caretX, caretY)
 234 | 			if previousCaretX ~= caretX then
 235 | 				-- Again, it's essential we reset the caret if
 236 | 				-- a difference in X position is detected otherwise
 237 | 				-- a slight quirk with AutomaticCanvas can cause
 238 | 				-- the caption to infinitely scale
 239 | 				previousCaretX = caretX
 240 | 				caret.Position = UDim2.fromOffset(0, caretY)
 241 | 				task.wait()
 242 | 			end
 243 | 			caret.Position = newCaretPosition
 244 | 		end
 245 | 		captionClone.Position = startPosition
 246 | 		updateCaret()
 247 | 		
 248 | 		-- Now we tween into the new state
 249 | 		local tweenInfo = (enabled and TWEEN_INFO_IN) or TWEEN_INFO_OUT
 250 | 		local tween = TweenService:Create(captionClone, tweenInfo, {Position = endPosition})
 251 | 		local updateCaretConnection = RunService.Heartbeat:Connect(updateCaret)
 252 | 		tween:Play()
 253 | 		tween.Completed:Once(function()
 254 | 			updateCaretConnection:Disconnect()
 255 | 		end)
 256 | 		
 257 | 	end
 258 | 	captionJanitor:add(clickRegion:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
 259 | 		updatePosition()
 260 | 	end))
 261 | 	updatePosition(false)
 262 | 	
 263 | 	captionJanitor:add(icon.toggleKeyAdded:Connect(updateHotkey))
 264 | 	for keyCodeEnum, _ in pairs(icon.bindedToggleKeys) do
 265 | 		updateHotkey(keyCodeEnum)
 266 | 		break
 267 | 	end
 268 | 	captionJanitor:add(icon.fakeToggleKeyChanged:Connect(updateHotkey))
 269 | 	local fakeToggleKey = icon.fakeToggleKey
 270 | 	if fakeToggleKey then
 271 | 		updateHotkey(fakeToggleKey)
 272 | 	end
 273 | 
 274 | 	local function setCaptionEnabled(enabled)
 275 | 		if isCompletelyEnabled == enabled then
 276 | 			return
 277 | 		end
 278 | 		local joinedFrame = icon.joinedFrame
 279 | 		if joinedFrame and string.match(joinedFrame.Name, "Dropdown") then
 280 | 			enabled = false
 281 | 		end
 282 | 		isCompletelyEnabled = enabled
 283 | 		local newTransparency = (enabled and 0) or 1
 284 | 		local tweenInfo = (enabled and TWEEN_INFO_IN) or TWEEN_INFO_OUT
 285 | 		local tweenTransparency = TweenService:Create(caption, tweenInfo, {
 286 | 			GroupTransparency = newTransparency
 287 | 		})
 288 | 		tweenTransparency:Play()
 289 | 		if enabled then
 290 | 			captionClone:SetAttribute("ForceUpdate", true)
 291 | 		end
 292 | 		updatePosition()
 293 | 		updateHotkey()
 294 | 	end
 295 | 	
 296 | 	local WAIT_DURATION = 0.5
 297 | 	local RECOVER_PERIOD = 0.3
 298 | 	local Icon = require(icon.iconModule)
 299 | 	captionJanitor:add(icon.stateChanged:Connect(function(stateName)
 300 | 		if stateName == "Viewing" then
 301 | 			local lastClock = Icon.captionLastClosedClock
 302 | 			local clockDifference = (lastClock and os.clock() - lastClock) or 999
 303 | 			local waitDuration = (clockDifference < RECOVER_PERIOD and 0) or WAIT_DURATION
 304 | 			task.delay(waitDuration, function()
 305 | 				if icon.activeState == "Viewing" then
 306 | 					setCaptionEnabled(true)
 307 | 				end
 308 | 			end)
 309 | 		else
 310 | 			Icon.captionLastClosedClock = os.clock()
 311 | 			setCaptionEnabled(false)
 312 | 		end
 313 | 	end))
 314 | 	
 315 | 	return caption
 316 | end
```
</details>

## ğŸŒ™ `Packages/_Index/1foreverhd_topbarplus@3.4.0/topbarplus/src/Elements/Container.lua`
<details>
<summary>View Source (214 lines)</summary>

```lua
   1 | local hasBecomeOldTheme = false
   2 | local previousInsetHeight = 0
   3 | return function(Icon)
   4 | 	
   5 | 	-- Has to be included for the time being due to this bug mentioned here:
   6 | 	-- https://devforum.roblox.com/t/bug/2973508/7
   7 | 	local GuiService = game:GetService("GuiService")
   8 | 	local Players =  game:GetService("Players")
   9 | 	local UserInputService = game:GetService("UserInputService")
  10 | 	local container = {}
  11 | 	local Signal = require(script.Parent.Parent.Packages.GoodSignal)
  12 | 	local insetChanged = Signal.new()
  13 | 	local guiInset = GuiService:GetGuiInset()
  14 | 	local startInset = 0
  15 | 	local yDownOffset = 0
  16 | 	local ySizeOffset = 0
  17 | 	local checkCount = 0
  18 | 	local isConsoleScreen = false
  19 | 	local isUsingVR = false
  20 | 	local function checkInset(status)
  21 | 		local currentHeight = GuiService.TopbarInset.Height
  22 | 		local isOldTopbar = currentHeight <= 36
  23 | 		
  24 | 
  25 | 		-- These additional checks are needed to ensure *it is actually* the old topbar
  26 | 		-- and not a client which takes a really long time to load
  27 | 		-- There's unfortunately no APIs to do this a prettier way
  28 | 		isConsoleScreen = GuiService:IsTenFootInterface()
  29 | 		isUsingVR = UserInputService.VREnabled
  30 | 		Icon.isOldTopbar = isOldTopbar
  31 | 		checkCount += 1
  32 | 		if currentHeight == 0 and status == nil then
  33 | 			task.defer(function()
  34 | 				task.wait(8)
  35 | 				checkInset("ForceConvertToOld")
  36 | 			end)
  37 | 		elseif checkCount == 1 then
  38 | 			task.delay(5, function()
  39 | 				local localPlayer = Players.LocalPlayer
  40 | 				localPlayer:WaitForChild("PlayerGui")
  41 | 				if checkCount == 1 then
  42 | 					checkInset()
  43 | 				end
  44 | 			end)
  45 | 		end
  46 | 
  47 | 		-- Conver to old theme if verified
  48 | 		if Icon.isOldTopbar and not isConsoleScreen and not isUsingVR and hasBecomeOldTheme == false and (currentHeight ~= 0 or status == "ForceConvertToOld") then
  49 | 			hasBecomeOldTheme = true
  50 | 			task.defer(function()
  51 | 				-- If oldtopbar, apply the Classic theme
  52 | 				local themes = script.Parent.Parent.Features.Themes
  53 | 				local Classic = require(themes.Classic)
  54 | 				Icon.modifyBaseTheme(Classic)
  55 | 
  56 | 				-- Also configure the oldtopbar correctly
  57 | 				local function decideToHideTopbar()
  58 | 					if GuiService.MenuIsOpen then
  59 | 						Icon.setTopbarEnabled(false, true)
  60 | 					else
  61 | 						Icon.setTopbarEnabled()
  62 | 					end
  63 | 				end
  64 | 				GuiService:GetPropertyChangedSignal("MenuIsOpen"):Connect(decideToHideTopbar)
  65 | 				decideToHideTopbar()
  66 | 			end)
  67 | 		end
  68 | 
  69 | 		-- Modify the offsets slightly depending on device type
  70 | 		guiInset = GuiService:GetGuiInset()
  71 | 		startInset = if isOldTopbar then 12 else guiInset.Y - 50
  72 | 		yDownOffset = if isOldTopbar then 2 else 0 --if isOldTopbar then 2 else 0 
  73 | 		ySizeOffset = -2
  74 | 		if isConsoleScreen then
  75 | 			startInset = 10
  76 | 			yDownOffset = 0 ---9
  77 | 		end
  78 | 		if GuiService.TopbarInset.Height == 0 and not hasBecomeOldTheme then
  79 | 			yDownOffset += 13
  80 | 			ySizeOffset = 50
  81 | 		end
  82 | 
  83 | 		-- Now inform other areas of the change
  84 | 		insetChanged:Fire(guiInset)
  85 | 		local insetHeight = guiInset.Y
  86 | 		if insetHeight ~= previousInsetHeight then
  87 | 			previousInsetHeight = insetHeight
  88 | 			task.defer(function()
  89 | 				Icon.insetHeightChanged:Fire(insetHeight)
  90 | 			end)
  91 | 		end
  92 | 		
  93 | 	end
  94 | 	GuiService:GetPropertyChangedSignal("TopbarInset"):Connect(checkInset)
  95 | 	checkInset("FirstTime")
  96 | 
  97 | 	local screenGui = Instance.new("ScreenGui")
  98 | 	insetChanged:Connect(function()
  99 | 		screenGui:SetAttribute("StartInset", startInset)
 100 | 	end)
 101 | 	screenGui.Name = "TopbarStandard"
 102 | 	screenGui.Enabled = true
 103 | 	screenGui.DisplayOrder = Icon.baseDisplayOrder
 104 | 	screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
 105 | 	screenGui.IgnoreGuiInset = true
 106 | 	screenGui.ResetOnSpawn = false
 107 | 	screenGui.ScreenInsets = Enum.ScreenInsets.TopbarSafeInsets
 108 | 	container[screenGui.Name] = screenGui
 109 | 	Icon.baseDisplayOrderChanged:Connect(function()
 110 | 		screenGui.DisplayOrder = Icon.baseDisplayOrder
 111 | 	end)
 112 | 
 113 | 	local holders = Instance.new("Frame")
 114 | 	holders.Name = "Holders"
 115 | 	holders.BackgroundTransparency = 1
 116 | 	insetChanged:Connect(function()
 117 | 		local holderY = if isUsingVR then 36 else 56
 118 | 		local holderSize = if isConsoleScreen then UDim2.new(1, 0, 0, holderY) else UDim2.new(1, 0, 1, ySizeOffset)
 119 | 		holders.Position = UDim2.new(0, 0, 0, yDownOffset)
 120 | 		holders.Size = holderSize
 121 | 	end)
 122 | 	holders.Visible = true
 123 | 	holders.ZIndex = 1
 124 | 	holders.Parent = screenGui
 125 | 	
 126 | 	local screenGuiCenter = screenGui:Clone()
 127 | 	local holdersCenter = screenGuiCenter.Holders
 128 | 	local function updateCenteredHoldersHeight()
 129 | 		holdersCenter.Size = UDim2.new(1, 0, 0, GuiService.TopbarInset.Height+ySizeOffset)
 130 | 	end
 131 | 	screenGuiCenter.Name = "TopbarCentered"
 132 | 	screenGuiCenter.DisplayOrder = Icon.baseDisplayOrder
 133 | 	screenGuiCenter.ScreenInsets = Enum.ScreenInsets.None
 134 | 	Icon.baseDisplayOrderChanged:Connect(function()
 135 | 		screenGuiCenter.DisplayOrder = Icon.baseDisplayOrder
 136 | 	end)
 137 | 	container[screenGuiCenter.Name] = screenGuiCenter
 138 | 	
 139 | 	insetChanged:Connect(updateCenteredHoldersHeight)
 140 | 	updateCenteredHoldersHeight()
 141 | 	
 142 | 	local screenGuiClipped = screenGui:Clone()
 143 | 	screenGuiClipped.Name = screenGuiClipped.Name.."Clipped"
 144 | 	screenGuiClipped.DisplayOrder = (Icon.baseDisplayOrder + 1)
 145 | 	Icon.baseDisplayOrderChanged:Connect(function()
 146 | 		screenGuiClipped.DisplayOrder = (Icon.baseDisplayOrder + 1)
 147 | 	end)
 148 | 	container[screenGuiClipped.Name] = screenGuiClipped
 149 | 	
 150 | 	local screenGuiCenterClipped = screenGuiCenter:Clone()
 151 | 	screenGuiCenterClipped.Name = screenGuiCenterClipped.Name.."Clipped"
 152 | 	screenGuiCenterClipped.DisplayOrder = (Icon.baseDisplayOrder + 1)
 153 | 	Icon.baseDisplayOrderChanged:Connect(function()
 154 | 		screenGuiCenterClipped.DisplayOrder = (Icon.baseDisplayOrder + 1)
 155 | 	end)
 156 | 	container[screenGuiCenterClipped.Name] = screenGuiCenterClipped
 157 | 	
 158 | 	local holderReduction = -24
 159 | 	local left = Instance.new("ScrollingFrame")
 160 | 	left:SetAttribute("IsAHolder", true)
 161 | 	left.Name = "Left"
 162 | 	insetChanged:Connect(function()
 163 | 		left.Position = UDim2.fromOffset(startInset, 0)
 164 | 	end)
 165 | 	left.Size = UDim2.new(1, holderReduction, 1, 0)
 166 | 	left.BackgroundTransparency = 1
 167 | 	left.Visible = true
 168 | 	left.ZIndex = 1
 169 | 	left.Active = false
 170 | 	left.ClipsDescendants = true
 171 | 	left.HorizontalScrollBarInset = Enum.ScrollBarInset.None
 172 | 	left.CanvasSize = UDim2.new(0, 0, 1, -1) -- This -1 prevents a dropdown scrolling appearance bug
 173 | 	left.AutomaticCanvasSize = Enum.AutomaticSize.X
 174 | 	left.ScrollingDirection = Enum.ScrollingDirection.X
 175 | 	left.ScrollBarThickness = 0
 176 | 	left.BorderSizePixel = 0
 177 | 	left.Selectable = false
 178 | 	left.ScrollingEnabled = false--true
 179 | 	left.ElasticBehavior = Enum.ElasticBehavior.Never
 180 | 	left.Parent = holders
 181 | 	
 182 | 	local UIListLayout = Instance.new("UIListLayout")
 183 | 	insetChanged:Connect(function()
 184 | 		UIListLayout.Padding = UDim.new(0, startInset)
 185 | 	end)
 186 | 	UIListLayout.FillDirection = Enum.FillDirection.Horizontal
 187 | 	UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
 188 | 	UIListLayout.VerticalAlignment = Enum.VerticalAlignment.Bottom
 189 | 	UIListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
 190 | 	UIListLayout.Parent = left
 191 | 	
 192 | 	local center = left:Clone()
 193 | 	insetChanged:Connect(function()
 194 | 		center.UIListLayout.Padding = UDim.new(0, startInset)
 195 | 	end)
 196 | 	center.ScrollingEnabled = false
 197 | 	center.UIListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
 198 | 	center.Name = "Center"
 199 | 	center.Parent = holdersCenter
 200 | 	
 201 | 	local right = left:Clone()
 202 | 	insetChanged:Connect(function()
 203 | 		right.UIListLayout.Padding = UDim.new(0, startInset)
 204 | 	end)
 205 | 	right.UIListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Right
 206 | 	right.Name = "Right"
 207 | 	right.AnchorPoint = Vector2.new(1, 0)
 208 | 	right.Position = UDim2.new(1, -12, 0, 0)
 209 | 	right.Parent = holders
 210 | 
 211 | 	-- This is important so that all elements update instantly
 212 | 	insetChanged:Fire(guiInset)
 213 | 
 214 | 	return container
 215 | end
```
</details>

## ğŸŒ™ `Packages/_Index/1foreverhd_topbarplus@3.4.0/topbarplus/src/Elements/Dropdown.lua`
<details>
<summary>View Source (314 lines)</summary>

```lua
   1 | local TweenService = game:GetService("TweenService")
   2 | local RunService = game:GetService("RunService")
   3 | local Themes = require(script.Parent.Parent.Features.Themes)
   4 | local PADDING = 0 -- used to be 8
   5 | return function(icon)
   6 | 	
   7 | 	local dropdown = Instance.new("Frame") -- Instance.new("CanvasGroup")
   8 | 	dropdown.Name = "Dropdown"
   9 | 	dropdown.AutomaticSize = Enum.AutomaticSize.X
  10 | 	dropdown.BackgroundTransparency = 1
  11 | 	dropdown.BorderSizePixel = 0
  12 | 	dropdown.AnchorPoint = Vector2.new(0.5, 0)
  13 | 	dropdown.Position = UDim2.new(0.5, 0, 1, 10)
  14 | 	dropdown.ZIndex = -2
  15 | 	dropdown.ClipsDescendants = true
  16 | 	dropdown.Parent = icon.widget
  17 | 
  18 | 	-- Account for PreferredTransparency which can be set by every player
  19 | 	local GuiService = game:GetService("GuiService")
  20 | 	icon:setBehaviour("Dropdown", "BackgroundTransparency", function(value)
  21 | 		local preference = GuiService.PreferredTransparency
  22 | 		local newValue = value * preference
  23 | 		if value == 1 then
  24 | 			return value
  25 | 		end
  26 | 		return newValue
  27 | 	end)
  28 | 	icon.janitor:add(GuiService:GetPropertyChangedSignal("PreferredTransparency"):Connect(function()
  29 | 		icon:refreshAppearance(dropdown, "BackgroundTransparency")
  30 | 	end))
  31 | 
  32 | 	local UICorner = Instance.new("UICorner")
  33 | 	UICorner.Name = "DropdownCorner"
  34 | 	UICorner.CornerRadius = UDim.new(0, 10)
  35 | 	UICorner.Parent = dropdown
  36 | 
  37 | 	local dropdownScroller = Instance.new("ScrollingFrame")
  38 | 	dropdownScroller.Name = "DropdownScroller"
  39 | 	dropdownScroller.AutomaticSize = Enum.AutomaticSize.X
  40 | 	dropdownScroller.BackgroundTransparency = 1
  41 | 	dropdownScroller.BorderSizePixel = 0
  42 | 	dropdownScroller.AnchorPoint = Vector2.new(0, 0)
  43 | 	dropdownScroller.Position = UDim2.new(0, 0, 0, 0)
  44 | 	dropdownScroller.ZIndex = -1
  45 | 	dropdownScroller.ClipsDescendants = true
  46 | 	dropdownScroller.Visible = true
  47 | 	dropdownScroller.VerticalScrollBarInset = Enum.ScrollBarInset.None --ScrollBar
  48 | 	dropdownScroller.VerticalScrollBarPosition = Enum.VerticalScrollBarPosition.Right
  49 | 	dropdownScroller.Active = false
  50 | 	dropdownScroller.ScrollingEnabled = true
  51 | 	dropdownScroller.AutomaticCanvasSize = Enum.AutomaticSize.Y
  52 | 	dropdownScroller.ScrollBarThickness = 5
  53 | 	dropdownScroller.ScrollBarImageColor3 = Color3.fromRGB(255, 255, 255)
  54 | 	dropdownScroller.ScrollBarImageTransparency = 0.8
  55 | 	dropdownScroller.CanvasSize = UDim2.new(0, 0, 0, 0)
  56 | 	dropdownScroller.Selectable = false
  57 | 	dropdownScroller.Active = true
  58 | 	dropdownScroller.Parent = dropdown
  59 | 
  60 | 	local TweenDuration = Instance.new("NumberValue") -- this helps to change the speed to open / close in modifyTheme()
  61 | 	TweenDuration.Name = "DropdownSpeed"
  62 | 	TweenDuration.Value = 0.07
  63 | 	TweenDuration.Parent = dropdown
  64 | 
  65 | 	local dropdownPadding = Instance.new("UIPadding")
  66 | 	dropdownPadding.Name = "DropdownPadding"
  67 | 	dropdownPadding.PaddingTop = UDim.new(0, PADDING)
  68 | 	dropdownPadding.PaddingBottom = UDim.new(0, PADDING)
  69 | 	dropdownPadding.Parent = dropdownScroller
  70 | 
  71 | 	local dropdownList = Instance.new("UIListLayout")
  72 | 	dropdownList.Name = "DropdownList"
  73 | 	dropdownList.FillDirection = Enum.FillDirection.Vertical
  74 | 	dropdownList.SortOrder = Enum.SortOrder.LayoutOrder
  75 | 	dropdownList.HorizontalAlignment = Enum.HorizontalAlignment.Center
  76 | 	dropdownList.HorizontalFlex = Enum.UIFlexAlignment.SpaceEvenly
  77 | 	dropdownList.Parent = dropdownScroller
  78 | 
  79 | 	local dropdownJanitor = icon.dropdownJanitor
  80 | 	local Icon = require(icon.iconModule)
  81 | 	icon.dropdownChildAdded:Connect(function(childIcon)
  82 | 		local _, modificationUID = childIcon:modifyTheme({
  83 | 			{"Widget", "BorderSize", 0},
  84 | 			{"IconCorners", "CornerRadius", UDim.new(0, 10)},
  85 | 			{"Widget", "MinimumWidth", 190},
  86 | 			{"Widget", "MinimumHeight", 58},
  87 | 			{"IconLabel", "TextSize", 20},
  88 | 			{"IconOverlay", "Size", UDim2.new(1, 0, 1, 0)},
  89 | 			{"PaddingLeft", "Size", UDim2.fromOffset(25, 0)},
  90 | 			{"Notice", "Position", UDim2.new(1, -24, 0, 5)},
  91 | 			{"ContentsList", "HorizontalAlignment", Enum.HorizontalAlignment.Left},
  92 | 			{"Selection", "Size", UDim2.new(1, -PADDING, 1, -PADDING)},
  93 | 			{"Selection", "Position", UDim2.new(0, PADDING/2, 0, PADDING/2)},
  94 | 		})
  95 | 		task.defer(function()
  96 | 			childIcon.joinJanitor:add(function()
  97 | 				childIcon:removeModification(modificationUID)
  98 | 			end)
  99 | 		end)
 100 | 	end)
 101 | 	icon.dropdownSet:Connect(function(arrayOfIcons)
 102 | 		for i, otherIconUID in pairs(icon.dropdownIcons) do
 103 | 			local otherIcon = Icon.getIconByUID(otherIconUID)
 104 | 			otherIcon:destroy()
 105 | 		end
 106 | 		if type(arrayOfIcons) == "table" then
 107 | 			for i, otherIcon in pairs(arrayOfIcons) do
 108 | 				otherIcon:joinDropdown(icon)
 109 | 			end
 110 | 		end
 111 | 	end)
 112 | 
 113 | 	local function updateMaxIcons()
 114 | 		--icon:modifyTheme({"Dropdown", "Visible", icon.isSelected})
 115 | 		local maxIcons = dropdown:GetAttribute("MaxIcons")
 116 | 		if not maxIcons then return 0 end
 117 | 		local children = {}
 118 | 		for _, child in pairs(dropdownScroller:GetChildren()) do
 119 | 			if child:IsA("GuiObject") and child.Visible then
 120 | 				table.insert(children, child)
 121 | 			end
 122 | 		end
 123 | 
 124 | 		table.sort(children, function(a, b) return a.AbsolutePosition.Y < b.AbsolutePosition.Y end)
 125 | 		local totalHeight = 0
 126 | 		local maxIconsRoundedUp = math.ceil(maxIcons)
 127 | 		for i = 1, maxIconsRoundedUp do
 128 | 			local child = children[i]
 129 | 			if not child then break end
 130 | 			local height = child.AbsoluteSize.Y
 131 | 			local isReduced = i == maxIconsRoundedUp and maxIconsRoundedUp ~= maxIcons
 132 | 			if isReduced then
 133 | 				height *= (maxIcons - maxIconsRoundedUp + 1)
 134 | 			end
 135 | 			totalHeight += height
 136 | 		end
 137 | 		totalHeight += dropdownPadding.PaddingTop.Offset + dropdownPadding.PaddingBottom.Offset
 138 | 		return totalHeight
 139 | 	end
 140 | 	
 141 | 	local openTween = nil
 142 | 	local closeTween = nil
 143 | 	local currentSpeedMultiplier = nil
 144 | 	local currentTweenInfo = nil
 145 | 	local function getTweenInfo()
 146 | 		local speedMultiplier = Themes.getInstanceValue(dropdown, "MaxIcons") or 1
 147 | 		if currentSpeedMultiplier and currentSpeedMultiplier == speedMultiplier and currentTweenInfo then
 148 | 			return currentTweenInfo
 149 | 		end
 150 | 		local newTweenInfo = TweenInfo.new(
 151 | 			TweenDuration.Value * speedMultiplier,
 152 | 			Enum.EasingStyle.Exponential,
 153 | 			Enum.EasingDirection.Out
 154 | 		)
 155 | 		currentTweenInfo = newTweenInfo
 156 | 		currentSpeedMultiplier = speedMultiplier
 157 | 		return newTweenInfo
 158 | 	end
 159 | 	local function updateVisibility()
 160 | 		-- Update visibiliy of dropdown using tween transition
 161 | 		local tweenInfo = getTweenInfo()
 162 | 		
 163 | 		if openTween then
 164 | 			openTween:Cancel()
 165 | 			openTween = nil
 166 | 		end
 167 | 		if closeTween then
 168 | 			closeTween:Cancel()
 169 | 			closeTween = nil
 170 | 		end
 171 | 
 172 | 		if icon.isSelected then
 173 | 			local height = updateMaxIcons()
 174 | 			dropdown.Visible = true
 175 | 			dropdown.BackgroundTransparency = 0 -- no transparency so it looks solid
 176 | 			dropdown.Size = UDim2.new(0, dropdown.Size.X.Offset, 0, 0) -- reset height to 0 before tween
 177 | 
 178 | 			openTween = TweenService:Create(dropdown, tweenInfo, {Size = UDim2.new(0, dropdown.Size.X.Offset, 0, height)})
 179 | 			openTween:Play()
 180 | 			openTween.Completed:Connect(function()
 181 | 				openTween = nil
 182 | 			end)
 183 | 		else
 184 | 			local closeTweenInfo = TweenInfo.new(0)
 185 | 			closeTween = TweenService:Create(dropdown, closeTweenInfo, {Size = UDim2.new(0, dropdown.Size.X.Offset, 0, 0)})
 186 | 			closeTween:Play()
 187 | 			closeTween.Completed:Connect(function()
 188 | 				closeTween = nil
 189 | 			end)
 190 | 		end
 191 | 	end
 192 | 
 193 | 	dropdownJanitor:add(icon.toggled:Connect(updateVisibility))
 194 | 	updateVisibility()
 195 | 	--task.delay(0.2, updateVisibility)
 196 | 
 197 | 	local function updateChildSize()
 198 | 		local tweenInfo = getTweenInfo()
 199 | 		if not icon.isSelected then return end
 200 | 		if openTween then
 201 | 			openTween:Cancel()
 202 | 			openTween = nil
 203 | 		end
 204 | 		if closeTween then
 205 | 			closeTween:Cancel()
 206 | 			closeTween = nil
 207 | 		end
 208 | 		
 209 | 		RunService.Heartbeat:Wait()
 210 | 		
 211 | 		local height = updateMaxIcons()
 212 | 
 213 | 		openTween = TweenService:Create(dropdown, tweenInfo, {Size = UDim2.new(0, dropdown.Size.X.Offset, 0, height)})
 214 | 		openTween:Play()
 215 | 		openTween.Completed:Connect(function()	
 216 | 			openTween = nil
 217 | 		end)
 218 | 	end
 219 | 
 220 | 	dropdownJanitor:add(icon.toggled:Connect(updateVisibility))
 221 | 
 222 | 	-- Ensures canvas and size stay synced (original updateMaxIcons logic)
 223 | 	local updateCount = 0
 224 | 	local isUpdating = false
 225 | 
 226 | 	-- This updates the scrolling frame to only display a scroll
 227 | 	-- length equal to the distance produced by its MaxIcons
 228 | 	local function updateMaxIconsListener()
 229 | 		updateCount += 1
 230 | 		if isUpdating then return end
 231 | 		local myUpdateCount = updateCount
 232 | 		isUpdating = true
 233 | 		task.defer(function()
 234 | 			isUpdating = false
 235 | 			if updateCount ~= myUpdateCount then
 236 | 				updateMaxIconsListener()
 237 | 			end
 238 | 		end)
 239 | 		local maxIcons = dropdown:GetAttribute("MaxIcons")
 240 | 		if not maxIcons then return end
 241 | 
 242 | 		local orderedInstances = {}
 243 | 		for _, child in pairs(dropdownScroller:GetChildren()) do
 244 | 			if child:IsA("GuiObject") and child.Visible then
 245 | 				table.insert(orderedInstances, {child, child.AbsolutePosition.Y})
 246 | 			end
 247 | 		end
 248 | 		table.sort(orderedInstances, function(a, b) return a[2] < b[2] end)
 249 | 
 250 | 		local totalHeight = 0
 251 | 		local hasSetNextSelection = false
 252 | 		local maxIconsRoundedUp = math.ceil(maxIcons)
 253 | 		for i = 1, maxIconsRoundedUp do
 254 | 			local group = orderedInstances[i]
 255 | 			if not group then break end
 256 | 			local child = group[1]
 257 | 			local height = child.AbsoluteSize.Y
 258 | 			local isReduced = i == maxIconsRoundedUp and maxIconsRoundedUp ~= maxIcons
 259 | 			if isReduced then
 260 | 				height = height * (maxIcons - maxIconsRoundedUp + 1)
 261 | 			end
 262 | 			totalHeight += height
 263 | 			if isReduced then
 264 | 				continue
 265 | 			end
 266 | 			local iconUID = child:GetAttribute("WidgetUID")
 267 | 			local childIcon = iconUID and Icon.getIconByUID(iconUID)
 268 | 			if childIcon then
 269 | 				local nextSelection = nil
 270 | 				if not hasSetNextSelection then
 271 | 					hasSetNextSelection = true
 272 | 					nextSelection = icon:getInstance("ClickRegion")
 273 | 				end
 274 | 				childIcon:getInstance("ClickRegion").NextSelectionUp = nextSelection
 275 | 			end
 276 | 		end
 277 | 		totalHeight += dropdownPadding.PaddingTop.Offset + dropdownPadding.PaddingBottom.Offset
 278 | 
 279 | 		dropdownScroller.Size = UDim2.fromOffset(0, totalHeight)
 280 | 
 281 | 	end
 282 | 
 283 | 	dropdownJanitor:add(dropdownScroller:GetPropertyChangedSignal("AbsoluteCanvasSize"):Connect(updateMaxIconsListener))
 284 | 	dropdownJanitor:add(dropdownScroller.ChildAdded:Connect(updateMaxIconsListener))
 285 | 	dropdownJanitor:add(dropdownScroller.ChildRemoved:Connect(updateChildSize)) -- rezise the dropdown when icon delects or adds
 286 | 	dropdownJanitor:add(dropdownScroller.ChildRemoved:Connect(updateMaxIconsListener))
 287 | 	dropdownJanitor:add(dropdown:GetAttributeChangedSignal("MaxIcons"):Connect(updateMaxIconsListener))
 288 | 	dropdownJanitor:add(dropdown:GetAttributeChangedSignal("MaxIcons"):Connect(updateChildSize))
 289 | 	dropdownJanitor:add(icon.childThemeModified:Connect(updateMaxIconsListener))
 290 | 	updateMaxIconsListener()
 291 | 
 292 | 	-- Ensures each child listens to visibility changes
 293 | 	local function connectVisibilityListeners(child)
 294 | 		if child:IsA("GuiObject") then
 295 | 			child:GetPropertyChangedSignal("Visible"):Connect(updateChildSize)
 296 | 			child:GetPropertyChangedSignal("Size"):Connect(updateChildSize) -- -- update max icons when child size changes
 297 | 		end
 298 | 	end
 299 | 	
 300 | 	-- For existing children
 301 | 	for _, child in pairs(dropdownScroller:GetChildren()) do
 302 | 		connectVisibilityListeners(child)
 303 | 	end
 304 | 	-- For new children
 305 | 	dropdownScroller.ChildAdded:Connect(function(child)
 306 | 		RunService.Heartbeat:Wait()
 307 | 		connectVisibilityListeners(child)
 308 | 		updateChildSize()
 309 | 	end)
 310 | 
 311 | 	-- On start, hide dropdown (prevent it showing as opened)
 312 | 	dropdown.Visible = false
 313 | 
 314 | 	return dropdown
 315 | end
```
</details>

## ğŸŒ™ `Packages/_Index/1foreverhd_topbarplus@3.4.0/topbarplus/src/Elements/Indicator.lua`
<details>
<summary>View Source (90 lines)</summary>

```lua
   1 | return function(icon, Icon)
   2 | 
   3 | 	local widget = icon.widget
   4 | 	local contents = icon:getInstance("Contents")
   5 | 	local indicator = Instance.new("Frame")
   6 | 	indicator.Name = "Indicator"
   7 | 	indicator.LayoutOrder = 9999999
   8 | 	indicator.ZIndex = 6
   9 | 	indicator.Size = UDim2.new(0, 42, 0, 42)
  10 | 	indicator.BorderColor3 = Color3.fromRGB(0, 0, 0)
  11 | 	indicator.BackgroundTransparency = 1
  12 | 	indicator.Position = UDim2.new(1, 0, 0.5, 0)
  13 | 	indicator.BorderSizePixel = 0
  14 | 	indicator.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
  15 | 	indicator.Parent = contents
  16 | 
  17 | 	local indicatorButton = Instance.new("Frame")
  18 | 	indicatorButton.Name = "IndicatorButton"
  19 | 	indicatorButton.BorderColor3 = Color3.fromRGB(0, 0, 0)
  20 | 	indicatorButton.AnchorPoint = Vector2.new(0.5, 0.5)
  21 | 	indicatorButton.BorderSizePixel = 0
  22 | 	indicatorButton.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
  23 | 	indicatorButton.Parent = indicator
  24 | 	
  25 | 	local GuiService = game:GetService("GuiService")
  26 | 	local GamepadService = game:GetService("GamepadService")
  27 | 	local ourClickRegion = icon:getInstance("ClickRegion")
  28 | 	local function selectionChanged()
  29 | 		local selectedClickRegion = GuiService.SelectedObject
  30 | 		if selectedClickRegion == ourClickRegion then
  31 | 			indicatorButton.BackgroundTransparency = 1
  32 | 			indicatorButton.Position = UDim2.new(0.5, -2, 0.5, 0)
  33 | 			indicatorButton.Size = UDim2.fromScale(1.2, 1.2)
  34 | 		else
  35 | 			indicatorButton.BackgroundTransparency = 0.75
  36 | 			indicatorButton.Position = UDim2.new(0.5, 2, 0.5, 0)
  37 | 			indicatorButton.Size = UDim2.fromScale(1, 1)
  38 | 		end
  39 | 	end
  40 | 	icon.janitor:add(GuiService:GetPropertyChangedSignal("SelectedObject"):Connect(selectionChanged))
  41 | 	selectionChanged()
  42 | 
  43 | 	local imageLabel = Instance.new("ImageLabel")
  44 | 	imageLabel.LayoutOrder = 2
  45 | 	imageLabel.ZIndex = 15
  46 | 	imageLabel.AnchorPoint = Vector2.new(0.5, 0.5)
  47 | 	imageLabel.Size = UDim2.new(0.5, 0, 0.5, 0)
  48 | 	imageLabel.BackgroundTransparency = 1
  49 | 	imageLabel.Position = UDim2.new(0.5, 0, 0.5, 0)
  50 | 	imageLabel.Image = "rbxasset://textures/ui/Controls/XboxController/DPadUp@2x.png"
  51 | 	imageLabel.Parent = indicatorButton
  52 | 
  53 | 	local UICorner = Instance.new("UICorner")
  54 | 	UICorner.CornerRadius = UDim.new(1, 0)
  55 | 	UICorner.Parent = indicatorButton
  56 | 
  57 | 	local UserInputService = game:GetService("UserInputService")
  58 | 	local function setIndicatorVisible(visibility)
  59 | 		if visibility == nil then
  60 | 			visibility = indicator.Visible
  61 | 		end
  62 | 		if GamepadService.GamepadCursorEnabled then
  63 | 			visibility = false
  64 | 		end
  65 | 		if visibility then
  66 | 			icon:modifyTheme({"PaddingRight", "Size", UDim2.new(0, 0, 1, 0)}, "IndicatorPadding")
  67 | 		elseif indicator.Visible then
  68 | 			icon:removeModification("IndicatorPadding")
  69 | 		end
  70 | 		icon:modifyTheme({"Indicator", "Visible", visibility})
  71 | 		icon.updateSize:Fire()
  72 | 	end
  73 | 	icon.janitor:add(GamepadService:GetPropertyChangedSignal("GamepadCursorEnabled"):Connect(setIndicatorVisible))
  74 | 	icon.indicatorSet:Connect(function(keyCode)
  75 | 		local visibility = false
  76 | 		if keyCode then
  77 | 			imageLabel.Image = UserInputService:GetImageForKeyCode(keyCode)
  78 | 			visibility = true
  79 | 		end
  80 | 		setIndicatorVisible(visibility)
  81 | 	end)
  82 | 
  83 | 	local function updateSize()
  84 | 		local ySize = widget.AbsoluteSize.Y*0.96
  85 | 		indicator.Size = UDim2.new(0, ySize, 0, ySize)
  86 | 	end
  87 | 	widget:GetPropertyChangedSignal("AbsoluteSize"):Connect(updateSize)
  88 | 	updateSize()
  89 | 
  90 | 	return indicator
  91 | end
```
</details>

## ğŸŒ™ `Packages/_Index/1foreverhd_topbarplus@3.4.0/topbarplus/src/Elements/Menu.lua`
<details>
<summary>View Source (179 lines)</summary>

```lua
   1 | return function(icon)
   2 | 
   3 | 	local menu = Instance.new("ScrollingFrame")
   4 | 	menu.Name = "Menu"
   5 | 	menu.BackgroundTransparency = 1
   6 | 	menu.Visible = true
   7 | 	menu.ZIndex = 1
   8 | 	menu.Size = UDim2.fromScale(1, 1)
   9 | 	menu.ClipsDescendants = true
  10 | 	menu.TopImage = ""
  11 | 	menu.BottomImage = ""
  12 | 	menu.HorizontalScrollBarInset = Enum.ScrollBarInset.Always
  13 | 	menu.CanvasSize = UDim2.new(0, 0, 1, -1) -- This -1 prevents a dropdown scrolling appearance bug
  14 | 	menu.ScrollingEnabled = true
  15 | 	menu.ScrollingDirection = Enum.ScrollingDirection.X
  16 | 	menu.ZIndex = 20
  17 | 	menu.ScrollBarThickness = 3
  18 | 	menu.ScrollBarImageColor3 = Color3.fromRGB(255, 255, 255)
  19 | 	menu.ScrollBarImageTransparency = 0.8
  20 | 	menu.BorderSizePixel = 0
  21 | 	menu.Selectable = false
  22 | 	
  23 | 	local Icon = require(icon.iconModule)
  24 | 	local menuUIListLayout = Icon.container.TopbarStandard:FindFirstChild("UIListLayout", true):Clone()
  25 | 	menuUIListLayout.Name = "MenuUIListLayout"
  26 | 	menuUIListLayout.VerticalAlignment = Enum.VerticalAlignment.Center
  27 | 	menuUIListLayout.Parent = menu
  28 | 
  29 | 	local menuGap = Instance.new("Frame")
  30 | 	menuGap.Name = "MenuGap"
  31 | 	menuGap.BackgroundTransparency = 1
  32 | 	menuGap.Visible = false
  33 | 	menuGap.AnchorPoint = Vector2.new(0, 0.5)
  34 | 	menuGap.ZIndex = 5
  35 | 	menuGap.Parent = menu
  36 | 	
  37 | 	local hasStartedMenu = false
  38 | 	local Themes = require(script.Parent.Parent.Features.Themes)
  39 | 	local function totalChildrenChanged()
  40 | 		
  41 | 		local menuJanitor = icon.menuJanitor
  42 | 		local totalIcons = #icon.menuIcons
  43 | 		if hasStartedMenu then
  44 | 			if totalIcons <= 0 then
  45 | 				menuJanitor:clean()
  46 | 				hasStartedMenu = false
  47 | 			end
  48 | 			return
  49 | 		end
  50 | 		hasStartedMenu = true
  51 | 		
  52 | 		-- Listen for changes
  53 | 		menuJanitor:add(icon.toggled:Connect(function()
  54 | 			if #icon.menuIcons > 0 then
  55 | 				icon.updateSize:Fire()
  56 | 			end
  57 | 		end))
  58 | 		
  59 | 		-- Modify appearance of menu icon when joined
  60 | 		local _, modificationUID = icon:modifyTheme({
  61 | 			{"Menu", "Active", true},
  62 | 		})
  63 | 		task.defer(function()
  64 | 			menuJanitor:add(function()
  65 | 				icon:removeModification(modificationUID)
  66 | 			end)
  67 | 		end)
  68 | 		
  69 | 		-- For right-aligned icons, this ensures their menus
  70 | 		-- close button appear instantly when selected (instead
  71 | 		-- of partially hidden from view)
  72 | 		local previousCanvasX = menu.AbsoluteCanvasSize.X
  73 | 		local function rightAlignCanvas()
  74 | 			if icon.alignment == "Right" then
  75 | 				local newCanvasX = menu.AbsoluteCanvasSize.X
  76 | 				local difference = previousCanvasX - newCanvasX
  77 | 				previousCanvasX = newCanvasX
  78 | 				menu.CanvasPosition = Vector2.new(menu.CanvasPosition.X - difference, 0)
  79 | 			end
  80 | 		end
  81 | 		menuJanitor:add(icon.selected:Connect(rightAlignCanvas))
  82 | 		menuJanitor:add(menu:GetPropertyChangedSignal("AbsoluteCanvasSize"):Connect(rightAlignCanvas))
  83 | 		
  84 | 		-- Apply a close selected image if the user hasn't applied thier own
  85 | 		local stateGroup = icon:getStateGroup()
  86 | 		local imageDeselected = Themes.getThemeValue(stateGroup, "IconImage", "Image", "Deselected")
  87 | 		local imageSelected = Themes.getThemeValue(stateGroup, "IconImage", "Image", "Selected")
  88 | 		if imageDeselected == imageSelected then
  89 | 			local fontLink = "rbxasset://fonts/families/FredokaOne.json"
  90 | 			local fontFace = Font.new(fontLink, Enum.FontWeight.Light, Enum.FontStyle.Normal)
  91 | 			icon:removeModificationWith("IconLabel", "Text", "Viewing")
  92 | 			icon:removeModificationWith("IconLabel", "Image", "Viewing")
  93 | 			icon:modifyTheme({
  94 | 				{"IconLabel", "FontFace", fontFace, "Selected"},
  95 | 				{"IconLabel", "Text", "X", "Selected"},
  96 | 				{"IconLabel", "TextSize", 20, "Selected"},
  97 | 				{"IconLabel", "TextStrokeTransparency", 0.8, "Selected"},
  98 | 				{"IconImage", "Image", "", "Selected"},
  99 | 			})
 100 | 		end
 101 | 
 102 | 		-- Change order of spot when alignment changes
 103 | 		local menuGap = icon:getInstance("MenuGap")
 104 | 		local function updateAlignent()
 105 | 			local alignment = icon.alignment
 106 | 			local spotIndex = -99999
 107 | 			local gapIndex = -99998
 108 | 			if alignment == "Right" then
 109 | 				spotIndex = 99999
 110 | 				gapIndex = 99998
 111 | 			end
 112 | 			icon:modifyTheme({"IconSpot", "LayoutOrder", spotIndex})
 113 | 			menuGap.LayoutOrder = gapIndex
 114 | 		end
 115 | 		menuJanitor:add(icon.alignmentChanged:Connect(updateAlignent))
 116 | 		updateAlignent()
 117 | 		
 118 | 		-- This updates the scrolling frame to only display a scroll
 119 | 		-- length equal to the distance produced by its MaxIcons
 120 | 		menu:GetAttributeChangedSignal("MenuCanvasWidth"):Connect(function()
 121 | 			local canvasWidth = menu:GetAttribute("MenuCanvasWidth")
 122 | 			local canvasY = menu.CanvasSize.Y
 123 | 			menu.CanvasSize = UDim2.new(0, canvasWidth, canvasY.Scale, canvasY.Offset)
 124 | 		end)
 125 | 		menuJanitor:add(icon.updateMenu:Connect(function()
 126 | 			local maxIcons = menu:GetAttribute("MaxIcons")
 127 | 			if not maxIcons then
 128 | 				return
 129 | 			end
 130 | 			local orderedInstances = {}
 131 | 			for _, child in pairs(menu:GetChildren()) do
 132 | 				local widgetUID = child:GetAttribute("WidgetUID")
 133 | 				if widgetUID and child.Visible then
 134 | 					table.insert(orderedInstances, {child, child.AbsolutePosition.X})
 135 | 				end
 136 | 			end
 137 | 			table.sort(orderedInstances, function(groupA, groupB)
 138 | 				return groupA[2] < groupB[2]
 139 | 			end)
 140 | 			local totalWidth = 0
 141 | 			for i = 1, maxIcons do
 142 | 				local group = orderedInstances[i]
 143 | 				if not group then
 144 | 					break
 145 | 				end
 146 | 				local child = group[1]
 147 | 				local width = child.AbsoluteSize.X + menuUIListLayout.Padding.Offset
 148 | 				totalWidth += width
 149 | 			end
 150 | 			menu:SetAttribute("MenuWidth", totalWidth)
 151 | 		end))
 152 | 		local function startMenuUpdate()
 153 | 			task.delay(0.1, function()
 154 | 				icon.startMenuUpdate:Fire()
 155 | 			end)
 156 | 		end
 157 | 		menuJanitor:add(menu.ChildAdded:Connect(startMenuUpdate))
 158 | 		menuJanitor:add(menu.ChildRemoved:Connect(startMenuUpdate))
 159 | 		menuJanitor:add(menu:GetAttributeChangedSignal("MaxIcons"):Connect(startMenuUpdate))
 160 | 		menuJanitor:add(menu:GetAttributeChangedSignal("MaxWidth"):Connect(startMenuUpdate))
 161 | 		startMenuUpdate()
 162 | 	end
 163 | 	
 164 | 	icon.menuChildAdded:Connect(totalChildrenChanged)
 165 | 	icon.menuSet:Connect(function(arrayOfIcons)
 166 | 		-- Reset any previous icons
 167 | 		for i, otherIconUID in pairs(icon.menuIcons) do
 168 | 			local otherIcon = Icon.getIconByUID(otherIconUID)
 169 | 			otherIcon:destroy()
 170 | 		end
 171 | 		-- Apply new icons
 172 | 		if type(arrayOfIcons) == "table" then
 173 | 			for i, otherIcon in pairs(arrayOfIcons) do
 174 | 				otherIcon:joinMenu(icon)
 175 | 			end
 176 | 		end
 177 | 	end)
 178 | 	
 179 | 	return menu
 180 | end
```
</details>

## ğŸŒ™ `Packages/_Index/1foreverhd_topbarplus@3.4.0/topbarplus/src/Elements/Notice.lua`
<details>
<summary>View Source (112 lines)</summary>

```lua
   1 | return function(icon, Icon)
   2 | 
   3 | 	local notice = Instance.new("Frame")
   4 | 	notice.Name = "Notice"
   5 | 	notice.ZIndex = 25
   6 | 	notice.AutomaticSize = Enum.AutomaticSize.X
   7 | 	notice.BorderColor3 = Color3.fromRGB(0, 0, 0)
   8 | 	notice.BorderSizePixel = 0
   9 | 	notice.BackgroundTransparency = 0.1
  10 | 	notice.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
  11 | 	notice.Visible = false
  12 | 	notice.Parent = icon.widget
  13 | 
  14 | 	local UICorner = Instance.new("UICorner")
  15 | 	UICorner.CornerRadius = UDim.new(1, 0)
  16 | 	UICorner.Parent = notice
  17 | 
  18 | 	local UIStroke = Instance.new("UIStroke")
  19 | 	UIStroke.Parent = notice
  20 | 
  21 | 	local noticeLabel = Instance.new("TextLabel")
  22 | 	noticeLabel.Name = "NoticeLabel"
  23 | 	noticeLabel.ZIndex = 26
  24 | 	noticeLabel.AnchorPoint = Vector2.new(0.5, 0.5)
  25 | 	noticeLabel.AutomaticSize = Enum.AutomaticSize.X
  26 | 	noticeLabel.Size = UDim2.new(1, 0, 1, 0)
  27 | 	noticeLabel.BackgroundTransparency = 1
  28 | 	noticeLabel.Position = UDim2.new(0.5, 0, 0.515, 0)
  29 | 	noticeLabel.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
  30 | 	noticeLabel.FontSize = Enum.FontSize.Size14
  31 | 	noticeLabel.TextColor3 = Color3.fromRGB(0, 0, 0)
  32 | 	noticeLabel.Text = "1"
  33 | 	noticeLabel.TextWrapped = true
  34 | 	noticeLabel.TextWrap = true
  35 | 	noticeLabel.Font = Enum.Font.Arial
  36 | 	noticeLabel.Parent = notice
  37 | 	
  38 | 	local iconModule = script.Parent.Parent
  39 | 	local packages = iconModule.Packages
  40 | 	local Janitor = require(packages.Janitor)
  41 | 	local Signal = require(packages.GoodSignal)
  42 | 	local Utility = require(iconModule.Utility)
  43 | 	icon.noticeChanged:Connect(function(totalNotices)
  44 | 
  45 | 		-- Notice amount
  46 | 		if not totalNotices then
  47 | 			return
  48 | 		end
  49 | 		local exceeded99 = totalNotices > 99
  50 | 		local noticeDisplay = (exceeded99 and "99+") or totalNotices
  51 | 		noticeLabel.Text = noticeDisplay
  52 | 		if exceeded99 then
  53 | 			noticeLabel.TextSize = 11
  54 | 		end
  55 | 
  56 | 		-- Should enable
  57 | 		local enabled = true
  58 | 		if totalNotices < 1 then
  59 | 			enabled = false
  60 | 		end
  61 | 		local parentIcon = Icon.getIconByUID(icon.parentIconUID)
  62 | 		local dropdownOrMenuActive = #icon.dropdownIcons > 0 or #icon.menuIcons > 0
  63 | 		if icon.isSelected and dropdownOrMenuActive then
  64 | 			enabled = false
  65 | 		elseif parentIcon and not parentIcon.isSelected then
  66 | 			enabled = false
  67 | 		end
  68 | 		Utility.setVisible(notice, enabled, "NoticeHandler")
  69 | 
  70 | 	end)
  71 | 	icon.noticeStarted:Connect(function(customClearSignal, noticeId)
  72 | 	
  73 | 		if not customClearSignal then
  74 | 			customClearSignal = icon.deselected
  75 | 		end
  76 | 		local parentIcon = Icon.getIconByUID(icon.parentIconUID)
  77 | 		if parentIcon then
  78 | 			parentIcon:notify(customClearSignal)
  79 | 		end
  80 | 		
  81 | 		local noticeJanitor = icon.janitor:add(Janitor.new())
  82 | 		local noticeComplete = noticeJanitor:add(Signal.new())
  83 | 		noticeJanitor:add(icon.endNotices:Connect(function()
  84 | 			noticeComplete:Fire()
  85 | 		end))
  86 | 		noticeJanitor:add(customClearSignal:Connect(function()
  87 | 			noticeComplete:Fire()
  88 | 		end))
  89 | 		noticeId = noticeId or Utility.generateUID()
  90 | 		icon.notices[noticeId] = {
  91 | 			completeSignal = noticeComplete,
  92 | 			clearNoticeEvent = customClearSignal,
  93 | 		}
  94 | 		local function updateNotice()
  95 | 			icon.noticeChanged:Fire(icon.totalNotices)
  96 | 		end
  97 | 		icon.notified:Fire(noticeId)
  98 | 		icon.totalNotices += 1
  99 | 		updateNotice()
 100 | 		noticeComplete:Once(function()
 101 | 			noticeJanitor:destroy()
 102 | 			icon.totalNotices -= 1
 103 | 			icon.notices[noticeId] = nil
 104 | 			updateNotice()
 105 | 		end)
 106 | 	end)
 107 | 	
 108 | 	-- Establish the notice
 109 | 	notice:SetAttribute("ClipToJoinedParent", true)
 110 | 	icon:clipOutside(notice)
 111 | 	
 112 | 	return notice
 113 | end
```
</details>

## ğŸŒ™ `Packages/_Index/1foreverhd_topbarplus@3.4.0/topbarplus/src/Elements/Selection.lua`
<details>
<summary>View Source (48 lines)</summary>

```lua
   1 | return function(Icon)
   2 | 
   3 | 	-- Credit to lolmansReturn and Canary Software for
   4 | 	-- retrieving these values
   5 | 	local selectionContainer = Instance.new("Frame")
   6 | 	selectionContainer.Name = "SelectionContainer"
   7 | 	selectionContainer.Visible = false
   8 | 	
   9 | 	local selection = Instance.new("Frame")
  10 | 	selection.Name = "Selection"
  11 | 	selection.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
  12 | 	selection.BackgroundTransparency = 1
  13 | 	selection.BorderColor3 = Color3.fromRGB(0, 0, 0)
  14 | 	selection.BorderSizePixel = 0
  15 | 	selection.Parent = selectionContainer
  16 | 
  17 | 	local UIStroke = Instance.new("UIStroke")
  18 | 	UIStroke.Name = "UIStroke"
  19 | 	UIStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
  20 | 	UIStroke.Color = Color3.fromRGB(255, 255, 255)
  21 | 	UIStroke.Thickness = 3
  22 | 	UIStroke.Parent = selection
  23 | 
  24 | 	local selectionGradient = Instance.new("UIGradient")
  25 | 	selectionGradient.Name = "SelectionGradient"
  26 | 	selectionGradient.Parent = UIStroke
  27 | 
  28 | 	local UICorner = Instance.new("UICorner")
  29 | 	UICorner:SetAttribute("Collective", "IconCorners")
  30 | 	UICorner.Name = "UICorner"
  31 | 	UICorner.CornerRadius = UDim.new(1, 0)
  32 | 	UICorner.Parent = selection
  33 | 	
  34 | 	local RunService = game:GetService("RunService")
  35 | 	local GuiService = game:GetService("GuiService")
  36 | 	local rotationSpeed = 1
  37 | 	selection:GetAttributeChangedSignal("RotationSpeed"):Connect(function()
  38 | 		rotationSpeed = selection:GetAttribute("RotationSpeed")
  39 | 	end)
  40 | 	RunService.Heartbeat:Connect(function()
  41 | 		if not GuiService.SelectedObject then
  42 | 			return
  43 | 		end
  44 | 		selectionGradient.Rotation = (os.clock() * rotationSpeed * 100) % 360
  45 | 	end)
  46 | 
  47 | 	return selectionContainer
  48 | 	
  49 | end
```
</details>

## ğŸŒ™ `Packages/_Index/1foreverhd_topbarplus@3.4.0/topbarplus/src/Elements/Widget.lua`
<details>
<summary>View Source (436 lines)</summary>

```lua
   1 | -- I named this 'Widget' instead of 'Icon' to make a clear difference between the icon *object* and
   2 | -- the icon (aka Widget) instance.
   3 | -- This contains the core components of the icon such as the button, image, label and notice. It's
   4 | -- also responsible for handling the automatic resizing of the widget (based upon image visibility and text length)
   5 | 
   6 | return function(icon, Icon)
   7 | 
   8 | 	local widget = Instance.new("Frame")
   9 | 	widget:SetAttribute("WidgetUID", icon.UID)
  10 | 	widget.Name = "Widget"
  11 | 	widget.BackgroundTransparency = 1
  12 | 	widget.Visible = true
  13 | 	widget.ZIndex = 20
  14 | 	widget.Active = false
  15 | 	widget.ClipsDescendants = true
  16 | 
  17 | 	local button = Instance.new("Frame")
  18 | 	button.Name = "IconButton"
  19 | 	button.Visible = true
  20 | 	button.ZIndex = 2
  21 | 	button.BorderSizePixel = 0
  22 | 	button.Parent = widget
  23 | 	button.ClipsDescendants = true
  24 | 	button.Active = false -- This is essential for mobile scrollers to work when dragging
  25 | 	icon.deselected:Connect(function()
  26 | 		button.ClipsDescendants = true
  27 | 		task.delay(0.2, function()
  28 | 			if icon.isSelected then
  29 | 				button.ClipsDescendants = false
  30 | 			end
  31 | 		end)
  32 | 	end)
  33 | 
  34 | 	-- Account for PreferredTransparency which can be set by every player
  35 | 	local GuiService = game:GetService("GuiService")
  36 | 	icon:setBehaviour("IconButton", "BackgroundTransparency", function(value)
  37 | 		local preference = GuiService.PreferredTransparency
  38 | 		local newValue = value * preference
  39 | 		if value == 1 then
  40 | 			return value
  41 | 		end
  42 | 		return newValue
  43 | 	end)
  44 | 	icon.janitor:add(GuiService:GetPropertyChangedSignal("PreferredTransparency"):Connect(function()
  45 | 		icon:refreshAppearance(button, "BackgroundTransparency")
  46 | 	end))
  47 | 
  48 | 	local iconCorner = Instance.new("UICorner")
  49 | 	iconCorner:SetAttribute("Collective", "IconCorners")
  50 | 	iconCorner.Name = "UICorner"
  51 | 	iconCorner.Parent = button
  52 | 
  53 | 	local menu = require(script.Parent.Menu)(icon)
  54 | 	local menuUIListLayout = menu.MenuUIListLayout
  55 | 	local menuGap = menu.MenuGap
  56 | 	menu.Parent = button
  57 | 
  58 | 	local iconSpot = Instance.new("Frame")
  59 | 	iconSpot.Name = "IconSpot"
  60 | 	iconSpot.BackgroundColor3 = Color3.fromRGB(225, 225, 225)
  61 | 	iconSpot.BackgroundTransparency = 0.9
  62 | 	iconSpot.Visible = true
  63 | 	iconSpot.AnchorPoint = Vector2.new(0, 0.5)
  64 | 	iconSpot.ZIndex = 5
  65 | 	iconSpot.Parent = menu
  66 | 
  67 | 	local iconSpotCorner = iconCorner:Clone()
  68 | 	iconSpotCorner.Parent = iconSpot
  69 | 
  70 | 	local overlay = iconSpot:Clone()
  71 | 	overlay.UICorner.Name = "OverlayUICorner"
  72 | 	overlay.Name = "IconOverlay"
  73 | 	overlay.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
  74 | 	overlay.ZIndex = iconSpot.ZIndex + 1
  75 | 	overlay.Size = UDim2.new(1, 0, 1, 0)
  76 | 	overlay.Position = UDim2.new(0, 0, 0, 0)
  77 | 	overlay.AnchorPoint = Vector2.new(0, 0)
  78 | 	overlay.Visible = false
  79 | 	overlay.Parent = iconSpot
  80 | 
  81 | 	local clickRegion = Instance.new("TextButton")
  82 | 	clickRegion:SetAttribute("CorrespondingIconUID", icon.UID)
  83 | 	clickRegion.Name = "ClickRegion"
  84 | 	clickRegion.BackgroundTransparency = 1
  85 | 	clickRegion.Visible = true
  86 | 	clickRegion.Text = ""
  87 | 	clickRegion.ZIndex = 20
  88 | 	clickRegion.Selectable = true
  89 | 	clickRegion.SelectionGroup = true
  90 | 	clickRegion.Parent = iconSpot
  91 | 	
  92 | 	local Gamepad = require(script.Parent.Parent.Features.Gamepad)
  93 | 	Gamepad.registerButton(clickRegion)
  94 | 
  95 | 	local clickRegionCorner = iconCorner:Clone()
  96 | 	clickRegionCorner.Parent = clickRegion
  97 | 
  98 | 	local contents = Instance.new("Frame")
  99 | 	contents.Name = "Contents"
 100 | 	contents.BackgroundTransparency = 1
 101 | 	contents.Size = UDim2.fromScale(1, 1)
 102 | 	contents.Parent = iconSpot
 103 | 
 104 | 	local contentsList = Instance.new("UIListLayout")
 105 | 	contentsList.Name = "ContentsList"
 106 | 	contentsList.FillDirection = Enum.FillDirection.Horizontal
 107 | 	contentsList.VerticalAlignment = Enum.VerticalAlignment.Center
 108 | 	contentsList.SortOrder = Enum.SortOrder.LayoutOrder
 109 | 	contentsList.VerticalFlex = Enum.UIFlexAlignment.SpaceEvenly
 110 | 	contentsList.Padding = UDim.new(0, 3)
 111 | 	contentsList.Parent = contents
 112 | 
 113 | 	local paddingLeft = Instance.new("Frame")
 114 | 	paddingLeft.Name = "PaddingLeft"
 115 | 	paddingLeft.LayoutOrder = 1
 116 | 	paddingLeft.ZIndex = 5
 117 | 	paddingLeft.BorderColor3 = Color3.fromRGB(0, 0, 0)
 118 | 	paddingLeft.BackgroundTransparency = 1
 119 | 	paddingLeft.BorderSizePixel = 0
 120 | 	paddingLeft.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
 121 | 	paddingLeft.Parent = contents
 122 | 
 123 | 	local paddingCenter = Instance.new("Frame")
 124 | 	paddingCenter.Name = "PaddingCenter"
 125 | 	paddingCenter.LayoutOrder = 3
 126 | 	paddingCenter.ZIndex = 5
 127 | 	paddingCenter.Size = UDim2.new(0, 0, 1, 0)
 128 | 	paddingCenter.BorderColor3 = Color3.fromRGB(0, 0, 0)
 129 | 	paddingCenter.BackgroundTransparency = 1
 130 | 	paddingCenter.BorderSizePixel = 0
 131 | 	paddingCenter.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
 132 | 	paddingCenter.Parent = contents
 133 | 
 134 | 	local paddingRight = Instance.new("Frame")
 135 | 	paddingRight.Name = "PaddingRight"
 136 | 	paddingRight.LayoutOrder = 5
 137 | 	paddingRight.ZIndex = 5
 138 | 	paddingRight.BorderColor3 = Color3.fromRGB(0, 0, 0)
 139 | 	paddingRight.BackgroundTransparency = 1
 140 | 	paddingRight.BorderSizePixel = 0
 141 | 	paddingRight.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
 142 | 	paddingRight.Parent = contents
 143 | 
 144 | 	local iconLabelContainer = Instance.new("Frame")
 145 | 	iconLabelContainer.Name = "IconLabelContainer"
 146 | 	iconLabelContainer.LayoutOrder = 4
 147 | 	iconLabelContainer.ZIndex = 3
 148 | 	iconLabelContainer.AnchorPoint = Vector2.new(0, 0.5)
 149 | 	iconLabelContainer.Size = UDim2.new(0, 0, 0.5, 0)
 150 | 	iconLabelContainer.BackgroundTransparency = 1
 151 | 	iconLabelContainer.Position = UDim2.new(0.5, 0, 0.5, 0)
 152 | 	iconLabelContainer.Parent = contents
 153 | 
 154 | 	local iconLabel = Instance.new("TextLabel")
 155 | 	local viewportX = workspace.CurrentCamera.ViewportSize.X+200
 156 | 	iconLabel.Name = "IconLabel"
 157 | 	iconLabel.LayoutOrder = 4
 158 | 	iconLabel.ZIndex = 15
 159 | 	iconLabel.AnchorPoint = Vector2.new(0, 0)
 160 | 	iconLabel.Size = UDim2.new(0, viewportX, 1, 0)
 161 | 	iconLabel.ClipsDescendants = false
 162 | 	iconLabel.BackgroundTransparency = 1
 163 | 	iconLabel.Position = UDim2.fromScale(0, 0)
 164 | 	iconLabel.RichText = true
 165 | 	iconLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
 166 | 	iconLabel.TextXAlignment = Enum.TextXAlignment.Left
 167 | 	iconLabel.Text = ""
 168 | 	iconLabel.TextWrapped = true
 169 | 	iconLabel.TextWrap = true
 170 | 	iconLabel.TextScaled = false
 171 | 	iconLabel.Active = false
 172 | 	iconLabel.AutoLocalize = true
 173 | 	iconLabel.Parent = iconLabelContainer
 174 | 
 175 | 	local iconImage = Instance.new("ImageLabel")
 176 | 	iconImage.Name = "IconImage"
 177 | 	iconImage.LayoutOrder = 2
 178 | 	iconImage.ZIndex = 15
 179 | 	iconImage.AnchorPoint = Vector2.new(0, 0.5)
 180 | 	iconImage.Size = UDim2.new(0, 0, 0.5, 0)
 181 | 	iconImage.BackgroundTransparency = 1
 182 | 	iconImage.Position = UDim2.new(0, 11, 0.5, 0)
 183 | 	iconImage.ScaleType = Enum.ScaleType.Stretch
 184 | 	iconImage.Active = false
 185 | 	iconImage.Parent = contents
 186 | 
 187 | 	local iconImageCorner = iconCorner:Clone()
 188 | 	iconImageCorner:SetAttribute("Collective", nil)
 189 | 	iconImageCorner.CornerRadius = UDim.new(0, 0)
 190 | 	iconImageCorner.Name = "IconImageCorner"
 191 | 	iconImageCorner.Parent = iconImage
 192 | 
 193 | 	local TweenService = game:GetService("TweenService")
 194 | 	local resizingCount = 0
 195 | 	local function handleLabelAndImageChangesUnstaggered(forceUpdateString)
 196 | 
 197 | 		-- We defer changes by a frame to eliminate all but 1 requests which
 198 | 		-- could otherwise stack up to 20+ requests in a single frame
 199 | 		-- We then repeat again once to account for any final changes
 200 | 		-- Deferring is also essential because properties are set immediately
 201 | 		-- afterwards (therefore calculations will use the correct values)
 202 | 		task.defer(function()
 203 | 			local indicator = icon.indicator
 204 | 			local usingIndicator = indicator and indicator.Visible
 205 | 			local usingText = usingIndicator or iconLabel.Text ~= ""
 206 | 			local usingImage = iconImage.Image ~= "" and iconImage.Image ~= nil
 207 | 			local _alignment = Enum.HorizontalAlignment.Center
 208 | 			local NORMAL_BUTTON_SIZE = UDim2.fromScale(1, 1)
 209 | 			local buttonSize = NORMAL_BUTTON_SIZE
 210 | 			if usingImage and not usingText then
 211 | 				iconLabelContainer.Visible = false
 212 | 				iconImage.Visible = true
 213 | 				paddingLeft.Visible = false
 214 | 				paddingCenter.Visible = false
 215 | 				paddingRight.Visible = false
 216 | 			elseif not usingImage and usingText then
 217 | 				iconLabelContainer.Visible = true
 218 | 				iconImage.Visible = false
 219 | 				paddingLeft.Visible = true
 220 | 				paddingCenter.Visible = false
 221 | 				paddingRight.Visible = true
 222 | 			elseif usingImage and usingText then
 223 | 				iconLabelContainer.Visible = true
 224 | 				iconImage.Visible = true
 225 | 				paddingLeft.Visible = true
 226 | 				paddingCenter.Visible = not usingIndicator
 227 | 				paddingRight.Visible = not usingIndicator
 228 | 				_alignment = Enum.HorizontalAlignment.Left
 229 | 			end
 230 | 			button.Size = buttonSize
 231 | 
 232 | 			local function getItemWidth(item)
 233 | 				local targetWidth = item:GetAttribute("TargetWidth") or item.AbsoluteSize.X
 234 | 				return targetWidth
 235 | 			end
 236 | 			local contentsPadding = contentsList.Padding.Offset
 237 | 			local initialWidgetWidth = contentsPadding --0
 238 | 			local textWidth = iconLabel.TextBounds.X
 239 | 			iconLabelContainer.Size = UDim2.new(0, textWidth, iconLabel.Size.Y.Scale, 0)
 240 | 			for _, child in pairs(contents:GetChildren()) do
 241 | 				if child:IsA("GuiObject") and child.Visible == true then
 242 | 					local itemWidth = getItemWidth(child)
 243 | 					initialWidgetWidth += itemWidth + contentsPadding
 244 | 				end
 245 | 			end
 246 | 			local widgetMinimumWidth = widget:GetAttribute("MinimumWidth")
 247 | 			local widgetMinimumHeight = widget:GetAttribute("MinimumHeight")
 248 | 			local widgetBorderSize = widget:GetAttribute("BorderSize")
 249 | 			local widgetWidth = math.clamp(initialWidgetWidth, widgetMinimumWidth, viewportX)
 250 | 			local menuIcons = icon.menuIcons
 251 | 			local additionalWidth = 0
 252 | 			local hasMenu = #menuIcons > 0
 253 | 			local showMenu = hasMenu and icon.isSelected
 254 | 			if showMenu then
 255 | 				for _, frame in pairs(menu:GetChildren()) do
 256 | 					if frame ~= iconSpot and frame:IsA("GuiObject") and frame.Visible then
 257 | 						additionalWidth += getItemWidth(frame) + menuUIListLayout.Padding.Offset
 258 | 					end
 259 | 				end
 260 | 				if not iconSpot.Visible then
 261 | 					widgetWidth -= (getItemWidth(iconSpot) + menuUIListLayout.Padding.Offset*2 + widgetBorderSize)
 262 | 				end
 263 | 				additionalWidth -= (widgetBorderSize*0.5)
 264 | 				widgetWidth += additionalWidth - (widgetBorderSize*0.75)
 265 | 			end
 266 | 			menuGap.Visible = showMenu and iconSpot.Visible
 267 | 			local desiredWidth = widget:GetAttribute("DesiredWidth")
 268 | 			if desiredWidth and widgetWidth < desiredWidth then
 269 | 				widgetWidth = desiredWidth
 270 | 			end
 271 | 
 272 | 			icon.updateMenu:Fire()
 273 | 			local preWidth = math.max(widgetWidth-additionalWidth, widgetMinimumWidth)
 274 | 			local spotWidth = preWidth-(widgetBorderSize*2)
 275 | 			local menuWidth = menu:GetAttribute("MenuWidth")
 276 | 			local totalMenuWidth = menuWidth and menuWidth + spotWidth + menuUIListLayout.Padding.Offset + 10
 277 | 			if totalMenuWidth then
 278 | 				local maxWidth = menu:GetAttribute("MaxWidth")
 279 | 				if maxWidth then
 280 | 					totalMenuWidth = math.max(maxWidth, widgetMinimumWidth)
 281 | 				end
 282 | 				menu:SetAttribute("MenuCanvasWidth", widgetWidth)
 283 | 				if totalMenuWidth < widgetWidth then
 284 | 					widgetWidth = totalMenuWidth
 285 | 				end
 286 | 			end
 287 | 
 288 | 			local style = Enum.EasingStyle.Quint
 289 | 			local direction = Enum.EasingDirection.Out
 290 | 			local spotWidthMax = math.max(spotWidth, getItemWidth(iconSpot), iconSpot.AbsoluteSize.X)
 291 | 			local widgetWidthMax = math.max(widgetWidth, getItemWidth(widget), widget.AbsoluteSize.X)
 292 | 			local SPEED = 750
 293 | 			local spotTweenInfo = TweenInfo.new(spotWidthMax/SPEED, style, direction)
 294 | 			local widgetTweenInfo = TweenInfo.new(widgetWidthMax/SPEED, style, direction)
 295 | 			TweenService:Create(iconSpot, spotTweenInfo, {
 296 | 				Position = UDim2.new(0, widgetBorderSize, 0.5, 0),
 297 | 				Size = UDim2.new(0, spotWidth, 1, -widgetBorderSize*2),
 298 | 			}):Play()
 299 | 			TweenService:Create(clickRegion, spotTweenInfo, {
 300 | 				Size = UDim2.new(0, spotWidth, 1, 0),
 301 | 			}):Play()
 302 | 			local newWidgetSize = UDim2.fromOffset(widgetWidth, widgetMinimumHeight)
 303 | 			local updateInstantly = widget.Size.Y.Offset ~= widgetMinimumHeight
 304 | 			if updateInstantly then
 305 | 				widget.Size = newWidgetSize
 306 | 			end
 307 | 			widget:SetAttribute("TargetWidth", newWidgetSize.X.Offset)
 308 | 			local movingTween = TweenService:Create(widget, widgetTweenInfo, {
 309 | 				Size = newWidgetSize,
 310 | 			})
 311 | 			movingTween:Play()
 312 | 			resizingCount += 1
 313 | 			for i = 1, widgetTweenInfo.Time * 100 do
 314 | 				task.delay(i/100, function()
 315 | 					Icon.iconChanged:Fire(icon)
 316 | 				end)
 317 | 			end
 318 | 			task.delay(widgetTweenInfo.Time-0.2, function()
 319 | 				resizingCount -= 1
 320 | 				task.defer(function()
 321 | 					if resizingCount == 0 then
 322 | 						icon.resizingComplete:Fire()
 323 | 					end
 324 | 				end)
 325 | 			end)
 326 | 			icon:updateParent()
 327 | 		end)
 328 | 	end
 329 | 	local Utility = require(script.Parent.Parent.Utility)
 330 | 	local handleLabelAndImageChanges = Utility.createStagger(0.01, handleLabelAndImageChangesUnstaggered)
 331 | 	local firstTimeSettingFontFace = true
 332 | 	icon:setBehaviour("IconLabel", "Text", handleLabelAndImageChanges)
 333 | 	icon:setBehaviour("IconLabel", "FontFace", function(value)
 334 | 		local previousFontFace = iconLabel.FontFace
 335 | 		if previousFontFace == value then
 336 | 			return
 337 | 		end
 338 | 		task.spawn(function()
 339 | 			--[[
 340 | 			local fontLink = value.Family
 341 | 			if string.match(fontLink, "rbxassetid://") then
 342 | 				local ContentProvider = game:GetService("ContentProvider")
 343 | 				local assets = {fontLink}
 344 | 				ContentProvider:PreloadAsync(assets)
 345 | 			end--]]
 346 | 
 347 | 			-- Afaik there's no way to determine when a Font Family has
 348 | 			-- loaded (even with ContentProvider), so we just have to try
 349 | 			-- a few times and hope it loads within the refresh period
 350 | 			handleLabelAndImageChanges()
 351 | 			if firstTimeSettingFontFace then
 352 | 				firstTimeSettingFontFace = false
 353 | 				for i = 1, 10 do
 354 | 					task.wait(1)
 355 | 					handleLabelAndImageChanges()
 356 | 				end
 357 | 			end
 358 | 		end)
 359 | 	end)
 360 | 	local function updateBorderSize()
 361 | 		task.defer(function()
 362 | 			local borderOffset = widget:GetAttribute("BorderSize")
 363 | 			local alignment = icon.alignment
 364 | 			local alignmentOffset = (iconSpot.Visible == false and 0) or (alignment == "Right" and -borderOffset) or borderOffset
 365 | 			menu.Position = UDim2.new(0, alignmentOffset, 0, 0)
 366 | 			menuGap.Size = UDim2.fromOffset(borderOffset, 0)
 367 | 			menuUIListLayout.Padding = UDim.new(0, 0)
 368 | 			handleLabelAndImageChanges()
 369 | 		end)
 370 | 	end
 371 | 	icon:setBehaviour("Widget", "BorderSize", updateBorderSize)
 372 | 	icon:setBehaviour("IconSpot", "Visible", updateBorderSize)
 373 | 	icon.startMenuUpdate:Connect(handleLabelAndImageChanges)
 374 | 	icon.updateSize:Connect(handleLabelAndImageChanges)
 375 | 	icon:setBehaviour("ContentsList", "HorizontalAlignment", handleLabelAndImageChanges)
 376 | 	icon:setBehaviour("Widget", "Visible", handleLabelAndImageChanges)
 377 | 	icon:setBehaviour("Widget", "DesiredWidth", handleLabelAndImageChanges)
 378 | 	icon:setBehaviour("Widget", "MinimumWidth", handleLabelAndImageChanges)
 379 | 	icon:setBehaviour("Widget", "MinimumHeight", handleLabelAndImageChanges)
 380 | 	icon:setBehaviour("Indicator", "Visible", handleLabelAndImageChanges)
 381 | 	icon:setBehaviour("IconImageRatio", "AspectRatio", handleLabelAndImageChanges)
 382 | 	icon:setBehaviour("IconImage", "Image", function(value)
 383 | 		local textureId = (tonumber(value) and "http://www.roblox.com/asset/?id="..value) or value or ""
 384 | 		if iconImage.Image ~= textureId then
 385 | 			handleLabelAndImageChanges()
 386 | 		end
 387 | 		return textureId
 388 | 	end)
 389 | 	icon.alignmentChanged:Connect(function(newAlignment)
 390 | 		if newAlignment == "Center" then
 391 | 			newAlignment = "Left"
 392 | 		end
 393 | 		menuUIListLayout.HorizontalAlignment = Enum.HorizontalAlignment[newAlignment]
 394 | 		updateBorderSize()
 395 | 	end)
 396 | 
 397 | 	-- Localization support (refresh icon size whenever player changes language changes in-game)
 398 | 	local Players = game:GetService("Players")
 399 | 	local localPlayer = Players.LocalPlayer
 400 | 	local lastLocaleId = localPlayer.LocaleId
 401 | 	icon.janitor:add(localPlayer:GetPropertyChangedSignal("LocaleId"):Connect(function()
 402 | 		task.delay(0.2, function()
 403 | 			local newLocaleId = localPlayer.LocaleId
 404 | 			if newLocaleId ~= lastLocaleId then
 405 | 				lastLocaleId = newLocaleId
 406 | 				icon:refresh()
 407 | 				task.wait(0.5)
 408 | 				icon:refresh()
 409 | 			end
 410 | 		end)
 411 | 	end))
 412 | 	
 413 | 	local iconImageScale = Instance.new("NumberValue")
 414 | 	iconImageScale.Name = "IconImageScale"
 415 | 	iconImageScale.Parent = iconImage
 416 | 	iconImageScale:GetPropertyChangedSignal("Value"):Connect(function()
 417 | 		iconImage.Size = UDim2.new(iconImageScale.Value, 0, iconImageScale.Value, 0)
 418 | 	end)
 419 | 
 420 | 	local UIAspectRatioConstraint = Instance.new("UIAspectRatioConstraint")
 421 | 	UIAspectRatioConstraint.Name = "IconImageRatio"
 422 | 	UIAspectRatioConstraint.AspectType = Enum.AspectType.FitWithinMaxSize
 423 | 	UIAspectRatioConstraint.DominantAxis = Enum.DominantAxis.Height
 424 | 	UIAspectRatioConstraint.Parent = iconImage
 425 | 
 426 | 	local iconGradient = Instance.new("UIGradient")
 427 | 	iconGradient.Name = "IconGradient"
 428 | 	iconGradient.Enabled = true
 429 | 	iconGradient.Parent = button
 430 | 
 431 | 	local iconSpotGradient = Instance.new("UIGradient")
 432 | 	iconSpotGradient.Name = "IconSpotGradient"
 433 | 	iconSpotGradient.Enabled = true
 434 | 	iconSpotGradient.Parent = iconSpot
 435 | 
 436 | 	return widget
 437 | end
```
</details>

## ğŸŒ™ `Packages/_Index/1foreverhd_topbarplus@3.4.0/topbarplus/src/Features/Gamepad.lua`
<details>
<summary>View Source (201 lines)</summary>

```lua
   1 | -- As the name suggests, this handles everything related to gamepads
   2 | -- (i.e. Xbox or Playstation controllers) and their navigation
   3 | -- I created a separate module for gamepads (and not touchpads or
   4 | -- keyboards) because gamepads are greatly more unqiue and require
   5 | -- additional tailored programming
   6 | 
   7 | 
   8 | 
   9 | -- SERVICES
  10 | local GamepadService = game:GetService("GamepadService")
  11 | local UserInputService = game:GetService("UserInputService")
  12 | local GuiService = game:GetService("GuiService")
  13 | 
  14 | 
  15 | 
  16 | -- LOCAL
  17 | local DEFAULT_HIGHLIGHT_KEY = Enum.KeyCode.DPadUp -- The default key to highlight the topbar icon
  18 | local GAMEPAD_INPUT = Enum.PreferredInput.Gamepad
  19 | local Gamepad = {}
  20 | local Icon
  21 | 
  22 | 
  23 | 
  24 | -- FUNCTIONS
  25 | -- This is called upon the Icon initializing
  26 | function Gamepad.start(incomingIcon)
  27 | 	
  28 | 	-- Public variables
  29 | 	Icon = incomingIcon
  30 | 	Icon.highlightKey = if Icon.highlightKey ~= nil then Icon.highlightKey else DEFAULT_HIGHLIGHT_KEY -- What controller key to highlight the topbar (or set to false to disable)
  31 | 	Icon.highlightIcon = false -- Change to a specific icon if you'd like to highlight a specific icon instead of the left-most
  32 | 	
  33 | 	-- We defer so the developer can make changes before the
  34 | 	-- gamepad controls are initialized
  35 | 	task.delay(1, function()
  36 | 		-- Some local utility
  37 | 		local iconsDict = Icon.iconsDictionary
  38 | 		local function getIconFromSelectedObject()
  39 | 			local clickRegion = GuiService.SelectedObject
  40 | 			local iconUID = clickRegion and clickRegion:GetAttribute("CorrespondingIconUID")
  41 | 			local icon = iconUID and iconsDict[iconUID]
  42 | 			return icon
  43 | 		end
  44 | 		
  45 | 		-- This enables users to instantly open up their last selected icon
  46 | 		local previousHighlightedIcon
  47 | 		local usedIndicatorOnce = DEFAULT_HIGHLIGHT_KEY ~= Icon.highlightKey
  48 | 		local usedBOnce = DEFAULT_HIGHLIGHT_KEY ~= Icon.highlightKey
  49 | 		local Selection = require(script.Parent.Parent.Elements.Selection)
  50 | 		local function updateSelectedObject()
  51 | 			local icon = getIconFromSelectedObject()
  52 | 			local isUsingGamepad = UserInputService.PreferredInput == GAMEPAD_INPUT
  53 | 			if icon then
  54 | 				if isUsingGamepad then
  55 | 					local clickRegion = icon:getInstance("ClickRegion")
  56 | 					local selection = icon.selection
  57 | 					if not selection then
  58 | 						selection = icon.janitor:add(Selection(Icon))
  59 | 						selection:SetAttribute("IgnoreVisibilityUpdater", true)
  60 | 						selection.Parent = icon.widget
  61 | 						icon.selection = selection
  62 | 						icon:refreshAppearance(selection) --icon:clipOutside(selection)
  63 | 					end
  64 | 					clickRegion.SelectionImageObject = selection.Selection
  65 | 				end
  66 | 				if previousHighlightedIcon and previousHighlightedIcon ~= icon then
  67 | 					previousHighlightedIcon:setIndicator()
  68 | 				end
  69 | 				local newIndicator = if isUsingGamepad and not usedBOnce and not icon.parentIconUID then Enum.KeyCode.ButtonB else nil
  70 | 				previousHighlightedIcon = icon
  71 | 				Icon.lastHighlightedIcon = icon
  72 | 				icon:setIndicator(newIndicator)
  73 | 			else
  74 | 				local newIndicator = if isUsingGamepad and not usedIndicatorOnce then Icon.highlightKey else nil
  75 | 				if not previousHighlightedIcon then
  76 | 					previousHighlightedIcon = Gamepad.getIconToHighlight()
  77 | 				end
  78 | 				if newIndicator == Icon.highlightKey then
  79 | 					-- We only display the highlightKey once to show
  80 | 					-- the user how to highlight the topbar icon
  81 | 					usedIndicatorOnce = true
  82 | 				else
  83 | 					--usedBOnce = true
  84 | 				end
  85 | 				if previousHighlightedIcon then
  86 | 					previousHighlightedIcon:setIndicator(newIndicator)
  87 | 				end
  88 | 			end
  89 | 		end
  90 | 		GuiService:GetPropertyChangedSignal("SelectedObject"):Connect(updateSelectedObject)
  91 | 
  92 | 		-- This listens for a gamepad being present/added/removed
  93 | 		local function preferredInputChanged()
  94 | 			local preferredInput = UserInputService.PreferredInput
  95 | 			local isUsingGamepad = preferredInput == GAMEPAD_INPUT
  96 | 
  97 | 			if not isUsingGamepad then
  98 | 				usedIndicatorOnce = false
  99 | 				usedBOnce = false
 100 | 			end
 101 | 			updateSelectedObject()
 102 | 		end
 103 | 		UserInputService:GetPropertyChangedSignal("PreferredInput"):Connect(preferredInputChanged)
 104 | 		preferredInputChanged()
 105 | 
 106 | 		-- This allows for easy highlighting of the topbar when the
 107 | 		-- when ``Icon.highlightKey`` (i.e. DPadUp) is pressed.
 108 | 		-- If you'd like to disable, do ``Icon.highlightKey = false``
 109 | 		UserInputService.InputBegan:Connect(function(input, touchingAnObject)
 110 | 			if input.UserInputType == Enum.UserInputType.MouseButton1 then
 111 | 				-- Sometimes the Roblox gamepad glitches when combined with a cursor
 112 | 				-- This fixes that by unhighlighting if the cursor is pressed down
 113 | 				-- (i.e. a mouse click)
 114 | 				local icon = getIconFromSelectedObject()
 115 | 				if icon then
 116 | 					GuiService.SelectedObject = nil
 117 | 				end
 118 | 				return
 119 | 			end
 120 | 			if input.KeyCode ~= Icon.highlightKey then
 121 | 				return
 122 | 			end
 123 | 			local iconToHighlight = Gamepad.getIconToHighlight()
 124 | 			if iconToHighlight then
 125 | 				if GamepadService.GamepadCursorEnabled then
 126 | 					task.wait(0.2)
 127 | 					GamepadService:DisableGamepadCursor()
 128 | 				end
 129 | 				local clickRegion = iconToHighlight:getInstance("ClickRegion")
 130 | 				GuiService.SelectedObject = clickRegion
 131 | 			end
 132 | 		end)
 133 | 	end)
 134 | end
 135 | 
 136 | function Gamepad.getIconToHighlight()
 137 | 	-- If an icon has already been selected, returns the last selected icon
 138 | 	-- Else if more than 0 icons, it selects the left-most icon
 139 | 	local iconsDict = Icon.iconsDictionary
 140 | 	local iconToHighlight = Icon.highlightIcon or Icon.lastHighlightedIcon
 141 | 	if not iconToHighlight then
 142 | 		local currentX
 143 | 		for _, icon in pairs(iconsDict) do
 144 | 			if icon.parentIconUID then
 145 | 				continue
 146 | 			end
 147 | 			local thisX = icon.widget.AbsolutePosition.X
 148 | 			if not currentX or thisX < currentX then
 149 | 				iconToHighlight = icon
 150 | 				currentX = iconToHighlight.widget.AbsolutePosition.X
 151 | 			end
 152 | 		end
 153 | 	end
 154 | 	return iconToHighlight
 155 | end
 156 | 
 157 | -- This called when the icon's ClickRegion is created
 158 | function Gamepad.registerButton(buttonInstance)
 159 | 	-- This provides a basic level of support for controllers by making
 160 | 	-- the icons easy to highlight via the virtual cursor, then
 161 | 	-- when selected, focuses in on the selected icon and hops
 162 | 	-- between other nearby icons simply by toggling the joystick
 163 | 	local inputBegan = false
 164 | 	buttonInstance.InputBegan:Connect(function(input)
 165 | 		-- Two wait frames required to ensure inputBegan is detected within
 166 | 		-- UserInputService.InputBegan. We do this because object.InputBegan
 167 | 		-- does not return the correct input objects (unlike the service)
 168 | 		inputBegan = true
 169 | 		task.wait()
 170 | 		task.wait()
 171 | 		inputBegan = false
 172 | 	end)
 173 | 	local connection = UserInputService.InputBegan:Connect(function(input)
 174 | 		task.wait()
 175 | 		if input.KeyCode == Enum.KeyCode.ButtonA and inputBegan then
 176 | 			-- We focus on an icon when selected via the virtual cursor
 177 | 			task.wait(0.2)
 178 | 			GamepadService:DisableGamepadCursor()
 179 | 			GuiService.SelectedObject = buttonInstance
 180 | 			return
 181 | 		end
 182 | 		local isSelected = GuiService.SelectedObject == buttonInstance
 183 | 		local unselectKeyCodes = {"ButtonB", "ButtonSelect"}
 184 | 		local keyName = input.KeyCode.Name
 185 | 		if table.find(unselectKeyCodes, keyName) and isSelected then
 186 | 			-- We unfocus when back button is pressed, but ignore
 187 | 			-- if the virtual cursor is disabled otherwise it will be
 188 | 			-- impossible to select the topbar
 189 | 			if not(keyName == "ButtonSelect" and not GamepadService.GamepadCursorEnabled) then
 190 | 				GuiService.SelectedObject = nil
 191 | 			end
 192 | 		end
 193 | 	end)
 194 | 	buttonInstance.Destroying:Once(function()
 195 | 		connection:Disconnect()
 196 | 	end)
 197 | end
 198 | 
 199 | 
 200 | 
 201 | return Gamepad
```
</details>

## ğŸŒ™ `Packages/_Index/1foreverhd_topbarplus@3.4.0/topbarplus/src/Features/Overflow.lua`
<details>
<summary>View Source (359 lines)</summary>

```lua
   1 | -- When designing your game for many devices and screen sizes, icons may occasionally
   2 | -- particularly for smaller devices like phones, overlap with other icons or the bounds
   3 | -- of the screen. The overflow handler solves this challenge by moving the out-of-bounds
   4 | -- icon into an overflow menu (with a limited scrolling canvas) preventing overlaps occuring
   5 | 
   6 | 
   7 | 
   8 | -- LOCAL
   9 | local Overflow = {}
  10 | local holders = {}
  11 | local orderedAvailableIcons = {}
  12 | local iconsDict
  13 | local currentCamera = workspace.CurrentCamera
  14 | local overflowIcons = {}
  15 | local overflowIconUIDs = {}
  16 | local Utility = require(script.Parent.Parent.Utility)
  17 | local beginCheckingCenterIcons = false
  18 | local beganSecondaryCenterCheck = false
  19 | local Icon
  20 | 
  21 | 
  22 | 
  23 | -- FUNCTIONS
  24 | -- This is called upon the Icon initializing
  25 | function Overflow.start(incomingIcon)
  26 | 	Icon = incomingIcon
  27 | 	iconsDict = Icon.iconsDictionary
  28 | 	local primaryScreenGui
  29 | 	for _, screenGui in pairs(Icon.container) do
  30 | 		if primaryScreenGui == nil and screenGui.ScreenInsets == Enum.ScreenInsets.TopbarSafeInsets then
  31 | 			primaryScreenGui = screenGui
  32 | 		end
  33 | 		for _, holder in pairs(screenGui.Holders:GetChildren()) do
  34 | 			if holder:GetAttribute("IsAHolder") then
  35 | 				holders[holder.Name] = holder
  36 | 			end
  37 | 		end
  38 | 	end
  39 | 
  40 | 	-- We listen for changes in icons (such as them being added, removed,
  41 | 	-- the setting of a different alignment, the widget size changing, etc)
  42 | 	local beginOverflow = false
  43 | 	local updateBoundaries = Utility.createStagger(0.1, function(ignoreAvailable)
  44 | 		if not beginOverflow then
  45 | 			return
  46 | 		end
  47 | 		if not ignoreAvailable then
  48 | 			Overflow.updateAvailableIcons("Center")
  49 | 		end
  50 | 		Overflow.updateBoundary("Left")
  51 | 		Overflow.updateBoundary("Right")
  52 | 	end)
  53 | 	task.delay(0.5, function()
  54 | 		beginOverflow = true
  55 | 		updateBoundaries()
  56 | 	end)
  57 | 	task.delay(2, function()
  58 | 		-- This is essential to prevent central icons begin added
  59 | 		-- left or right due to incomplete UIListLayout calculations
  60 | 		-- within the first few frames
  61 | 		beginCheckingCenterIcons = true
  62 | 		updateBoundaries()
  63 | 	end)
  64 | 	Icon.iconAdded:Connect(updateBoundaries)
  65 | 	Icon.iconRemoved:Connect(updateBoundaries)
  66 | 	Icon.iconChanged:Connect(updateBoundaries)
  67 | 	currentCamera:GetPropertyChangedSignal("ViewportSize"):Connect(function()
  68 | 		updateBoundaries(true)
  69 | 	end)
  70 | 	primaryScreenGui:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
  71 | 		updateBoundaries(true)
  72 | 	end)
  73 | end
  74 | 
  75 | function Overflow.getWidth(icon, getMaxWidth)
  76 | 	local widget = icon.widget
  77 | 	return widget:GetAttribute("TargetWidth") or widget.AbsoluteSize.X
  78 | end
  79 | 
  80 | function Overflow.getAvailableIcons(alignment)
  81 | 	local ourOrderedIcons = orderedAvailableIcons[alignment]
  82 | 	if not ourOrderedIcons then
  83 | 		ourOrderedIcons = Overflow.updateAvailableIcons(alignment)
  84 | 	end
  85 | 	return ourOrderedIcons
  86 | end
  87 | 
  88 | function Overflow.updateAvailableIcons(alignment)
  89 | 
  90 | 	-- We only track items that are directly on the topbar (i.e. not within a parent icon)
  91 | 	local ourTotal = 0
  92 | 	local ourOrderedIcons = {}
  93 | 	for _, icon in pairs(iconsDict) do
  94 | 		local parentUID = icon.parentIconUID
  95 | 		local isDirectlyOnTopbar = not parentUID or overflowIconUIDs[parentUID]
  96 | 		local isOverflow = overflowIconUIDs[icon.UID]
  97 | 		if isDirectlyOnTopbar and icon.alignment == alignment and not isOverflow and icon.isEnabled then
  98 | 			table.insert(ourOrderedIcons, icon)
  99 | 			ourTotal += 1
 100 | 		end
 101 | 	end
 102 | 
 103 | 	-- Ignore if no icons are available
 104 | 	if ourTotal <= 0 then
 105 | 		return {}
 106 | 	end
 107 | 
 108 | 	-- This sorts these icons by smallest order, or if equal, left-most position
 109 | 	-- (even for the right alignment because all icons are sorted left-to-right)
 110 | 	table.sort(ourOrderedIcons, function(iconA, iconB)
 111 | 		local orderA = iconA.widget.LayoutOrder
 112 | 		local orderB = iconB.widget.LayoutOrder
 113 | 		local hasParentA = iconA.parentIconUID
 114 | 		local hasParentB = iconB.parentIconUID
 115 | 		if hasParentA == hasParentB then
 116 | 			if orderA < orderB then
 117 | 				return true
 118 | 			end
 119 | 			if orderA > orderB then
 120 | 				return false
 121 | 			end
 122 | 			return iconA.widget.AbsolutePosition.X < iconB.widget.AbsolutePosition.X
 123 | 		elseif hasParentB then
 124 | 			return false
 125 | 		elseif hasParentA then
 126 | 			return true
 127 | 		end
 128 | 		return nil
 129 | 	end)
 130 | 
 131 | 	-- Finish up
 132 | 	orderedAvailableIcons[alignment] = ourOrderedIcons
 133 | 	return ourOrderedIcons
 134 | 
 135 | end
 136 | 
 137 | function Overflow.getRealXPositions(alignment, orderedIcons)
 138 | 	-- We calculate the the absolute position of icons instead of reading
 139 | 	-- directly to determine where they would be if not within an overflow
 140 | 	local isLeft = alignment == "Left"
 141 | 	local holder = holders[alignment]
 142 | 	local holderXPos = holder.AbsolutePosition.X
 143 | 	local holderXSize = holder.AbsoluteSize.X
 144 | 	local holderUIList = holder.UIListLayout
 145 | 	local topbarInset = holderUIList.Padding.Offset
 146 | 	local absoluteX = (isLeft and holderXPos) or holderXPos + holderXSize
 147 | 	local realXPositions = {}
 148 | 	if isLeft then
 149 | 		Utility.reverseTable(orderedIcons)
 150 | 	end
 151 | 	for i = #orderedIcons, 1, -1 do
 152 | 		local icon = orderedIcons[i]
 153 | 		local sizeX = Overflow.getWidth(icon)
 154 | 		if not isLeft then
 155 | 			absoluteX -= sizeX
 156 | 		end
 157 | 		realXPositions[icon.UID] = absoluteX
 158 | 		if isLeft then
 159 | 			absoluteX += sizeX
 160 | 		end
 161 | 		absoluteX += (isLeft and topbarInset) or -topbarInset
 162 | 	end
 163 | 	return realXPositions
 164 | end
 165 | 
 166 | function Overflow.updateBoundary(alignment)
 167 | 
 168 | 	-- We only track items that are directly on the topbar (i.e. not within a parent icon) or within an overflow
 169 | 	local holder = holders[alignment]
 170 | 	local holderUIList = holder.UIListLayout
 171 | 	local holderXPos = holder.AbsolutePosition.X
 172 | 	local holderXSize = holder.AbsoluteSize.X
 173 | 	local topbarInset = holderUIList.Padding.Offset
 174 | 	local topbarPadding = holderUIList.Padding.Offset
 175 | 	local BOUNDARY_GAP = topbarInset
 176 | 	local ourOrderedIcons = Overflow.updateAvailableIcons(alignment)
 177 | 	local boundWidth = 0
 178 | 	local ourTotal = 0
 179 | 	for _, icon in pairs(ourOrderedIcons) do
 180 | 		boundWidth += Overflow.getWidth(icon) + topbarPadding
 181 | 		ourTotal += 1
 182 | 	end
 183 | 	if ourTotal <= 0 then
 184 | 		return
 185 | 	end
 186 | 	
 187 | 	-- These are the icons with menus which icons will be moved into
 188 | 	-- when overflowing
 189 | 	local isCentral = alignment == "Center"
 190 | 	local isLeft = alignment == "Left"
 191 | 	local isRight = not isLeft
 192 | 	local overflowIcon = overflowIcons[alignment]
 193 | 	if not overflowIcon and not isCentral and #ourOrderedIcons > 0 then
 194 | 		local order = (isLeft and -9999999) or 9999999
 195 | 		overflowIcon = Icon.new()--:setLabel(`{alignment}`)
 196 | 		overflowIcon:setImage(6069276526, "Deselected")
 197 | 		overflowIcon:setName("Overflow"..alignment)
 198 | 		overflowIcon:setOrder(order)
 199 | 		overflowIcon:setAlignment(alignment)
 200 | 		overflowIcon:autoDeselect(false)
 201 | 		overflowIcon.isAnOverflow = true
 202 | 		--overflowIcon:freezeMenu()
 203 | 		overflowIcon:select("OverflowStart", overflowIcon)
 204 | 		overflowIcon:setEnabled(false)
 205 | 		overflowIcons[alignment] = overflowIcon
 206 | 		overflowIconUIDs[overflowIcon.UID] = true
 207 | 		if not Icon.closeableOverflowMenus then
 208 | 			local iconSpot = overflowIcon:getInstance("IconSpot")
 209 | 			iconSpot.Visible = false
 210 | 		end
 211 | 	end
 212 | 
 213 | 	-- The default boundary is the point where both the left-most-right-icon
 214 | 	-- and left-most-right-icon meet OR the opposite side of the screen
 215 | 	local oppositeAlignment = (alignment == "Left" and "Right") or "Left"
 216 | 	local oppositeOrderedIcons = Overflow.updateAvailableIcons(oppositeAlignment)
 217 | 	local nearestOppositeIcon = (isLeft and oppositeOrderedIcons[1]) or (isRight and oppositeOrderedIcons[#oppositeOrderedIcons])
 218 | 	local oppositeOverflowIcon = overflowIcons[oppositeAlignment]
 219 | 	local boundary = (isLeft and holderXPos + holderXSize) or holderXPos
 220 | 	if nearestOppositeIcon then
 221 | 		local oppositeRealXPositions = Overflow.getRealXPositions(oppositeAlignment, oppositeOrderedIcons)
 222 | 		local oppositeX = oppositeRealXPositions[nearestOppositeIcon.UID]
 223 | 		local oppositeXSize = Overflow.getWidth(nearestOppositeIcon)
 224 | 		boundary = (isLeft and oppositeX - BOUNDARY_GAP) or oppositeX + oppositeXSize + BOUNDARY_GAP
 225 | 	end
 226 | 	
 227 | 	-- We get the left-most icon (if left alignment) or right-most-icon (if
 228 | 	-- right alignment) of the central icons group to see if we need to change
 229 | 	-- the boundary (if the central icon boundary is smaller than the alignment
 230 | 	-- boundary then we use the central)
 231 | 	local totalChecks = 0
 232 | 	local usingNearestCenter = false
 233 | 	local function checkToShiftCentralIcon()
 234 | 		local centerOrderedIcons = Overflow.getAvailableIcons("Center")
 235 | 		local centerPos = (isLeft and 1) or #centerOrderedIcons
 236 | 		local nearestCenterIcon = centerOrderedIcons[centerPos]
 237 | 		local function secondaryCheck()
 238 | 			if not beganSecondaryCenterCheck then
 239 | 				beganSecondaryCenterCheck = true
 240 | 				task.delay(3, Overflow.updateBoundary, alignment)
 241 | 			end
 242 | 		end
 243 | 		if nearestCenterIcon and not nearestCenterIcon.hasRelocatedInOverflow then
 244 | 			local ourNearestIcon = (isLeft and ourOrderedIcons[#ourOrderedIcons]) or (isRight and ourOrderedIcons[1])
 245 | 			local centralNearestXPos = nearestCenterIcon.widget.AbsolutePosition.X
 246 | 			local ourNearestXPos = ourNearestIcon.widget.AbsolutePosition.X
 247 | 			local ourNearestXSize = Overflow.getWidth(ourNearestIcon)
 248 | 			local centerBoundary = (isLeft and centralNearestXPos-BOUNDARY_GAP) or centralNearestXPos + Overflow.getWidth(nearestCenterIcon) + BOUNDARY_GAP
 249 | 			local removeBoundary = (isLeft and ourNearestXPos + ourNearestXSize) or ourNearestXPos
 250 | 			local hasShifted = false
 251 | 			if isLeft then
 252 | 				if centerBoundary < removeBoundary then
 253 | 					if not beginCheckingCenterIcons then
 254 | 						secondaryCheck()
 255 | 						return
 256 | 					end
 257 | 					nearestCenterIcon:align("Left")
 258 | 					nearestCenterIcon.hasRelocatedInOverflow = true
 259 | 					hasShifted = true
 260 | 				end
 261 | 			elseif isRight then
 262 | 				if centerBoundary > removeBoundary then
 263 | 					if not beginCheckingCenterIcons or removeBoundary < 0 then
 264 | 						secondaryCheck()
 265 | 						return
 266 | 					end
 267 | 					nearestCenterIcon:align("Right")
 268 | 					nearestCenterIcon.hasRelocatedInOverflow = true
 269 | 					hasShifted = true
 270 | 				end
 271 | 			end
 272 | 			if hasShifted then
 273 | 				totalChecks += 1
 274 | 				if totalChecks <= 4 then
 275 | 					Overflow.updateAvailableIcons("Center")
 276 | 					checkToShiftCentralIcon()
 277 | 				end
 278 | 			end
 279 | 		end
 280 | 	end
 281 | 	checkToShiftCentralIcon()
 282 | 	
 283 | 	--[[
 284 | 	This updates the maximum size of the overflow menus
 285 | 	The menu determines its bounds from the smallest of either:
 286 | 	 	1. The closest center-aligned icon (i.e. the boundary)
 287 | 	 	2. The edge of the opposite overflow menu UNLESS...
 288 | 	 	3. ... the edge exceeds more than half the screenGui
 289 | 	--]]
 290 | 	if overflowIcon then
 291 | 		local menuBoundary = boundary
 292 | 		local menu = overflowIcon:getInstance("Menu")
 293 | 		local holderXEndPos = holderXPos + holderXSize
 294 | 		local menuWidth = holderXSize
 295 | 		if menu and oppositeOverflowIcon then
 296 | 			local oppositeWidget = oppositeOverflowIcon.widget
 297 | 			local oppositeXPos = oppositeWidget.AbsolutePosition.X
 298 | 			local oppositeXSize = Overflow.getWidth(oppositeOverflowIcon)
 299 | 			local oppositeBoundary = (isLeft and oppositeXPos - BOUNDARY_GAP) or oppositeXPos + oppositeXSize + BOUNDARY_GAP
 300 | 			local oppositeMenu = oppositeOverflowIcon:getInstance("Menu")
 301 | 			local isDominant = menu.AbsoluteCanvasSize.X >= oppositeMenu.AbsoluteCanvasSize.X
 302 | 			if not usingNearestCenter then
 303 | 				local halfwayXPos = holderXPos + holderXSize/2
 304 | 				local halfwayBoundary = (isLeft and halfwayXPos - BOUNDARY_GAP/2) or halfwayXPos + BOUNDARY_GAP/2
 305 | 				menuBoundary = halfwayBoundary
 306 | 				if isDominant then
 307 | 					menuBoundary = oppositeBoundary
 308 | 				end
 309 | 			end
 310 | 			menuWidth = (isLeft and menuBoundary - holderXPos) or (holderXEndPos - menuBoundary)
 311 | 		end
 312 | 		local currentMaxWidth = menu and menu:GetAttribute("MaxWidth")
 313 | 		menuWidth = Utility.round(menuWidth)
 314 | 		if menu and currentMaxWidth ~= menuWidth then
 315 | 			menu:SetAttribute("MaxWidth", menuWidth)
 316 | 		end
 317 | 	end
 318 | 
 319 | 	-- Parent ALL icons of that alignment into the overflow if at least on
 320 | 	-- sibling exceeds the bounds.
 321 | 	-- We calculate the the absolute position of icons instead of reading
 322 | 	-- directly to determine where they would be if not within an overflow
 323 | 	local joinOverflow = false
 324 | 	local realXPositions = Overflow.getRealXPositions(alignment, ourOrderedIcons)
 325 | 	for i = #ourOrderedIcons, 1, -1 do
 326 | 		local icon = ourOrderedIcons[i]
 327 | 		local widgetX = Overflow.getWidth(icon)
 328 | 		local xPos = realXPositions[icon.UID]
 329 | 		if (isLeft and xPos + widgetX >= boundary) or (isRight and xPos <= boundary) then
 330 | 			joinOverflow = true
 331 | 		end
 332 | 	end
 333 | 	for i = #ourOrderedIcons, 1, -1 do
 334 | 		local icon = ourOrderedIcons[i]
 335 | 		local isOverflow = overflowIconUIDs[icon.UID]
 336 | 		if not isOverflow then
 337 | 			if joinOverflow and not icon.parentIconUID then
 338 | 				icon:joinMenu(overflowIcon)
 339 | 			elseif not joinOverflow and icon.parentIconUID then
 340 | 				icon:leave()
 341 | 			end
 342 | 		end
 343 | 	end
 344 | 	
 345 | 	-- Hide the overflows when not in use
 346 | 	if overflowIcon.isEnabled ~= joinOverflow then
 347 | 		overflowIcon:setEnabled(joinOverflow)
 348 | 	end
 349 | 	
 350 | 	-- Have the menus auto selected
 351 | 	if overflowIcon.isEnabled and not overflowIcon.overflowAlreadyOpened then
 352 | 		overflowIcon.overflowAlreadyOpened = true
 353 | 		overflowIcon:select()
 354 | 	end
 355 | 
 356 | end
 357 | 
 358 | 
 359 | 
 360 | return Overflow
```
</details>

## ğŸŒ™ `Packages/_Index/1foreverhd_topbarplus@3.4.0/topbarplus/src/Features/Themes/Classic.lua`
<details>
<summary>View Source (26 lines)</summary>

```lua
   1 | -- This is to provide backwards compatability with the old Roblox
   2 | -- topbar while experiences transition over to the new topbar
   3 | -- You don't need to apply this yourself, topbarplus automatically
   4 | -- applies it if the old roblox topbar is detected
   5 | 
   6 | 
   7 | return {
   8 | 	{"Selection", "Size", UDim2.new(1, -6, 1, -5)},
   9 | 	{"Selection", "Position", UDim2.new(0, 3, 0, 3)},
  10 | 	
  11 | 	{"Widget", "MinimumWidth", 32, "Deselected"},
  12 | 	{"Widget", "MinimumHeight", 32, "Deselected"},
  13 | 	{"Widget", "BorderSize", 0, "Deselected"},
  14 | 	{"IconCorners", "CornerRadius", UDim.new(0, 9), "Deselected"},
  15 | 	{"IconButton", "BackgroundTransparency", 0.5, "Deselected"},
  16 | 	{"IconLabel", "TextSize", 14, "Deselected"},
  17 | 	{"Dropdown", "BackgroundTransparency", 0.5, "Deselected"},
  18 | 	{"Notice", "Position", UDim2.new(1, -12, 0, -3), "Deselected"},
  19 | 	{"Notice", "Size", UDim2.new(0, 15, 0, 15), "Deselected"},
  20 | 	{"NoticeLabel", "TextSize", 11, "Deselected"},
  21 | 	
  22 | 	{"IconSpot", "BackgroundColor3", Color3.fromRGB(0, 0, 0), "Selected"},
  23 | 	{"IconSpot", "BackgroundTransparency", 0.702, "Selected"},
  24 | 	{"IconSpotGradient", "Enabled", false, "Selected"},
  25 | 	{"IconOverlay", "BackgroundTransparency", 0.97, "Selected"},
  26 | 	
  27 | }
```
</details>

## ğŸŒ™ `Packages/_Index/1foreverhd_topbarplus@3.4.0/topbarplus/src/Features/Themes/Default.lua`
<details>
<summary>View Source (74 lines)</summary>

```lua
   1 | -- Themes in v3 work simply by applying the value (agument[3])
   2 | -- to the property (agument[2]) of an instance within the icon which
   3 | -- matches the name of argument[1]. Argument[1] can also be used to
   4 | -- specify a collection of instances with a corresponding 'collective'
   5 | -- value. A colletive is simply an attribute applied to some instances
   6 | -- within the icon to group them together (such as "IconCorners").
   7 | -- If the property (argument[2]) does not exist within the instance,
   8 | -- it will instead be applied as an attribute on the instance:
   9 | -- (i.e. ``instance:SetAttribute(argument[2], [argument[3])``)
  10 | -- Use argument[4] to specify a state: "Deselected", "Selected"
  11 | -- or "Viewing". If argument[4] is empty the state will default
  12 | -- to "Deselected".
  13 | -- I've designed themes this way so you have full control over
  14 | -- the appearance of the widget and its descendants
  15 | 
  16 | 
  17 | return {
  18 | 	
  19 | 	-- When no state is specified the modification is applied to *all* states (Deselected, Selected and Viewing)
  20 | 	{"IconCorners", "CornerRadius", UDim.new(1, 0)},
  21 | 	{"Selection", "RotationSpeed", 1},
  22 | 	{"Selection", "Size", UDim2.new(1, 0, 1, 1)},
  23 | 	{"Selection", "Position", UDim2.new(0, 0, 0, 0)},
  24 | 	{"SelectionGradient", "Color", ColorSequence.new({
  25 | 		ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
  26 | 		ColorSequenceKeypoint.new(1, Color3.fromRGB(86, 86, 86)),
  27 | 	})},
  28 | 	
  29 | 	-- When the icon is deselected
  30 | 	{"IconImage", "Image", "", "Deselected"},
  31 | 	{"IconLabel", "Text", "", "Deselected"},
  32 | 	{"IconLabel", "Position", UDim2.fromOffset(0, 0), "Deselected"}, -- 0, -1
  33 | 	{"Widget", "DesiredWidth", 44, "Deselected"},
  34 | 	{"Widget", "MinimumWidth", 44, "Deselected"},
  35 | 	{"Widget", "MinimumHeight", 44, "Deselected"},
  36 | 	{"Widget", "BorderSize", 4, "Deselected"},
  37 |   	{"IconButton", "BackgroundColor3", Color3.fromRGB(18, 18, 21), "Deselected"},
  38 | 	{"IconButton", "BackgroundTransparency", 0.08, "Deselected"},
  39 | 	{"IconImageScale", "Value", 0.5, "Deselected"},
  40 | 	{"IconImageCorner", "CornerRadius", UDim.new(0, 0), "Deselected"},
  41 | 	{"IconImage", "ImageColor3", Color3.fromRGB(255, 255, 255), "Deselected"},
  42 | 	{"IconImage", "ImageTransparency", 0, "Deselected"},
  43 | 	{"IconImageRatio", "AspectRatio", 1, "Deselected"},
  44 | 	{"IconLabel", "FontFace", Font.new("rbxasset://fonts/families/BuilderSans.json", Enum.FontWeight.Bold, Enum.FontStyle.Normal), "Deselected"},
  45 | 	{"IconLabel", "TextSize", 16, "Deselected"},
  46 | 	{"IconSpot", "BackgroundTransparency", 1, "Deselected"},
  47 | 	{"IconOverlay", "BackgroundTransparency", 0.85, "Deselected"},
  48 | 	{"IconSpotGradient", "Enabled", false, "Deselected"},
  49 | 	{"IconGradient", "Enabled", false, "Deselected"},
  50 | 	{"ClickRegion", "Active", true, "Deselected"},  -- This is set to false within scrollers to ensure scroller can be dragged on mobile
  51 | 	{"Menu", "Active", false, "Deselected"},
  52 | 	{"ContentsList", "HorizontalAlignment", Enum.HorizontalAlignment.Center, "Deselected"},
  53 |   	{"Dropdown", "BackgroundColor3", Color3.fromRGB(18, 18, 21), "Deselected"},
  54 | 	{"Dropdown", "BackgroundTransparency", 0.08, "Deselected"},
  55 | 	{"Dropdown", "MaxIcons", 4.5, "Deselected"},
  56 | 	{"Menu", "MaxIcons", 4, "Deselected"},
  57 | 	{"Notice", "Position", UDim2.new(1, -12, 0, -1), "Deselected"},
  58 | 	{"Notice", "Size", UDim2.new(0, 20, 0, 20), "Deselected"},
  59 | 	{"NoticeLabel", "TextSize", 13, "Deselected"},
  60 | 	{"PaddingLeft", "Size", UDim2.new(0, 9, 1, 0), "Deselected"},
  61 | 	{"PaddingRight", "Size", UDim2.new(0, 11, 1, 0), "Deselected"},
  62 | 	
  63 | 	-- When the icon is selected
  64 | 	-- Selected also inherits everything from Deselected if nothing is set
  65 | 	{"IconSpot", "BackgroundTransparency", 0.7, "Selected"},
  66 | 	{"IconSpot", "BackgroundColor3", Color3.fromRGB(255, 255, 255), "Selected"},
  67 | 	{"IconSpotGradient", "Enabled", true, "Selected"},
  68 | 	{"IconSpotGradient", "Rotation", 45, "Selected"},
  69 | 	{"IconSpotGradient", "Color", ColorSequence.new(Color3.fromRGB(96, 98, 100), Color3.fromRGB(77, 78, 80)), "Selected"},
  70 | 	
  71 | 	
  72 | 	-- When a cursor is hovering above, a controller highlighting, or touchpad (mobile) pressing (but not released)
  73 | 	--{"IconSpot", "BackgroundTransparency", 0.75, "Viewing"},
  74 | 	
  75 | }
```
</details>

## ğŸŒ™ `Packages/_Index/1foreverhd_topbarplus@3.4.0/topbarplus/src/Features/Themes/init.lua`
<details>
<summary>View Source (352 lines)</summary>

```lua
   1 | -- The functions here are dedicated solely to managing theme state
   2 | -- and updating the appearance of instances to match that state.
   3 | -- You don't need to use any of these functions, the useful ones
   4 | -- have been abstracted as icon methods
   5 | 
   6 | 
   7 | 
   8 | -- LOCAL
   9 | local Themes = {}
  10 | local Utility = require(script.Parent.Parent.Utility)
  11 | local baseTheme = require(script.Default)
  12 | 
  13 | 
  14 | 
  15 | -- FUNCTIONS
  16 | function Themes.getThemeValue(stateGroup, instanceName, property, iconState)
  17 | 	if stateGroup then
  18 | 		for _, detail in pairs(stateGroup) do
  19 | 			local checkingInstanceName, checkingPropertyName, checkingValue = unpack(detail)
  20 | 			if instanceName == checkingInstanceName and property == checkingPropertyName then
  21 | 				return checkingValue
  22 | 			end
  23 | 		end
  24 | 	end
  25 | 	return nil
  26 | end
  27 | 
  28 | function Themes.getInstanceValue(instance, property)
  29 | 	local success, value = pcall(function()
  30 | 		return instance[property]
  31 | 	end)
  32 | 	if not success then
  33 | 		value = instance:GetAttribute(property)
  34 | 	end
  35 | 	return value
  36 | end
  37 | 
  38 | function Themes.getRealInstance(instance)
  39 | 	if not instance:GetAttribute("IsAClippedClone") then
  40 | 		return
  41 | 	end
  42 | 	local originalInstance = instance:FindFirstChild("OriginalInstance")
  43 | 	if not originalInstance then
  44 | 		return
  45 | 	end
  46 | 	return originalInstance.Value
  47 | end
  48 | 
  49 | function Themes.getClippedClone(instance)
  50 | 	if not instance:GetAttribute("HasAClippedClone") then
  51 | 		return
  52 | 	end
  53 | 	local clippedClone = instance:FindFirstChild("ClippedClone")
  54 | 	if not clippedClone then
  55 | 		return
  56 | 	end
  57 | 	return clippedClone.Value
  58 | end
  59 | 
  60 | function Themes.refresh(icon, instance, specificProperty)
  61 | 	-- Some instances such as notices need immediate refreshing upon creation as
  62 | 	-- they're added in after the initial refresh period
  63 | 	if specificProperty then
  64 | 		local stateGroup = icon:getStateGroup()
  65 | 		local value = Themes.getThemeValue(stateGroup, instance.Name, specificProperty) or Themes.getInstanceValue(instance, specificProperty)
  66 | 		Themes.apply(icon, instance, specificProperty, value, true)
  67 | 		return
  68 | 	end
  69 | 	-- If no property is specified we update all properties that exist within
  70 | 	-- the applied theme appearance
  71 | 	local stateGroup = icon:getStateGroup()
  72 | 	if not stateGroup then
  73 | 		return
  74 | 	end
  75 | 	local validInstances = {[instance.Name] = instance}
  76 | 	for _, child in pairs(instance:GetDescendants()) do
  77 | 		local collective = child:GetAttribute("Collective")
  78 | 		if collective then
  79 | 			validInstances[collective] = child
  80 | 		end
  81 | 		validInstances[child.Name] = child
  82 | 	end
  83 | 	for _, detail in pairs(stateGroup) do
  84 | 		local checkingInstanceName, checkingPropertyName, checkingValue = unpack(detail)
  85 | 		local instanceToUpdate = validInstances[checkingInstanceName]
  86 | 		if instanceToUpdate then
  87 | 			Themes.apply(icon, instanceToUpdate.Name, checkingPropertyName, checkingValue, true)
  88 | 		end
  89 | 	end
  90 | 	return
  91 | end
  92 | 
  93 | function Themes.apply(icon, collectiveOrInstanceNameOrInstance, property, value, forceApply)
  94 | 	-- This is responsible for **applying** appearance changes to instances within the icon
  95 | 	-- however it IS NOT responsible for updating themes. Use :modifyTheme for that.
  96 | 	-- This also calls callbacks given by :setBehaviour before applying these property changes
  97 | 	-- to the given instances
  98 | 	if icon.isDestroyed then
  99 | 		return
 100 | 	end
 101 | 	local instances
 102 | 	local collectiveOrInstanceName = collectiveOrInstanceNameOrInstance
 103 | 	if typeof(collectiveOrInstanceNameOrInstance) == "Instance" then
 104 | 		instances = {collectiveOrInstanceNameOrInstance}
 105 | 		collectiveOrInstanceName = collectiveOrInstanceNameOrInstance.Name
 106 | 	else
 107 | 		instances = icon:getInstanceOrCollective(collectiveOrInstanceNameOrInstance)
 108 | 	end
 109 | 	local key = collectiveOrInstanceName.."-"..property
 110 | 	local customBehaviour = icon.customBehaviours[key]
 111 | 	for _, instance in pairs(instances) do
 112 | 		local clippedClone = Themes.getClippedClone(instance)
 113 | 		if clippedClone then
 114 | 			-- This means theme effects are applied to both the original
 115 | 			-- instance and its clone (instead of just the instance).
 116 | 			-- This is important for some properties such as position
 117 | 			-- and size which might be dictated by the clone
 118 | 			table.insert(instances, clippedClone)
 119 | 		end
 120 | 	end
 121 | 	for _, instance in pairs(instances) do
 122 | 		if property == "Position" and Themes.getClippedClone(instance) then
 123 | 			-- The clone manages the position of the real instance so ignore
 124 | 			continue
 125 | 		elseif property == "Size" and Themes.getRealInstance(instance) then
 126 | 			-- The real instance manages the size of the clone so ignore
 127 | 			continue
 128 | 		end
 129 | 		local currentValue = Themes.getInstanceValue(instance, property)
 130 | 		if not forceApply and value == currentValue then
 131 | 			continue
 132 | 		end
 133 | 		if customBehaviour then
 134 | 			local newValue = customBehaviour(value, instance, property)
 135 | 			if newValue ~= nil then
 136 | 				value = newValue
 137 | 			end
 138 | 		end
 139 | 		local success = pcall(function()
 140 | 			instance[property] = value
 141 | 		end)
 142 | 		if not success then
 143 | 			-- If property is not a real property, we set
 144 | 			-- the value as an attribute instead. This is useful
 145 | 			-- for instance in :setWidth where we also want to
 146 | 			-- specify a desired width for every state which can
 147 | 			-- then be easily read by the widget element
 148 | 			instance:SetAttribute(property, value)
 149 | 		end
 150 | 	end
 151 | end
 152 | 
 153 | function Themes.getModifications(modifications)
 154 | 	if typeof(modifications[1]) ~= "table" then
 155 | 		-- This enables users to do :modifyTheme({a,b,c,d})
 156 | 		-- in addition of :modifyTheme({{a,b,c,d}})
 157 | 		modifications = {modifications}
 158 | 	end
 159 | 	return modifications
 160 | end
 161 | 
 162 | function Themes.merge(detail, modification, callback)
 163 | 	local instanceName, property, value, stateName = table.unpack(modification)
 164 | 	local checkingInstanceName, checkingPropertyName, _, checkingStateName = table.unpack(detail)
 165 | 	if instanceName == checkingInstanceName and property == checkingPropertyName and Themes.statesMatch(stateName, checkingStateName) then
 166 | 		detail[3] = value
 167 | 		if callback then
 168 | 			callback(detail)
 169 | 		end
 170 | 		return true
 171 | 	end
 172 | 	return false
 173 | end
 174 | 
 175 | function Themes.modify(icon, modifications, modificationsUID)
 176 | 	-- This is what the 'old set' used to do (although for clarity that behaviour has now been
 177 | 	-- split into two methods, .modifyTheme and .apply).
 178 | 	-- modifyTheme is responsible for UPDATING the internal values within a theme for a particular
 179 | 	-- state, then checking to see if the appearance of the icon needs to be updated.
 180 | 	-- If no iconState is specified, the change is applied to both Deselected and Selected
 181 | 	-- A modification can also be 'undone' using :removeModification and passing in
 182 | 	-- the UID returned from this method
 183 | 	task.spawn(function()
 184 | 		modificationsUID = modificationsUID or Utility.generateUID()
 185 | 		modifications = Themes.getModifications(modifications)
 186 | 		for _, modification in pairs(modifications) do
 187 | 			local instanceName, property, value, iconState = table.unpack(modification)
 188 | 			if iconState == nil then
 189 | 				-- If no state specified, apply to all states
 190 | 				Themes.modify(icon, {instanceName, property, value, "Selected"}, modificationsUID)
 191 | 				Themes.modify(icon, {instanceName, property, value, "Viewing"}, modificationsUID)
 192 | 			end
 193 | 			local chosenState = Utility.formatStateName(iconState or "Deselected")
 194 | 			local stateGroup = icon:getStateGroup(chosenState)
 195 | 			local function nowSetIt()
 196 | 				if chosenState == icon.activeState then
 197 | 					Themes.apply(icon, instanceName, property, value)
 198 | 				end
 199 | 			end
 200 | 			local function updateRecord()
 201 | 				for stateName, detail in pairs(stateGroup) do
 202 | 					local didMerge = Themes.merge(detail, modification, function(detail)
 203 | 						detail[5] = modificationsUID
 204 | 						nowSetIt()
 205 | 					end)
 206 | 					if didMerge then
 207 | 						return
 208 | 					end
 209 | 				end
 210 | 				local detail = {instanceName, property, value, chosenState, modificationsUID}
 211 | 				table.insert(stateGroup, detail)
 212 | 				nowSetIt()
 213 | 			end
 214 | 			updateRecord()
 215 | 		end
 216 | 	end)
 217 | 	return modificationsUID
 218 | end
 219 | 
 220 | function Themes.remove(icon, modificationsUID)
 221 | 	for iconState, stateGroup in pairs(icon.appearance) do
 222 | 		for i = #stateGroup, 1, -1 do
 223 | 			local detail = stateGroup[i]
 224 | 			local checkingUID = detail[5]
 225 | 			if checkingUID == modificationsUID then
 226 | 				table.remove(stateGroup, i)
 227 | 			end
 228 | 		end
 229 | 	end
 230 | 	Themes.rebuild(icon)
 231 | end
 232 | 
 233 | function Themes.removeWith(icon, instanceName, property, state)
 234 | 	for iconState, stateGroup in pairs(icon.appearance) do
 235 | 		if state == iconState or not state then
 236 | 			for i = #stateGroup, 1, -1 do
 237 | 				local detail = stateGroup[i]
 238 | 				local detailName = detail[1]
 239 | 				local detailProperty = detail[2]
 240 | 				if detailName == instanceName and detailProperty == property then
 241 | 					table.remove(stateGroup, i)
 242 | 				end
 243 | 			end
 244 | 		end
 245 | 	end
 246 | 	Themes.rebuild(icon)
 247 | end
 248 | 
 249 | function Themes.change(icon)
 250 | 	-- This changes the theme to the appearance of whatever
 251 | 	-- state is currently active
 252 | 	local stateGroup = icon:getStateGroup()
 253 | 	for _, detail in pairs(stateGroup) do
 254 | 		local instanceName, property, value = unpack(detail)
 255 | 		Themes.apply(icon, instanceName, property, value)
 256 | 	end
 257 | end
 258 | 
 259 | function Themes.set(icon, theme)
 260 | 	-- This is responsible for processing the final appearance of a given theme (such as
 261 | 	-- ensuring Deselected merge into missing Selected, saving that internal state,
 262 | 	-- then checking to see if the appearance of the icon needs to be updated
 263 | 	local themesJanitor = icon.themesJanitor
 264 | 	themesJanitor:clean()
 265 | 	themesJanitor:add(icon.stateChanged:Connect(function()
 266 | 		Themes.change(icon)
 267 | 	end))
 268 | 	if typeof(theme) == "Instance" and theme:IsA("ModuleScript") then
 269 | 		theme = require(theme)
 270 | 	end
 271 | 	icon.appliedTheme = theme
 272 | 	Themes.rebuild(icon)
 273 | end
 274 | 
 275 | function Themes.statesMatch(state1, state2)
 276 | 	-- States match if they have the same name OR if nil (because unspecified represents all states)
 277 | 	local state1lower = (state1 and string.lower(state1))
 278 | 	local state2lower = (state2 and string.lower(state2))
 279 | 	return state1lower == state2lower or not state1 or not state2
 280 | end
 281 | 
 282 | function Themes.rebuild(icon)
 283 | 	-- A note for my future self: this code can be optimised further by
 284 | 	-- converting appearance into a instanceName-property dictionary
 285 | 	-- as apposed to an array of every potential change. When converting
 286 | 	-- in the future, .modify and .apply would also have to be updated.
 287 | 	local appliedTheme = icon.appliedTheme
 288 | 	local statesArray = {"Deselected", "Selected", "Viewing"}
 289 | 	local function generateTheme()
 290 | 		for _, stateName in pairs(statesArray) do
 291 | 			-- This applies themes in layers
 292 | 			-- The last layers take higher priority as they overwrite
 293 | 			-- any duplicate earlier applied effects
 294 | 			local stateAppearance = {}
 295 | 			local function updateDetails(theme, incomingStateName)
 296 | 				-- This ensures there's always a base 'default' layer
 297 | 				if not theme then
 298 | 					return
 299 | 				end
 300 | 				for _, detail in pairs(theme) do
 301 | 					local modificationsUID = detail[5]
 302 | 					local detailStateName = detail[4]
 303 | 					if Themes.statesMatch(incomingStateName, detailStateName) then
 304 | 						local key = detail[1].."-"..detail[2]
 305 | 						local newDetail = Utility.copyTable(detail)
 306 | 						newDetail[5] = modificationsUID
 307 | 						stateAppearance[key] = newDetail
 308 | 					end
 309 | 				end
 310 | 			end
 311 | 			-- First we apply the base theme (i.e. the Default module)
 312 | 			if stateName == "Selected" then
 313 | 				updateDetails(baseTheme, "Deselected")
 314 | 			end
 315 | 			updateDetails(baseTheme, "Empty")
 316 | 			updateDetails(baseTheme, stateName)
 317 | 			-- Next we apply any custom themes by the games developer
 318 | 			if appliedTheme ~= baseTheme then
 319 | 				if stateName == "Selected" then
 320 | 					updateDetails(appliedTheme, "Deselected")
 321 | 				end
 322 | 				updateDetails(baseTheme, "Empty")
 323 | 				updateDetails(appliedTheme, stateName)
 324 | 			end
 325 | 			-- Finally we apply any modifications that have already been made
 326 | 			-- Modifiers are all the changes made using icon:modifyTheme(...)
 327 | 			local alreadyAppliedTheme = {}
 328 | 			local alreadyAppliedGroup = icon.appearance[stateName]
 329 | 			if alreadyAppliedGroup then
 330 | 				for _, modifier in pairs(alreadyAppliedGroup) do
 331 | 					local modificationsUID = modifier[5]
 332 | 					if modificationsUID ~= nil then
 333 | 						local modification = {modifier[1], modifier[2], modifier[3], stateName, modificationsUID}
 334 | 						table.insert(alreadyAppliedTheme, modification)
 335 | 					end
 336 | 				end
 337 | 			end
 338 | 			updateDetails(alreadyAppliedTheme, stateName)
 339 | 			-- This now converts it into our final appearance
 340 | 			local finalStateAppearance = {}
 341 | 			for _, detail in pairs(stateAppearance) do
 342 | 				table.insert(finalStateAppearance, detail)
 343 | 			end
 344 | 			icon.appearance[stateName] = finalStateAppearance
 345 | 		end
 346 | 		Themes.change(icon)
 347 | 	end
 348 | 	generateTheme()
 349 | end
 350 | 
 351 | 
 352 | 
 353 | return Themes
```
</details>

## ğŸŒ™ `Packages/_Index/1foreverhd_topbarplus@3.4.0/topbarplus/src/init.lua`
<details>
<summary>View Source (1249 lines)</summary>

```lua
   1 | --!nonstrict
   2 | --[[
   3 | 	
   4 | 	The majority of this code is an interface designed to make it easy for you to
   5 | 	work with TopbarPlus (most methods for instance reference :modifyTheme()).
   6 | 	The processing overhead mainly consists of applying themes and calculating 
   7 | 	appearance (such as size and width of labels) which is handled in about
   8 | 	200 lines of code here and the Widget UI module. This has been achieved
   9 | 	in v3 by outsourcing a majority of previous calculations to inbuilt Roblox
  10 | 	features like UIListLayouts.
  11 | 
  12 | 
  13 | 	v3 provides inbuilt support for controllers (simply press DPadUp),
  14 | 	touch devices (phones, tablets , etc), localization (automatic resizing
  15 | 	of widgets, autolocalize for relevant labels), backwards compatability
  16 | 	with the old topbar, and more.
  17 | 
  18 | 
  19 | 	My primary goals for the v3 re-write have been to:
  20 | 		
  21 | 	1. Improve code readability and organisation (reduced lines of code within
  22 | 	   Icon+IconController from 3200 to ~950, separated UI elements, etc)
  23 | 		
  24 | 	2. Improve ease-of-use (themes now actually make sense and can account
  25 | 	   for any modifications you want, converted to a package for
  26 | 	   quick installation and easy-comparisons of new updates, etc)
  27 | 	
  28 | 	3. Provide support for all key features of the new Roblox topbar
  29 | 	   while improving performance of the module (deferring and collecting
  30 | 	   changes then calling as a singular, utilizing inbuilt Roblox features
  31 | 	   such as UILIstLayouts, etc)
  32 | 
  33 | --]]
  34 | 
  35 | 
  36 | 
  37 | -- SERVICES
  38 | local UserInputService = game:GetService("UserInputService")
  39 | local ContentProvider = game:GetService("ContentProvider")
  40 | local StarterGui = game:GetService("StarterGui")
  41 | local Players = game:GetService("Players")
  42 | local Types = require(script.Types)
  43 | 
  44 | 
  45 | 
  46 | -- TYPES
  47 | export type Icon = Types.Icon
  48 | 
  49 | 
  50 | 
  51 | -- REFERENCE HANDLER
  52 | -- Multiple Icons packages may exist at runtime (for instance if the developer additionally uses HD Admin)
  53 | -- therefore this ensures that the first required package becomes the dominant and only functioning module
  54 | local iconModule = script
  55 | local Reference = require(iconModule.Reference)
  56 | local referenceObject = Reference.getObject()
  57 | local leadPackage = referenceObject and referenceObject.Value
  58 | if leadPackage and leadPackage ~= iconModule then
  59 | 	return require(leadPackage) :: Types.StaticIcon
  60 | end
  61 | if not referenceObject then
  62 | 	Reference.addToReplicatedStorage()
  63 | end
  64 | 
  65 | 
  66 | 
  67 | -- MODULES
  68 | local Signal = require(iconModule.Packages.GoodSignal)
  69 | local Janitor = require(iconModule.Packages.Janitor)
  70 | local Utility = require(iconModule.Utility)
  71 | local Themes = require(iconModule.Features.Themes)
  72 | local Gamepad = require(iconModule.Features.Gamepad)
  73 | local Overflow = require(iconModule.Features.Overflow)
  74 | local Icon = {}
  75 | Icon.__index = Icon
  76 | 
  77 | 
  78 | 
  79 | --- LOCAL
  80 | local localPlayer = Players.LocalPlayer
  81 | local themes = iconModule.Features.Themes
  82 | local iconsDict = {}
  83 | local anyIconSelected = Signal.new()
  84 | local elements = iconModule.Elements
  85 | local totalCreatedIcons = 0
  86 | local preferredInput = {
  87 | 	mobile = Enum.PreferredInput.Touch,
  88 | 	desktop = Enum.PreferredInput.KeyboardAndMouse,
  89 | 	console = Enum.PreferredInput.Gamepad
  90 | }
  91 | 
  92 | 
  93 | 
  94 | -- PUBLIC VARIABLES
  95 | Icon.baseDisplayOrderChanged = Signal.new()
  96 | Icon.baseDisplayOrder = 10
  97 | Icon.baseTheme = require(themes.Default)
  98 | Icon.isOldTopbar = false -- Logic has been moved to Container
  99 | Icon.iconsDictionary = iconsDict
 100 | Icon.insetHeightChanged = Signal.new()
 101 | Icon.container = require(elements.Container)(Icon)
 102 | Icon.topbarEnabled = true
 103 | Icon.iconAdded = Signal.new()
 104 | Icon.iconRemoved = Signal.new()
 105 | Icon.iconChanged = Signal.new()
 106 | 
 107 | 
 108 | 
 109 | -- PUBLIC FUNCTIONS
 110 | function Icon.getIcons()
 111 | 	return Icon.iconsDictionary
 112 | end
 113 | 
 114 | function Icon.getIconByUID(UID)
 115 | 	local match = Icon.iconsDictionary[UID]
 116 | 	if match then
 117 | 		return match
 118 | 	end
 119 | 	return nil
 120 | end
 121 | 
 122 | function Icon.getIcon(nameOrUID)
 123 | 	local match = Icon.getIconByUID(nameOrUID)
 124 | 	if match then
 125 | 		return match
 126 | 	end
 127 | 	for _, icon in pairs(iconsDict) do
 128 | 		if icon.name == nameOrUID then
 129 | 			return icon
 130 | 		end
 131 | 	end
 132 | 	return nil
 133 | end
 134 | 
 135 | function Icon.setTopbarEnabled(bool, isInternal)
 136 | 	if typeof(bool) ~= "boolean" then
 137 | 		bool = Icon.topbarEnabled
 138 | 	end
 139 | 	if not isInternal then
 140 | 		Icon.topbarEnabled = bool
 141 | 	end
 142 | 	for _, screenGui in pairs(Icon.container) do
 143 | 		screenGui.Enabled = bool
 144 | 	end
 145 | end
 146 | 
 147 | function Icon.modifyBaseTheme(modifications)
 148 | 	modifications = Themes.getModifications(modifications)
 149 | 	for _, modification in pairs(modifications) do
 150 | 		for _, detail in pairs(Icon.baseTheme) do
 151 | 			Themes.merge(detail, modification)
 152 | 		end
 153 | 	end
 154 | 	for _, icon in pairs(iconsDict) do
 155 | 		icon:setTheme(Icon.baseTheme)
 156 | 	end
 157 | end
 158 | 
 159 | function Icon.setDisplayOrder(int)
 160 | 	Icon.baseDisplayOrder = int
 161 | 	Icon.baseDisplayOrderChanged:Fire(int)
 162 | end
 163 | 
 164 | 
 165 | 
 166 | -- SETUP
 167 | task.defer(Gamepad.start, Icon)
 168 | task.defer(Overflow.start, Icon)
 169 | task.defer(function()
 170 | 	local playerGui = localPlayer:WaitForChild("PlayerGui")
 171 | 	for _, screenGui in pairs(Icon.container) do
 172 | 		screenGui.Parent = playerGui
 173 | 	end
 174 | 	require(iconModule.Attribute)
 175 | end)
 176 | 
 177 | 
 178 | 
 179 | -- CONSTRUCTOR
 180 | function Icon.new()
 181 | 	local self = {}
 182 | 	setmetatable(self, Icon)
 183 | 
 184 | 	--- Janitors (for cleanup)
 185 | 	local janitor = Janitor.new()
 186 | 	self.janitor = janitor
 187 | 	self.themesJanitor = janitor:add(Janitor.new())
 188 | 	self.singleClickJanitor = janitor:add(Janitor.new())
 189 | 	self.captionJanitor = janitor:add(Janitor.new())
 190 | 	self.joinJanitor = janitor:add(Janitor.new())
 191 | 	self.menuJanitor = janitor:add(Janitor.new())
 192 | 	self.dropdownJanitor = janitor:add(Janitor.new())
 193 | 
 194 | 	-- Register
 195 | 	local iconUID = Utility.generateUID()
 196 | 	iconsDict[iconUID] = self
 197 | 	janitor:add(function()
 198 | 		iconsDict[iconUID] = nil
 199 | 	end)
 200 | 
 201 | 	-- Signals (events)
 202 | 	self.selected = janitor:add(Signal.new())
 203 | 	self.deselected = janitor:add(Signal.new())
 204 | 	self.toggled = janitor:add(Signal.new())
 205 | 	self.viewingStarted = janitor:add(Signal.new())
 206 | 	self.viewingEnded = janitor:add(Signal.new())
 207 | 	self.stateChanged = janitor:add(Signal.new())
 208 | 	self.notified = janitor:add(Signal.new())
 209 | 	self.noticeStarted = janitor:add(Signal.new())
 210 | 	self.noticeChanged = janitor:add(Signal.new())
 211 | 	self.endNotices = janitor:add(Signal.new())
 212 | 	self.toggleKeyAdded = janitor:add(Signal.new())
 213 | 	self.fakeToggleKeyChanged = janitor:add(Signal.new())
 214 | 	self.alignmentChanged = janitor:add(Signal.new())
 215 | 	self.updateSize = janitor:add(Signal.new())
 216 | 	self.resizingComplete = janitor:add(Signal.new())
 217 | 	self.joinedParent = janitor:add(Signal.new())
 218 | 	self.menuSet = janitor:add(Signal.new())
 219 | 	self.dropdownSet = janitor:add(Signal.new())
 220 | 	self.updateMenu = janitor:add(Signal.new())
 221 | 	self.startMenuUpdate = janitor:add(Signal.new())
 222 | 	self.childThemeModified = janitor:add(Signal.new())
 223 | 	self.indicatorSet = janitor:add(Signal.new())
 224 | 	self.dropdownChildAdded = janitor:add(Signal.new())
 225 | 	self.menuChildAdded = janitor:add(Signal.new())
 226 | 
 227 | 	-- Properties
 228 | 	self.iconModule = iconModule
 229 | 	self.UID = iconUID
 230 | 	self.isEnabled = true
 231 | 	self.enabled = self.isEnabled -- Backwards compatability
 232 | 	self.isSelected = false
 233 | 	self.isViewing = false
 234 | 	self.joinedFrame = false
 235 | 	self.parentIconUID = false
 236 | 	self.deselectWhenOtherIconSelected = true
 237 | 	self.totalNotices = 0
 238 | 	self.activeState = "Deselected"
 239 | 	self.alignment = ""
 240 | 	self.originalAlignment = ""
 241 | 	self.appliedTheme = {}
 242 | 	self.appearance = {}
 243 | 	self.cachedInstances = {}
 244 | 	self.cachedNamesToInstances = {}
 245 | 	self.cachedCollectives = {}
 246 | 	self.bindedToggleKeys = {}
 247 | 	self.customBehaviours = {}
 248 | 	self.toggleItems = {}
 249 | 	self.bindedEvents = {}
 250 | 	self.notices = {}
 251 | 	self.menuIcons = {}
 252 | 	self.dropdownIcons = {}
 253 | 	self.childIconsDict = {}
 254 | 	self.creationTime = os.clock()
 255 | 
 256 | 	-- Widget is the new name for an icon
 257 | 	local widget = janitor:add(require(elements.Widget)(self, Icon))
 258 | 	self.widget = widget
 259 | 	self:setAlignment()
 260 | 	
 261 | 	-- It's important we set an order otherwise icons will not align
 262 | 	-- correctly within menus
 263 | 	totalCreatedIcons += 1
 264 | 	local ourOrder = 1+(totalCreatedIcons*0.01)
 265 | 	self:setOrder(ourOrder, "deselected")
 266 | 	self:setOrder(ourOrder, "selected")
 267 | 
 268 | 	-- This applies the default them
 269 | 	self:setTheme(Icon.baseTheme)
 270 | 
 271 | 	-- Button Clicked (for states "Selected" and "Deselected")
 272 | 	local clickRegion = self:getInstance("ClickRegion")
 273 | 	local hasUsedMouseButton1Click = false
 274 | 	local lastToggleTime = 0
 275 | 	local DEBOUNCE_TIME = 0.1 -- 100ms debounce to prevent rapid toggles
 276 | 
 277 | 	local function handleToggle()
 278 | 		if self.locked then
 279 | 			return
 280 | 		end
 281 | 
 282 | 		-- Debounce logic to prevent rapid toggling
 283 | 		local currentTime = tick()
 284 | 		if currentTime - lastToggleTime < DEBOUNCE_TIME then
 285 | 			return
 286 | 		end
 287 | 		lastToggleTime = currentTime
 288 | 
 289 | 		if self.isSelected then
 290 | 			self:deselect("User", self)
 291 | 		else
 292 | 			self:select("User", self)
 293 | 		end
 294 | 	end
 295 | 
 296 | 	clickRegion.MouseButton1Click:Connect(function()
 297 | 		hasUsedMouseButton1Click = true
 298 | 		handleToggle()
 299 | 	end)
 300 | 
 301 | 	clickRegion.TouchTap:Connect(function()
 302 | 		-- This resolves the bug report by @28Pixels:
 303 | 		-- https://devforum.roblox.com/t/topbarplus/1017485/1104
 304 | 		-- Only use TouchTap if MouseButton1Click has never fired
 305 | 		-- This handles edge cases where ONLY TouchTap works
 306 | 		-- Also prevents double-toggle bug with multi-touch on mobile
 307 | 		-- Credit to @sayer80 for this fix
 308 | 		if not hasUsedMouseButton1Click then
 309 | 			handleToggle()
 310 | 		end
 311 | 	end)
 312 | 
 313 | 	-- Keys can be bound to toggle between Selected and Deselected
 314 | 	janitor:add(UserInputService.InputBegan:Connect(function(input, touchingAnObject)
 315 | 		if self.locked then
 316 | 			return
 317 | 		end
 318 | 		if self.bindedToggleKeys[input.KeyCode] and not touchingAnObject then
 319 | 			handleToggle()
 320 | 		end
 321 | 	end))
 322 | 
 323 | 	-- Button Hovering (for state "Viewing")
 324 | 	-- Hovering is a state only for devices with keyboards
 325 | 	-- and controllers (not touchpads)
 326 | 	local function viewingStarted(dontSetState)
 327 | 		if self.locked then
 328 | 			return
 329 | 		end
 330 | 		self.isViewing = true
 331 | 		self.viewingStarted:Fire(true)
 332 | 		if not dontSetState then
 333 | 			self:setState("Viewing", "User", self)
 334 | 		end
 335 | 	end
 336 | 	local function viewingEnded()
 337 | 		if self.locked then
 338 | 			return
 339 | 		end
 340 | 		self.isViewing = false
 341 | 		self.viewingEnded:Fire(true)
 342 | 		self:setState(nil, "User", self)
 343 | 	end
 344 | 	self.joinedParent:Connect(function()
 345 | 		if self.isViewing then
 346 | 			viewingEnded()
 347 | 		end
 348 | 	end)
 349 | 	clickRegion.MouseEnter:Connect(function()
 350 | 		local dontSetState = UserInputService.PreferredInput ~= preferredInput.desktop
 351 | 		viewingStarted(dontSetState)
 352 | 	end)
 353 | 	local touchCount = 0
 354 | 	janitor:add(UserInputService.TouchEnded:Connect(viewingEnded))
 355 | 	clickRegion.MouseLeave:Connect(viewingEnded)
 356 | 	clickRegion.SelectionGained:Connect(viewingStarted)
 357 | 	clickRegion.SelectionLost:Connect(viewingEnded)
 358 | 	clickRegion.MouseButton1Down:Connect(function()
 359 | 		if not self.locked and UserInputService.PreferredInput == preferredInput.mobile then
 360 | 			touchCount += 1
 361 | 			local myTouchCount = touchCount
 362 | 			task.delay(0.2, function()
 363 | 				if myTouchCount == touchCount then
 364 | 					viewingStarted()
 365 | 				end
 366 | 			end)
 367 | 		end
 368 | 	end)
 369 | 	clickRegion.MouseButton1Up:Connect(function()
 370 | 		touchCount += 1
 371 | 	end)
 372 | 
 373 | 	-- Handle overlay on viewing
 374 | 	local iconOverlay = self:getInstance("IconOverlay")
 375 | 	self.viewingStarted:Connect(function()
 376 | 		iconOverlay.Visible = not self.overlayDisabled
 377 | 	end)
 378 | 	self.viewingEnded:Connect(function()
 379 | 		iconOverlay.Visible = false
 380 | 	end)
 381 | 
 382 | 	-- Deselect when another icon is selected
 383 | 	janitor:add(anyIconSelected:Connect(function(incomingIcon)
 384 | 		if incomingIcon ~= self and self.deselectWhenOtherIconSelected and incomingIcon.deselectWhenOtherIconSelected then
 385 | 			self:deselect("AutoDeselect", incomingIcon)
 386 | 		end
 387 | 	end))
 388 | 
 389 | 	-- This checks if the script calling this module is a descendant of a ScreenGui
 390 | 	-- with 'ResetOnSpawn' set to true. If it is, then we destroy the icon the
 391 | 	-- client respawns. This solves one of the most asked about questions on the post
 392 | 	-- The only caveat this may not work if the player doesn't uniquely name their ScreenGui and the frames
 393 | 	-- the LocalScript rests within
 394 | 	local source =  debug.info(2, "s")
 395 | 	local sourcePath = string.split(source, ".")
 396 | 	local origin = game
 397 | 	local originsScreenGui
 398 | 	for i, sourceName in pairs(sourcePath) do
 399 | 		origin = origin:FindFirstChild(sourceName)
 400 | 		if not origin then
 401 | 			break
 402 | 		end
 403 | 		if origin:IsA("ScreenGui") then
 404 | 			originsScreenGui = origin
 405 | 		end
 406 | 	end
 407 | 	if origin and originsScreenGui and originsScreenGui.ResetOnSpawn == true then
 408 | 		self.originsScreenGui = originsScreenGui
 409 | 		Utility.localPlayerRespawned(function()
 410 | 			self:destroy()
 411 | 		end)
 412 | 	end
 413 | 
 414 | 	-- Additional children behaviour when toggled (mostly notices)
 415 | 	self.toggled:Connect(function(isSelected)
 416 | 		self.noticeChanged:Fire(self.totalNotices)
 417 | 		for childIconUID, _ in pairs(self.childIconsDict) do
 418 | 			local childIcon = Icon.getIconByUID(childIconUID)
 419 | 			childIcon.noticeChanged:Fire(childIcon.totalNotices)
 420 | 			if not isSelected and childIcon.isSelected then
 421 | 				-- If an icon within a menu or dropdown is also
 422 | 				-- a dropdown or menu, then close it
 423 | 				for _, _ in pairs(childIcon.childIconsDict) do
 424 | 					childIcon:deselect("HideParentFeature", self)
 425 | 				end
 426 | 			end
 427 | 		end
 428 | 	end)
 429 | 	
 430 | 	-- This closes/reopens the chat or playerlist if the icon is a dropdown
 431 | 	-- In the future I'd prefer to use the position+size of the chat
 432 | 	-- to determine whether to close dropdown (instead of non-right-set)
 433 | 	-- but for reasons mentioned here it's unreliable at the time of
 434 | 	-- writing this: https://devforum.roblox.com/t/here/2794915
 435 | 	-- I could also make this better by accounting for multiple
 436 | 	-- dropdowns being open (not just this one) but this will work
 437 | 	-- fine for almost every use case for now.
 438 | 	self.selected:Connect(function()
 439 | 		local isDropdown = #self.dropdownIcons > 0
 440 | 		if isDropdown then
 441 | 			if StarterGui:GetCore("ChatActive") and self.alignment ~= "Right" then
 442 | 				self.chatWasPreviouslyActive = true
 443 | 				StarterGui:SetCore("ChatActive", false)
 444 | 			end
 445 | 			if StarterGui:GetCoreGuiEnabled("PlayerList") and self.alignment ~= "Left" then
 446 | 				self.playerlistWasPreviouslyActive = true
 447 | 				StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, false)
 448 | 			end
 449 | 		end
 450 | 	end)
 451 | 	self.deselected:Connect(function()
 452 | 		if self.chatWasPreviouslyActive then
 453 | 			self.chatWasPreviouslyActive = nil
 454 | 			StarterGui:SetCore("ChatActive", true)
 455 | 		end
 456 | 		if self.playerlistWasPreviouslyActive then
 457 | 			self.playerlistWasPreviouslyActive = nil
 458 | 			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, true)
 459 | 		end
 460 | 	end)
 461 | 	
 462 | 	-- There's a rare occassion where the appearance is not
 463 | 	-- fully set to deselected so this ensures the icons
 464 | 	-- appearance is fully as it should be
 465 | 	task.delay(0.1, function()
 466 | 		if self.activeState == "Deselected" then
 467 | 			self.stateChanged:Fire("Deselected")
 468 | 			self:refresh()
 469 | 		end
 470 | 	end)
 471 | 	
 472 | 	-- Call icon added
 473 | 	Icon.iconAdded:Fire(self)
 474 | 
 475 | 	return self
 476 | end
 477 | 
 478 | 
 479 | 
 480 | -- METHODS
 481 | function Icon:setName(name)
 482 | 	self.widget.Name = name
 483 | 	self.name = name
 484 | 	return self
 485 | end
 486 | 
 487 | function Icon:setState(incomingStateName, fromSource, sourceIcon)
 488 | 	-- This is responsible for acknowleding a change in stage (such as from "Deselected" to "Viewing" when
 489 | 	-- a users mouse enters the widget), then informing other systems of this state change to then act upon
 490 | 	-- (such as the theme handler applying the theme which corresponds to that state).
 491 | 	if not incomingStateName then
 492 | 		incomingStateName = (self.isSelected and "Selected") or "Deselected"
 493 | 	end
 494 | 	local stateName = Utility.formatStateName(incomingStateName)
 495 | 	local previousStateName = self.activeState
 496 | 	if previousStateName == stateName then
 497 | 		return
 498 | 	end
 499 | 	local currentIsSelected = self.isSelected
 500 | 	self.activeState = stateName
 501 | 	if stateName == "Deselected" then
 502 | 		self.isSelected = false
 503 | 		if currentIsSelected then
 504 | 			self.toggled:Fire(false, fromSource, sourceIcon)
 505 | 			self.deselected:Fire(fromSource, sourceIcon)
 506 | 		end
 507 | 		self:_setToggleItemsVisible(false, fromSource, sourceIcon)
 508 | 	elseif stateName == "Selected" then
 509 | 		self.isSelected = true
 510 | 		if not currentIsSelected then
 511 | 			self.toggled:Fire(true, fromSource, sourceIcon)
 512 | 			self.selected:Fire(fromSource, sourceIcon)
 513 | 			anyIconSelected:Fire(self, fromSource, sourceIcon)
 514 | 		end
 515 | 		self:_setToggleItemsVisible(true, fromSource, sourceIcon)
 516 | 	end
 517 | 	self.stateChanged:Fire(stateName, fromSource, sourceIcon)
 518 | end
 519 | 
 520 | function Icon:getInstance(name)
 521 | 	-- This enables us to easily retrieve instances located within the icon simply by passing its name.
 522 | 	-- Every important/significant instance is named uniquely therefore this is no worry of overlap.
 523 | 	-- We cache the result for more performant retrieval in the future.
 524 | 	local instance = self.cachedNamesToInstances[name]
 525 | 	if instance then
 526 | 		return instance
 527 | 	end
 528 | 	local function cacheInstance(childName, child)
 529 | 		local currentCache = self.cachedInstances[child]
 530 | 		if not currentCache then
 531 | 			local collectiveName = child:GetAttribute("Collective")
 532 | 			local cachedCollective = collectiveName and self.cachedCollectives[collectiveName]
 533 | 			if cachedCollective then
 534 | 				table.insert(cachedCollective, child)
 535 | 			end
 536 | 			self.cachedNamesToInstances[childName] = child
 537 | 			self.cachedInstances[child] = true
 538 | 			child.Destroying:Once(function()
 539 | 				self.cachedNamesToInstances[childName] = nil
 540 | 				self.cachedInstances[child] = nil
 541 | 			end)
 542 | 		end
 543 | 	end
 544 | 	local widget = self.widget
 545 | 	cacheInstance("Widget", widget)
 546 | 	if name == "Widget" then
 547 | 		return widget
 548 | 	end
 549 | 
 550 | 	local returnChild
 551 | 	local function scanChildren(parentInstance)
 552 | 		for _, child in pairs(parentInstance:GetChildren()) do
 553 | 			local widgetUID = child:GetAttribute("WidgetUID")
 554 | 			if widgetUID and widgetUID ~= self.UID then
 555 | 				-- This prevents instances within other icons from being recorded
 556 | 				-- (for instance when other icons are added to this icons menu)
 557 | 				continue
 558 | 			end
 559 | 			-- If the child is a fake placeholder instance (such as dropdowns, notices, etc)
 560 | 			-- then its important we scan the real original instance instead of this clone
 561 | 			local realChild = Themes.getRealInstance(child)
 562 | 			if realChild then
 563 | 				child = realChild
 564 | 			end
 565 | 			-- Finally scan its children
 566 | 			scanChildren(child)
 567 | 			if child:IsA("GuiBase") or child:IsA("UIBase") or child:IsA("ValueBase") then
 568 | 				local childName = child.Name
 569 | 				cacheInstance(childName, child)
 570 | 				if childName == name then
 571 | 					returnChild = child
 572 | 				end
 573 | 			end
 574 | 		end
 575 | 	end
 576 | 	scanChildren(widget)
 577 | 	return returnChild
 578 | end
 579 | 
 580 | function Icon:getCollective(name)
 581 | 	-- A collective is an array of instances within the Widget that have been
 582 | 	-- grouped together based on a given name. This just makes it easy
 583 | 	-- to act on multiple instances at once which share similar behaviours.
 584 | 	-- For instance, if we want to change the icons corner size, all corner instances
 585 | 	-- with the attribute "Collective" and value "WidgetCorner" could be updated
 586 | 	-- instantly by doing Themes.apply(icon, "WidgetCorner", newSize)
 587 | 	local collective = self.cachedCollectives[name]
 588 | 	if collective then
 589 | 		return collective
 590 | 	end
 591 | 	collective = {}
 592 | 	for instance, _ in pairs(self.cachedInstances) do
 593 | 		if instance:GetAttribute("Collective") == name then
 594 | 			table.insert(collective, instance)
 595 | 		end
 596 | 	end
 597 | 	self.cachedCollectives[name] = collective
 598 | 	return collective
 599 | end
 600 | 
 601 | function Icon:getInstanceOrCollective(collectiveOrInstanceName)
 602 | 	-- Similar to :getInstance but also accounts for 'Collectives', such as UICorners and returns
 603 | 	-- an array of instances instead of a single instance
 604 | 	local instances = {}
 605 | 	local instance = self:getInstance(collectiveOrInstanceName)
 606 | 	if instance then
 607 | 		table.insert(instances, instance)
 608 | 	end
 609 | 	if #instances == 0 then
 610 | 		instances = self:getCollective(collectiveOrInstanceName)
 611 | 	end
 612 | 	return instances
 613 | end
 614 | 
 615 | function Icon:getStateGroup(iconState)
 616 | 	local chosenState = iconState or self.activeState
 617 | 	local stateGroup = self.appearance[chosenState]
 618 | 	if not stateGroup then
 619 | 		stateGroup = {}
 620 | 		self.appearance[chosenState] = stateGroup
 621 | 	end
 622 | 	return stateGroup
 623 | end
 624 | 
 625 | function Icon:refreshAppearance(instance, specificProperty)
 626 | 	Themes.refresh(self, instance, specificProperty)
 627 | 	return self
 628 | end
 629 | 
 630 | function Icon:refresh()
 631 | 	self:refreshAppearance(self.widget)
 632 | 	self.updateSize:Fire()
 633 | 	return self
 634 | end
 635 | 
 636 | function Icon:updateParent()
 637 | 	local parentIcon = Icon.getIconByUID(self.parentIconUID)
 638 | 	if parentIcon then
 639 | 		parentIcon.updateSize:Fire()
 640 | 	end
 641 | end
 642 | 
 643 | function Icon:setBehaviour(collectiveOrInstanceName, property, callback, refreshAppearance)
 644 | 	-- You can specify your own custom callback to handle custom logic just before
 645 | 	-- an instances property is changed by using :setBehaviour()
 646 | 	local key = collectiveOrInstanceName.."-"..property
 647 | 	self.customBehaviours[key] = callback
 648 | 	if refreshAppearance then
 649 | 		local instances = self:getInstanceOrCollective(collectiveOrInstanceName)
 650 | 		for _, instance in pairs(instances) do
 651 | 			self:refreshAppearance(instance, property)
 652 | 		end
 653 | 	end
 654 | end
 655 | 
 656 | function Icon:modifyTheme(modifications, customModificationUID)
 657 | 	local modificationUID = Themes.modify(self, modifications, customModificationUID)
 658 | 	return self, modificationUID
 659 | end
 660 | 
 661 | function Icon:modifyChildTheme(modifications, modificationUID)
 662 | 	-- Same as modifyTheme except for its children (i.e. icons
 663 | 	-- within its dropdown or menu)
 664 | 	self.childModifications = modifications
 665 | 	self.childModificationsUID = modificationUID
 666 | 	for childIconUID, _ in pairs(self.childIconsDict) do
 667 | 		local childIcon = Icon.getIconByUID(childIconUID)
 668 | 		childIcon:modifyTheme(modifications, modificationUID)
 669 | 	end
 670 | 	self.childThemeModified:Fire()
 671 | 	return self
 672 | end
 673 | 
 674 | function Icon:removeModification(modificationUID)
 675 | 	Themes.remove(self, modificationUID)
 676 | 	return self
 677 | end
 678 | 
 679 | function Icon:removeModificationWith(instanceName, property, state)
 680 | 	Themes.removeWith(self, instanceName, property, state)
 681 | 	return self
 682 | end
 683 | 
 684 | function Icon:setTheme(theme)
 685 | 	Themes.set(self, theme)
 686 | 	return self
 687 | end
 688 | 
 689 | function Icon:setEnabled(bool)
 690 | 	self.isEnabled = bool
 691 | 	self.enabled = self.isEnabled
 692 | 	self.widget.Visible = bool
 693 | 	self:updateParent()
 694 | 	return self
 695 | end
 696 | 
 697 | function Icon:select(fromSource, sourceIcon)
 698 | 	self:setState("Selected", fromSource, sourceIcon)
 699 | 	return self
 700 | end
 701 | 
 702 | function Icon:deselect(fromSource, sourceIcon)
 703 | 	self:setState("Deselected", fromSource, sourceIcon)
 704 | 	return self
 705 | end
 706 | 
 707 | function Icon:notify(customClearSignal, noticeId)
 708 | 	-- Generates a notification which appears in the top right of the icon. Useful for example for prompting
 709 | 	-- users of changes/updates within your UI such as a Catalog
 710 | 	-- 'customClearSignal' is a signal object (e.g. icon.deselected) or
 711 | 	-- Roblox event (e.g. Instance.new("BindableEvent").Event)
 712 | 	local notice = self.notice
 713 | 	if not notice then
 714 | 		notice = require(elements.Notice)(self, Icon)
 715 | 		self.notice = notice
 716 | 	end
 717 | 	self.noticeStarted:Fire(customClearSignal, noticeId)
 718 | 	return self
 719 | end
 720 | 
 721 | function Icon:clearNotices()
 722 | 	self.endNotices:Fire()
 723 | 	return self
 724 | end
 725 | 
 726 | function Icon:disableOverlay(bool)
 727 | 	self.overlayDisabled = bool
 728 | 	return self
 729 | end
 730 | Icon.disableStateOverlay = Icon.disableOverlay
 731 | 
 732 | function Icon:setImage(imageId, iconState)
 733 | 	self:modifyTheme({"IconImage", "Image", imageId, iconState})
 734 | 	
 735 | 	-- This code ensures icon images are preloaded if they haven't been fetched yet
 736 | 	task.spawn(function()
 737 | 		local newIdContent = if tonumber(imageId) then `rbxassetid://{imageId}` else imageId
 738 | 		local initialAssetFetchStatus = ContentProvider:GetAssetFetchStatus(newIdContent)
 739 | 	
 740 | 		if initialAssetFetchStatus ~= Enum.AssetFetchStatus.Success then
 741 | 			pcall(ContentProvider.PreloadAsync, ContentProvider, { newIdContent })
 742 | 		end
 743 | 	end)
 744 | 		
 745 | 	return self
 746 | end
 747 | 
 748 | function Icon:setLabel(text, iconState)
 749 | 	self:modifyTheme({"IconLabel", "Text", text, iconState})
 750 | 	return self
 751 | end
 752 | 
 753 | function Icon:setOrder(int, iconState)
 754 | 	-- We multiply by 100 to allow for custom increments inbetween
 755 | 	-- (.01, .02, etc) as LayoutOrders only support integers
 756 | 	local newInt = int*100
 757 | 	self:modifyTheme({"IconSpot", "LayoutOrder", newInt, iconState})
 758 | 	self:modifyTheme({"Widget", "LayoutOrder", newInt, iconState})
 759 | 	return self
 760 | end
 761 | 
 762 | function Icon:setCornerRadius(udim, iconState)
 763 | 	self:modifyTheme({"IconCorners", "CornerRadius", udim, iconState})
 764 | 	return self
 765 | end
 766 | 
 767 | function Icon:align(leftCenterOrRight, isFromParentIcon)
 768 | 	-- Determines the side of the screen the icon will be ordered
 769 | 	local direction = tostring(leftCenterOrRight):lower()
 770 | 	if direction == "mid" or direction == "centre" then
 771 | 		direction = "center"
 772 | 	end
 773 | 	if direction ~= "left" and direction ~= "center" and direction ~= "right" then
 774 | 		direction = "left"
 775 | 	end
 776 | 	local screenGui = (direction == "center" and Icon.container.TopbarCentered) or Icon.container.TopbarStandard
 777 | 	local holders = screenGui.Holders
 778 | 	local finalDirection = string.upper(string.sub(direction, 1, 1))..string.sub(direction, 2)
 779 | 	if not isFromParentIcon then
 780 | 		self.originalAlignment = finalDirection
 781 | 	end
 782 | 	local joinedFrame = self.joinedFrame
 783 | 	local alignmentHolder = holders[finalDirection]
 784 | 	self.screenGui = screenGui
 785 | 	self.alignmentHolder = alignmentHolder
 786 | 	if not self.isDestroyed then
 787 | 		self.widget.Parent = joinedFrame or alignmentHolder
 788 | 	end
 789 | 	self.alignment = finalDirection
 790 | 	self.alignmentChanged:Fire(finalDirection)
 791 | 	Icon.iconChanged:Fire(self)
 792 | 	return self
 793 | end
 794 | Icon.setAlignment = Icon.align
 795 | 
 796 | function Icon:setLeft()
 797 | 	self:setAlignment("Left")
 798 | 	return self
 799 | end
 800 | 
 801 | function Icon:setMid()
 802 | 	self:setAlignment("Center")
 803 | 	return self
 804 | end
 805 | 
 806 | function Icon:setRight()
 807 | 	self:setAlignment("Right")
 808 | 	return self
 809 | end
 810 | 
 811 | function Icon:setWidth(offsetMinimum, iconState)
 812 | 	-- This sets a minimum X offset size for the widget, useful
 813 | 	-- for example if you're constantly changing the label
 814 | 	-- but don't want the icon to resize every time
 815 | 	self:modifyTheme({"Widget", "DesiredWidth", offsetMinimum, iconState})
 816 | 	return self
 817 | end
 818 | 
 819 | function Icon:setImageScale(number, iconState)
 820 | 	self:modifyTheme({"IconImageScale", "Value", number, iconState})
 821 | 	return self
 822 | end
 823 | 
 824 | function Icon:setImageRatio(number, iconState)
 825 | 	self:modifyTheme({"IconImageRatio", "AspectRatio", number, iconState})
 826 | 	return self
 827 | end
 828 | 
 829 | function Icon:setTextSize(number, iconState)
 830 | 	self:modifyTheme({"IconLabel", "TextSize", number, iconState})
 831 | 	return self
 832 | end
 833 | 
 834 | function Icon:setTextFont(font, fontWeight, fontStyle, iconState)
 835 | 	fontWeight = fontWeight or Enum.FontWeight.Regular
 836 | 	fontStyle = fontStyle or Enum.FontStyle.Normal
 837 | 	local fontFace
 838 | 	local fontType = typeof(font)
 839 | 	if fontType == "number" then
 840 | 		fontFace = Font.fromId(font, fontWeight, fontStyle)
 841 | 	elseif fontType == "EnumItem" then
 842 | 		fontFace = Font.fromEnum(font)
 843 | 	elseif fontType == "string" then
 844 | 		if not font:match("rbxasset") then
 845 | 			fontFace = Font.fromName(font, fontWeight, fontStyle)
 846 | 		end
 847 | 	end
 848 | 	if not fontFace then
 849 | 		fontFace = Font.new(font, fontWeight, fontStyle)
 850 | 	end
 851 | 	self:modifyTheme({"IconLabel", "FontFace", fontFace, iconState})
 852 | 	return self
 853 | end
 854 | 
 855 | function Icon:setTextColor(Color, iconState)
 856 | 	if Color == nil or Color == "" or (type(Color) ~= "userdata" or typeof(Color) ~= "Color3") then
 857 | 		if Color ~= nil and Color ~= "" then
 858 | 			warn("setTextColor item must be a Color3 value! Changed the color to white.")
 859 | 		end
 860 | 		Color = Color3.fromRGB(255, 255, 255)
 861 | 	end
 862 | 
 863 | 	self:modifyTheme({"IconLabel", "TextColor3", Color, iconState})
 864 | 	return self
 865 | end
 866 | 
 867 | function Icon:bindToggleItem(guiObjectOrLayerCollector)
 868 | 	if not guiObjectOrLayerCollector:IsA("GuiObject") and not guiObjectOrLayerCollector:IsA("LayerCollector") then
 869 | 		error("Toggle item must be a GuiObject or LayerCollector!")
 870 | 	end
 871 | 	self.toggleItems[guiObjectOrLayerCollector] = true
 872 | 	self:_updateSelectionInstances()
 873 | 	return self
 874 | end
 875 | 
 876 | function Icon:unbindToggleItem(guiObjectOrLayerCollector)
 877 | 	self.toggleItems[guiObjectOrLayerCollector] = nil
 878 | 	self:_updateSelectionInstances()
 879 | 	return self
 880 | end
 881 | 
 882 | function Icon:_updateSelectionInstances()
 883 | 	-- This is to assist with controller navigation and selection
 884 | 	-- It converts the value true to an array
 885 | 	for guiObjectOrLayerCollector, _ in pairs(self.toggleItems) do
 886 | 		local buttonInstancesArray = {}
 887 | 		for _, instance in pairs(guiObjectOrLayerCollector:GetDescendants()) do
 888 | 			if (instance:IsA("TextButton") or instance:IsA("ImageButton")) and instance.Active then
 889 | 				table.insert(buttonInstancesArray, instance)
 890 | 			end
 891 | 		end
 892 | 		self.toggleItems[guiObjectOrLayerCollector] = buttonInstancesArray
 893 | 	end
 894 | end
 895 | 
 896 | function Icon:_setToggleItemsVisible(bool, fromSource, sourceIcon)
 897 | 	for toggleItem, _ in pairs(self.toggleItems) do
 898 | 		if not sourceIcon or sourceIcon == self or sourceIcon.toggleItems[toggleItem] == nil then
 899 | 			local property = "Visible"
 900 | 			if toggleItem:IsA("LayerCollector") then
 901 | 				property = "Enabled"
 902 | 			end
 903 | 			toggleItem[property] = bool
 904 | 		end
 905 | 	end
 906 | end
 907 | 
 908 | function Icon:bindEvent(iconEventName, eventFunction)
 909 | 	local event = self[iconEventName]
 910 | 	assert(event and typeof(event) == "table" and event.Connect, "argument[1] must be a valid topbarplus icon event name!")
 911 | 	assert(typeof(eventFunction) == "function", "argument[2] must be a function!")
 912 | 	self.bindedEvents[iconEventName] = event:Connect(function(...)
 913 | 		eventFunction(self, ...)
 914 | 	end)
 915 | 	return self
 916 | end
 917 | 
 918 | function Icon:unbindEvent(iconEventName)
 919 | 	local eventConnection = self.bindedEvents[iconEventName]
 920 | 	if eventConnection then
 921 | 		eventConnection:Disconnect()
 922 | 		self.bindedEvents[iconEventName] = nil
 923 | 	end
 924 | 	return self
 925 | end
 926 | 
 927 | function Icon:bindToggleKey(keyCodeEnum)
 928 | 	assert(typeof(keyCodeEnum) == "EnumItem", "argument[1] must be a KeyCode EnumItem!")
 929 | 	self.bindedToggleKeys[keyCodeEnum] = true
 930 | 	self.toggleKeyAdded:Fire(keyCodeEnum)
 931 | 	self:setCaption("_hotkey_")
 932 | 	return self
 933 | end
 934 | 
 935 | function Icon:unbindToggleKey(keyCodeEnum)
 936 | 	assert(typeof(keyCodeEnum) == "EnumItem", "argument[1] must be a KeyCode EnumItem!")
 937 | 	self.bindedToggleKeys[keyCodeEnum] = nil
 938 | 	return self
 939 | end
 940 | 
 941 | function Icon:call(callback, ...)
 942 | 	local packedArgs = table.pack(...)
 943 | 	task.spawn(function()
 944 | 		callback(self, table.unpack(packedArgs))
 945 | 	end)
 946 | 	return self
 947 | end
 948 | 
 949 | function Icon:addToJanitor(callback, methodName, index)
 950 | 	self.janitor:add(callback, methodName, index)
 951 | 	return self
 952 | end
 953 | 
 954 | function Icon:lock()
 955 | 	-- This disables all user inputs related to the icon (such as clicking buttons, pressing keys, etc)
 956 | 	local clickRegion = self:getInstance("ClickRegion")
 957 | 	clickRegion.Visible = false
 958 | 	self.locked = true
 959 | 	return self
 960 | end
 961 | 
 962 | function Icon:unlock()
 963 | 	local clickRegion = self:getInstance("ClickRegion")
 964 | 	clickRegion.Visible = true
 965 | 	self.locked = false
 966 | 	return self
 967 | end
 968 | 
 969 | function Icon:debounce(seconds)
 970 | 	self:lock()
 971 | 	task.wait(seconds)
 972 | 	self:unlock()
 973 | 	return self
 974 | end
 975 | 
 976 | function Icon:autoDeselect(bool)
 977 | 	-- When set to true the icon will deselect itself automatically whenever
 978 | 	-- another icon is selected
 979 | 	if bool == nil then
 980 | 		bool = true
 981 | 	end
 982 | 	self.deselectWhenOtherIconSelected = bool
 983 | 	return self
 984 | end
 985 | 
 986 | function Icon:oneClick(bool)
 987 | 	-- When set to true the icon will automatically deselect when selected, this creates
 988 | 	-- the effect of a single click button
 989 | 	local singleClickJanitor = self.singleClickJanitor
 990 | 	singleClickJanitor:clean()
 991 | 	if bool or bool == nil then
 992 | 		singleClickJanitor:add(self.selected:Connect(function()
 993 | 			self:deselect("OneClick", self)
 994 | 		end))
 995 | 	end
 996 | 	self.oneClickEnabled = true
 997 | 	return self
 998 | end
 999 | 
1000 | function Icon:setCaption(text)
1001 | 	if text == "_hotkey_" and (self.captionText) then
1002 | 		return self
1003 | 	end
1004 | 	local captionJanitor = self.captionJanitor
1005 | 	self.captionJanitor:clean()
1006 | 	if not text or text == "" then
1007 | 		self.caption = nil
1008 | 		self.captionText = nil
1009 | 		return self
1010 | 	end
1011 | 	local caption = captionJanitor:add(require(elements.Caption)(self))
1012 | 	caption:SetAttribute("CaptionText", text)
1013 | 	self.caption = caption
1014 | 	self.captionText = text
1015 | 	return self
1016 | end
1017 | 
1018 | function Icon:setCaptionHint(keyCodeEnum)
1019 | 	assert(typeof(keyCodeEnum) == "EnumItem", "argument[1] must be a KeyCode EnumItem!")
1020 | 	self.fakeToggleKey = keyCodeEnum
1021 | 	self.fakeToggleKeyChanged:Fire(keyCodeEnum)
1022 | 	self:setCaption("_hotkey_")
1023 | 	return self
1024 | end
1025 | 
1026 | function Icon:leave()
1027 | 	local joinJanitor = self.joinJanitor
1028 | 	joinJanitor:clean()
1029 | 	return self
1030 | end
1031 | 
1032 | function Icon:joinMenu(parentIcon)
1033 | 	Utility.joinFeature(self, parentIcon, parentIcon.menuIcons, parentIcon:getInstance("Menu"))
1034 | 	parentIcon.menuChildAdded:Fire(self)
1035 | 	return self
1036 | end
1037 | 
1038 | function Icon:setMenu(arrayOfIcons)
1039 | 	self.menuSet:Fire(arrayOfIcons)
1040 | 	return self
1041 | end
1042 | 
1043 | function Icon:setFixedMenu(arrayOfIcons)
1044 | 	self:freezeMenu(arrayOfIcons)
1045 | 	self:setMenu(arrayOfIcons)
1046 | end
1047 | Icon.setFrozenMenu = Icon.setFixedMenu
1048 | 
1049 | function Icon:freezeMenu()
1050 | 	-- A frozen menu is a menu which is permanently locked in the
1051 | 	-- the selected state (with its toggle hidden)
1052 | 	self:select("FrozenMenu", self)
1053 | 	self:bindEvent("deselected", function(icon)
1054 | 		icon:select("FrozenMenu", self)
1055 | 	end)
1056 | 	self:modifyTheme({"IconSpot", "Visible", false})
1057 | end
1058 | 
1059 | function Icon:joinDropdown(parentIcon)
1060 | 	parentIcon:getDropdown()
1061 | 	Utility.joinFeature(self, parentIcon, parentIcon.dropdownIcons, parentIcon:getInstance("DropdownScroller"))
1062 | 	parentIcon.dropdownChildAdded:Fire(self)
1063 | 	return self
1064 | end
1065 | 
1066 | function Icon:getDropdown()
1067 | 	local dropdown = self.dropdown
1068 | 	if not dropdown then
1069 | 		dropdown = require(elements.Dropdown)(self)
1070 | 		self.dropdown = dropdown
1071 | 		self:clipOutside(dropdown)
1072 | 	end
1073 | 	return dropdown
1074 | end
1075 | 
1076 | function Icon:setDropdown(arrayOfIcons)
1077 | 	self:getDropdown()
1078 | 	self.dropdownSet:Fire(arrayOfIcons)
1079 | 	return self
1080 | end
1081 | 
1082 | function Icon:clipOutside(instance)
1083 | 	-- This is essential for items such as notices and dropdowns which will exceed the bounds of the widget. This is an issue
1084 | 	-- because the widget must have ClipsDescendents enabled to hide items for instance when the menu is closing or opening.
1085 | 	-- This creates an invisible frame which matches the size and position of the instance, then the instance is parented outside of
1086 | 	-- the widget and tracks the clone to match its size and position. In order for themes, etc to work the applying system checks
1087 | 	-- to see if an instance is a clone, then if it is, it applies it to the original instance instead of the clone.
1088 | 	local instanceClone = Utility.clipOutside(self, instance)
1089 | 	self:refreshAppearance(instance)
1090 | 	return self, instanceClone
1091 | end
1092 | 
1093 | function Icon:setIndicator(keyCode)
1094 | 	-- An indicator is a direction button prompt with an image of the given keycode. This is useful for instance
1095 | 	-- with controllers to show the user what button to press to highlight the topbar. You don't need
1096 | 	-- to set an indicator for controllers as this is handled internally within the Gamepad module
1097 | 	local indicator = self.indicator
1098 | 	if not indicator then
1099 | 		indicator = self.janitor:add(require(elements.Indicator)(self, Icon))
1100 | 		self.indicator = indicator
1101 | 	end
1102 | 	self.indicatorSet:Fire(keyCode)
1103 | end
1104 | 
1105 | function Icon:convertLabelToNumberSpinner(numberSpinner, callback)
1106 | 	task.defer(function()
1107 | 		
1108 | 		local label = self:getInstance("IconLabel")
1109 | 		label.Transparency = 1
1110 | 		numberSpinner.Parent = label.Parent
1111 | 		numberSpinner.Size = UDim2.fromScale(1, 1)
1112 | 		numberSpinner.AnchorPoint = Vector2.new(0.5, 0.5)
1113 | 		numberSpinner.Position = UDim2.new(0.5, 0, 0.5, 0)
1114 | 		numberSpinner.TextXAlignment = Enum.TextXAlignment.Center
1115 | 		numberSpinner.ClipsDescendants = false
1116 | 
1117 | 		local propertiesToChangeLabel = {
1118 | 			"FontFace",
1119 | 			"BorderSizePixel",
1120 | 			"BorderColor3",
1121 | 			"Rotation",
1122 | 			"TextStrokeTransparency",
1123 | 			"TextStrokeColor3",
1124 | 			"TextStrokeTransparency",
1125 | 			"TextColor3",
1126 | 		}
1127 | 		for _, property in ipairs(propertiesToChangeLabel) do
1128 | 			numberSpinner[property] = label[property]
1129 | 			self:addToJanitor(label:GetPropertyChangedSignal(property):Connect(function()
1130 | 				numberSpinner[property] = label[property]
1131 | 			end))
1132 | 		end
1133 | 
1134 | 		local minDigits = 0
1135 | 		local maxDigits = 8
1136 | 		local function getSpinnerSizeAndDigitCount()
1137 | 			local TotalSize = 0
1138 | 			local numOfDigits = 0
1139 | 			for i, child in numberSpinner.Frame:GetChildren() do
1140 | 				local name = string.lower(child.Name)
1141 | 				if name == "digit" then
1142 | 					TotalSize += child.AbsoluteSize.X
1143 | 					numOfDigits += 1
1144 | 				elseif name == "prefix" or name == "suffix" or name == "comma" then
1145 | 					if child.Text ~= "" then
1146 | 						TotalSize += child.AbsoluteSize.X
1147 | 						numOfDigits += 1
1148 | 					end
1149 | 				end
1150 | 			end
1151 | 			return TotalSize, numOfDigits
1152 | 		end
1153 | 		
1154 | 		local function getLabelParentContainerXSize()
1155 | 			local firstParent = label.Parent
1156 | 			local nextParent = firstParent and firstParent.Parent
1157 | 			if nextParent == nil then
1158 | 				return 0
1159 | 			end
1160 | 			if nextParent.IconImage.Visible == true then
1161 | 				return numberSpinner.Frame.AbsoluteSize.X + label.Parent.Parent.IconImage.AbsoluteSize.X
1162 | 			else
1163 | 				return nextParent.AbsoluteSize.X
1164 | 			end
1165 | 		end
1166 | 		local function getNumberSpinnerXSize()
1167 | 			return numberSpinner.Frame.AbsoluteSize.X
1168 | 		end
1169 | 
1170 | 		local function adjustSize()
1171 | 			local totalDigitXSize, numOfDigits = getSpinnerSizeAndDigitCount()
1172 | 			if numOfDigits < 18 then
1173 | 				self:setLabel(numberSpinner.Value)
1174 | 			end
1175 | 
1176 | 			local NumberSpinnerXSize = getNumberSpinnerXSize()
1177 | 
1178 | 			while totalDigitXSize < NumberSpinnerXSize and self.isDestroyed ~= true do
1179 | 				task.wait(0.05)
1180 | 				if numOfDigits > minDigits and numOfDigits < maxDigits then
1181 | 					numberSpinner.TextSize = label.TextSize
1182 | 					break
1183 | 				else
1184 | 					numberSpinner.TextSize += 1
1185 | 				end
1186 | 
1187 | 				NumberSpinnerXSize = getNumberSpinnerXSize()
1188 | 				totalDigitXSize, numOfDigits = getSpinnerSizeAndDigitCount()
1189 | 			end
1190 | 
1191 | 			local labelParentContainerXSize = getLabelParentContainerXSize()
1192 | 			while totalDigitXSize > labelParentContainerXSize and self.isDestroyed ~= true do
1193 | 				task.wait(0.05)
1194 | 				if numOfDigits < maxDigits and numOfDigits > minDigits then
1195 | 					numberSpinner.TextSize = label.TextSize
1196 | 					break
1197 | 				else
1198 | 					numberSpinner.TextSize -= 1
1199 | 				end
1200 | 
1201 | 				labelParentContainerXSize = getLabelParentContainerXSize()
1202 | 				totalDigitXSize, numOfDigits = getSpinnerSizeAndDigitCount()
1203 | 			end
1204 | 		end
1205 | 
1206 | 		self:addToJanitor(numberSpinner.Frame.ChildAdded:Connect(adjustSize))
1207 | 		self:addToJanitor(numberSpinner.Frame.ChildRemoved:Connect(adjustSize))
1208 | 		self:addToJanitor(self.iconAdded:Connect(function()
1209 | 			task.wait(1)
1210 | 			adjustSize()
1211 | 		end))
1212 | 
1213 | 		self:updateParent()
1214 | 
1215 | 		-- This corrects text to the size of a normal label
1216 | 		numberSpinner.Name = "LabelSpinner"
1217 | 		numberSpinner.Prefix = "$"
1218 | 		numberSpinner.Commas = true
1219 | 		numberSpinner.Decimals = 0
1220 | 		numberSpinner.Duration = 0.25
1221 | 		numberSpinner.Value = 10
1222 | 		task.wait(0.2)
1223 | 		
1224 | 		if typeof(callback) == "function" then
1225 | 			callback()
1226 | 		end
1227 | 		
1228 | 	end)
1229 | 	return self
1230 | end
1231 | 
1232 | 
1233 | 
1234 | -- DESTROY/CLEANUP
1235 | function Icon:destroy()
1236 | 	if self.isDestroyed then
1237 | 		return
1238 | 	end
1239 | 	self:clearNotices()
1240 | 	if self.parentIconUID then
1241 | 		self:leave()
1242 | 	end
1243 | 	self.isDestroyed = true
1244 | 	self.janitor:clean()
1245 | 	Icon.iconRemoved:Fire(self)
1246 | end
1247 | Icon.Destroy = Icon.destroy
1248 | 
1249 | return Icon :: Types.StaticIcon
```
</details>

## ğŸŒ™ `Packages/_Index/1foreverhd_topbarplus@3.4.0/topbarplus/src/Packages/GoodSignal.lua`
<details>
<summary>View Source (181 lines)</summary>

```lua
   1 | --------------------------------------------------------------------------------
   2 | --               Batched Yield-Safe Signal Implementation                     --
   3 | -- This is a Signal class which has effectively identical behavior to a       --
   4 | -- normal RBXScriptSignal, with the only difference being a couple extra      --
   5 | -- stack frames at the bottom of the stack trace when an error is thrown.     --
   6 | -- This implementation caches runner coroutines, so the ability to yield in   --
   7 | -- the signal handlers comes at minimal extra cost over a naive signal        --
   8 | -- implementation that either always or never spawns a thread.                --
   9 | --                                                                            --
  10 | -- API:                                                                       --
  11 | --   local Signal = require(THIS MODULE)                                      --
  12 | --   local sig = Signal.new()                                                 --
  13 | --   local connection = sig:Connect(function(arg1, arg2, ...) ... end)        --
  14 | --   sig:Fire(arg1, arg2, ...)                                                --
  15 | --   connection:Disconnect()                                                  --
  16 | --   sig:DisconnectAll()                                                      --
  17 | --   local arg1, arg2, ... = sig:Wait()                                       --
  18 | --                                                                            --
  19 | -- Licence:                                                                   --
  20 | --   Licenced under the MIT licence.                                          --
  21 | --                                                                            --
  22 | -- Authors:                                                                   --
  23 | --   stravant - July 31st, 2021 - Created the file.                           --
  24 | --------------------------------------------------------------------------------
  25 | 
  26 | -- The currently idle thread to run the next handler on
  27 | local freeRunnerThread = nil
  28 | 
  29 | -- Function which acquires the currently idle handler runner thread, runs the
  30 | -- function fn on it, and then releases the thread, returning it to being the
  31 | -- currently idle one.
  32 | -- If there was a currently idle runner thread already, that's okay, that old
  33 | -- one will just get thrown and eventually GCed.
  34 | local function acquireRunnerThreadAndCallEventHandler(fn, ...)
  35 | 	local acquiredRunnerThread = freeRunnerThread
  36 | 	freeRunnerThread = nil
  37 | 	fn(...)
  38 | 	-- The handler finished running, this runner thread is free again.
  39 | 	freeRunnerThread = acquiredRunnerThread
  40 | end
  41 | 
  42 | -- Coroutine runner that we create coroutines of. The coroutine can be 
  43 | -- repeatedly resumed with functions to run followed by the argument to run
  44 | -- them with.
  45 | local function runEventHandlerInFreeThread()
  46 | 	-- Note: We cannot use the initial set of arguments passed to
  47 | 	-- runEventHandlerInFreeThread for a call to the handler, because those
  48 | 	-- arguments would stay on the stack for the duration of the thread's
  49 | 	-- existence, temporarily leaking references. Without access to raw bytecode
  50 | 	-- there's no way for us to clear the "..." references from the stack.
  51 | 	while true do
  52 | 		acquireRunnerThreadAndCallEventHandler(coroutine.yield())
  53 | 	end
  54 | end
  55 | 
  56 | -- Connection class
  57 | local Connection = {}
  58 | Connection.__index = Connection
  59 | 
  60 | function Connection.new(signal, fn)
  61 | 	return setmetatable({
  62 | 		_connected = true,
  63 | 		_signal = signal,
  64 | 		_fn = fn,
  65 | 		_next = false,
  66 | 	}, Connection)
  67 | end
  68 | 
  69 | function Connection:Disconnect()
  70 | 	self._connected = false
  71 | 
  72 | 	-- Unhook the node, but DON'T clear it. That way any fire calls that are
  73 | 	-- currently sitting on this node will be able to iterate forwards off of
  74 | 	-- it, but any subsequent fire calls will not hit it, and it will be GCed
  75 | 	-- when no more fire calls are sitting on it.
  76 | 	if self._signal._handlerListHead == self then
  77 | 		self._signal._handlerListHead = self._next
  78 | 	else
  79 | 		local prev = self._signal._handlerListHead
  80 | 		while prev and prev._next ~= self do
  81 | 			prev = prev._next
  82 | 		end
  83 | 		if prev then
  84 | 			prev._next = self._next
  85 | 		end
  86 | 	end
  87 | end
  88 | Connection.Destroy = Connection.Disconnect
  89 | 
  90 | -- Make Connection strict
  91 | setmetatable(Connection, {
  92 | 	__index = function(tb, key)
  93 | 		error(("Attempt to get Connection::%s (not a valid member)"):format(tostring(key)), 2)
  94 | 	end,
  95 | 	__newindex = function(tb, key, value)
  96 | 		error(("Attempt to set Connection::%s (not a valid member)"):format(tostring(key)), 2)
  97 | 	end
  98 | })
  99 | 
 100 | -- Signal class
 101 | local Signal = {}
 102 | Signal.__index = Signal
 103 | 
 104 | function Signal.new()
 105 | 	return setmetatable({
 106 | 		_handlerListHead = false,
 107 | 	}, Signal)
 108 | end
 109 | 
 110 | function Signal:Connect(fn)
 111 | 	local connection = Connection.new(self, fn)
 112 | 	if self._handlerListHead then
 113 | 		connection._next = self._handlerListHead
 114 | 		self._handlerListHead = connection
 115 | 	else
 116 | 		self._handlerListHead = connection
 117 | 	end
 118 | 	return connection
 119 | end
 120 | 
 121 | -- Disconnect all handlers. Since we use a linked list it suffices to clear the
 122 | -- reference to the head handler.
 123 | function Signal:DisconnectAll()
 124 | 	self._handlerListHead = false
 125 | end
 126 | Signal.Destroy = Signal.DisconnectAll
 127 | 
 128 | -- Signal:Fire(...) implemented by running the handler functions on the
 129 | -- coRunnerThread, and any time the resulting thread yielded without returning
 130 | -- to us, that means that it yielded to the Roblox scheduler and has been taken
 131 | -- over by Roblox scheduling, meaning we have to make a new coroutine runner.
 132 | function Signal:Fire(...)
 133 | 	local item = self._handlerListHead
 134 | 	while item do
 135 | 		if item._connected then
 136 | 			if not freeRunnerThread then
 137 | 				freeRunnerThread = coroutine.create(runEventHandlerInFreeThread)
 138 | 				-- Get the freeRunnerThread to the first yield
 139 | 				coroutine.resume(freeRunnerThread)
 140 | 			end
 141 | 			task.spawn(freeRunnerThread, item._fn, ...)
 142 | 		end
 143 | 		item = item._next
 144 | 	end
 145 | end
 146 | 
 147 | -- Implement Signal:Wait() in terms of a temporary connection using
 148 | -- a Signal:Connect() which disconnects itself.
 149 | function Signal:Wait()
 150 | 	local waitingCoroutine = coroutine.running()
 151 | 	local cn;
 152 | 	cn = self:Connect(function(...)
 153 | 		cn:Disconnect()
 154 | 		task.spawn(waitingCoroutine, ...)
 155 | 	end)
 156 | 	return coroutine.yield()
 157 | end
 158 | 
 159 | -- Implement Signal:Once() in terms of a connection which disconnects
 160 | -- itself before running the handler.
 161 | function Signal:Once(fn)
 162 | 	local cn;
 163 | 	cn = self:Connect(function(...)
 164 | 		if cn._connected then
 165 | 			cn:Disconnect()
 166 | 		end
 167 | 		fn(...)
 168 | 	end)
 169 | 	return cn
 170 | end
 171 | 
 172 | -- Make signal strict
 173 | setmetatable(Signal, {
 174 | 	__index = function(tb, key)
 175 | 		error(("Attempt to get Signal::%s (not a valid member)"):format(tostring(key)), 2)
 176 | 	end,
 177 | 	__newindex = function(tb, key, value)
 178 | 		error(("Attempt to set Signal::%s (not a valid member)"):format(tostring(key)), 2)
 179 | 	end
 180 | })
 181 | 
 182 | return Signal
```
</details>

## ğŸŒ™ `Packages/_Index/1foreverhd_topbarplus@3.4.0/topbarplus/src/Packages/Janitor.lua`
<details>
<summary>View Source (321 lines)</summary>

```lua
   1 | --[[
   2 | -------------------------------------
   3 | This package was modified by ForeverHD.
   4 | 
   5 | PACKAGE MODIFICATIONS:
   6 | 	1. Added pascalCase aliases for all methods
   7 | 	2. Modified behaviour of :add so that it takes both objects and promises (previously only objects)
   8 | 	3. Slight change to how promises are tracked
   9 | 	4. Added isAnInstanceBeingDestroyed check to line 228
  10 | 	5. Added 'OriginalTraceback' to help determine where an error was added to the janitor
  11 | 	6. Likely some additional changes which weren't record here
  12 | 	7. Removed comments as these were detected by Moonwave
  13 | -------------------------------------
  14 | --]]
  15 | 
  16 | 
  17 | 
  18 | -- Janitor
  19 | -- Original by Validark
  20 | -- Modifications by pobammer
  21 | -- roblox-ts support by OverHash and Validark
  22 | -- LinkToInstance fixed by Elttob.
  23 | 
  24 | local RunService = game:GetService("RunService")
  25 | local Heartbeat = RunService.Heartbeat
  26 | local function getPromiseReference()
  27 | 	return false
  28 | end
  29 | 
  30 | local IndicesReference = newproxy(true)
  31 | getmetatable(IndicesReference).__tostring = function()
  32 | 	return "IndicesReference"
  33 | end
  34 | 
  35 | local LinkToInstanceIndex = newproxy(true)
  36 | getmetatable(LinkToInstanceIndex).__tostring = function()
  37 | 	return "LinkToInstanceIndex"
  38 | end
  39 | 
  40 | local METHOD_NOT_FOUND_ERROR = "Object %s doesn't have method %s, are you sure you want to add it? Traceback: %s"
  41 | local NOT_A_PROMISE = "Invalid argument #1 to 'Janitor:AddPromise' (Promise expected, got %s (%s))"
  42 | 
  43 | local Janitor = {
  44 | 	IGNORE_MEMORY_DEBUG = true,
  45 | 	ClassName = "Janitor";
  46 | 	__index = {
  47 | 		CurrentlyCleaning = true;
  48 | 		[IndicesReference] = nil;
  49 | 	};
  50 | }
  51 | 
  52 | local TypeDefaults = {
  53 | 	["function"] = true;
  54 | 	["Promise"] = "cancel";
  55 | 	RBXScriptConnection = "Disconnect";
  56 | }
  57 | 
  58 | function Janitor.new()
  59 | 	return setmetatable({
  60 | 		CurrentlyCleaning = false;
  61 | 		[IndicesReference] = nil;
  62 | 	}, Janitor)
  63 | end
  64 | 
  65 | function Janitor.Is(Object)
  66 | 	return type(Object) == "table" and getmetatable(Object) == Janitor
  67 | end
  68 | 
  69 | Janitor.is = Janitor.Is
  70 | 
  71 | function Janitor.__index:Add(Object, MethodName, Index)
  72 | 	if Index then
  73 | 		self:Remove(Index)
  74 | 
  75 | 		local This = self[IndicesReference]
  76 | 		if not This then
  77 | 			This = {}
  78 | 			self[IndicesReference] = This
  79 | 		end
  80 | 
  81 | 		This[Index] = Object
  82 | 	end
  83 | 
  84 | 	local objectType = typeof(Object)
  85 | 	if objectType == "table" and string.match(tostring(Object), "Promise") then
  86 | 		objectType = "Promise"
  87 | 		--local status = Object:getStatus()
  88 | 		--print("status =", status, status == "Rejected")
  89 | 	end
  90 | 	MethodName = MethodName or TypeDefaults[objectType] or "Destroy"
  91 | 	if type(Object) ~= "function" and not Object[MethodName] then
  92 | 		warn(string.format(METHOD_NOT_FOUND_ERROR, tostring(Object), tostring(MethodName), debug.traceback(nil :: any, 2)))
  93 | 	end
  94 | 
  95 | 	local OriginalTraceback = debug.traceback("")
  96 | 	self[Object] = {MethodName, OriginalTraceback}
  97 | 	return Object
  98 | end
  99 | Janitor.__index.Give = Janitor.__index.Add
 100 | 
 101 | -- My version of Promise has PascalCase, but I converted it to use lowerCamelCase for this release since obviously that's important to do.
 102 | 
 103 | function Janitor.__index:AddPromise(PromiseObject)
 104 | 	local Promise = getPromiseReference()
 105 | 	if Promise then
 106 | 		if not Promise.is(PromiseObject) then
 107 | 			error(string.format(NOT_A_PROMISE, typeof(PromiseObject), tostring(PromiseObject)))
 108 | 		end
 109 | 		if PromiseObject:getStatus() == Promise.Status.Started then
 110 | 			local Id = newproxy(false)
 111 | 			local NewPromise = self:Add(Promise.new(function(Resolve, _, OnCancel)
 112 | 				if OnCancel(function()
 113 | 						PromiseObject:cancel()
 114 | 					end) then
 115 | 					return
 116 | 				end
 117 | 
 118 | 				Resolve(PromiseObject)
 119 | 			end), "cancel", Id)
 120 | 
 121 | 			NewPromise:finallyCall(self.Remove, self, Id)
 122 | 			return NewPromise
 123 | 		else
 124 | 			return PromiseObject
 125 | 		end
 126 | 	else
 127 | 		return PromiseObject
 128 | 	end
 129 | end
 130 | Janitor.__index.GivePromise = Janitor.__index.AddPromise
 131 | 
 132 | -- This will assume whether or not the object is a Promise or a regular object.
 133 | function Janitor.__index:AddObject(Object)
 134 | 	local Id = newproxy(false)
 135 | 	local Promise = getPromiseReference()
 136 | 	if Promise and Promise.is(Object) then
 137 | 		if Object:getStatus() == Promise.Status.Started then
 138 | 			local NewPromise = self:Add(Promise.resolve(Object), "cancel", Id)
 139 | 			NewPromise:finallyCall(self.Remove, self, Id)
 140 | 			return NewPromise, Id
 141 | 		else
 142 | 			return Object
 143 | 		end
 144 | 	else
 145 | 		return self:Add(Object, false, Id), Id
 146 | 	end
 147 | end
 148 | 
 149 | Janitor.__index.GiveObject = Janitor.__index.AddObject
 150 | 
 151 | function Janitor.__index:Remove(Index)
 152 | 	local This = self[IndicesReference]
 153 | 	if This then
 154 | 		local Object = This[Index]
 155 | 
 156 | 		if Object then
 157 | 			local ObjectDetail = self[Object]
 158 | 			local MethodName = ObjectDetail and ObjectDetail[1]
 159 | 
 160 | 			if MethodName then
 161 | 				if MethodName == true then
 162 | 					Object()
 163 | 				else
 164 | 					local ObjectMethod = Object[MethodName]
 165 | 					if ObjectMethod then
 166 | 						ObjectMethod(Object)
 167 | 					end
 168 | 				end
 169 | 
 170 | 				self[Object] = nil
 171 | 			end
 172 | 
 173 | 			This[Index] = nil
 174 | 		end
 175 | 	end
 176 | 
 177 | 	return self
 178 | end
 179 | 
 180 | function Janitor.__index:Get(Index)
 181 | 	local This = self[IndicesReference]
 182 | 	if This then
 183 | 		return This[Index]
 184 | 	end
 185 | 	return nil
 186 | end
 187 | 
 188 | function Janitor.__index:Cleanup()
 189 | 	if not self.CurrentlyCleaning then
 190 | 		self.CurrentlyCleaning = nil
 191 | 		for Object, ObjectDetail in next, self do
 192 | 			if Object == IndicesReference then
 193 | 				continue
 194 | 			end
 195 | 
 196 | 			-- Weird decision to rawset directly to the janitor in Agent. This should protect against it though.
 197 | 			local TypeOf = type(Object)
 198 | 			if TypeOf == "string" or TypeOf == "number" then
 199 | 				self[Object] = nil
 200 | 				continue
 201 | 			end
 202 | 
 203 | 			local MethodName = ObjectDetail[1]
 204 | 			local OriginalTraceback = ObjectDetail[2]
 205 | 			local function warnUser(warning)
 206 | 				local cleanupLine = debug.traceback("", 3)--string.gsub(debug.traceback("", 3), "%c", "")
 207 | 				local addedLine = OriginalTraceback
 208 | 				warn("-------- Janitor Error --------".."\n"..tostring(warning).."\n"..cleanupLine..""..addedLine)
 209 | 			end
 210 | 			if MethodName == true then
 211 | 				local success, warning = pcall(Object)
 212 | 				if not success then
 213 | 					warnUser(warning)
 214 | 				end
 215 | 			else
 216 | 				local ObjectMethod = Object[MethodName]
 217 | 				if ObjectMethod then
 218 | 					local success, warning = pcall(ObjectMethod, Object)
 219 | 					local isAnInstanceBeingDestroyed = typeof(Object) == "Instance" and ObjectMethod == "Destroy"
 220 | 					if not success and not isAnInstanceBeingDestroyed then
 221 | 						warnUser(warning)
 222 | 					end
 223 | 				end
 224 | 			end
 225 | 
 226 | 			self[Object] = nil
 227 | 		end
 228 | 
 229 | 		local This = self[IndicesReference]
 230 | 		if This then
 231 | 			for Index in next, This do
 232 | 				This[Index] = nil
 233 | 			end
 234 | 
 235 | 			self[IndicesReference] = {}
 236 | 		end
 237 | 
 238 | 		self.CurrentlyCleaning = false
 239 | 	end
 240 | end
 241 | 
 242 | Janitor.__index.Clean = Janitor.__index.Cleanup
 243 | 
 244 | function Janitor.__index:Destroy()
 245 | 	self:Cleanup()
 246 | 	--table.clear(self)
 247 | 	--setmetatable(self, nil)
 248 | end
 249 | 
 250 | Janitor.__call = Janitor.__index.Cleanup
 251 | 
 252 | local Disconnect = {Connected = true}
 253 | Disconnect.__index = Disconnect
 254 | function Disconnect:Disconnect()
 255 | 	if self.Connected then
 256 | 		self.Connected = false
 257 | 		self.Connection:Disconnect()
 258 | 	end
 259 | end
 260 | 
 261 | function Disconnect:__tostring()
 262 | 	return "Disconnect<" .. tostring(self.Connected) .. ">"
 263 | end
 264 | 
 265 | function Janitor.__index:LinkToInstance(Object, AllowMultiple)
 266 | 	local Connection
 267 | 	local IndexToUse = AllowMultiple and newproxy(false) or LinkToInstanceIndex
 268 | 	local IsNilParented = Object.Parent == nil
 269 | 	local ManualDisconnect = setmetatable({}, Disconnect)
 270 | 
 271 | 	local function ChangedFunction(_DoNotUse, NewParent)
 272 | 		if ManualDisconnect.Connected then
 273 | 			_DoNotUse = nil
 274 | 			IsNilParented = NewParent == nil
 275 | 
 276 | 			if IsNilParented then
 277 | 				coroutine.wrap(function()
 278 | 					Heartbeat:Wait()
 279 | 					if not ManualDisconnect.Connected then
 280 | 						return
 281 | 					elseif not Connection.Connected then
 282 | 						self:Cleanup()
 283 | 					else
 284 | 						while IsNilParented and Connection.Connected and ManualDisconnect.Connected do
 285 | 							Heartbeat:Wait()
 286 | 						end
 287 | 
 288 | 						if ManualDisconnect.Connected and IsNilParented then
 289 | 							self:Cleanup()
 290 | 						end
 291 | 					end
 292 | 				end)()
 293 | 			end
 294 | 		end
 295 | 	end
 296 | 
 297 | 	Connection = Object.AncestryChanged:Connect(ChangedFunction)
 298 | 	ManualDisconnect.Connection = Connection
 299 | 
 300 | 	if IsNilParented then
 301 | 		ChangedFunction(nil, Object.Parent)
 302 | 	end
 303 | 
 304 | 	Object = nil
 305 | 	return self:Add(ManualDisconnect, "Disconnect", IndexToUse)
 306 | end
 307 | 
 308 | function Janitor.__index:LinkToInstances(...)
 309 | 	local ManualCleanup = Janitor.new()
 310 | 	for _, Object in ipairs({...}) do
 311 | 		ManualCleanup:Add(self:LinkToInstance(Object, true), "Disconnect")
 312 | 	end
 313 | 
 314 | 	return ManualCleanup
 315 | end
 316 | 
 317 | for FunctionName, Function in next, Janitor.__index do
 318 | 	local NewFunctionName = string.sub(string.lower(FunctionName), 1, 1) .. string.sub(FunctionName, 2)
 319 | 	Janitor.__index[NewFunctionName] = Function
 320 | end
 321 | 
 322 | return Janitor
```
</details>

## ğŸŒ™ `Packages/_Index/1foreverhd_topbarplus@3.4.0/topbarplus/src/Reference.lua`
<details>
<summary>View Source (29 lines)</summary>

```lua
   1 | -- This module enables you to place Icon wherever you like within the data model while
   2 | -- still enabling third-party applications (such as HDAdmin/Nanoblox) to locate it
   3 | -- This is necessary to prevent two TopbarPlus applications initiating at runtime which would
   4 | -- cause icons to overlap with each other
   5 | 
   6 | local replicatedStorage = game:GetService("ReplicatedStorage")
   7 | local Reference = {}
   8 | Reference.objectName = "TopbarPlusReference"
   9 | 
  10 | function Reference.addToReplicatedStorage()
  11 | 	local existingItem = replicatedStorage:FindFirstChild(Reference.objectName)
  12 |     if existingItem then
  13 |         return false
  14 |     end
  15 |     local objectValue = Instance.new("ObjectValue")
  16 | 	objectValue.Name = Reference.objectName
  17 |     objectValue.Value = script.Parent
  18 |     objectValue.Parent = replicatedStorage
  19 |     return objectValue
  20 | end
  21 | 
  22 | function Reference.getObject()
  23 | 	local objectValue = replicatedStorage:FindFirstChild(Reference.objectName)
  24 |     if objectValue then
  25 |         return objectValue
  26 |     end
  27 |     return false
  28 | end
  29 | 
  30 | return Reference
```
</details>

## ğŸŒ™ `Packages/_Index/1foreverhd_topbarplus@3.4.0/topbarplus/src/Types.lua`
<details>
<summary>View Source (476 lines)</summary>

```lua
   1 | --!strict
   2 | 
   3 | -- GoodSignal Types (...but simpler!)
   4 | 
   5 | --- Connection
   6 | 
   7 | type Connection<Variant... = ...any> = {
   8 | 	Disconnect: (self: Connection<Variant...>) -> (),
   9 | }
  10 | 
  11 | --- Signal
  12 | 
  13 | type Signal<Variant... = ...any> = {
  14 | 	Connect: (self: Signal<Variant...>, func: (Variant...) -> ()) -> Connection<Variant...>,
  15 |     Once: (self: Signal<Variant...>, func: (Variant...) -> ()) -> Connection<Variant...>,
  16 | 	Wait: (self: Signal<Variant...>) -> Variant...,
  17 | }
  18 | 
  19 | ----------------------
  20 | 
  21 | export type IconState = "Deselected" | "Selected" | "Viewing"
  22 | export type Events = "selected" | "deselected" | "toggled" | "viewingStarted" | "viewingEnded" | "notified"
  23 | export type Alignment = "Left" | "Center" | "Right"
  24 | export type EventSource = "User" | "OneClick" | "AutoDeselect" | "HideParentFeature" | "Overflow"
  25 | export type Modification = { any }
  26 | 
  27 | 
  28 | type StaticFunctions = {
  29 | 	getIcons: typeof(
  30 | 		--[[
  31 | 			Returns a dictionary of icons where the key is the icon's UID and value the icon.
  32 | 		]]
  33 | 		function(): { Icon }
  34 | 			return (nil :: any) :: { Icon }
  35 | 		end
  36 | 	),
  37 | 	getIcon: typeof(
  38 | 		--[[
  39 | 			Returns an icon of the given name or UID.
  40 | 		]]
  41 | 		function(nameOrUID: string): Icon?
  42 | 			return nil :: any
  43 | 		end
  44 | 	),
  45 | 	setTopbarEnabled: typeof(
  46 | 		--[[
  47 | 			When set to <code>false</code> all TopbarPlus ScreenGuis are hidden.
  48 | 			This does not impact Roblox's Topbar.
  49 | 		]]
  50 | 		function(enabled: boolean)
  51 | 
  52 | 		end
  53 | 	),
  54 | 	modifyBaseTheme: typeof(
  55 | 		--[[
  56 | 			Updates the appearance of all icons.
  57 | 		]]
  58 | 		function(modifications: { Modification })
  59 | 
  60 | 		end
  61 | 	),
  62 | 	setDisplayOrder: typeof(
  63 | 		--[[
  64 | 			Sets the base DisplayOrder of all TopbarPlus ScreenGuis.
  65 | 		]]
  66 | 		function(order: number)
  67 | 
  68 | 		end
  69 | 	),
  70 | }
  71 | 
  72 | type Methods = {
  73 | 	
  74 | 	-- CLASS FUNCTIONS
  75 | 	setName: typeof(
  76 | 		--[[
  77 | 			Sets the name of the Widget instance. This can be used in conjunction with <code>Icon.getIcon(name)</code>
  78 | 		]]
  79 | 		function(self: Icon, name: string): Icon
  80 | 			return nil :: any
  81 | 		end
  82 | 	),
  83 | 	getInstance: typeof(
  84 | 		--[[
  85 | 			Returns the first descendant found within the widget of name <code>instanceName</code>.
  86 | 		]]
  87 | 		function(self: Icon, instanceName: string): Instance?
  88 | 			return (nil :: any) :: Instance?
  89 | 		end
  90 | 	),
  91 | 	modifyTheme: typeof(
  92 | 		--[[
  93 | 			Updates the appearance of the icon.
  94 | 		]]
  95 | 		function(self: Icon, modifications: {Modification} | Modification): Icon
  96 | 			return nil :: any
  97 | 		end
  98 | 	),
  99 | 	modifyChildTheme: typeof(
 100 | 		--[[
 101 | 			Updates the appearance of all icons that are parented to this icon (for example when a menu or dropdown).
 102 | 		]]
 103 | 		function(self: Icon, modifications: { Modification }): Icon
 104 | 			return nil :: any
 105 | 		end
 106 | 	),
 107 | 	setEnabled: typeof(
 108 | 		--[[
 109 | 			When set to <code>false</code> the icon will be disabled and hidden.
 110 | 		]]
 111 | 		function(self: Icon, enabled: boolean): Icon
 112 | 			return nil :: any
 113 | 		end
 114 | 	),
 115 | 	select: typeof(
 116 | 		--[[
 117 | 			Selects the icon (as if it were clicked once).
 118 | 		]]
 119 | 		function(self: Icon): Icon
 120 | 			return nil :: any
 121 | 		end
 122 | 	),
 123 | 	deselect: typeof(
 124 | 		--[[
 125 | 			Deselects the icon (as if it were clicked, then clicked again).
 126 | 		]]
 127 | 		function(self: Icon): Icon
 128 | 			return nil :: any
 129 | 		end
 130 | 	),
 131 | 	notify: typeof(
 132 | 		--[[
 133 | 			Prompts a notice bubble which accumulates the further it is prompted.
 134 | 			If the icon belongs to a dropdown or menu, then the notice will appear on the parent icon when the parent icon is deselected.
 135 | 		]]
 136 | 		function(self: Icon, clearNoticeEvent: Signal?): Icon
 137 | 			return nil :: any
 138 | 		end
 139 | 	),
 140 | 	clearNotices: typeof(
 141 | 		--[[
 142 | 			
 143 | 		]]
 144 | 		function(self: Icon): Icon
 145 | 			return nil :: any
 146 | 		end
 147 | 	),
 148 | 	disableOverlay: typeof(
 149 | 		--[[
 150 | 			When set to <code>true</code>, disables the shade effect which appears when the icon is pressed and released.
 151 | 		]]
 152 | 		function(self: Icon, disabled: boolean): Icon
 153 | 			return nil :: any
 154 | 		end
 155 | 	),
 156 | 	setImage: typeof(
 157 | 		--[[
 158 | 			Applies an image to the icon based on the given <code>imageId</code>. <code>imageId</code> can be an assetId or a complete asset string.
 159 | 		]]
 160 | 		function(self: Icon, imageId: string | number, iconState: IconState?): Icon
 161 | 			return nil :: any
 162 | 		end
 163 | 	),
 164 | 	setLabel: typeof(
 165 | 		--[[
 166 | 			
 167 | 		]]
 168 | 		function(self: Icon, text: string, iconState: IconState?): Icon
 169 | 			return nil :: any
 170 | 		end
 171 | 	),
 172 | 	setOrder: typeof(
 173 | 		--[[
 174 | 			
 175 | 		]]
 176 | 		function(self: Icon, order: number, iconState: IconState?): Icon
 177 | 			return nil :: any
 178 | 		end
 179 | 	),
 180 | 	setCornerRadius: typeof(
 181 | 		--[[
 182 | 			
 183 | 		]]
 184 | 		function(self: Icon, udim: UDim2, iconState: IconState?): Icon
 185 | 			return nil :: any
 186 | 		end
 187 | 	),
 188 | 	align: typeof(
 189 | 		--[[
 190 | 			This enables you to set the icon to the <code>"Left"</code> (default), <code>"Center"</code> or <code>"Right"</code> side of the screen.
 191 | 		]]
 192 | 		function(self: Icon, alignment: Alignment?): Icon
 193 | 			return nil :: any
 194 | 		end
 195 | 	),
 196 | 	setWidth: typeof(
 197 | 		--[[
 198 | 			This sets the minimum width the icon can be (it can be larger for instance when setting a long label). The default width is <code>44</code>.
 199 | 		]]
 200 | 		function(self: Icon, minimumSize: number, iconState: IconState?): Icon
 201 | 			return nil :: any
 202 | 		end
 203 | 	),
 204 | 	setImageScale: typeof(
 205 | 		--[[
 206 | 			How large the image is relative to the icon. The default value is <code>0.5</code>.
 207 | 		]]
 208 | 		function(self: Icon, scale: number, iconState: IconState?): Icon
 209 | 			return nil :: any
 210 | 		end
 211 | 	),
 212 | 	setImageRatio: typeof(
 213 | 		--[[
 214 | 			How stretched the image will appear. The default value is <code>1</code> (a perfect square).
 215 | 		]]
 216 | 		function(self: Icon, ratio: number, iconState: IconState?): Icon
 217 | 			return nil :: any
 218 | 		end
 219 | 	),
 220 | 	setTextSize: typeof(
 221 | 		--[[
 222 | 			The size of the icon labels' text. The default value is <code>16</code>.
 223 | 		]]
 224 | 		function(self: Icon, textSize: number, iconState: IconState?): Icon
 225 | 			return nil :: any
 226 | 		end
 227 | 	),
 228 | 	setTextColor: typeof(
 229 | 		--[[
 230 | 			The color of the icon labels' text
 231 | 		]]
 232 | 		function(self: Icon, color: Color3, iconState: IconState?): Icon
 233 | 			return nil :: any
 234 | 		end
 235 | 	),
 236 | 	setTextFont: typeof(
 237 | 		--[[
 238 | 			Sets the labels FontFace.
 239 | 			<code>font</code> can be a font family name (such as <code>"Creepster"</code>),
 240 | 			a font enum (such as <code>Enum.Font.Bangers</code>),
 241 | 			a font ID (such as <code>12187370928</code>),
 242 | 			or font family link (such as <code>"rbxasset://fonts/families/Sarpanch.json"</code>).
 243 | 		]]
 244 | 		function(self: Icon, font: string | Enum.Font, fontWeight: Enum.FontWeight?, fontStyle: Enum.FontSize?, iconState: IconState?): Icon
 245 | 			return nil :: any
 246 | 		end
 247 | 	),
 248 | 	bindToggleItem: typeof(
 249 | 		--[[
 250 | 			Binds a GuiObject or LayerCollector to appear and disappeared when the icon is toggled.
 251 | 		]]
 252 | 		function(self: Icon, guiObjectOrLayerCollector: GuiObject | LayerCollector): Icon
 253 | 			return nil :: any
 254 | 		end
 255 | 	),
 256 | 	unbindToggleItem: typeof(
 257 | 		--[[
 258 | 			Unbinds the given GuiObject or LayerCollector from the toggle.
 259 | 		]]
 260 | 		function(self: Icon, guiObjectOrLayerCollector: GuiObject | LayerCollector): Icon
 261 | 			return nil :: any
 262 | 		end
 263 | 	),
 264 | 	bindEvent: typeof(
 265 | 		--[[
 266 | 			Connects to an icon event with <code>iconEventName</code>.
 267 | 			It's important to remember all event names are in <code>camelCase</code>.
 268 | 			<code>callback</code> is called with arguments <code>(self, ...)</code> when the event is triggered.
 269 | 		]]
 270 | 		function(self: Icon, event: Events, callback: (...any) -> ()): Icon
 271 | 			return nil :: any
 272 | 		end
 273 | 	),
 274 | 	unbindEvent: typeof(
 275 | 		--[[
 276 | 			Unbinds the connection of the associated <code>iconEventName</code>.
 277 | 		]]
 278 | 		function(self: Icon, event: Events): Icon
 279 | 			return nil :: any
 280 | 		end
 281 | 	),
 282 | 	bindToggleKey: typeof(
 283 | 		--[[
 284 | 			Binds a keycode which toggles the icon when pressed.
 285 | 		]]
 286 | 		function(self: Icon, keycode: Enum.KeyCode): Icon
 287 | 			return nil :: any
 288 | 		end
 289 | 	),
 290 | 	unbindToggleKey: typeof(
 291 | 		--[[
 292 | 			Unbinds the given keycode.
 293 | 		]]
 294 | 		function(self: Icon, keycode: Enum.KeyCode): Icon
 295 | 			return nil :: any
 296 | 		end
 297 | 	),
 298 | 	call: typeof(
 299 | 		--[[
 300 | 			Calls the function immediately via <code>task.spawn</code>.
 301 | 			The first argument passed is the icon itself.
 302 | 			This is useful when needing to extend the behaviour of an icon while remaining in the chain.
 303 | 		]]
 304 | 		function(self: Icon, func: (self: Icon) -> (...any), ...: any): Icon
 305 | 			return nil :: any
 306 | 		end
 307 | 	),
 308 | 	addToJanitor: typeof(
 309 | 		--[[
 310 | 			Passes the given userdata to the icons janitor to be destroyed/disconnected on the icons destruction.
 311 | 			If a function is passed, it will be called when the icon is destroyed.
 312 | 		]]
 313 | 		function(self: Icon, userdata: unknown): Icon
 314 | 			return nil :: any
 315 | 		end
 316 | 	),
 317 | 	lock: typeof(
 318 | 		--[[
 319 | 			Prevents the icon being toggled by user-input (such as clicking), however, the icon can still be toggled via localscript using methods such as <code>icon:select()</code>.
 320 | 		]]
 321 | 		function(self: Icon): Icon
 322 | 			return nil :: any
 323 | 		end
 324 | 	),
 325 | 	unlock: typeof(
 326 | 		--[[
 327 | 			Re-enables user-input to toggle the icon again.
 328 | 		]]
 329 | 		function(self: Icon): Icon
 330 | 			return nil :: any
 331 | 		end
 332 | 	),
 333 | 	debounce: typeof(
 334 | 		--[[
 335 | 			Locks the icon, yields for the given time, then unlocks the icon, effectively shorthand for <code>icon:lock() task.wait(seconds) icon:unlock()</code>.
 336 | 			This is useful for applying cooldowns (to prevent an icon from being pressed again) after an icon has been selected or deselected.
 337 | 		]]
 338 | 		function(self: Icon, seconds: number): Icon
 339 | 			return nil :: any
 340 | 		end
 341 | 	),
 342 | 	autoDeselect: typeof(
 343 | 		--[[
 344 | 			When set to <code>true</code> (the default) the icon is deselected when another icon (with autoDeselect enabled) is pressed.
 345 | 			Set to <code>false</code> to prevent the icon being deselected when another icon is selected (a useful behaviour in dropdowns).
 346 | 		]]
 347 | 		function(self: Icon, enabled: boolean?): Icon
 348 | 			return nil :: any
 349 | 		end
 350 | 	),
 351 | 	oneClick: typeof(
 352 | 		--[[
 353 | 			When set to true the icon will automatically deselect when selected.
 354 | 			This creates the effect of a single click button.
 355 | 		]]
 356 | 		function(self: Icon, enabled: boolean?): Icon
 357 | 			return nil :: any
 358 | 		end
 359 | 	),
 360 | 	setCaption: typeof(
 361 | 		--[[
 362 | 			Sets a caption. To remove, pass <code>nil</code> as <code>text</code>.
 363 | 		]]
 364 | 		function(self: Icon, text: string?): Icon
 365 | 			return nil :: any
 366 | 		end
 367 | 	),
 368 | 	setCaptionHint: typeof(
 369 | 		--[[
 370 | 			This customizes the appearance of the caption's hint without having to use <code>icon:bindToggleKey</code>.
 371 | 		]]
 372 | 		function(self: Icon, keyCode: Enum.KeyCode): Icon
 373 | 			return nil :: any
 374 | 		end
 375 | 	),
 376 | 	setDropdown: typeof(
 377 | 		--[[
 378 | 			Creates a vertical dropdown based upon the given table array of icons.
 379 | 			Pass an empty table <code>{}</code> to remove the dropdown.
 380 | 		]]
 381 | 		function(self: Icon, icons: { Icon }): Icon
 382 | 			return nil :: any
 383 | 		end
 384 | 	),
 385 | 	joinDropdown: typeof(
 386 | 		--[[
 387 | 			Joins the dropdown of <code>parentIcon</code>.
 388 | 			This is what <code>icon:setDropdown</code> calls internally on the icons within its array.
 389 | 		]]
 390 | 		function(self: Icon, parent: Icon): Icon
 391 | 			return nil :: any
 392 | 		end
 393 | 	),
 394 | 	setMenu: typeof(
 395 | 		--[[
 396 | 			Creates a horizontal menu based upon the given array of icons.
 397 | 			Pass an empty table <code>{}</code> to remove the menu.
 398 | 		]]
 399 | 		function(self: Icon, icons: { Icon }): Icon
 400 | 			return nil :: any
 401 | 		end
 402 | 	),
 403 | 	setFixedMenu: typeof(
 404 | 		--[[
 405 | 			Creates a menu that is always selected and has it's close button hidden.
 406 | 			Pass an empty table <code>{}</code> to remove the menu.
 407 | 		]]
 408 | 		function(self: Icon, icons: { Icon }): Icon
 409 | 			return nil :: any
 410 | 		end
 411 | 	),
 412 | 	joinMenu: typeof(
 413 | 		--[[
 414 | 			Joins the menu of <code>parentIcon</code>.
 415 | 			This is what <code>icon:setMenu</code> calls internally on the icons within its array.
 416 | 		]]
 417 | 		function(self: Icon, parentIcon: Icon): Icon
 418 | 			return nil :: any
 419 | 		end
 420 | 	),
 421 | 	leave: typeof(
 422 | 		--[[
 423 | 			Unparents an icon from a parentIcon if it belongs to a dropdown or menu.
 424 | 		]]
 425 | 		function(self: Icon): Icon
 426 | 			return nil :: any
 427 | 		end
 428 | 	),
 429 | 	convertLabelToNumberSpinner: typeof(
 430 | 		--[[
 431 | 			Unparents an icon from a parentIcon if it belongs to a dropdown or menu.
 432 | 		]]
 433 | 		function(self: Icon, numberSpinner: any, func: (...any) -> (...any), ...: any): Icon
 434 | 			return nil :: any
 435 | 		end
 436 | 	),
 437 | 	destroy: typeof(
 438 | 		--[[
 439 | 			Clears all connections and destroys all instances associated with the icon.
 440 | 		]]
 441 | 		function(self: Icon): Icon
 442 | 			return nil :: any
 443 | 		end
 444 | 	),
 445 | } & StaticFunctions
 446 | 
 447 | type Fields = {
 448 | 	-- CLASS PROPERTIES
 449 | 	name: string,
 450 | 	isSelected: boolean,
 451 | 	isEnabled: boolean,
 452 | 	totalNotices: number,
 453 | 	locked: boolean,
 454 | 
 455 | 	-- CLASS EVENTS
 456 | 	selected: Signal<EventSource>,
 457 | 	deselected: Signal<EventSource>,
 458 | 	toggled: Signal<boolean, EventSource>,
 459 | 	viewingStarted: Signal,
 460 | 	viewingEnded: Signal,
 461 | 	notified: Signal,
 462 | }
 463 | 
 464 | export type Icon = Methods & StaticFunctions --typeof(setmetatable({} :: Fields, MT))
 465 | 
 466 | export type StaticIcon = {
 467 | 	new: typeof(
 468 | 		--[[
 469 | 			Constructs an empty <code>32x32</code> icon on the topbar.
 470 | 		]]
 471 | 		function(): Icon
 472 | 			return (nil :: any) :: Icon
 473 | 		end
 474 | 	),
 475 | } & StaticFunctions
 476 | 
 477 | return {}
```
</details>

## ğŸŒ™ `Packages/_Index/1foreverhd_topbarplus@3.4.0/topbarplus/src/Utility.lua`
<details>
<summary>View Source (461 lines)</summary>

```lua
   1 | -- Just generic utility functions which I use and repeat across all my projects
   2 | 
   3 | 
   4 | 
   5 | -- LOCAL
   6 | local Utility = {}
   7 | local Players = game:GetService("Players")
   8 | local localPlayer = Players.LocalPlayer
   9 | 
  10 | 
  11 | 
  12 | -- FUNCTIONS
  13 | function Utility.createStagger(delayTime, callback, delayInitially)
  14 | 	-- This creates and returns a function which when called
  15 | 	-- acts identically to callback, however will only be called
  16 | 	-- for a maximum of once per delayTime. If the returned function
  17 | 	-- is called more than once during the delayTime, then it will
  18 | 	-- wait until the expiryTime then perform another recall.
  19 | 	-- This is useful for visual interfaces and effects which may be
  20 | 	-- triggered multiple times within a frame or short period, but which
  21 | 	-- we don't necessary need to (for performance reasons).
  22 | 	local staggerActive = false
  23 | 	local multipleCalls = false
  24 | 	if not delayTime or delayTime == 0 then
  25 | 		-- We make 0.01 instead of 0 because devices can now run at
  26 | 		-- different frame rates
  27 | 		delayTime = 0.01
  28 | 	end
  29 | 	local function staggeredCallback(...)
  30 | 		if staggerActive then
  31 | 			multipleCalls = true
  32 | 			return
  33 | 		end
  34 | 		local packedArgs = table.pack(...)
  35 | 		staggerActive = true
  36 | 		multipleCalls = false
  37 | 		task.spawn(function()
  38 | 			if delayInitially then
  39 | 				task.wait(delayTime)
  40 | 			end
  41 | 			callback(table.unpack(packedArgs))
  42 | 		end)
  43 | 		task.delay(delayTime, function()
  44 | 			staggerActive = false
  45 | 			if multipleCalls then
  46 | 				-- This means it has been called at least once during
  47 | 				-- the stagger period, so call again
  48 | 				staggeredCallback(table.unpack(packedArgs))
  49 | 			end
  50 | 		end)
  51 | 	end
  52 | 	return staggeredCallback
  53 | end
  54 | 
  55 | function Utility.round(n)
  56 | 	-- Credit to Darkmist101 for this
  57 | 	return math.floor(n + 0.5)
  58 | end
  59 | 
  60 | function Utility.reverseTable(t)
  61 | 	for i = 1, math.floor(#t/2) do
  62 | 		local j = #t - i + 1
  63 | 		t[i], t[j] = t[j], t[i]
  64 | 	end
  65 | end
  66 | 
  67 | function Utility.copyTable(t)
  68 | 	-- Credit to Stephen Leitnick (September 13, 2017) for this function from TableUtil
  69 | 	assert(type(t) == "table", "First argument must be a table")
  70 | 	local tCopy = table.create(#t)
  71 | 	for k,v in pairs(t) do
  72 | 		if (type(v) == "table") then
  73 | 			tCopy[k] = Utility.copyTable(v)
  74 | 		else
  75 | 			tCopy[k] = v
  76 | 		end
  77 | 	end
  78 | 	return tCopy
  79 | end
  80 | 
  81 | local validCharacters = {"a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","1","2","3","4","5","6","7","8","9","0","<",">","?","@","{","}","[","]","!","(",")","=","+","~","#"}
  82 | function Utility.generateUID(length)
  83 | 	length = length or 8
  84 | 	local UID = ""
  85 | 	local list = validCharacters
  86 | 	local total = #list
  87 | 	for i = 1, length do
  88 | 		local randomCharacter = list[math.random(1, total)]
  89 | 		UID = UID..randomCharacter
  90 | 	end
  91 | 	return UID
  92 | end
  93 | 
  94 | local instanceTrackers = {}
  95 | function Utility.setVisible(instance, bool, sourceUID)
  96 | 	-- This effectively works like a buff object but
  97 | 	-- incredibly simplified. It stacks false values
  98 | 	-- so that if there is more than more than, the 
  99 | 	-- instance remains hidden even if set visible true
 100 | 	local tracker = instanceTrackers[instance]
 101 | 	if not tracker then
 102 | 		tracker = {}
 103 | 		instanceTrackers[instance] = tracker
 104 | 		instance.Destroying:Once(function()
 105 | 			instanceTrackers[instance] = nil
 106 | 		end)
 107 | 	end
 108 | 	if not bool then
 109 | 		tracker[sourceUID] = true
 110 | 	else
 111 | 		tracker[sourceUID] = nil
 112 | 	end
 113 | 	local isVisible = bool
 114 | 	if bool then
 115 | 		for sourceUID, _ in pairs(tracker) do
 116 | 			isVisible = false
 117 | 			break
 118 | 		end
 119 | 	end
 120 | 	instance.Visible = isVisible
 121 | end
 122 | 
 123 | function Utility.formatStateName(incomingStateName)
 124 | 	return string.upper(string.sub(incomingStateName, 1, 1))..string.lower(string.sub(incomingStateName, 2))
 125 | end
 126 | 
 127 | function Utility.localPlayerRespawned(callback)
 128 | 	-- The client localscript may be located under a ScreenGui with ResetOnSpawn set to true
 129 | 	-- In these scenarios, traditional methods like CharacterAdded won't be called by the
 130 | 	-- time the localscript has been destroyed, therefore we listen for removing instead
 131 | 	-- If humanoid and health == 0, then reset/died normally, else was
 132 | 	-- forcefully reset via a method such as LoadCharacter
 133 | 	-- We wrap this behaviour in case any additional quirks need to be accounted for
 134 | 	localPlayer.CharacterRemoving:Connect(callback)
 135 | end
 136 | 
 137 | function Utility.getClippedContainer(screenGui)
 138 | 	-- We always want clipped items to display in front hence
 139 | 	-- why we have this
 140 | 	local clippedContainer = screenGui:FindFirstChild("ClippedContainer")
 141 | 	if not clippedContainer then
 142 | 		clippedContainer = Instance.new("Folder")
 143 | 		clippedContainer.Name = "ClippedContainer"
 144 | 		clippedContainer.Parent = screenGui
 145 | 	end
 146 | 	return clippedContainer
 147 | end
 148 | 
 149 | local Janitor = require(script.Parent.Packages.Janitor)
 150 | local GuiService = game:GetService("GuiService")
 151 | function Utility.clipOutside(icon, instance)
 152 | 	local cloneJanitor = icon.janitor:add(Janitor.new())
 153 | 	instance.Destroying:Once(function()
 154 | 		cloneJanitor:Destroy()
 155 | 	end)
 156 | 	icon.janitor:add(instance)
 157 | 
 158 | 	local originalParent = instance.Parent
 159 | 	local clone = cloneJanitor:add(Instance.new("Frame"))
 160 | 	clone:SetAttribute("IsAClippedClone", true)
 161 | 	clone.Name = instance.Name
 162 | 	clone.AnchorPoint = instance.AnchorPoint
 163 | 	clone.Size = instance.Size
 164 | 	clone.Position = instance.Position
 165 | 	clone.BackgroundTransparency = 1
 166 | 	clone.LayoutOrder = instance.LayoutOrder
 167 | 	clone.Parent = originalParent
 168 | 
 169 | 	local valueInstance = Instance.new("ObjectValue")
 170 | 	valueInstance.Name = "OriginalInstance"
 171 | 	valueInstance.Value = instance
 172 | 	valueInstance.Parent = clone
 173 | 
 174 | 	local valueInstanceCopy = valueInstance:Clone()
 175 | 	instance:SetAttribute("HasAClippedClone", true)
 176 | 	valueInstanceCopy.Name = "ClippedClone"
 177 | 	valueInstanceCopy.Value = clone
 178 | 	valueInstanceCopy.Parent = instance
 179 | 
 180 | 	local screenGui
 181 | 	local Icon = require(icon.iconModule)
 182 | 	local container = Icon.container
 183 | 	local function updateScreenGui()
 184 | 		local originalScreenGui = originalParent:FindFirstAncestorWhichIsA("ScreenGui")
 185 | 		screenGui = if string.match(originalScreenGui.Name, "Clipped") then originalScreenGui else container[originalScreenGui.Name.."Clipped"]
 186 | 		instance.AnchorPoint = Vector2.new(0, 0)
 187 | 		instance.Parent = Utility.getClippedContainer(screenGui)
 188 | 	end
 189 | 	cloneJanitor:add(icon.alignmentChanged:Connect(updateScreenGui))
 190 | 	updateScreenGui()
 191 | 
 192 | 	-- Lets copy over children that modify size
 193 | 	for _, child in pairs(instance:GetChildren()) do
 194 | 		if child:IsA("UIAspectRatioConstraint") then
 195 | 			child:Clone().Parent = clone
 196 | 		end
 197 | 	end
 198 | 
 199 | 	-- If the icon is hidden, its important we are too (as
 200 | 	-- setting a parent to visible = false no longer makes
 201 | 	-- this hidden)
 202 | 	local widget = icon.widget
 203 | 	local isOutsideParent = false
 204 | 	local ignoreVisibilityUpdater = instance:GetAttribute("IgnoreVisibilityUpdater")
 205 | 	local function updateVisibility()
 206 | 		if ignoreVisibilityUpdater then
 207 | 			return
 208 | 		end
 209 | 		local isVisible = widget.Visible
 210 | 		if isOutsideParent then
 211 | 			isVisible = false
 212 | 		end
 213 | 		Utility.setVisible(instance, isVisible, "ClipHandler")
 214 | 	end
 215 | 	cloneJanitor:add(widget:GetPropertyChangedSignal("Visible"):Connect(updateVisibility))
 216 | 
 217 | 	local previousScroller
 218 | 	local function checkIfOutsideParentXBounds()
 219 | 		-- Defer so that roblox's properties reflect their true values
 220 | 		task.defer(function()
 221 | 			-- If the instance is within a parent item (such as a dropdown or menu)
 222 | 			-- then we hide it if it exceeds the bounds of that parent
 223 | 			local parentInstance
 224 | 			local ourUID = icon.UID
 225 | 			local nextIconUID = ourUID
 226 | 			local shouldClipToParent = instance:GetAttribute("ClipToJoinedParent")
 227 | 			if shouldClipToParent then
 228 | 				for i = 1, 10 do -- This is safer than while true do and should never be > 4 parents
 229 | 					local nextIcon = Icon.getIconByUID(nextIconUID)
 230 | 					if not nextIcon then
 231 | 						break
 232 | 					end
 233 | 					local nextParentInstance = nextIcon.joinedFrame
 234 | 					nextIconUID = nextIcon.parentIconUID
 235 | 					if not nextParentInstance then
 236 | 						break
 237 | 					end
 238 | 					parentInstance = nextParentInstance
 239 | 					if parentInstance and parentInstance.Name == "DropdownScroller" then
 240 | 						break
 241 | 					end
 242 | 				end
 243 | 			end
 244 | 			if not parentInstance then
 245 | 				isOutsideParent = false
 246 | 				updateVisibility()
 247 | 				return
 248 | 			end
 249 | 			local pos = instance.AbsolutePosition
 250 | 			local halfSize = instance.AbsoluteSize/2
 251 | 			local parentPos = parentInstance.AbsolutePosition
 252 | 			local parentSize = parentInstance.AbsoluteSize
 253 | 			local posHalf = (pos + halfSize)
 254 | 			local exceededLeft = posHalf.X < parentPos.X
 255 | 			local exceededRight = posHalf.X > (parentPos.X + parentSize.X)
 256 | 			local exceededTop = posHalf.Y < parentPos.Y
 257 | 			local exceededBottom = posHalf.Y > (parentPos.Y + parentSize.Y)
 258 | 			local hasExceeded = exceededLeft or exceededRight or exceededTop or exceededBottom
 259 | 			if hasExceeded ~= isOutsideParent then
 260 | 				isOutsideParent = hasExceeded
 261 | 				updateVisibility()
 262 | 			end
 263 | 			if parentInstance:IsA("ScrollingFrame") and previousScroller ~= parentInstance then
 264 | 				previousScroller = parentInstance
 265 | 				local connection = parentInstance:GetPropertyChangedSignal("AbsoluteWindowSize"):Connect(function()
 266 | 					checkIfOutsideParentXBounds()
 267 | 				end)
 268 | 				cloneJanitor:add(connection, "Disconnect", "TrackUtilityScroller-"..ourUID)
 269 | 			end
 270 | 		end)
 271 | 	end
 272 | 
 273 | 	local camera = workspace.CurrentCamera
 274 | 	local additionalOffsetX = instance:GetAttribute("AdditionalOffsetX") or 0
 275 | 	local function trackProperty(property)
 276 | 		local absoluteProperty = "Absolute"..property
 277 | 		local function updateProperty()
 278 | 			local cloneValue = clone[absoluteProperty]
 279 | 			local absoluteValue = UDim2.fromOffset(cloneValue.X, cloneValue.Y)
 280 | 			if property == "Position" then
 281 | 
 282 | 				-- This binds the instances within the bounds of the screen
 283 | 				local SIDE_PADDING = 4
 284 | 				local limitX = camera.ViewportSize.X - instance.AbsoluteSize.X - SIDE_PADDING
 285 | 				local inputX = absoluteValue.X.Offset
 286 | 				if inputX < SIDE_PADDING then
 287 | 					inputX = SIDE_PADDING
 288 | 				elseif inputX > limitX then
 289 | 					inputX = limitX
 290 | 				end
 291 | 				absoluteValue = UDim2.fromOffset(inputX, absoluteValue.Y.Offset)
 292 | 
 293 | 				-- AbsolutePosition does not perfectly match with TopbarInsets enabled
 294 | 				-- This corrects this
 295 | 				local topbarInset = GuiService.TopbarInset
 296 | 				local viewportWidth = workspace.CurrentCamera.ViewportSize.X
 297 | 				local guiWidth = screenGui.AbsoluteSize.X
 298 | 				local guiOffset = screenGui.AbsolutePosition.X
 299 | 				--local widthDifference = guiOffset - topbarInset.Min.X
 300 | 				local oldTopbarCenterOffset = 0--widthDifference/30
 301 | 				local offsetX = if Icon.isOldTopbar then guiOffset else viewportWidth - guiWidth - oldTopbarCenterOffset
 302 | 				
 303 | 				-- Also add additionalOffset
 304 | 				offsetX -= additionalOffsetX
 305 | 				absoluteValue += UDim2.fromOffset(-offsetX, topbarInset.Height)
 306 | 
 307 | 				-- Finally check if within its direct parents bounds
 308 | 				checkIfOutsideParentXBounds()
 309 | 
 310 | 			end
 311 | 			instance[property] = absoluteValue
 312 | 		end
 313 | 		
 314 | 		-- This defer is essential as the listener may be in a different screenGui to the actor
 315 | 		local updatePropertyStaggered = Utility.createStagger(0.01, updateProperty)
 316 | 		cloneJanitor:add(clone:GetPropertyChangedSignal(absoluteProperty):Connect(updatePropertyStaggered))
 317 | 		cloneJanitor:add(clone:GetAttributeChangedSignal("ForceUpdate"):Connect(function()
 318 | 			updatePropertyStaggered()
 319 | 		end))
 320 | 
 321 | 		-- This is to patch a weirddddd bug with ScreenGuis with SreenInsets set to
 322 | 		-- 'TopbarSafeInsets'. For some reason the absolute position of gui instances
 323 | 		-- within this type of screenGui DO NOT accurately update to match their new
 324 | 		-- real world position; instead they jump around almost randomly for a few frames.
 325 | 		-- I have spent way too many hours trying to solve this bug, I think the only way
 326 | 		-- for the time being is to not use ScreenGuis with TopbarSafeInsets, but I don't
 327 | 		-- have time to redesign the entire system around that at the moment.
 328 | 		-- Here's a GIF of this bug: https://i.imgur.com/VitHdC1.gif
 329 | 		local updatePropertyPatch = Utility.createStagger(0.5, updateProperty, true)
 330 | 		cloneJanitor:add(clone:GetPropertyChangedSignal(absoluteProperty):Connect(updatePropertyPatch))
 331 | 		
 332 | 		-- When the screenGui is resized (such as when chat is hidden/shown), we need
 333 | 		-- to update the position of the clone. Ths especially fixes the following:
 334 | 		-- https://devforum.roblox.com/t/bug/1017485/1732
 335 | 		if property == "Position" then
 336 | 			cloneJanitor:add(screenGui:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
 337 | 				updatePropertyStaggered()
 338 | 			end))
 339 | 		end
 340 | 
 341 | 	end
 342 | 	task.delay(0.1, checkIfOutsideParentXBounds)
 343 | 	checkIfOutsideParentXBounds()
 344 | 	updateVisibility()
 345 | 	trackProperty("Position")
 346 | 	
 347 | 	-- Track visiblity changes
 348 | 	cloneJanitor:add(instance:GetPropertyChangedSignal("Visible"):Connect(function()
 349 | 		--print("Visiblity changed:", instance, clone, instance.Visible)
 350 | 		--clone.Visible = instance.Visible
 351 | 	end))
 352 | 
 353 | 	-- To ensure accurate positioning, it's important the clone also remains the same size as the instance
 354 | 	local shouldTrackCloneSize = instance:GetAttribute("TrackCloneSize")
 355 | 	if shouldTrackCloneSize then
 356 | 		trackProperty("Size")
 357 | 	else
 358 | 		cloneJanitor:add(instance:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
 359 | 			local absolute = instance.AbsoluteSize
 360 | 			clone.Size = UDim2.fromOffset(absolute.X, absolute.Y)
 361 | 		end))
 362 | 	end
 363 | 
 364 | 	return clone
 365 | end
 366 | 
 367 | function Utility.joinFeature(originalIcon, parentIcon, iconsArray, scrollingFrameOrFrame)
 368 | 
 369 | 	-- This is resonsible for moving the icon under a feature like a dropdown
 370 | 	local joinJanitor = originalIcon.joinJanitor
 371 | 	joinJanitor:clean()
 372 | 	if not scrollingFrameOrFrame then
 373 | 		originalIcon:leave()
 374 | 		return
 375 | 	end
 376 | 	originalIcon.parentIconUID = parentIcon.UID
 377 | 	originalIcon.joinedFrame = scrollingFrameOrFrame
 378 | 	local function updateAlignent()
 379 | 		local parentAlignment = parentIcon.alignment
 380 | 		if parentAlignment == "Center" then
 381 | 			parentAlignment = "Left"
 382 | 		end
 383 | 		originalIcon:setAlignment(parentAlignment, true)
 384 | 	end
 385 | 	joinJanitor:add(parentIcon.alignmentChanged:Connect(updateAlignent))
 386 | 	updateAlignent()
 387 | 	originalIcon:modifyTheme({"IconButton", "BackgroundTransparency", 1}, "JoinModification")
 388 | 	originalIcon:modifyTheme({"ClickRegion", "Active", false}, "JoinModification")
 389 | 	if parentIcon.childModifications then
 390 | 		-- We defer so that the default values (such as dropdown
 391 | 		-- minimum width can be applied before any custom
 392 | 		-- child modifications from the user)
 393 | 		task.defer(function()
 394 | 			originalIcon:modifyTheme(parentIcon.childModifications, parentIcon.childModificationsUID)
 395 | 		end)
 396 | 	end
 397 | 	--
 398 | 	local clickRegion = originalIcon:getInstance("ClickRegion")
 399 | 	local function makeSelectable()
 400 | 		clickRegion.Selectable = parentIcon.isSelected
 401 | 	end
 402 | 	joinJanitor:add(parentIcon.toggled:Connect(makeSelectable))
 403 | 	task.defer(makeSelectable)
 404 | 	joinJanitor:add(function()
 405 | 		clickRegion.Selectable = true
 406 | 	end)
 407 | 	--
 408 | 
 409 | 	-- We track icons in arrays and dictionaries using their UID instead of the icon
 410 | 	-- itself to prevent heavy cyclical tables when printing the icons
 411 | 	local originalIconUID = originalIcon.UID
 412 | 	table.insert(iconsArray, originalIconUID)
 413 | 	parentIcon:autoDeselect(false)
 414 | 	parentIcon.childIconsDict[originalIconUID] = true
 415 | 	if not parentIcon.isEnabled then
 416 | 		parentIcon:setEnabled(true)
 417 | 	end
 418 | 	originalIcon.joinedParent:Fire(parentIcon)
 419 | 
 420 | 	-- This is responsible for removing it from that feature and updating
 421 | 	-- their parent icon so its informed of the icon leaving it
 422 | 	joinJanitor:add(function()
 423 | 		local joinedFrame = originalIcon.joinedFrame
 424 | 		if not joinedFrame then
 425 | 			return
 426 | 		end
 427 | 		for i, iconUID in pairs(iconsArray) do
 428 | 			if iconUID == originalIconUID then
 429 | 				table.remove(iconsArray, i)
 430 | 				break
 431 | 			end
 432 | 		end
 433 | 		local Icon = require(originalIcon.iconModule)
 434 | 		local parentIcon = Icon.getIconByUID(originalIcon.parentIconUID)
 435 | 		if not parentIcon then
 436 | 			return
 437 | 		end
 438 | 		originalIcon:setAlignment(originalIcon.originalAlignment)
 439 | 		originalIcon.parentIconUID = false
 440 | 		originalIcon.joinedFrame = false
 441 | 		--originalIcon:setBehaviour("IconButton", "BackgroundTransparency", nil, true)
 442 | 		originalIcon:removeModification("JoinModification")
 443 | 		
 444 | 		local parentHasNoChildren = true
 445 | 		local parentChildIcons = parentIcon.childIconsDict
 446 | 		parentChildIcons[originalIconUID] = nil
 447 | 		for childIconUID, _ in pairs(parentChildIcons) do
 448 | 			parentHasNoChildren = false
 449 | 			break
 450 | 		end
 451 | 		if parentHasNoChildren and not parentIcon.isAnOverflow then
 452 | 			parentIcon:setEnabled(false)
 453 | 		end
 454 | 		updateAlignent()
 455 | 
 456 | 	end)
 457 | 
 458 | end
 459 | 
 460 | 
 461 | 
 462 | return Utility
```
</details>

## ğŸŒ™ `Packages/_Index/1foreverhd_topbarplus@3.4.0/topbarplus/src/VERSION.lua`
<details>
<summary>View Source (50 lines)</summary>

```lua
   1 | --!strict
   2 | -- LOCAL
   3 | local VERSION = {}
   4 | 
   5 | 
   6 | 
   7 | -- SHARED
   8 | VERSION.appVersion = "v3.4.0"
   9 | VERSION.latestVersion = nil :: string?
  10 | 
  11 | 
  12 | 
  13 | -- FUNCTIONS
  14 | function VERSION.getLatestVersion(): string?
  15 | 	local DEVELOPMENT_PLACE_ID = 117501901079852
  16 | 	local latestVersion = VERSION.latestVersion
  17 | 	if latestVersion then
  18 | 		return latestVersion
  19 | 	end
  20 | 	local placeName = ""
  21 | 	while true do
  22 | 		local success, hdDevelopmentDetails = pcall(function()
  23 | 			return game:GetService("MarketplaceService"):GetProductInfo(DEVELOPMENT_PLACE_ID)
  24 | 		end)
  25 | 		if success and hdDevelopmentDetails then
  26 | 			placeName = hdDevelopmentDetails.Name
  27 | 			break
  28 | 		end
  29 | 		task.wait(1)
  30 | 	end
  31 | 	latestVersion = string.match(placeName, "^TopbarPlus (.*)$")
  32 | 	if latestVersion then
  33 | 		latestVersion = latestVersion:gsub("%s+", "") -- Remove all whitespace (spaces, tabs, newlines)
  34 | 	end
  35 | 	VERSION.latestVersion = latestVersion
  36 | 	return latestVersion
  37 | end
  38 | 
  39 | function VERSION.getAppVersion()
  40 | 	return VERSION.appVersion
  41 | end
  42 | 
  43 | function VERSION.isUpToDate()
  44 | 	local latestVersion = VERSION.getLatestVersion()
  45 | 	local appVersion = VERSION.getAppVersion()
  46 | 	return latestVersion ~= nil and latestVersion == appVersion
  47 | end
  48 | 
  49 | 
  50 | 
  51 | return VERSION
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/APCA/Const.lua`
<details>
<summary>View Source (22 lines)</summary>

```lua
   1 | return {
   2 | 	SRGB_TRC = 2.4,
   3 | 	NORM_BG_EXP = 0.56,
   4 | 	NORM_FG_EXP = 0.57,
   5 | 	REV_BG_EXP = 0.62,
   6 | 	REV_FG_EXP = 0.65,
   7 | 	SCALE_BOW = 1.14,
   8 | 	SCALE_WOB = 1.14,
   9 | 	RED_COEF = 0.212,
  10 | 	GREEN_COEF = 0.715,
  11 | 	BLUE_COEF = 0.072,
  12 | 	BLK_THRS = 0.022,
  13 | 	BLK_CLMP = 1.414,
  14 | 	LOW_BOW_THRS = 0.036,
  15 | 	LOW_WOB_THRS = 0.036,
  16 | 	LOW_BOW_FACT = 27.785,
  17 | 	LOW_WOB_FACT = 27.785,
  18 | 	LOW_BOW_OFFS = 0.027,
  19 | 	LOW_WOB_OFFS = 0.027,
  20 | 	LOW_CLIP = 0.001,
  21 | 	MIN_DELTA_Y = 0.0005,
  22 | }
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/APCA/GetContrastRatio.lua`
<details>
<summary>View Source (81 lines)</summary>

```lua
   1 | --[[
   2 | 	This is a Luau implementation of the APAC method of calculating the contrast
   3 | 	ratio between two colors.
   4 | 
   5 | 	This APAC method is based around a few different implementations:
   6 | 
   7 | 	> Visual Contrast by W3C
   8 | 	> https://w3c.github.io/silver/guidelines/methods/Method-font-characteristic-contrast.html#section3
   9 | 
  10 | 	> Google Chrome
  11 | 	> https://chromium.googlesource.com/devtools/devtools-frontend/+/c88c76b465f2dc8a853fe2a0997ccbfbff0e5bac/front_end/common/ColorUtils.js#88
  12 | 
  13 | 	> Answer by @myndex on StackOverflow
  14 | 	> https://stackoverflow.com/a/69411415
  15 | 
  16 | 	> Contrast by @cliambrown
  17 | 	> https://github.com/cliambrown/contrast/blob/master/src/apca.js
  18 | ]]
  19 | local Assert = require(script.Parent.Parent.Util.Assert)
  20 | local CONST = require(script.Parent.Const)
  21 | 
  22 | local assertTypeOf = Assert.prepTypeOf("GetContrastRatioAPCA")
  23 | 
  24 | local abs = math.abs
  25 | 
  26 | local function ComputePower(value: number): number
  27 | 	return value ^ CONST.SRGB_TRC
  28 | end
  29 | 
  30 | local function ComputeY(color: Color3): number
  31 | 	return ComputePower(color.R) * CONST.RED_COEF
  32 | 		+ ComputePower(color.G) * CONST.GREEN_COEF
  33 | 		+ ComputePower(color.B) * CONST.BLUE_COEF
  34 | end
  35 | 
  36 | local function SoftClampBlack(y: number): number
  37 | 	return if y > CONST.BLK_THRS then y else y + abs(y - CONST.BLK_THRS) ^ CONST.BLK_CLMP
  38 | end
  39 | 
  40 | --[=[
  41 | 	@function GetContrastRatio
  42 | 	@within APCA
  43 | 
  44 | 	@param foreground Color3 -- The foreground color.
  45 | 	@param background Color3 -- The background color.
  46 | 	@return number -- The contrast ratio [â‰ˆ-100-100].
  47 | ]=]
  48 | local function GetContrastRatio(foreground: Color3, background: Color3): number
  49 | 	assertTypeOf("foreground", "Color3", foreground)
  50 | 	assertTypeOf("background", "Color3", background)
  51 | 
  52 | 	local sapc = 0
  53 | 	local outputContrast = 0
  54 | 
  55 | 	local fgY = SoftClampBlack(ComputeY(foreground))
  56 | 	local bgY = SoftClampBlack(ComputeY(background))
  57 | 
  58 | 	if abs(bgY - fgY) < CONST.MIN_DELTA_Y then
  59 | 		return 0
  60 | 	end
  61 | 
  62 | 	if bgY > fgY then
  63 | 		sapc = (bgY ^ CONST.NORM_BG_EXP - fgY ^ CONST.NORM_FG_EXP) * CONST.SCALE_BOW
  64 | 
  65 | 		outputContrast = if sapc < CONST.LOW_CLIP
  66 | 			then 0
  67 | 			elseif sapc < CONST.LOW_BOW_THRS then sapc - sapc * CONST.LOW_BOW_FACT * CONST.LOW_BOW_OFFS
  68 | 			else sapc - CONST.LOW_BOW_OFFS
  69 | 	else
  70 | 		sapc = (bgY ^ CONST.REV_BG_EXP - fgY ^ CONST.REV_FG_EXP) * CONST.SCALE_WOB
  71 | 
  72 | 		outputContrast = if sapc > -CONST.LOW_CLIP
  73 | 			then 0
  74 | 			elseif sapc > -CONST.LOW_WOB_THRS then sapc - sapc * CONST.LOW_WOB_FACT * CONST.LOW_WOB_OFFS
  75 | 			else sapc + CONST.LOW_WOB_OFFS
  76 | 	end
  77 | 
  78 | 	return outputContrast * 100
  79 | end
  80 | 
  81 | return GetContrastRatio
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/APCA/init.lua`
<details>
<summary>View Source (6 lines)</summary>

```lua
   1 | --[=[
   2 | 	@class APCA
   3 | ]=]
   4 | return {
   5 | 	GetContrastRatio = require(script.GetContrastRatio),
   6 | }
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/Blend/_Filter.lua`
<details>
<summary>View Source (19 lines)</summary>

```lua
   1 | local Assert = require(script.Parent.Parent.Util.Assert)
   2 | local ClampColor = require(script.Parent.Parent.Util.ClampColor)
   3 | 
   4 | return function(filterName: string, applyFilter: (number, number) -> number): (Color3, Color3) -> Color3
   5 | 	local assertTypeOf = Assert.prepTypeOf(filterName)
   6 | 
   7 | 	return function(background: Color3, foreground: Color3): Color3
   8 | 		assertTypeOf("background", "Color3", background)
   9 | 		assertTypeOf("foreground", "Color3", foreground)
  10 | 
  11 | 		local newColor = Color3.fromRGB(
  12 | 			applyFilter(background.R, foreground.R),
  13 | 			applyFilter(background.G, foreground.G),
  14 | 			applyFilter(background.B, foreground.B)
  15 | 		)
  16 | 
  17 | 		return ClampColor(newColor)
  18 | 	end
  19 | end
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/Blend/Burn.lua`
<details>
<summary>View Source (20 lines)</summary>

```lua
   1 | local PrepFilter = require(script.Parent._Filter)
   2 | 
   3 | local lshift = bit32.lshift
   4 | local clamp = math.clamp
   5 | local max = math.max
   6 | 
   7 | --[=[
   8 | 	@function Burn
   9 | 	@within Blend
  10 | 
  11 | 	@param background Color3 -- The background color.
  12 | 	@param foreground Color3 -- The foreground color.
  13 | 	@return Color3 -- The resulting color.
  14 | ]=]
  15 | return PrepFilter("Burn", function(background: number, foreground: number): number
  16 | 	local bg = clamp(background * 255, 0, 255)
  17 | 	local fg = foreground * 255
  18 | 
  19 | 	return (bg == 0) and bg or max(0, (255 - lshift((255 - fg), 8) / bg))
  20 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/Blend/Dodge.lua`
<details>
<summary>View Source (20 lines)</summary>

```lua
   1 | local PrepFilter = require(script.Parent._Filter)
   2 | 
   3 | local lshift = bit32.lshift
   4 | local clamp = math.clamp
   5 | local min = math.min
   6 | 
   7 | --[=[
   8 | 	@function Dodge
   9 | 	@within Blend
  10 | 
  11 | 	@param background Color3 -- The background color.
  12 | 	@param foreground Color3 -- The foreground color.
  13 | 	@return Color3 -- The resulting color.
  14 | ]=]
  15 | return PrepFilter("Dodge", function(background: number, foreground: number): number
  16 | 	local bg = clamp(background * 255, 0, 255)
  17 | 	local fg = foreground * 255
  18 | 
  19 | 	return (bg == 255) and bg or min(255, lshift(fg, 8) / (255 - bg))
  20 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/Blend/init.lua`
<details>
<summary>View Source (11 lines)</summary>

```lua
   1 | --[=[
   2 | 	@class Blend
   3 | ]=]
   4 | return {
   5 | 	Multiply = require(script.Multiply),
   6 | 	Screen = require(script.Screen),
   7 | 	Overlay = require(script.Overlay),
   8 | 	Dodge = require(script.Dodge),
   9 | 	Burn = require(script.Burn),
  10 | 	Transparency = require(script.Transparency),
  11 | }
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/Blend/Multiply.lua`
<details>
<summary>View Source (13 lines)</summary>

```lua
   1 | local PrepFilter = require(script.Parent._Filter)
   2 | 
   3 | --[=[
   4 | 	@function Multiply
   5 | 	@within Blend
   6 | 
   7 | 	@param background Color3 -- The background color.
   8 | 	@param foreground Color3 -- The foreground color.
   9 | 	@return Color3 -- The resulting color.
  10 | ]=]
  11 | return PrepFilter("Multiply", function(background: number, foreground: number): number
  12 | 	return ((foreground * 255) * (background * 255)) / 255
  13 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/Blend/Overlay.lua`
<details>
<summary>View Source (16 lines)</summary>

```lua
   1 | local PrepFilter = require(script.Parent._Filter)
   2 | 
   3 | --[=[
   4 | 	@function Overlay
   5 | 	@within Blend
   6 | 
   7 | 	@param background Color3 -- The background color.
   8 | 	@param foreground Color3 -- The foreground color.
   9 | 	@return Color3 -- The resulting color.
  10 | ]=]
  11 | return PrepFilter("Overlay", function(background: number, foreground: number): number
  12 | 	local bg = background * 255
  13 | 	local fg = foreground * 255
  14 | 
  15 | 	return (bg < 128) and (2 * fg * bg / 255) or (255 - 2 * (255 - bg) * (255 - fg) / 255)
  16 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/Blend/Screen.lua`
<details>
<summary>View Source (14 lines)</summary>

```lua
   1 | local PrepFilter = require(script.Parent._Filter)
   2 | local rshift = bit32.rshift
   3 | 
   4 | --[=[
   5 | 	@function Screen
   6 | 	@within Blend
   7 | 
   8 | 	@param background Color3 -- The background color.
   9 | 	@param foreground Color3 -- The foreground color.
  10 | 	@return Color3 -- The resulting color.
  11 | ]=]
  12 | return PrepFilter("Screen", function(background: number, foreground: number): number
  13 | 	return 255 - rshift(((255 - (foreground * 255)) * (255 - (background * 255))), 8)
  14 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/Blend/Transparency.lua`
<details>
<summary>View Source (20 lines)</summary>

```lua
   1 | --[=[
   2 |   @function Transparency
   3 |   @within Blend
   4 | 
   5 |   @param background Color3 -- The background color.
   6 |   @param foreground Color3 -- The foreground color.
   7 |   @param transparency number -- The transparency value.
   8 |   @return Color3 -- The resulting color.
   9 | ]=]
  10 | local function applyTransparency(background: Color3, foreground: Color3, transparency: number): Color3
  11 | 	local alpha = 1 - transparency
  12 | 
  13 | 	local red = foreground.R * alpha + background.R * transparency
  14 | 	local green = foreground.G * alpha + background.G * transparency
  15 | 	local blue = foreground.B * alpha + background.B * transparency
  16 | 
  17 | 	return Color3.new(red, green, blue)
  18 | end
  19 | 
  20 | return applyTransparency
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/Blind/Enum.lua`
<details>
<summary>View Source (84 lines)</summary>

```lua
   1 | --[=[
   2 | 	@interface Enums
   3 | 	@within Blind
   4 | 	.Blind Blind -- Types of color blindness.
   5 | 	.Group Group -- Color blindness groups.
   6 | ]=]
   7 | 
   8 | --[=[
   9 | 	@interface Blind
  10 | 	@tag Enum
  11 | 	@within Blind
  12 | 	.Trichromacy 0 -- No color blindness.
  13 | 	.Protanopia 1 -- Red blind.
  14 | 	.Protanomaly 2 -- Red deficient.
  15 | 	.Deuteranopia 3 -- Green blind.
  16 | 	.Deuteranomaly 4 -- Green deficient.
  17 | 	.Tritanopia 5 -- Blue blind.
  18 | 	.Tritanomaly 6 -- Blue deficient.
  19 | 	.Achromatopsia 7 -- All colors are absent.
  20 | 	.Achromatomaly 8 -- All colors are deficient.
  21 | 
  22 | 	.None 0 -- Trichromacy (no color blindness).
  23 | 	.NoRed 1 -- Protanopia (red blind).
  24 | 	.LowRed 2 -- Protanomaly (red deficient).
  25 | 	.NoGreen 3 -- Deuteranopia (green blind).
  26 | 	.LowGreen 4 -- Deuteranomaly (green deficient).
  27 | 	.NoBlue 5 -- Tritanopia (blue blind).
  28 | 	.LowBlue 6 -- Tritanomaly (blue deficient).
  29 | 	.NoColor 7 -- Achromatopsia (totally color blind).
  30 | 	.LowColor 8 -- Achromatomaly (color deficient).
  31 | 
  32 | 	The Blind enum is used to represent the different types of color blindness. It
  33 | 	features a number of aliases for non-scientists.
  34 | ]=]
  35 | 
  36 | --[=[
  37 | 	@interface Group
  38 | 	@tag Enum
  39 | 	@within Blind
  40 | 	.Trichroma 0 -- Trichromacy (no color blindness).
  41 | 	.Protan 1 -- Protanopia/Protanomaly.
  42 | 	.Deutan 2 -- Deuteranopia/Deuteranomaly.
  43 | 	.Tritan 3 -- Tritanopia/Tritanomaly.
  44 | 	.Achroma 4 -- Achromatopsia/Achromatomaly.
  45 | 
  46 | 	The Group enum is used to represent the different groups of color blindness.
  47 | 	It is used internally by the [Simulate](#Simulate) method to determine which
  48 | 	color blindness simulation to use. It is unlikely that you will need to
  49 | 	use this enum.
  50 | ]=]
  51 | local Enums = {
  52 | 	Blind = {
  53 | 		Trichromacy = 0,
  54 | 		Protanopia = 1,
  55 | 		Protanomaly = 2,
  56 | 		Deuteranopia = 3,
  57 | 		Deuteranomaly = 4,
  58 | 		Tritanopia = 5,
  59 | 		Tritanomaly = 6,
  60 | 		Achromatopsia = 7,
  61 | 		Achromatomaly = 8,
  62 | 	},
  63 | 
  64 | 	Group = {
  65 | 		Trichroma = 0,
  66 | 		Protan = 1,
  67 | 		Deutan = 2,
  68 | 		Tritan = 3,
  69 | 		Achroma = 4,
  70 | 	},
  71 | }
  72 | 
  73 | Enums.Blind.None = Enums.Blind.Trichromacy
  74 | Enums.Blind.LowRed = Enums.Blind.Protanomaly
  75 | Enums.Blind.LowGreen = Enums.Blind.Deuteranomaly
  76 | Enums.Blind.LowBlue = Enums.Blind.Tritanomaly
  77 | Enums.Blind.LowColor = Enums.Blind.Achromatomaly
  78 | 
  79 | Enums.Blind.NoRed = Enums.Blind.Protanopia
  80 | Enums.Blind.NoGreen = Enums.Blind.Deuteranopia
  81 | Enums.Blind.NoBlue = Enums.Blind.Tritanopia
  82 | Enums.Blind.NoColor = Enums.Blind.Achromatopsia
  83 | 
  84 | return Enums
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/Blind/init.lua`
<details>
<summary>View Source (7 lines)</summary>

```lua
   1 | --[=[
   2 | 	@class Blind
   3 | ]=]
   4 | return {
   5 | 	Enum = require(script.Enum),
   6 | 	Simulate = require(script.Simulate),
   7 | }
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/Blind/Simulate/Configs.lua`
<details>
<summary>View Source (78 lines)</summary>

```lua
   1 | local Enums = require(script.Parent.Parent.Enum)
   2 | 
   3 | local ANOMALISED = {
   4 | 	[Enums.Blind.Protanomaly] = true,
   5 | 	[Enums.Blind.Deuteranomaly] = true,
   6 | 	[Enums.Blind.Tritanomaly] = true,
   7 | 	[Enums.Blind.Achromatomaly] = true,
   8 | }
   9 | 
  10 | local GROUPS = {
  11 | 	[Enums.Blind.Trichromacy] = Enums.Group.Trichroma,
  12 | 	[Enums.Blind.Protanopia] = Enums.Group.Protan,
  13 | 	[Enums.Blind.Protanomaly] = Enums.Group.Protan,
  14 | 	[Enums.Blind.Deuteranopia] = Enums.Group.Deutan,
  15 | 	[Enums.Blind.Deuteranomaly] = Enums.Group.Deutan,
  16 | 	[Enums.Blind.Tritanopia] = Enums.Group.Tritan,
  17 | 	[Enums.Blind.Tritanomaly] = Enums.Group.Tritan,
  18 | 	[Enums.Blind.Achromatopsia] = Enums.Group.Achroma,
  19 | 	[Enums.Blind.Achromatomaly] = Enums.Group.Achroma,
  20 | }
  21 | 
  22 | local GAMMA_CORRECT = 2.2
  23 | 
  24 | local MATRIX_XYZ_RGB = {
  25 | 	3.241,
  26 | 	-0.969,
  27 | 	0.056,
  28 | 	-1.537,
  29 | 	1.876,
  30 | 	-0.204,
  31 | 	-0.499,
  32 | 	0.042,
  33 | 	1.057,
  34 | }
  35 | 
  36 | local MATRIX_RGB_XYZ = {
  37 | 	0.412,
  38 | 	0.213,
  39 | 	0.019,
  40 | 	0.358,
  41 | 	0.715,
  42 | 	0.119,
  43 | 	0.18,
  44 | 	0.072,
  45 | 	0.95,
  46 | }
  47 | 
  48 | local BLINDER = {
  49 | 	[Enums.Group.Protan] = {
  50 | 		X = 0.747,
  51 | 		Y = 0.254,
  52 | 		M = 1.273,
  53 | 		YI = -0.074,
  54 | 	},
  55 | 	[Enums.Group.Deutan] = {
  56 | 		X = 1.4,
  57 | 		Y = -0.4,
  58 | 		M = 0.968,
  59 | 		YI = 0.003,
  60 | 	},
  61 | 	[Enums.Group.Tritan] = {
  62 | 		X = 0.175,
  63 | 		Y = 0,
  64 | 		M = 0.063,
  65 | 		YI = 0.292,
  66 | 	},
  67 | }
  68 | 
  69 | return {
  70 | 	Anomalised = ANOMALISED,
  71 | 	Groups = GROUPS,
  72 | 	Gamma_Correct = GAMMA_CORRECT,
  73 | 	Matrix = {
  74 | 		XYZ_RGB = MATRIX_XYZ_RGB,
  75 | 		RGB_XYZ = MATRIX_RGB_XYZ,
  76 | 	},
  77 | 	Blinder = BLINDER,
  78 | }
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/Blind/Simulate/init.lua`
<details>
<summary>View Source (157 lines)</summary>

```lua
   1 | --[[
   2 | 	This is a Luau port of the excellent `color-blind` library by skratchdot.
   3 | 	The original library is licensed under the MIT license.
   4 | 
   5 | 	> https://github.com/skratchdot/color-blind/blob/master/lib/blind.js
   6 | 
   7 | 	The `color-utils` adaptation is ported for use within Roblox's Luau library,
   8 | 	but also contains TypeScript bindings for those using roblox-ts.
   9 | ]]
  10 | 
  11 | type VectorXyY = {
  12 | 	X: number,
  13 | 	y: number,
  14 | 	Y: number,
  15 | }
  16 | 
  17 | local Configs = require(script.Configs)
  18 | local Enums = require(script.Parent.Enum)
  19 | 
  20 | local function RGBtoXYZ(color: Color3): Vector3
  21 | 	local M = Configs.Matrix.RGB_XYZ
  22 | 
  23 | 	local r = color.R
  24 | 	local g = color.G
  25 | 	local b = color.B
  26 | 
  27 | 	r = if r > 0.04 then ((r + 0.055) / 1.055) ^ 2.4 else r / 12.92
  28 | 	g = if g > 0.04 then ((g + 0.055) / 1.055) ^ 2.4 else g / 12.92
  29 | 	b = if b > 0.04 then ((b + 0.055) / 1.055) ^ 2.4 else b / 12.92
  30 | 
  31 | 	return Vector3.new(r * M[1] + g * M[4] + b * M[7], r * M[2] + g * M[5] + b * M[8], r * M[3] + g * M[6] + b * M[9])
  32 | end
  33 | 
  34 | local function XYZtoXyY(vector: Vector3): VectorXyY
  35 | 	local value = vector.X + vector.Y + vector.Z
  36 | 
  37 | 	if value == 0 then
  38 | 		return {
  39 | 			X = 0,
  40 | 			y = 0,
  41 | 			Y = vector.Y,
  42 | 		}
  43 | 	end
  44 | 
  45 | 	return {
  46 | 		X = vector.X / value,
  47 | 		y = vector.Y / value,
  48 | 		Y = vector.Y,
  49 | 	}
  50 | end
  51 | 
  52 | local function Anomalise(origin: Color3, blinded: Color3, multiplier: number?): Color3
  53 | 	multiplier = if type(multiplier) == "number" then multiplier else 1.75
  54 | 
  55 | 	local n = multiplier + 1
  56 | 
  57 | 	return Color3.new(
  58 | 		(multiplier * blinded.R + origin.R) / n,
  59 | 		(multiplier * blinded.G + origin.G) / n,
  60 | 		(multiplier * blinded.B + origin.B) / n
  61 | 	)
  62 | end
  63 | 
  64 | --[=[
  65 | 	@function Simulate
  66 | 	@within Blind
  67 | 
  68 | 	@param color Color3 -- The color to simulate.
  69 | 	@param blinder Blind -- The blinder to simulate with.
  70 | 	@return Color3 -- The simulated color.
  71 | ]=]
  72 | local function SimulateBlinder(color: Color3, blinder: number): Color3
  73 | 	assert(typeof(color) == "Color3", "Color must be a Color3")
  74 | 	assert(typeof(blinder) == "number", "Blinder must be a number (see Enums.Blind)")
  75 | 
  76 | 	local group = Configs.Groups[blinder]
  77 | 	local anomalise = Configs.Anomalised[blinder]
  78 | 
  79 | 	if group == Enums.Group.Trichroma then
  80 | 		return color
  81 | 	end
  82 | 
  83 | 	if group == Enums.Group.Achroma then
  84 | 		local val = color.R * 0.213 + color.G * 0.715 + color.B * 0.072
  85 | 		local blinded = Color3.new(val, val, val)
  86 | 
  87 | 		if anomalise then
  88 | 			return Anomalise(color, blinded)
  89 | 		end
  90 | 
  91 | 		return blinded
  92 | 	end
  93 | 
  94 | 	local line = Configs.Blinder[group]
  95 | 	local xyy = XYZtoXyY(RGBtoXYZ(color))
  96 | 
  97 | 	local slope = (xyy.y - line.Y) / (xyy.X - line.X)
  98 | 	local yi = xyy.y - xyy.X * slope
  99 | 
 100 | 	local dX = (line.YI - yi) / (slope - line.M)
 101 | 	local dy = (slope * dX) + yi
 102 | 	local dY = 0
 103 | 
 104 | 	local vector = {
 105 | 		X = dX * xyy.Y / dy,
 106 | 		Y = xyy.Y,
 107 | 		Z = (1 - (dX + dy)) * xyy.Y / dy,
 108 | 	}
 109 | 
 110 | 	local ngx = 0.313 * xyy.Y / 0.329
 111 | 	local ngz = 0.358 * xyy.Y / 0.329
 112 | 
 113 | 	local dZ = ngz - vector.Z
 114 | 	dX = ngx - vector.X
 115 | 
 116 | 	local M = Configs.Matrix.XYZ_RGB
 117 | 
 118 | 	local dR = dX * M[1] + dY * M[4] + dZ * M[7]
 119 | 	local dG = dX * M[2] + dY * M[5] + dZ * M[8]
 120 | 	local dB = dX * M[3] + dY * M[6] + dZ * M[9]
 121 | 
 122 | 	vector.R = vector.X * M[1] + vector.Y * M[4] + vector.Z * M[7]
 123 | 	vector.G = vector.X * M[2] + vector.Y * M[5] + vector.Z * M[8]
 124 | 	vector.B = vector.X * M[3] + vector.Y * M[6] + vector.Z * M[9]
 125 | 
 126 | 	local _r = ((if vector.R < 0 then 0 else 1) - vector.R) / dR
 127 | 	local _g = ((if vector.G < 0 then 0 else 1) - vector.G) / dG
 128 | 	local _b = ((if vector.B < 0 then 0 else 1) - vector.B) / dB
 129 | 
 130 | 	_r = if _r > 1 or _r < 0 then 0 else _r
 131 | 	_g = if _g > 1 or _g < 0 then 0 else _g
 132 | 	_b = if _b > 1 or _b < 0 then 0 else _b
 133 | 
 134 | 	local adjust = if _r > _g then _r else _g
 135 | 
 136 | 	if _b > adjust then
 137 | 		adjust = _b
 138 | 	end
 139 | 
 140 | 	vector.R += adjust * dR
 141 | 	vector.G += adjust * dG
 142 | 	vector.B += adjust * dB
 143 | 
 144 | 	vector.R = 255 * (if vector.R <= 0 then 0 elseif vector.R >= 1 then 1 else vector.R ^ (1 / Configs.Gamma_Correct))
 145 | 	vector.G = 255 * (if vector.G <= 0 then 0 elseif vector.G >= 1 then 1 else vector.G ^ (1 / Configs.Gamma_Correct))
 146 | 	vector.B = 255 * (if vector.B <= 0 then 0 elseif vector.B >= 1 then 1 else vector.B ^ (1 / Configs.Gamma_Correct))
 147 | 
 148 | 	local blinded = Color3.fromRGB(vector.R or 0, vector.G or 0, vector.B or 0)
 149 | 
 150 | 	if anomalise then
 151 | 		return Anomalise(color, blinded)
 152 | 	end
 153 | 
 154 | 	return blinded
 155 | end
 156 | 
 157 | return SimulateBlinder
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/Darken.lua`
<details>
<summary>View Source (19 lines)</summary>

```lua
   1 | local Assert = require(script.Parent.Util.Assert)
   2 | local assertTypeOf = Assert.prepTypeOf("Darken")
   3 | 
   4 | local clampColor = require(script.Parent.Util.ClampColor)
   5 | 
   6 | --[=[
   7 | 	@function Darken
   8 | 	@within ColorUtils
   9 | 
  10 | 	@param color Color3 -- The color to darken.
  11 | 	@param coefficient number -- The amount to darken by [0-1].
  12 | 	@return Color3 -- The darkened color.
  13 | ]=]
  14 | return function(color: Color3, coefficient: number): Color3
  15 | 	assertTypeOf("color", "Color3", color)
  16 | 	assertTypeOf("coefficient", "number", coefficient)
  17 | 
  18 | 	return clampColor(color:Lerp(Color3.new(), coefficient))
  19 | end
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/Desaturate.lua`
<details>
<summary>View Source (19 lines)</summary>

```lua
   1 | local Assert = require(script.Parent.Util.Assert)
   2 | local Saturate = require(script.Parent.Saturate)
   3 | 
   4 | local assertTypeOf = Assert.prepTypeOf("Saturate")
   5 | 
   6 | --[=[
   7 |   @function Desaturate
   8 |   @within ColorUtils
   9 | 
  10 |   @param color Color3 -- The color to desaturate.
  11 |   @param coefficient number -- The coefficient to desaturate by [0-1].
  12 |   @return Color3 -- The desaturated color.
  13 | ]=]
  14 | return function(color: Color3, coefficient: number): Color3
  15 | 	assertTypeOf("color", "Color3", color)
  16 | 	assertTypeOf("coefficient", "number", coefficient)
  17 | 
  18 | 	return Saturate(color, -coefficient)
  19 | end
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/Emphasize.lua`
<details>
<summary>View Source (17 lines)</summary>

```lua
   1 | local Darken = require(script.Parent.Darken)
   2 | local GetLuminance = require(script.Parent.GetLuminance)
   3 | local Lighten = require(script.Parent.Lighten)
   4 | 
   5 | --[=[
   6 | 	@function Emphasize
   7 | 	@within ColorUtils
   8 | 
   9 | 	@param color Color3 -- The color to emphasize.
  10 | 	@param coefficient number -- The amount to emphasize by [0-1].
  11 | 	@param threshold? number -- The threshold for light/dark [0-1] (defaults to 0.5).
  12 | 	@return Color3 -- The emphasized color.
  13 | ]=]
  14 | return function(color: Color3, coefficient: number, threshold: number?): Color3
  15 | 	threshold = type(threshold) == "number" and threshold or 0.5
  16 | 	return GetLuminance(color) > threshold and Darken(color, coefficient) or Lighten(color, coefficient)
  17 | end
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/GetContrastRatioCompat.lua`
<details>
<summary>View Source (18 lines)</summary>

```lua
   1 | local getContrastRatio = require(script.Parent.APCA.GetContrastRatio)
   2 | local didWarnAPCA = false
   3 | 
   4 | local function getContrastRatioCompat(foreground: Color3, background: Color3): number
   5 | 	local contrastRatio = math.abs(getContrastRatio(foreground, background))
   6 | 
   7 | 	if not didWarnAPCA then
   8 | 		didWarnAPCA = true
   9 | 
  10 | 		warn(
  11 | 			"ColorUtils.GetContrastRatio is providing a compatibility layer for APCA.GetContrastRatio. To continue using the old behavior, use WCAG.GetContrastRatio instead."
  12 | 		)
  13 | 	end
  14 | 
  15 | 	return (contrastRatio / 100) * 21
  16 | end
  17 | 
  18 | return getContrastRatioCompat
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/GetLuminance.lua`
<details>
<summary>View Source (26 lines)</summary>

```lua
   1 | local Assert = require(script.Parent.Util.Assert)
   2 | 
   3 | local assertTypeOf = Assert.prepTypeOf("GetLuminance")
   4 | 
   5 | local function transformValue(value: number): number
   6 | 	return value <= 0.03928 and value / 12.92 or ((value + 0.055) / 1.055) ^ 2.4
   7 | end
   8 | 
   9 | --[=[
  10 | 	@function GetLuminance
  11 | 	@within ColorUtils
  12 | 
  13 | 	@param color Color3 -- The color to get the luminance of.
  14 | 	@return number -- The luminance of the color [0-1].
  15 | ]=]
  16 | return function(color: Color3): number
  17 | 	assertTypeOf("color", "Color3", color)
  18 | 
  19 | 	local red = transformValue(color.R)
  20 | 	local green = transformValue(color.G)
  21 | 	local blue = transformValue(color.B)
  22 | 
  23 | 	local lum = 0.2126 * red + 0.7152 * green + 0.0722 * blue
  24 | 
  25 | 	return lum
  26 | end
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/GetPerceivedBrightness.lua`
<details>
<summary>View Source (22 lines)</summary>

```lua
   1 | local Assert = require(script.Parent.Util.Assert)
   2 | 
   3 | local assertTypeOf = Assert.prepTypeOf("GetPerceivedBrightness")
   4 | 
   5 | --[=[
   6 | 	@function GetPerceivedBrightness
   7 | 	@within ColorUtils
   8 | 
   9 | 	@param color Color3 -- The color to get the perceived brightness of.
  10 | 	@return number -- The perceived brightness of the color [0-1].
  11 | ]=]
  12 | return function(color: Color3): number
  13 | 	assertTypeOf("color", "Color3", color)
  14 | 
  15 | 	local red = color.R * 255
  16 | 	local green = color.G * 255
  17 | 	local blue = color.B * 255
  18 | 
  19 | 	local bright = ((red * 299 + green * 587 + blue * 114) / 1000) / 255
  20 | 
  21 | 	return bright
  22 | end
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/Hex/init.lua`
<details>
<summary>View Source (124 lines)</summary>

```lua
   1 | local Assert = require(script.Parent.Util.Assert)
   2 | local ClampColor = require(script.Parent.Util.ClampColor)
   3 | local Transparency = require(script.Parent.Blend.Transparency)
   4 | 
   5 | local sub = string.sub
   6 | local gsub = string.gsub
   7 | local fmt = string.format
   8 | local rep = string.rep
   9 | local split = string.split
  10 | 
  11 | local HEX_EXCLUDE_PATTERN = "[^A-Fa-f0-9]"
  12 | local HEX_FORMAT_PATTERN = "%.2x%.2x%.2x"
  13 | local BACKGROUND_BASE_COLOR = Color3.new()
  14 | 
  15 | --[=[
  16 | 	@function fromHex
  17 | 	@within Hex
  18 | 
  19 | 	:::tip
  20 | 
  21 | 	You can use hex values in any format. This includes with or without
  22 | 	a leading hash, any case, and any length (`FromHex` will try to
  23 | 	interpret malformed hex codes as best as possible).
  24 | 
  25 | 	:::
  26 | 
  27 | 	@param hex string -- The hex string to convert.
  28 | 	@return Color3 -- The resulting Color3.
  29 | ]=]
  30 | local function FromHex(hex: string): Color3
  31 | 	Assert.typeOf("FromHex", "hex", "string", hex)
  32 | 
  33 | 	hex = gsub(hex, HEX_EXCLUDE_PATTERN, "")
  34 | 
  35 | 	if #hex == 3 then
  36 | 		local characters = split(hex, "")
  37 | 		local finalHex = ""
  38 | 
  39 | 		for _, character in ipairs(characters) do
  40 | 			finalHex ..= rep(character, 2)
  41 | 		end
  42 | 
  43 | 		hex = finalHex
  44 | 	elseif #hex < 6 then
  45 | 		hex = fmt("%s%s", hex, rep(hex, 6 - #hex))
  46 | 	end
  47 | 
  48 | 	local red = tonumber(sub(hex, 1, 2), 16)
  49 | 	local green = tonumber(sub(hex, 3, 4), 16)
  50 | 	local blue = tonumber(sub(hex, 5, 6), 16)
  51 | 
  52 | 	return ClampColor(Color3.fromRGB(red, green, blue))
  53 | end
  54 | 
  55 | --[=[
  56 | 	@function fromHexRGBA
  57 | 	@within Hex
  58 | 
  59 | 	Creates a Color3 from a hex string with an alpha value. The background
  60 | 	doesn't need to be specified, but the resulting Color3 will vary
  61 | 	depending on the color of the background, so it's recommended to
  62 | 	specify a background unless `Color3.new()` is what you want.
  63 | 
  64 | 	If the hex string is less than 8 characters, it will be passed to
  65 | 	`fromHex` and the resulting Color3 will be returned without transparency
  66 | 	applied.
  67 | 
  68 | 	Hex strings longer than 8 characters will be truncated to 8 characters
  69 | 	will be accepted. If the hex string is longer than 8 characters, the
  70 | 	last two characters will be used as the alpha value.
  71 | 
  72 | 	@param hex string -- The hex string to convert.
  73 | 	@param background Color3? -- The background color (defaults to black).
  74 | 	@return Color3 -- The resulting Color3.
  75 | ]=]
  76 | local function FromHexRGBA(hex: string, background: Color3?): Color3
  77 | 	Assert.typeOf("FromHexRGBA", "hex", "string", hex)
  78 | 
  79 | 	hex = gsub(hex, HEX_EXCLUDE_PATTERN, "")
  80 | 
  81 | 	if #hex < 8 then
  82 | 		return FromHex(hex)
  83 | 	end
  84 | 
  85 | 	local transparency = 1 - (tonumber(sub(hex, -2), 16) / 255)
  86 | 	local color = FromHex(sub(hex, 1, -3))
  87 | 
  88 | 	return Transparency(color, background or BACKGROUND_BASE_COLOR, transparency)
  89 | end
  90 | 
  91 | --[=[
  92 | 	@function toHex
  93 | 	@within Hex
  94 | 
  95 | 	:::note
  96 | 
  97 | 	The hex string is always lowercase, will always be 6 characters long, and
  98 | 	is not prefixed with a hash.
  99 | 
 100 | 	:::
 101 | 
 102 | 	@param color Color3 -- The color to convert.
 103 | 	@return string -- The hex representation of the color.
 104 | ]=]
 105 | local function ToHex(color: Color3): string
 106 | 	Assert.typeOf("ToHex", "color", "Color3", color)
 107 | 
 108 | 	local red = color.R * 255
 109 | 	local green = color.G * 255
 110 | 	local blue = color.B * 255
 111 | 
 112 | 	local hex = fmt(HEX_FORMAT_PATTERN, red, green, blue)
 113 | 
 114 | 	return hex
 115 | end
 116 | 
 117 | --[=[
 118 | 	@class Hex
 119 | ]=]
 120 | return {
 121 | 	fromHex = FromHex,
 122 | 	fromHexRGBA = FromHexRGBA,
 123 | 	toHex = ToHex,
 124 | }
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/HSL/init.lua`
<details>
<summary>View Source (117 lines)</summary>

```lua
   1 | local Assert = require(script.Parent.Util.Assert)
   2 | 
   3 | local round = math.round
   4 | local floor = math.floor
   5 | local clamp = math.clamp
   6 | local min = math.min
   7 | local max = math.max
   8 | local abs = math.abs
   9 | 
  10 | --[=[
  11 |   @interface HSL
  12 |   @within HSL
  13 |   .H number
  14 |   .S number
  15 |   .L number
  16 | ]=]
  17 | export type HSL = {
  18 | 	H: number,
  19 | 	S: number,
  20 | 	L: number,
  21 | }
  22 | 
  23 | --[=[
  24 |   @function toHSL
  25 |   @within HSL
  26 | 
  27 |   @param color Color3 -- The color to convert.
  28 |   @return HSL -- The HSL representation of the color.
  29 | ]=]
  30 | local function ToHSL(color: Color3): HSL
  31 | 	Assert.typeOf("ToHSL", "color", "Color3", color)
  32 | 
  33 | 	local channelMin = min(color.R, color.G, color.B)
  34 | 	local channelMax = max(color.R, color.G, color.B)
  35 | 	local delta = channelMax - channelMin
  36 | 
  37 | 	local hue = 0
  38 | 	local lightness = (channelMax + channelMin) / 2
  39 | 	local saturation = if delta == 0 then 0 else delta / (1 - abs(2 * lightness - 1))
  40 | 
  41 | 	if delta == 0 then
  42 | 		hue = 0
  43 | 	elseif channelMax == color.R then
  44 | 		hue = ((color.G - color.B) / delta) % 6
  45 | 	elseif channelMax == color.G then
  46 | 		hue = (color.B - color.R) / delta + 2
  47 | 	else
  48 | 		hue = (color.R - color.G) / delta + 4
  49 | 	end
  50 | 
  51 | 	hue = round(hue * 60)
  52 | 
  53 | 	if hue < 0 then
  54 | 		hue += 360
  55 | 	end
  56 | 
  57 | 	saturation = clamp(abs(round(saturation * 100)), 0, 100)
  58 | 	lightness = clamp(abs(round(lightness * 100)), 0, 100)
  59 | 
  60 | 	return {
  61 | 		H = hue,
  62 | 		S = saturation,
  63 | 		L = lightness,
  64 | 	}
  65 | end
  66 | 
  67 | --[=[
  68 |   @function fromHSL
  69 |   @within HSL
  70 | 
  71 |   @param hsl HSL -- The HSL color to convert.
  72 |   @return Color3 -- The resulting Color3.
  73 | ]=]
  74 | local function FromHSL(hsl: HSL): Color3
  75 | 	Assert.typeOf("FromHSL", "hsl", "table", hsl)
  76 | 
  77 | 	Assert.typeOf("FromHSL", "hsl.H", "number", hsl.H)
  78 | 	Assert.typeOf("FromHSL", "hsl.S", "number", hsl.S)
  79 | 	Assert.typeOf("FromHSL", "hsl.L", "number", hsl.L)
  80 | 
  81 | 	local saturation = hsl.S / 100
  82 | 	local lightness = hsl.L / 100
  83 | 
  84 | 	local c = (1 - abs(2 * lightness - 1)) * saturation
  85 | 	local x = c * (1 - abs((hsl.H / 60) % 2 - 1))
  86 | 	local m = lightness - c / 2
  87 | 
  88 | 	local red, green, blue = 0, 0, 0
  89 | 
  90 | 	if hsl.H >= 0 and hsl.H < 60 then
  91 | 		red, green, blue = c, x, 0
  92 | 	elseif hsl.H >= 60 and hsl.H < 120 then
  93 | 		red, green, blue = x, c, 0
  94 | 	elseif hsl.H >= 120 and hsl.H < 180 then
  95 | 		red, green, blue = 0, c, x
  96 | 	elseif hsl.H >= 180 and hsl.H < 240 then
  97 | 		red, green, blue = 0, x, c
  98 | 	elseif hsl.H >= 240 and hsl.H < 300 then
  99 | 		red, green, blue = x, 0, c
 100 | 	elseif hsl.H >= 300 and hsl.H < 360 then
 101 | 		red, green, blue = c, 0, x
 102 | 	end
 103 | 
 104 | 	red = min(floor((red + m) * 255), 255)
 105 | 	green = min(floor((green + m) * 255), 255)
 106 | 	blue = min(floor((blue + m) * 255), 255)
 107 | 
 108 | 	return Color3.fromRGB(red, green, blue)
 109 | end
 110 | 
 111 | --[=[
 112 |   @class HSL
 113 | ]=]
 114 | return {
 115 | 	fromHSL = FromHSL,
 116 | 	toHSL = ToHSL,
 117 | }
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/init.lua`
<details>
<summary>View Source (55 lines)</summary>

```lua
   1 | local deprecateWarnOnce = require(script.Util.DeprecateWarnOnce)
   2 | 
   3 | local GetContrastRatioCompat = require(script.GetContrastRatioCompat)
   4 | local WCAG = require(script.WCAG)
   5 | 
   6 | --[=[
   7 | 	@class ColorUtils
   8 | ]=]
   9 | local module = {
  10 | 	-- Methods --
  11 | 	Darken = require(script.Darken),
  12 | 	Desaturate = require(script.Desaturate),
  13 | 	Emphasize = require(script.Emphasize),
  14 | 	GetLuminance = require(script.GetLuminance),
  15 | 	GetPerceivedBrightness = require(script.GetPerceivedBrightness),
  16 | 	Invert = require(script.Invert),
  17 | 	isDark = require(script.isDark),
  18 | 	isLight = require(script.isLight),
  19 | 	Lighten = require(script.Lighten),
  20 | 	Rotate = require(script.Rotate),
  21 | 	Saturate = require(script.Saturate),
  22 | 
  23 | 	-- Submodules --
  24 | 	APCA = require(script.APCA),
  25 | 	Blend = require(script.Blend),
  26 | 	Blind = require(script.Blind),
  27 | 	Hex = require(script.Hex),
  28 | 	HSL = require(script.HSL),
  29 | 	Int = require(script.Int),
  30 | 	LAB = require(script.LAB),
  31 | 	LCH = require(script.LCH),
  32 | 	Palette = require(script.Palette),
  33 | 	WCAG = WCAG,
  34 | }
  35 | 
  36 | -- Deprecated methods --
  37 | module.Emphasise =
  38 | 	deprecateWarnOnce(module.Emphasize)("ColorUtils.Emphasise", "ColorUtils.Emphasize") :: typeof(module.Emphasize)
  39 | 
  40 | module.GetContrastingColor = deprecateWarnOnce(WCAG.GetContrastingColor)(
  41 | 	"ColorUtils.GetContrastingColor",
  42 | 	"WCAG.GetContrastingColor"
  43 | ) :: typeof(WCAG.GetContrastingColor)
  44 | 
  45 | module.GetContrastingColour = deprecateWarnOnce(module.GetContrastingColor)(
  46 | 	"ColorUtils.GetContrastingColour",
  47 | 	"WCAG.GetContrastingColor"
  48 | ) :: typeof(module.GetContrastingColor)
  49 | 
  50 | module.GetContrastRatio = deprecateWarnOnce(GetContrastRatioCompat)(
  51 | 	"ColorUtils.GetContrastRatio",
  52 | 	"WCAG.GetContrastRatio"
  53 | ) :: typeof(GetContrastRatioCompat)
  54 | 
  55 | return module
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/Int/init.lua`
<details>
<summary>View Source (50 lines)</summary>

```lua
   1 | local Assert = require(script.Parent.Util.Assert)
   2 | local ClampColor = require(script.Parent.Util.ClampColor)
   3 | 
   4 | local floor = math.floor
   5 | local rshift = bit32.rshift
   6 | local lshift = bit32.lshift
   7 | local band = bit32.band
   8 | 
   9 | --[=[
  10 | 	@function fromInt
  11 | 	@within Int
  12 | 
  13 | 	@param int number -- The integer to convert.
  14 | 	@return Color3 -- The resulting Color3.
  15 | ]=]
  16 | local function FromInt(int: number): Color3
  17 | 	Assert.typeOf("FromInt", "int", "number", int)
  18 | 	int = floor(int)
  19 | 
  20 | 	local red = band(rshift(int, 16), 255)
  21 | 	local green = band(rshift(int, 8), 255)
  22 | 	local blue = band(int, 255)
  23 | 
  24 | 	return ClampColor(Color3.fromRGB(red, green, blue))
  25 | end
  26 | 
  27 | --[=[
  28 | 	@function toInt
  29 | 	@within Int
  30 | 
  31 | 	@param color Color3 -- The color to convert.
  32 | 	@return number -- The integer representation of the color.
  33 | ]=]
  34 | local function ToInt(color: Color3): number
  35 | 	Assert.typeOf("ToInt", "color", "Color3", color)
  36 | 
  37 | 	local int = floor(color.R * 255)
  38 | 	int = lshift(int, 8) + floor(color.G * 255)
  39 | 	int = lshift(int, 8) + floor(color.B * 255)
  40 | 
  41 | 	return int
  42 | end
  43 | 
  44 | --[=[
  45 | 	@class Int
  46 | ]=]
  47 | return {
  48 | 	fromInt = FromInt,
  49 | 	toInt = ToInt,
  50 | }
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/Invert.lua`
<details>
<summary>View Source (18 lines)</summary>

```lua
   1 | local Assert = require(script.Parent.Util.Assert)
   2 | local ClampColor = require(script.Parent.Util.ClampColor)
   3 | local assertTypeOf = Assert.prepTypeOf("Invert")
   4 | 
   5 | --[=[
   6 | 	@function Invert
   7 | 	@within ColorUtils
   8 | 
   9 | 	@param color Color3 -- The color to invert.
  10 | 	@return Color3 -- The inverted color.
  11 | ]=]
  12 | return function(color: Color3): Color3
  13 | 	assertTypeOf("color", "Color3", color)
  14 | 
  15 | 	local inverse = Color3.new(1 - color.R, 1 - color.G, 1 - color.B)
  16 | 
  17 | 	return ClampColor(inverse)
  18 | end
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/isDark.lua`
<details>
<summary>View Source (17 lines)</summary>

```lua
   1 | local Assert = require(script.Parent.Util.Assert)
   2 | local assertTypeOf = Assert.prepTypeOf("isDark")
   3 | 
   4 | local GetLuminance = require(script.Parent.GetLuminance)
   5 | 
   6 | --[=[
   7 | 	@function isDark
   8 | 	@within ColorUtils
   9 | 
  10 | 	@param color Color3 -- The color to check.
  11 | 	@return boolean -- Whether the color is dark.
  12 | ]=]
  13 | return function(color: Color3): boolean
  14 | 	assertTypeOf("color", "Color3", color)
  15 | 
  16 | 	return GetLuminance(color) < 0.5
  17 | end
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/isLight.lua`
<details>
<summary>View Source (17 lines)</summary>

```lua
   1 | local Assert = require(script.Parent.Util.Assert)
   2 | local assertTypeOf = Assert.prepTypeOf("isLight")
   3 | 
   4 | local isDark = require(script.Parent.isDark)
   5 | 
   6 | --[=[
   7 | 	@function isLight
   8 | 	@within ColorUtils
   9 | 
  10 | 	@param color Color3 -- The color to check.
  11 | 	@return boolean -- Whether the color is light.
  12 | ]=]
  13 | return function(color: Color3): boolean
  14 | 	assertTypeOf("color", "Color3", color)
  15 | 
  16 | 	return not isDark(color)
  17 | end
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/LAB/Constants.lua`
<details>
<summary>View Source (25 lines)</summary>

```lua
   1 | --[=[
   2 |   @interface LAB
   3 |   @within LAB
   4 |   .L number
   5 |   .A number
   6 |   .B number
   7 | ]=]
   8 | export type LAB = {
   9 | 	L: number,
  10 | 	A: number,
  11 | 	B: number,
  12 | }
  13 | 
  14 | return {
  15 | 	Kn = 18,
  16 | 
  17 | 	Xn = 0.950470,
  18 | 	Yn = 1,
  19 | 	Zn = 1.088830,
  20 | 
  21 | 	t0 = 0.137931034,
  22 | 	t1 = 0.206896552,
  23 | 	t2 = 0.12841855,
  24 | 	t3 = 0.008856452,
  25 | }
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/LAB/FromLAB.lua`
<details>
<summary>View Source (43 lines)</summary>

```lua
   1 | local Assert = require(script.Parent.Parent.Util.Assert)
   2 | local isNaN = require(script.Parent.Parent.Util.isNaN)
   3 | 
   4 | local CONST = require(script.Parent.Constants)
   5 | 
   6 | local function XYZ_RGB(value: number): number
   7 | 	return 255 * (if value <= 0.00304 then 12.92 * value else 1.055 * value ^ (1 / 2.4) - 0.055)
   8 | end
   9 | 
  10 | local function LAB_XYZ(value: number): number
  11 | 	return if value > CONST.t1 then value ^ 3 else CONST.t2 * (value - CONST.t0)
  12 | end
  13 | 
  14 | --[=[
  15 |   @function fromLAB
  16 |   @within LAB
  17 | 
  18 |   @param lab LAB -- The color to convert.
  19 |   @return Color3 -- The converted color.
  20 | ]=]
  21 | local function FromLAB(lab: CONST.LAB): Color3
  22 | 	Assert.typeOf("FromLAB", "lab", "table", lab)
  23 | 
  24 | 	Assert.typeOf("FromLAB", "lab.L", "number", lab.L)
  25 | 	Assert.typeOf("FromLAB", "lab.A", "number", lab.A)
  26 | 	Assert.typeOf("FromLAB", "lab.B", "number", lab.B)
  27 | 
  28 | 	local y = (lab.L + 16) / 116
  29 | 	local x = if isNaN(lab.A) then y else y + lab.A / 500
  30 | 	local z = if isNaN(lab.B) then y else y - lab.B / 200
  31 | 
  32 | 	y = CONST.Yn * LAB_XYZ(y)
  33 | 	x = CONST.Xn * LAB_XYZ(x)
  34 | 	z = CONST.Zn * LAB_XYZ(z)
  35 | 
  36 | 	local red = XYZ_RGB(3.2404542 * x - 1.5371385 * y - 0.4985314 * z)
  37 | 	local green = XYZ_RGB(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z)
  38 | 	local blue = XYZ_RGB(0.0556434 * x - 0.2040259 * y + 1.0572252 * z)
  39 | 
  40 | 	return Color3.fromRGB(red, green, blue)
  41 | end
  42 | 
  43 | return FromLAB
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/LAB/init.lua`
<details>
<summary>View Source (12 lines)</summary>

```lua
   1 | local CONST = require(script.Constants)
   2 | 
   3 | export type LAB = CONST.LAB
   4 | 
   5 | --[=[
   6 | 	@class LAB
   7 | ]=]
   8 | return {
   9 | 	fromLAB = require(script.FromLAB),
  10 | 	toLAB = require(script.ToLAB),
  11 | 	Lerp = require(script.Lerp),
  12 | }
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/LAB/Lerp.lua`
<details>
<summary>View Source (31 lines)</summary>

```lua
   1 | --!strict
   2 | local convertFromLAB = require(script.Parent.FromLAB)
   3 | local convertToLAB = require(script.Parent.ToLAB)
   4 | 
   5 | --[=[
   6 | 	@function Lerp
   7 | 	@within LAB
   8 | 
   9 | 	Interpolates between two Color3s using the CIELAB color space.
  10 | 
  11 | 	@param from Color3 -- The color to interpolate from.
  12 | 	@param to Color3 -- The color to interpolate to.
  13 | 	@param alpha number -- The amount to interpolate by (typically between 0-1).
  14 | 	@return Color3 -- The resulting color.
  15 | ]=]
  16 | local function lerp(from: Color3, to: Color3, alpha: number): Color3
  17 | 	assert(typeof(from) == "Color3", `Lerp(...): Expected "from" to be a Color3, got {typeof(from)}`)
  18 | 	assert(typeof(to) == "Color3", `Lerp(...): Expected "to" to be a Color3, got {typeof(to)}`)
  19 | 	assert(typeof(alpha) == "number", `Lerp(...): Expected "alpha" to be a number, got {typeof(alpha)}`)
  20 | 
  21 | 	local fromLAB = convertToLAB(from)
  22 | 	local toLAB = convertToLAB(to)
  23 | 
  24 | 	local L = fromLAB.L * (1 - alpha) + toLAB.L * alpha
  25 | 	local A = fromLAB.A * (1 - alpha) + toLAB.A * alpha
  26 | 	local B = fromLAB.B * (1 - alpha) + toLAB.B * alpha
  27 | 
  28 | 	return convertFromLAB({ L = L, A = A, B = B })
  29 | end
  30 | 
  31 | return lerp
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/LAB/ToLAB.lua`
<details>
<summary>View Source (52 lines)</summary>

```lua
   1 | local Assert = require(script.Parent.Parent.Util.Assert)
   2 | local CONST = require(script.Parent.Constants)
   3 | 
   4 | local function RGB_XYZ(value: number): number
   5 | 	if value <= 0.04045 then
   6 | 		return value / 12.92
   7 | 	end
   8 | 
   9 | 	return ((value + 0.055) / 1.055) ^ 2.4
  10 | end
  11 | 
  12 | local function XYZ_LAB(value: number): number
  13 | 	if value > CONST.t3 then
  14 | 		return value ^ (1 / 3)
  15 | 	end
  16 | 
  17 | 	return value / CONST.t2 + CONST.t0
  18 | end
  19 | 
  20 | local function ToVector3(color: Color3): Vector3
  21 | 	local red = RGB_XYZ(color.R)
  22 | 	local green = RGB_XYZ(color.G)
  23 | 	local blue = RGB_XYZ(color.B)
  24 | 
  25 | 	return Vector3.new(
  26 | 		XYZ_LAB((0.4124564 * red + 0.3575761 * green + 0.1804375 * blue) / CONST.Xn),
  27 | 		XYZ_LAB((0.2126729 * red + 0.7151522 * green + 0.0721750 * blue) / CONST.Yn),
  28 | 		XYZ_LAB((0.0193339 * red + 0.1191920 * green + 0.9503041 * blue) / CONST.Zn)
  29 | 	)
  30 | end
  31 | 
  32 | --[=[
  33 |   @function toLAB
  34 |   @within LAB
  35 | 
  36 |   @param color Color3 -- The color to convert.
  37 |   @return LAB -- The converted color.
  38 | ]=]
  39 | local function ToLAB(color: Color3): CONST.LAB
  40 | 	Assert.typeOf("ToLAB", "color", "Color3", color)
  41 | 
  42 | 	local vector = ToVector3(color)
  43 | 	local l = 116 * vector.Y - 16
  44 | 
  45 | 	return {
  46 | 		L = if l < 0 then 0 else l,
  47 | 		A = 500 * (vector.X - vector.Y),
  48 | 		B = 200 * (vector.Y - vector.Z),
  49 | 	}
  50 | end
  51 | 
  52 | return ToLAB
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/LCH/Constants.lua`
<details>
<summary>View Source (11 lines)</summary>

```lua
   1 | export type LCH = {
   2 | 	L: number,
   3 | 	C: number,
   4 | 	H: number,
   5 | }
   6 | 
   7 | return {
   8 | 	DEG_RAD = math.rad(1),
   9 | 	RAD_DEG = math.deg(1),
  10 | 	NaN = 0 / 0,
  11 | }
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/LCH/FromLCH.lua`
<details>
<summary>View Source (42 lines)</summary>

```lua
   1 | local Assert = require(script.Parent.Parent.Util.Assert)
   2 | local isNaN = require(script.Parent.Parent.Util.isNaN)
   3 | 
   4 | local CONST = require(script.Parent.Constants)
   5 | local LAB = require(script.Parent.Parent.LAB)
   6 | 
   7 | local sin = math.sin
   8 | local cos = math.cos
   9 | 
  10 | local function LCHtoLAB(lch: CONST.LCH): LAB.LAB
  11 | 	if isNaN(lch.H) then
  12 | 		lch.H = 0
  13 | 	end
  14 | 
  15 | 	lch.H *= CONST.DEG_RAD
  16 | 
  17 | 	return {
  18 | 		L = lch.L,
  19 | 		A = cos(lch.H) * lch.C,
  20 | 		B = sin(lch.H) * lch.C,
  21 | 	}
  22 | end
  23 | 
  24 | --[=[
  25 | 	@function fromLCH
  26 | 	@within LCH
  27 | 
  28 | 	@param lch LCH -- The color to convert.
  29 | 	@return Color3 -- The converted color.
  30 | ]=]
  31 | local function FromLCH(lch: CONST.LCH): Color3
  32 | 	Assert.typeOf("FromLCH", "lch", "table", lch)
  33 | 
  34 | 	Assert.typeOf("FromLCH", "lch.L", "number", lch.L)
  35 | 	Assert.typeOf("FromLCH", "lch.C", "number", lch.C)
  36 | 	Assert.typeOf("FromLCH", "lch.H", "number", lch.H)
  37 | 
  38 | 	local lab = LCHtoLAB(lch)
  39 | 	return LAB.fromLAB(lab)
  40 | end
  41 | 
  42 | return FromLCH
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/LCH/init.lua`
<details>
<summary>View Source (11 lines)</summary>

```lua
   1 | local CONST = require(script.Constants)
   2 | 
   3 | export type LCH = CONST.LCH
   4 | 
   5 | --[=[
   6 |   @class LCH
   7 | ]=]
   8 | return {
   9 | 	toLCH = require(script.ToLCH),
  10 | 	fromLCH = require(script.FromLCH),
  11 | }
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/LCH/ToLCH.lua`
<details>
<summary>View Source (39 lines)</summary>

```lua
   1 | local Assert = require(script.Parent.Parent.Util.Assert)
   2 | local LAB = require(script.Parent.Parent.LAB)
   3 | 
   4 | local CONST = require(script.Parent.Constants)
   5 | 
   6 | local round = math.round
   7 | local atan2 = math.atan2
   8 | local sqrt = math.sqrt
   9 | 
  10 | local function LABtoLCH(lab: LAB.LAB): CONST.LCH
  11 | 	local c = sqrt(lab.A ^ 2 + lab.B ^ 2)
  12 | 	local h = (atan2(lab.B, lab.A) * CONST.RAD_DEG + 360) % 360
  13 | 
  14 | 	if round(c * 10000) == 0 then
  15 | 		h = CONST.NaN
  16 | 	end
  17 | 
  18 | 	return {
  19 | 		L = lab.L,
  20 | 		C = c,
  21 | 		H = h,
  22 | 	}
  23 | end
  24 | 
  25 | --[=[
  26 | 	@function toLCH
  27 | 	@within LCH
  28 | 
  29 | 	@param color Color3 -- The color to convert.
  30 | 	@return LCH -- The converted color.
  31 | ]=]
  32 | local function ToLCH(color: Color3): CONST.LCH
  33 | 	Assert.typeOf("ToLCH", "color", "Color3", color)
  34 | 
  35 | 	local lab = LAB.toLAB(color)
  36 | 	return LABtoLCH(lab)
  37 | end
  38 | 
  39 | return ToLCH
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/Lighten.lua`
<details>
<summary>View Source (19 lines)</summary>

```lua
   1 | local Assert = require(script.Parent.Util.Assert)
   2 | local assertTypeOf = Assert.prepTypeOf("Lighten")
   3 | 
   4 | local clampColor = require(script.Parent.Util.ClampColor)
   5 | 
   6 | --[=[
   7 | 	@function Lighten
   8 | 	@within ColorUtils
   9 | 
  10 | 	@param color Color3 -- The color to lighten.
  11 | 	@param coefficient number -- The amount to lighten by [0-1].
  12 | 	@return Color3 -- The lightened color.
  13 | ]=]
  14 | return function(color: Color3, coefficient: number): Color3
  15 | 	assertTypeOf("color", "Color3", color)
  16 | 	assertTypeOf("coefficient", "number", coefficient)
  17 | 
  18 | 	return clampColor(color:Lerp(Color3.new(1, 1, 1), coefficient))
  19 | end
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/Palette/Analogous.lua`
<details>
<summary>View Source (23 lines)</summary>

```lua
   1 | local Assert = require(script.Parent.Parent.Util.Assert)
   2 | local Rotate = require(script.Parent.Parent.Rotate)
   3 | local Types = require(script.Parent.Parent.Util.Types)
   4 | 
   5 | local assertTypeOf = Assert.prepTypeOf("Analogous")
   6 | 
   7 | type Array<T> = Types.Array<T>
   8 | 
   9 | --[=[
  10 | 	@function Analogous
  11 | 	@within Palette
  12 | 
  13 | 	@param base Color3 -- The base color.
  14 | 	@return {Color3} -- The analogous colors.
  15 | ]=]
  16 | return function(base: Color3): Array<Color3>
  17 | 	assertTypeOf("base", "Color3", base)
  18 | 
  19 | 	return {
  20 | 		Rotate(base, -30),
  21 | 		Rotate(base, 30),
  22 | 	}
  23 | end
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/Palette/Complementary.lua`
<details>
<summary>View Source (22 lines)</summary>

```lua
   1 | local Assert = require(script.Parent.Parent.Util.Assert)
   2 | local Rotate = require(script.Parent.Parent.Rotate)
   3 | local Types = require(script.Parent.Parent.Util.Types)
   4 | 
   5 | local assertTypeOf = Assert.prepTypeOf("Complementary")
   6 | 
   7 | type Array<T> = Types.Array<T>
   8 | 
   9 | --[=[
  10 | 	@function Complementary
  11 | 	@within Palette
  12 | 
  13 | 	@param base Color3 -- The base color.
  14 | 	@return {Color3} -- The complementary colors.
  15 | ]=]
  16 | return function(base: Color3): Array<Color3>
  17 | 	assertTypeOf("base", "Color3", base)
  18 | 
  19 | 	return {
  20 | 		Rotate(base, 180),
  21 | 	}
  22 | end
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/Palette/init.lua`
<details>
<summary>View Source (14 lines)</summary>

```lua
   1 | --[=[
   2 | 	@class Palette
   3 | ]=]
   4 | return {
   5 | 	Analogous = require(script.Analogous),
   6 | 	Complementary = require(script.Complementary),
   7 | 	Monochromatic = require(script.Monochromatic),
   8 | 	Nearest = require(script.Nearest),
   9 | 	SplitComplementary = require(script.SplitComplementary),
  10 | 	Tailwind = require(script.Tailwind),
  11 | 	Tetradic = require(script.Tetradic),
  12 | 	Triadic = require(script.Triadic),
  13 | 	Vibrant = require(script.Vibrant),
  14 | }
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/Palette/Monochromatic.lua`
<details>
<summary>View Source (42 lines)</summary>

```lua
   1 | local Assert = require(script.Parent.Parent.Util.Assert)
   2 | 
   3 | local assertTypeOf = Assert.prepTypeOf("Monochromatic")
   4 | local assertEvalArg = Assert.prepEvalArg("Monochromatic")
   5 | 
   6 | local push = table.insert
   7 | local floor = math.floor
   8 | local sort = table.sort
   9 | 
  10 | --[=[
  11 | 	@function Monochromatic
  12 | 	@within Palette
  13 | 
  14 | 	@param base Color3 -- The base color.
  15 | 	@param swatches number -- The number of swatches to generate.
  16 | 	@return {Color3} -- The monochromatic colors.
  17 | ]=]
  18 | return function(base: Color3, swatches: number?): { Color3 }
  19 | 	swatches = swatches or 3
  20 | 
  21 | 	assertTypeOf("base", "Color3", base)
  22 | 	assertTypeOf("swatches", "number", swatches)
  23 | 
  24 | 	swatches = floor(swatches)
  25 | 	assertEvalArg("swatches", "be greater than 0", swatches > 0, swatches)
  26 | 
  27 | 	local h, s, v = base:ToHSV()
  28 | 	local increment = 1 / swatches
  29 | 
  30 | 	local colors = {}
  31 | 
  32 | 	for _ = 1, swatches do
  33 | 		push(colors, Color3.fromHSV(h, s, v))
  34 | 		v = (v + increment) % 1
  35 | 	end
  36 | 
  37 | 	sort(colors, function(a, b)
  38 | 		return select(3, a:ToHSV()) < select(3, b:ToHSV())
  39 | 	end)
  40 | 
  41 | 	return colors
  42 | end
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/Palette/Nearest.lua`
<details>
<summary>View Source (42 lines)</summary>

```lua
   1 | --!strict
   2 | --[=[
   3 | 	@function Nearest
   4 | 	@within Palette
   5 | 
   6 | 	Given an array of Color3s, returns the color that is closest to the given Color3.
   7 | 
   8 | 	@param to Color3 -- The color to find the nearest color to.
   9 | 	@param colors { Color3 } -- The array of colors to search through.
  10 | 	@return Color3 -- The nearest color.
  11 | ]=]
  12 | local function nearest(to: Color3, colors: { Color3 }): Color3
  13 | 	assert(typeof(to) == "Color3", `Nearest(...): Expected "to" to be a Color3, got "{to}" ({typeof(to)})`)
  14 | 
  15 | 	local smallestMagnitude: number = math.huge
  16 | 	local nearestColor: Color3 = nil
  17 | 	local didWarn = false
  18 | 
  19 | 	for index, color in colors do
  20 | 		if typeof(color) ~= "Color3" then
  21 | 			if didWarn == false then
  22 | 				warn(
  23 | 					`Nearest(...): Expected "colors" to be an array of Color3, got "{color}" ({typeof(color)}) at index #{index}`
  24 | 				)
  25 | 				didWarn = true
  26 | 			end
  27 | 
  28 | 			continue
  29 | 		end
  30 | 
  31 | 		local magnitude = math.sqrt((color.R - to.R) ^ 2 + (color.G - to.G) ^ 2 + (color.B - to.B) ^ 2)
  32 | 
  33 | 		if magnitude < smallestMagnitude then
  34 | 			smallestMagnitude = magnitude
  35 | 			nearestColor = color
  36 | 		end
  37 | 	end
  38 | 
  39 | 	return nearestColor
  40 | end
  41 | 
  42 | return nearest
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/Palette/SplitComplementary.lua`
<details>
<summary>View Source (23 lines)</summary>

```lua
   1 | local Assert = require(script.Parent.Parent.Util.Assert)
   2 | local Rotate = require(script.Parent.Parent.Rotate)
   3 | local Types = require(script.Parent.Parent.Util.Types)
   4 | 
   5 | local assertTypeOf = Assert.prepTypeOf("SplitComplementary")
   6 | 
   7 | type Array<T> = Types.Array<T>
   8 | 
   9 | --[=[
  10 | 	@function SplitComplementary
  11 | 	@within Palette
  12 | 
  13 | 	@param base Color3 -- The base color.
  14 | 	@return {Color3} -- The split complementary colors.
  15 | ]=]
  16 | return function(base: Color3): Array<Color3>
  17 | 	assertTypeOf("base", "Color3", base)
  18 | 
  19 | 	return {
  20 | 		Rotate(base, 180 - 30),
  21 | 		Rotate(base, 180 + 30),
  22 | 	}
  23 | end
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/Palette/Tailwind.lua`
<details>
<summary>View Source (90 lines)</summary>

```lua
   1 | local Array = require(script.Parent.Parent.Util.Array)
   2 | local Assert = require(script.Parent.Parent.Util.Assert)
   3 | local Types = require(script.Parent.Parent.Util.Types)
   4 | 
   5 | local HSL = require(script.Parent.Parent.HSL)
   6 | local Saturate = require(script.Parent.Parent.Saturate)
   7 | 
   8 | local assertTypeOf = Assert.prepTypeOf("Tailwind")
   9 | 
  10 | local tfind = table.find
  11 | local abs = math.abs
  12 | 
  13 | local SATURATION_MAP = { 0.32, 0.16, 0.08, 0.04, 0, 0, 0.04, 0.08, 0.16, 0.32, 0.84 }
  14 | local LIGHTNESS_MAP = { 0.95, 0.85, 0.75, 0.65, 0.55, 0.45, 0.35, 0.25, 0.15, 0.1, 0.05 }
  15 | 
  16 | --[=[
  17 | 	@interface TailwindPalette
  18 | 	@within Palette
  19 | 	.50 Color3
  20 | 	.100 Color3
  21 | 	.200 Color3
  22 | 	.300 Color3
  23 | 	.400 Color3
  24 | 	.500 Color3
  25 | 	.600 Color3
  26 | 	.700 Color3
  27 | 	.800 Color3
  28 | 	.900 Color3
  29 | 	.950 Color3
  30 | ]=]
  31 | export type TailwindPalette = Types.Dictionary<number, Color3>
  32 | 
  33 | local function GetBaseColorSaturationIndex(hsl: HSL.HSL): number
  34 | 	local goal = hsl.L / 100
  35 | 
  36 | 	local closestLightness = Array.reduce(LIGHTNESS_MAP, function(previous, current)
  37 | 		return if abs(current - goal) < abs(previous - goal) then current else previous
  38 | 	end)
  39 | 
  40 | 	return tfind(LIGHTNESS_MAP, closestLightness)
  41 | end
  42 | 
  43 | --[=[
  44 | 	@function Tailwind
  45 | 	@within Palette
  46 | 
  47 | 	Generates a TailwindCSS-like palette from a given base color. The generator is
  48 | 	based on Smart Swatch by Ivan Dalmet, so results will not be identical to
  49 | 	TailwindCSS.
  50 | 
  51 | 	@param base Color3 -- The base color.
  52 | 	@return TailwindPalette -- The generated palette.
  53 | 
  54 | 	```lua
  55 | 	local BASE_COLOR = Color3.fromHex("#00a2ff")
  56 | 	local palette = Tailwind(BASE_COLOR)
  57 | 	```
  58 | 
  59 | 	![Tailwind palette](/media/tailwind-palette.png)
  60 | ]=]
  61 | local function Tailwind(base: Color3): TailwindPalette
  62 | 	assertTypeOf("base", "Color3", base)
  63 | 
  64 | 	local hsl = HSL.toHSL(base)
  65 | 	local satIndex = GetBaseColorSaturationIndex(hsl)
  66 | 
  67 | 	local colors = Array.map(
  68 | 		Array.map(LIGHTNESS_MAP, function(lightness: number)
  69 | 			return HSL.fromHSL({ H = hsl.H, S = hsl.S, L = lightness * 100 })
  70 | 		end),
  71 | 		function(color: Color3, index)
  72 | 			local satDelta = SATURATION_MAP[index] - SATURATION_MAP[satIndex]
  73 | 			return Saturate(color, satDelta)
  74 | 		end
  75 | 	)
  76 | 
  77 | 	return Array.reduce(colors, function(accumulator, color: Color3, index)
  78 | 		local key = if index == 1 then 50 else (index - 1) * 100
  79 | 
  80 | 		if index == #colors then
  81 | 			key -= 50
  82 | 		end
  83 | 
  84 | 		accumulator[key] = color
  85 | 
  86 | 		return accumulator
  87 | 	end, {})
  88 | end
  89 | 
  90 | return Tailwind
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/Palette/Tetradic.lua`
<details>
<summary>View Source (24 lines)</summary>

```lua
   1 | local Assert = require(script.Parent.Parent.Util.Assert)
   2 | local Rotate = require(script.Parent.Parent.Rotate)
   3 | local Types = require(script.Parent.Parent.Util.Types)
   4 | 
   5 | local assertTypeOf = Assert.prepTypeOf("Tetradic")
   6 | 
   7 | type Array<T> = Types.Array<T>
   8 | 
   9 | --[=[
  10 | 	@function Tetradic
  11 | 	@within Palette
  12 | 
  13 | 	@param base Color3 -- The base color.
  14 | 	@return {Color3} -- The tetradic colors.
  15 | ]=]
  16 | return function(base: Color3): Array<Color3>
  17 | 	assertTypeOf("base", "Color3", base)
  18 | 
  19 | 	return {
  20 | 		Rotate(base, -180),
  21 | 		Rotate(base, -120),
  22 | 		Rotate(base, -300),
  23 | 	}
  24 | end
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/Palette/Triadic.lua`
<details>
<summary>View Source (23 lines)</summary>

```lua
   1 | local Assert = require(script.Parent.Parent.Util.Assert)
   2 | local Rotate = require(script.Parent.Parent.Rotate)
   3 | local Types = require(script.Parent.Parent.Util.Types)
   4 | 
   5 | local assertTypeOf = Assert.prepTypeOf("Triadic")
   6 | 
   7 | type Array<T> = Types.Array<T>
   8 | 
   9 | --[=[
  10 | 	@function Triadic
  11 | 	@within Palette
  12 | 
  13 | 	@param base Color3 -- The base color.
  14 | 	@return {Color3} -- The triadic colors.
  15 | ]=]
  16 | return function(base: Color3): Array<Color3>
  17 | 	assertTypeOf("base", "Color3", base)
  18 | 
  19 | 	return {
  20 | 		Rotate(base, 180 - 60),
  21 | 		Rotate(base, 180 + 60),
  22 | 	}
  23 | end
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/Palette/Vibrant.lua`
<details>
<summary>View Source (76 lines)</summary>

```lua
   1 | local Assert = require(script.Parent.Parent.Util.Assert)
   2 | local GetLuminance = require(script.Parent.Parent.GetLuminance)
   3 | local Schema = require(script.Parent.Parent.Util.Schema)
   4 | local Types = require(script.Parent.Parent.Util.Types)
   5 | 
   6 | local assertArrayOf = Assert.prepArrayOf("Vibrant")
   7 | 
   8 | local abs = math.abs
   9 | local sqrt = math.sqrt
  10 | local toHSV = Color3.toHSV
  11 | 
  12 | type Array<T> = Types.Array<T>
  13 | 
  14 | export type VibrantOptions = {
  15 | 	TargetLuminance: number,
  16 | 	TargetSaturation: number,
  17 | 	TargetValue: number,
  18 | }
  19 | 
  20 | --[=[
  21 | 	@interface VibrantOptions
  22 | 	@within Palette
  23 | 	.TargetLuminance number -- The target luminance.
  24 | 	.TargetSaturation number -- The target saturation.
  25 | 	.TargetValue number -- The target value.
  26 | ]=]
  27 | local DEFAULT_OPTIONS: VibrantOptions = {
  28 | 	TargetLuminance = 0.49,
  29 | 	TargetSaturation = 1,
  30 | 	TargetValue = 0.8,
  31 | }
  32 | 
  33 | --[=[
  34 | 	@function Vibrant
  35 | 	@within Palette
  36 | 
  37 | 	The default options are:
  38 | 
  39 | 	```lua
  40 | 	{
  41 | 		TargetLuminance = 0.49,
  42 | 		TargetSaturation = 1,
  43 | 		TargetValue = 0.8,
  44 | 	}
  45 | 	```
  46 | 
  47 | 	@param swatches {Color3} -- The swatches to select from.
  48 | 	@param options? VibrantOptions -- The options to use.
  49 | 	@return Color3 -- The "most vibrant" color.
  50 | ]=]
  51 | return function(swatches: Array<Color3>, options: VibrantOptions?): Color3
  52 | 	assertArrayOf("swatches", "Color3", swatches)
  53 | 
  54 | 	options = Schema.Loose(DEFAULT_OPTIONS, options) :: VibrantOptions
  55 | 
  56 | 	local vibrant: Color3 = nil
  57 | 	local distance = math.huge
  58 | 
  59 | 	for _, swatch in ipairs(swatches) do
  60 | 		local _, sat, val = toHSV(swatch)
  61 | 		local lum = GetLuminance(swatch)
  62 | 
  63 | 		local deltaSat = abs(sat - options.TargetSaturation)
  64 | 		local deltaVal = abs(val - options.TargetValue)
  65 | 		local deltaLum = abs(lum - options.TargetLuminance)
  66 | 
  67 | 		local dist = sqrt((deltaSat ^ 2) + (deltaVal ^ 2) + (deltaLum ^ 2))
  68 | 
  69 | 		if dist < distance then
  70 | 			distance = dist
  71 | 			vibrant = swatch
  72 | 		end
  73 | 	end
  74 | 
  75 | 	return vibrant
  76 | end
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/Rotate.lua`
<details>
<summary>View Source (25 lines)</summary>

```lua
   1 | local Assert = require(script.Parent.Util.Assert)
   2 | local clampColor = require(script.Parent.Util.ClampColor)
   3 | 
   4 | local assertTypeOf = Assert.prepTypeOf("Rotate")
   5 | local clamp = math.clamp
   6 | 
   7 | --[=[
   8 | 	@function Rotate
   9 | 	@within ColorUtils
  10 | 
  11 | 	@param color Color3 -- The color to rotate.
  12 | 	@param angle number -- The angle to rotate by.
  13 | 	@return Color3 -- The rotated color.
  14 | ]=]
  15 | return function(color: Color3, angle: number): Color3
  16 | 	assertTypeOf("color", "Color3", color)
  17 | 	assertTypeOf("angle", "number", angle)
  18 | 
  19 | 	local hue, sat, val = color:ToHSV()
  20 | 	local newHue = clamp((hue + (angle / 360)) % 1, 0, 1)
  21 | 
  22 | 	local newColor = Color3.fromHSV(newHue, sat, val)
  23 | 
  24 | 	return clampColor(newColor)
  25 | end
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/Saturate.lua`
<details>
<summary>View Source (24 lines)</summary>

```lua
   1 | local Assert = require(script.Parent.Util.Assert)
   2 | local ClampColor = require(script.Parent.Util.ClampColor)
   3 | 
   4 | local assertTypeOf = Assert.prepTypeOf("Saturate")
   5 | 
   6 | local clamp = math.clamp
   7 | 
   8 | --[=[
   9 |   @function Saturate
  10 |   @within ColorUtils
  11 | 
  12 |   @param color Color3 -- The color to saturate.
  13 |   @param coefficient number -- The coefficient to saturate by [0-1].
  14 |   @return Color3 -- The saturated color.
  15 | ]=]
  16 | return function(color: Color3, coefficient: number): Color3
  17 | 	assertTypeOf("color", "Color3", color)
  18 | 	assertTypeOf("coefficient", "number", coefficient)
  19 | 
  20 | 	local H, S, V = color:ToHSV()
  21 | 	S += S * coefficient
  22 | 
  23 | 	return ClampColor(Color3.fromHSV(H, clamp(S, 0, 1), V))
  24 | end
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/Util/Array.lua`
<details>
<summary>View Source (38 lines)</summary>

```lua
   1 | local push = table.insert
   2 | 
   3 | local function map<T>(array: { T }, mapper: (T?, number?) -> T?): { T }
   4 | 	local mapped = {}
   5 | 
   6 | 	for index, value in ipairs(array) do
   7 | 		local mappedValue = mapper(value, index)
   8 | 
   9 | 		if mappedValue ~= nil then
  10 | 			push(mapped, mappedValue)
  11 | 		end
  12 | 	end
  13 | 
  14 | 	return mapped
  15 | end
  16 | 
  17 | local function reduce<T>(
  18 | 	array: { T },
  19 | 	reducer: (({ T } | T)?, T?, number?) -> { T } | T,
  20 | 	initialValue: ({ T } | T)?
  21 | ): { T } | T
  22 | 	local result, start = initialValue, 1
  23 | 
  24 | 	if not result then
  25 | 		result, start = array[1], 2
  26 | 	end
  27 | 
  28 | 	for index = start, #array do
  29 | 		result = reducer(result, array[index], index)
  30 | 	end
  31 | 
  32 | 	return result
  33 | end
  34 | 
  35 | return {
  36 | 	map = map,
  37 | 	reduce = reduce,
  38 | }
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/Util/Assert.lua`
<details>
<summary>View Source (65 lines)</summary>

```lua
   1 | local Assert = {}
   2 | 
   3 | local fmt = string.format
   4 | 
   5 | type Array = { [number]: any }
   6 | 
   7 | Assert.TYPE = {
   8 | 	INVALID_TYPE = "%s(...): The `%s` argument must be a %s, but you passed %q (%s)",
   9 | 	INVALID_ARRAY = "%s(...): The `%s` argument must be an array of %s, but you passed %q (%s) at index #%d",
  10 | 	INVALID_EVAL_ARG = "%s(...): The `%s` argument must %s, but you passed %q (%s)",
  11 | }
  12 | 
  13 | function Assert.typeOf<T>(methodName: string, argName: string, class: string, value: T?): T
  14 | 	local errorText = fmt(Assert.TYPE.INVALID_TYPE, methodName, argName, class, tostring(value), typeof(value))
  15 | 
  16 | 	if typeof(value) ~= class then
  17 | 		error(errorText, 3)
  18 | 	end
  19 | 
  20 | 	return value
  21 | end
  22 | 
  23 | function Assert.evalArg<T>(methodName: string, argName: string, message: string, eval: boolean?, value: T?): T
  24 | 	local errorText = fmt(Assert.TYPE.INVALID_EVAL_ARG, methodName, argName, message, tostring(value), typeof(value))
  25 | 
  26 | 	if eval ~= true then
  27 | 		error(errorText, 3)
  28 | 	end
  29 | 
  30 | 	return value
  31 | end
  32 | 
  33 | function Assert.arrayOf(methodName: string, argName: string, class: string, array: Array): nil
  34 | 	Assert.typeOf("Assert.arrayOf", "array", "table", array)
  35 | 
  36 | 	for index, value in ipairs(array) do
  37 | 		if typeof(value) ~= class then
  38 | 			local errorText =
  39 | 				fmt(Assert.TYPE.INVALID_ARRAY, methodName, argName, class, tostring(value), typeof(value), index)
  40 | 			error(errorText, 3)
  41 | 		end
  42 | 	end
  43 | 
  44 | 	return nil
  45 | end
  46 | 
  47 | function Assert.prepTypeOf(methodName: string)
  48 | 	return function(argName: string, class: string, value: any?)
  49 | 		return Assert.typeOf(methodName, argName, class, value)
  50 | 	end
  51 | end
  52 | 
  53 | function Assert.prepEvalArg(methodName: string)
  54 | 	return function(argName: string, message: string, eval: boolean?, value: any?)
  55 | 		return Assert.evalArg(methodName, argName, message, eval, value)
  56 | 	end
  57 | end
  58 | 
  59 | function Assert.prepArrayOf(methodName: string)
  60 | 	return function(argName: string, class: string, array: Array)
  61 | 		return Assert.arrayOf(methodName, argName, class, array)
  62 | 	end
  63 | end
  64 | 
  65 | return Assert
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/Util/BasicallyIdentical.lua`
<details>
<summary>View Source (50 lines)</summary>

```lua
   1 | local fmt = string.format
   2 | local abs = math.abs
   3 | 
   4 | local function StringifyColor3(color: Color3): string
   5 | 	return string.format('Color3<%.3g, %.3g, %.3g> "#%s"', color.R * 255, color.G * 255, color.B * 255, color:ToHex())
   6 | end
   7 | 
   8 | return function(base: Color3, compare: Color3, distance: number?): boolean
   9 | 	distance = if type(distance) == "number" then distance else 0.005
  10 | 
  11 | 	assert(typeof(base) == "Color3", '"Base" is not a Color3')
  12 | 	assert(typeof(compare) == "Color3", '"Compare" is not a Color3')
  13 | 
  14 | 	local distRed = abs(base.R - compare.R)
  15 | 	local distGreen = abs(base.G - compare.G)
  16 | 	local distBlue = abs(base.B - compare.B)
  17 | 
  18 | 	local identical = distRed <= distance and distGreen <= distance and distBlue <= distance
  19 | 
  20 | 	if not identical then
  21 | 		local problems = {}
  22 | 
  23 | 		if distRed > distance then
  24 | 			table.insert(problems, fmt("R was out by %.3g", tostring(abs(distance - distRed))))
  25 | 		end
  26 | 
  27 | 		if distGreen > distance then
  28 | 			table.insert(problems, fmt("G was out by %.3g", tostring(abs(distance - distGreen))))
  29 | 		end
  30 | 
  31 | 		if distBlue > distance then
  32 | 			table.insert(problems, fmt("B was out by %.3g", tostring(abs(distance - distBlue))))
  33 | 		end
  34 | 
  35 | 		error(
  36 | 			fmt(
  37 | 				"Expected %s (%s) to be within %s, got %s (%s) instead; %s",
  38 | 				StringifyColor3(base),
  39 | 				typeof(base),
  40 | 				tostring(distance),
  41 | 				StringifyColor3(compare),
  42 | 				typeof(compare),
  43 | 				table.concat(problems, ", ")
  44 | 			),
  45 | 			2
  46 | 		)
  47 | 	end
  48 | 
  49 | 	return identical
  50 | end
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/Util/ClampColor.lua`
<details>
<summary>View Source (9 lines)</summary>

```lua
   1 | local clamp = math.clamp
   2 | 
   3 | return function(color: Color3): Color3
   4 | 	local red = clamp(color.R, 0, 1)
   5 | 	local green = clamp(color.G, 0, 1)
   6 | 	local blue = clamp(color.B, 0, 1)
   7 | 
   8 | 	return Color3.new(red, green, blue)
   9 | end
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/Util/DeprecateWarnOnce.lua`
<details>
<summary>View Source (18 lines)</summary>

```lua
   1 | local function deprecateWarnOnce(method)
   2 | 	return function(oldMethod: string, newMethod: string, removalInVersion: string?): typeof(method)
   3 | 		local didWarn = false
   4 | 
   5 | 		return function(...)
   6 | 			if not didWarn then
   7 | 				local removalString = removalInVersion and ` and will be removed in {removalInVersion}` or ""
   8 | 
   9 | 				didWarn = true
  10 | 				warn(`{oldMethod} is deprecated{removalString}. Please use {newMethod} instead.`)
  11 | 			end
  12 | 
  13 | 			return method(...)
  14 | 		end
  15 | 	end
  16 | end
  17 | 
  18 | return deprecateWarnOnce
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/Util/init.lua`
<details>
<summary>View Source (9 lines)</summary>

```lua
   1 | return {
   2 | 	Array = require(script.Array),
   3 | 	Assert = require(script.Assert),
   4 | 	BasicallyIdentical = require(script.BasicallyIdentical),
   5 | 	ClampColor = require(script.ClampColor),
   6 | 	isNaN = require(script.isNaN),
   7 | 	Schema = require(script.Schema),
   8 | 	Types = require(script.Types),
   9 | }
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/Util/isNaN.lua`
<details>
<summary>View Source (3 lines)</summary>

```lua
   1 | return function(value: number): boolean
   2 | 	return value ~= value
   3 | end
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/Util/Schema.lua`
<details>
<summary>View Source (36 lines)</summary>

```lua
   1 | local function Loose(schema: table, input: table?): table
   2 | 	if type(input) ~= "table" then
   3 | 		return schema
   4 | 	end
   5 | 
   6 | 	local output = {}
   7 | 
   8 | 	for key, value in pairs(schema) do
   9 | 		output[key] = input[key] or value
  10 | 	end
  11 | 
  12 | 	return output
  13 | end
  14 | 
  15 | local function Strict(schema: table, input: table?): table
  16 | 	if type(input) ~= "table" then
  17 | 		return schema
  18 | 	end
  19 | 
  20 | 	local output = {}
  21 | 
  22 | 	for key, value in pairs(schema) do
  23 | 		if typeof(input[key]) == typeof(value) then
  24 | 			output[key] = input[key]
  25 | 		else
  26 | 			output[key] = value
  27 | 		end
  28 | 	end
  29 | 
  30 | 	return output
  31 | end
  32 | 
  33 | return {
  34 | 	Loose = Loose,
  35 | 	Strict = Strict,
  36 | }
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/Util/Types.lua`
<details>
<summary>View Source (4 lines)</summary>

```lua
   1 | export type Dictionary<K, V> = { [K]: V }
   2 | export type Array<T> = Dictionary<number, T>
   3 | 
   4 | return nil
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/WCAG/GetContrastingColor.lua`
<details>
<summary>View Source (37 lines)</summary>

```lua
   1 | local Assert = require(script.Parent.Parent.Util.Assert)
   2 | local assertTypeOf = Assert.prepTypeOf("GetContrastingColor")
   3 | 
   4 | local Darken = require(script.Parent.Parent.Darken)
   5 | local GetContrastRatio = require(script.Parent.GetContrastRatio)
   6 | local Lighten = require(script.Parent.Parent.Lighten)
   7 | local isDark = require(script.Parent.Parent.isDark)
   8 | 
   9 | local MIN_RATIO = 4.5
  10 | 
  11 | --[=[
  12 | 	@function GetContrastingColor
  13 | 	@within WCAG
  14 | 
  15 | 	@param foreground Color3 -- The foreground color.
  16 | 	@param background Color3 -- The background color.
  17 | 	@param ratio? number -- The ratio to check against [0-1] (defaults to 4.5).
  18 | 	@return Color3 -- The contrasting color.
  19 | ]=]
  20 | return function(foreground: Color3, background: Color3, ratio: number?): Color3
  21 | 	assertTypeOf("foreground", "Color3", foreground)
  22 | 	assertTypeOf("background", "Color3", background)
  23 | 
  24 | 	ratio = if type(ratio) == "number" then ratio else MIN_RATIO
  25 | 
  26 | 	local contrastRatio = GetContrastRatio(foreground, background)
  27 | 
  28 | 	if contrastRatio >= ratio then
  29 | 		return foreground
  30 | 	end
  31 | 
  32 | 	if isDark(background) then
  33 | 		return Lighten(foreground, (ratio - contrastRatio) / ratio)
  34 | 	end
  35 | 
  36 | 	return Darken(foreground, (ratio - contrastRatio) / ratio)
  37 | end
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/WCAG/GetContrastRatio.lua`
<details>
<summary>View Source (25 lines)</summary>

```lua
   1 | local Assert = require(script.Parent.Parent.Util.Assert)
   2 | local assertTypeOf = Assert.prepTypeOf("GetContrastRatio")
   3 | 
   4 | local GetLuminance = require(script.Parent.Parent.GetLuminance)
   5 | 
   6 | local max = math.max
   7 | local min = math.min
   8 | 
   9 | --[=[
  10 | 	@function GetContrastRatio
  11 | 	@within WCAG
  12 | 
  13 | 	@param foreground Color3 -- The foreground color.
  14 | 	@param background Color3 -- The background color.
  15 | 	@return number -- The contrast ratio [0-21].
  16 | ]=]
  17 | return function(foreground: Color3, background: Color3): number
  18 | 	assertTypeOf("foreground", "Color3", foreground)
  19 | 	assertTypeOf("background", "Color3", background)
  20 | 
  21 | 	local lumA = GetLuminance(foreground)
  22 | 	local lumB = GetLuminance(background)
  23 | 
  24 | 	return (max(lumA, lumB) + 0.05) / (min(lumA, lumB) + 0.05)
  25 | end
```
</details>

## ğŸŒ™ `Packages/_Index/csqrl_colour-utils@1.4.1/colour-utils/src/WCAG/init.lua`
<details>
<summary>View Source (7 lines)</summary>

```lua
   1 | --[=[
   2 | 	@class WCAG
   3 | ]=]
   4 | return {
   5 | 	GetContrastingColor = require(script.GetContrastingColor),
   6 | 	GetContrastRatio = require(script.GetContrastRatio),
   7 | }
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/Animation/ExternalTime.luau`
<details>
<summary>View Source (83 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 | 	Outputs the current external time as a state object.
   8 | ]]
   9 | 
  10 | local Package = script.Parent.Parent
  11 | local Types = require(Package.Types)
  12 | local External = require(Package.External)
  13 | -- Graph
  14 | local change = require(Package.Graph.change)
  15 | -- Utility
  16 | local nicknames = require(Package.Utility.nicknames)
  17 | 
  18 | type ExternalTime = Types.StateObject<number>
  19 | 
  20 | type Self = ExternalTime
  21 | 
  22 | local class = {}
  23 | class.type = "State"
  24 | class.kind = "ExternalTime"
  25 | class.timeliness = "lazy"
  26 | class.dependencySet = table.freeze {}
  27 | class._EXTREMELY_DANGEROUS_usedAsValue = External.lastUpdateStep()
  28 | 
  29 | local METATABLE = table.freeze {__index = class}
  30 | 
  31 | local allTimers: {Self} = {}
  32 | 
  33 | local function ExternalTime(
  34 | 	scope: Types.Scope<unknown>
  35 | ): ExternalTime
  36 | 	local createdAt = os.clock()
  37 | 	local self: Self = setmetatable(
  38 | 		{
  39 | 			createdAt = createdAt,
  40 | 			dependentSet = {},
  41 | 			lastChange = nil,
  42 | 			scope = scope,
  43 | 			validity = "invalid"
  44 | 		}, 
  45 | 		METATABLE
  46 | 	) :: any
  47 | 	local destroy = function()
  48 | 		self.scope = nil
  49 | 		local index = table.find(allTimers, self)
  50 | 		if index ~= nil then
  51 | 			table.remove(allTimers, index)
  52 | 		end
  53 | 	end
  54 | 	self.oldestTask = destroy
  55 | 	nicknames[self.oldestTask] = "ExternalTime"
  56 | 	table.insert(scope, destroy)
  57 | 	table.insert(allTimers, self)
  58 | 	return self
  59 | end
  60 | 
  61 | function class._evaluate(
  62 | 	self: Self
  63 | ): boolean
  64 | 	-- While someone else could call `change()` on this object, it wouldn't be
  65 | 	-- idiomatic. So, since the only idiomatic time this function runs is when
  66 | 	-- the external update step runs, it's safe enough to assume that the result
  67 | 	-- has always meaningfully changed. The worst that can happen is unexpected
  68 | 	-- refreshing for people doing unorthodox shenanigans, which is an OK trade.
  69 | 	return true
  70 | end
  71 | 
  72 | External.bindToUpdateStep(function(
  73 | 	externalNow: number
  74 | ): ()
  75 | 	class._EXTREMELY_DANGEROUS_usedAsValue = External.lastUpdateStep()
  76 | 	for _, timer in allTimers do
  77 | 		change(timer)
  78 | 	end
  79 | end)
  80 | 
  81 | -- Do *not* freeze the class table, because it stores the shared value of all
  82 | -- external time objects, and is updated every frame because of that.
  83 | -- table.freeze(class)
  84 | return ExternalTime
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/Animation/getTweenDuration.luau`
<details>
<summary>View Source (27 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 | 	Given a `tweenInfo`, returns how many seconds it will take before the tween
   8 | 	finishes moving. The result may be infinite if the tween repeats forever.
   9 | ]]
  10 | 
  11 | local TweenService = game:GetService("TweenService")
  12 | 
  13 | local function getTweenDuration(
  14 | 	tweenInfo: TweenInfo
  15 | ): number
  16 | 	if tweenInfo.RepeatCount <= -1 then
  17 | 		return math.huge
  18 | 	end
  19 | 	local tweenDuration = tweenInfo.DelayTime + tweenInfo.Time
  20 | 	if tweenInfo.Reverses then
  21 | 		tweenDuration += tweenInfo.Time
  22 | 	end
  23 | 	tweenDuration *= tweenInfo.RepeatCount + 1
  24 | 	return tweenDuration
  25 | end
  26 | 
  27 | return getTweenDuration
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/Animation/getTweenRatio.luau`
<details>
<summary>View Source (47 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 | 	Given a `tweenInfo` and `currentTime`, returns a ratio which can be used to
   8 | 	tween between two values over time.
   9 | ]]
  10 | 
  11 | local TweenService = game:GetService("TweenService")
  12 | 
  13 | local function getTweenRatio(
  14 | 	tweenInfo: TweenInfo,
  15 | 	currentTime: number
  16 | ): number
  17 | 	local delay = tweenInfo.DelayTime
  18 | 	local duration = tweenInfo.Time
  19 | 	local reverses = tweenInfo.Reverses
  20 | 	local numCycles = 1 + tweenInfo.RepeatCount
  21 | 	local easeStyle = tweenInfo.EasingStyle
  22 | 	local easeDirection = tweenInfo.EasingDirection
  23 | 	local cycleDuration = delay + duration
  24 | 	if reverses then
  25 | 		cycleDuration += duration
  26 | 	end
  27 | 	-- If currentTime is infinity, then presumably the tween should be over.
  28 | 	-- This avoids NaN when the duration of an infinitely repeating tween is given.
  29 | 	if currentTime == math.huge then
  30 | 		return 1
  31 | 	end
  32 | 	if currentTime >= cycleDuration * numCycles and tweenInfo.RepeatCount > -1 then
  33 | 		return 1
  34 | 	end
  35 | 	local cycleTime = currentTime % cycleDuration
  36 | 	if cycleTime <= delay then
  37 | 		return 0
  38 | 	end
  39 | 	local tweenProgress = (cycleTime - delay) / duration
  40 | 	if tweenProgress > 1 then
  41 | 		tweenProgress = 2 - tweenProgress
  42 | 	end
  43 | 	local ratio = TweenService:GetValue(tweenProgress, easeStyle, easeDirection)
  44 | 	return ratio
  45 | end
  46 | 
  47 | return getTweenRatio
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/Animation/lerpType.luau`
<details>
<summary>View Source (163 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 | 	Linearly interpolates the given animatable types by a ratio.
   8 | 	If the types are different or not animatable, then the first value will be
   9 | 	returned for ratios below 0.5, and the second value for 0.5 and above.
  10 | ]]
  11 | 
  12 | local Package = script.Parent.Parent
  13 | local Oklab = require(Package.Colour.Oklab)
  14 | 
  15 | local function lerpType(
  16 | 	from: unknown, 
  17 | 	to: unknown, 
  18 | 	ratio: number
  19 | ): unknown
  20 | 	local typeString = typeof(from)
  21 | 
  22 | 	if typeof(to) == typeString then
  23 | 		-- both types must match for interpolation to make sense
  24 | 		if typeString == "number" then
  25 | 			local to, from = to :: number, from :: number
  26 | 			return (to - from) * ratio + from
  27 | 
  28 | 		elseif typeString == "CFrame" then
  29 | 			local to, from = to :: CFrame, from :: CFrame
  30 | 			return from:Lerp(to, ratio)
  31 | 
  32 | 		elseif typeString == "Color3" then
  33 | 			local to, from = to :: Color3, from :: Color3
  34 | 			local fromLab = Oklab.fromSRGB(from)
  35 | 			local toLab = Oklab.fromSRGB(to)
  36 | 			return Oklab.toSRGB(
  37 | 				fromLab:Lerp(toLab, ratio),
  38 | 				false
  39 | 			)
  40 | 
  41 | 		elseif typeString == "ColorSequenceKeypoint" then
  42 | 			local to, from = to :: ColorSequenceKeypoint, from :: ColorSequenceKeypoint
  43 | 			local fromLab = Oklab.fromSRGB(from.Value)
  44 | 			local toLab = Oklab.fromSRGB(to.Value)
  45 | 			return ColorSequenceKeypoint.new(
  46 | 				(to.Time - from.Time) * ratio + from.Time,
  47 | 				Oklab.toSRGB(
  48 | 					fromLab:Lerp(toLab, ratio),
  49 | 					false
  50 | 				)
  51 | 			)
  52 | 
  53 | 		elseif typeString == "DateTime" then
  54 | 			local to, from = to :: DateTime, from :: DateTime
  55 | 			return DateTime.fromUnixTimestampMillis(
  56 | 				(to.UnixTimestampMillis - from.UnixTimestampMillis) * ratio + from.UnixTimestampMillis
  57 | 			)
  58 | 
  59 | 		elseif typeString == "NumberRange" then
  60 | 			local to, from = to :: NumberRange, from :: NumberRange
  61 | 			return NumberRange.new(
  62 | 				(to.Min - from.Min) * ratio + from.Min,
  63 | 				(to.Max - from.Max) * ratio + from.Max
  64 | 			)
  65 | 
  66 | 		elseif typeString == "NumberSequenceKeypoint" then
  67 | 			local to, from = to :: NumberSequenceKeypoint, from :: NumberSequenceKeypoint
  68 | 			return NumberSequenceKeypoint.new(
  69 | 				(to.Time - from.Time) * ratio + from.Time,
  70 | 				(to.Value - from.Value) * ratio + from.Value,
  71 | 				(to.Envelope - from.Envelope) * ratio + from.Envelope
  72 | 			)
  73 | 
  74 | 		elseif typeString == "PhysicalProperties" then
  75 | 			local to, from = to :: PhysicalProperties, from :: PhysicalProperties
  76 | 			return PhysicalProperties.new(
  77 | 				(to.Density - from.Density) * ratio + from.Density,
  78 | 				(to.Friction - from.Friction) * ratio + from.Friction,
  79 | 				(to.Elasticity - from.Elasticity) * ratio + from.Elasticity,
  80 | 				(to.FrictionWeight - from.FrictionWeight) * ratio + from.FrictionWeight,
  81 | 				(to.ElasticityWeight - from.ElasticityWeight) * ratio + from.ElasticityWeight
  82 | 			)
  83 | 
  84 | 		elseif typeString == "Ray" then
  85 | 			local to, from = to :: Ray, from :: Ray
  86 | 			return Ray.new(
  87 | 				from.Origin:Lerp(to.Origin, ratio),
  88 | 				from.Direction:Lerp(to.Direction, ratio)
  89 | 			)
  90 | 
  91 | 		elseif typeString == "Rect" then
  92 | 			local to, from = to :: Rect, from :: Rect
  93 | 			return Rect.new(
  94 | 				from.Min:Lerp(to.Min, ratio),
  95 | 				from.Max:Lerp(to.Max, ratio)
  96 | 			)
  97 | 
  98 | 		elseif typeString == "Region3" then
  99 | 			local to, from = to :: Region3, from :: Region3
 100 | 			-- FUTURE: support rotated Region3s if/when they become constructable
 101 | 			local position = from.CFrame.Position:Lerp(to.CFrame.Position, ratio)
 102 | 			local halfSize = from.Size:Lerp(to.Size, ratio) / 2
 103 | 			return Region3.new(position - halfSize, position + halfSize)
 104 | 
 105 | 		elseif typeString == "Region3int16" then
 106 | 			local to, from = to :: Region3int16, from :: Region3int16
 107 | 			return Region3int16.new(
 108 | 				Vector3int16.new(
 109 | 					(to.Min.X - from.Min.X) * ratio + from.Min.X,
 110 | 					(to.Min.Y - from.Min.Y) * ratio + from.Min.Y,
 111 | 					(to.Min.Z - from.Min.Z) * ratio + from.Min.Z
 112 | 				),
 113 | 				Vector3int16.new(
 114 | 					(to.Max.X - from.Max.X) * ratio + from.Max.X,
 115 | 					(to.Max.Y - from.Max.Y) * ratio + from.Max.Y,
 116 | 					(to.Max.Z - from.Max.Z) * ratio + from.Max.Z
 117 | 				)
 118 | 			)
 119 | 
 120 | 		elseif typeString == "UDim" then
 121 | 			local to, from = to :: UDim, from :: UDim
 122 | 			return UDim.new(
 123 | 				(to.Scale - from.Scale) * ratio + from.Scale,
 124 | 				(to.Offset - from.Offset) * ratio + from.Offset
 125 | 			)
 126 | 
 127 | 		elseif typeString == "UDim2" then
 128 | 			local to, from = to :: UDim2, from :: UDim2
 129 | 			return from:Lerp(to, ratio)
 130 | 
 131 | 		elseif typeString == "Vector2" then
 132 | 			local to, from = to :: Vector2, from :: Vector2
 133 | 			return from:Lerp(to, ratio)
 134 | 
 135 | 		elseif typeString == "Vector2int16" then
 136 | 			local to, from = to :: Vector2int16, from :: Vector2int16
 137 | 			return Vector2int16.new(
 138 | 				(to.X - from.X) * ratio + from.X,
 139 | 				(to.Y - from.Y) * ratio + from.Y
 140 | 			)
 141 | 
 142 | 		elseif typeString == "Vector3" then
 143 | 			local to, from = to :: Vector3, from :: Vector3
 144 | 			return from:Lerp(to, ratio)
 145 | 
 146 | 		elseif typeString == "Vector3int16" then
 147 | 			local to, from = to :: Vector3int16, from :: Vector3int16
 148 | 			return Vector3int16.new(
 149 | 				(to.X - from.X) * ratio + from.X,
 150 | 				(to.Y - from.Y) * ratio + from.Y,
 151 | 				(to.Z - from.Z) * ratio + from.Z
 152 | 			)
 153 | 		end
 154 | 	end
 155 | 
 156 | 	-- fallback case: the types are different or not animatable
 157 | 	if ratio < 0.5 then
 158 | 		return from
 159 | 	else
 160 | 		return to
 161 | 	end
 162 | end
 163 | 
 164 | return lerpType
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/Animation/packType.luau`
<details>
<summary>View Source (99 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 | 	Packs an array of numbers into a given animatable data type.
   8 | 	If the type is not animatable, nil will be returned.
   9 | ]]
  10 | 
  11 | local Package = script.Parent.Parent
  12 | local Types = require(Package.Types)
  13 | local Oklab = require(Package.Colour.Oklab)
  14 | 
  15 | local function packType(
  16 | 	numbers: {number},
  17 | 	typeString: string
  18 | ): Types.Animatable?
  19 | 	if typeString == "number" then
  20 | 		return numbers[1]
  21 | 
  22 | 	elseif typeString == "CFrame" then
  23 | 		return
  24 | 			CFrame.new(numbers[1], numbers[2], numbers[3]) *
  25 | 			CFrame.fromAxisAngle(
  26 | 				Vector3.new(numbers[4], numbers[5], numbers[6]).Unit,
  27 | 				numbers[7]
  28 | 			)
  29 | 
  30 | 	elseif typeString == "Color3" then
  31 | 		return Oklab.toSRGB(
  32 | 			Vector3.new(numbers[1], numbers[2], numbers[3]),
  33 | 			false
  34 | 		)
  35 | 
  36 | 	elseif typeString == "ColorSequenceKeypoint" then
  37 | 		return ColorSequenceKeypoint.new(
  38 | 			numbers[4],
  39 | 			Oklab.toSRGB(
  40 | 				Vector3.new(numbers[1], numbers[2], numbers[3]),
  41 | 				false
  42 | 			)
  43 | 		)
  44 | 
  45 | 	elseif typeString == "DateTime" then
  46 | 		return DateTime.fromUnixTimestampMillis(numbers[1])
  47 | 
  48 | 	elseif typeString == "NumberRange" then
  49 | 		return NumberRange.new(numbers[1], numbers[2])
  50 | 
  51 | 	elseif typeString == "NumberSequenceKeypoint" then
  52 | 		return NumberSequenceKeypoint.new(numbers[2], numbers[1], numbers[3])
  53 | 
  54 | 	elseif typeString == "PhysicalProperties" then
  55 | 		return PhysicalProperties.new(numbers[1], numbers[2], numbers[3], numbers[4], numbers[5])
  56 | 
  57 | 	elseif typeString == "Ray" then
  58 | 		return Ray.new(
  59 | 			Vector3.new(numbers[1], numbers[2], numbers[3]),
  60 | 			Vector3.new(numbers[4], numbers[5], numbers[6])
  61 | 		)
  62 | 
  63 | 	elseif typeString == "Rect" then
  64 | 		return Rect.new(numbers[1], numbers[2], numbers[3], numbers[4])
  65 | 
  66 | 	elseif typeString == "Region3" then
  67 | 		-- FUTURE: support rotated Region3s if/when they become constructable
  68 | 		local position = Vector3.new(numbers[1], numbers[2], numbers[3])
  69 | 		local halfSize = Vector3.new(numbers[4] / 2, numbers[5] / 2, numbers[6] / 2)
  70 | 		return Region3.new(position - halfSize, position + halfSize)
  71 | 
  72 | 	elseif typeString == "Region3int16" then
  73 | 		return Region3int16.new(
  74 | 			Vector3int16.new(numbers[1], numbers[2], numbers[3]),
  75 | 			Vector3int16.new(numbers[4], numbers[5], numbers[6])
  76 | 		)
  77 | 
  78 | 	elseif typeString == "UDim" then
  79 | 		return UDim.new(numbers[1], numbers[2])
  80 | 
  81 | 	elseif typeString == "UDim2" then
  82 | 		return UDim2.new(numbers[1], numbers[2], numbers[3], numbers[4])
  83 | 
  84 | 	elseif typeString == "Vector2" then
  85 | 		return Vector2.new(numbers[1], numbers[2])
  86 | 
  87 | 	elseif typeString == "Vector2int16" then
  88 | 		return Vector2int16.new(numbers[1], numbers[2])
  89 | 
  90 | 	elseif typeString == "Vector3" then
  91 | 		return Vector3.new(numbers[1], numbers[2], numbers[3])
  92 | 
  93 | 	elseif typeString == "Vector3int16" then
  94 | 		return Vector3int16.new(numbers[1], numbers[2], numbers[3])
  95 | 	else
  96 | 		return nil
  97 | 	end
  98 | end
  99 | 
 100 | return packType
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/Animation/Spring.luau`
<details>
<summary>View Source (321 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 | 	A specialised state object for following a goal state smoothly over time,
   8 | 	using physics to shape the motion.
   9 | 
  10 | 	https://elttob.uk/Fusion/0.3/api-reference/animation/types/spring/
  11 | ]]
  12 | 
  13 | local Package = script.Parent.Parent
  14 | local Types = require(Package.Types)
  15 | local External = require(Package.External)
  16 | -- Memory
  17 | local checkLifetime = require(Package.Memory.checkLifetime)
  18 | -- Graph
  19 | local depend = require(Package.Graph.depend)
  20 | local change = require(Package.Graph.change)
  21 | local evaluate = require(Package.Graph.evaluate)
  22 | -- State
  23 | local castToState = require(Package.State.castToState)
  24 | local peek = require(Package.State.peek)
  25 | -- Animation
  26 | local ExternalTime = require(Package.Animation.ExternalTime)
  27 | local Stopwatch = require(Package.Animation.Stopwatch)
  28 | local packType = require(Package.Animation.packType)
  29 | local unpackType = require(Package.Animation.unpackType)
  30 | local springCoefficients = require(Package.Animation.springCoefficients)
  31 | -- Utility
  32 | local nicknames = require(Package.Utility.nicknames)
  33 | 
  34 | local EPSILON = 0.00001
  35 | 
  36 | type Self<T> = Types.Spring<T> & {
  37 | 	_activeDamping: number,
  38 | 	_activeGoal: T,
  39 | 	_activeLatestP: {number},
  40 | 	_activeLatestV: {number},
  41 | 	_activeNumSprings: number,
  42 | 	_activeSpeed: number,
  43 | 	_activeStartP: {number},
  44 | 	_activeStartV: {number},
  45 | 	_activeTargetP: {number},
  46 | 	_activeType: string,
  47 | 	_speed: Types.UsedAs<number>,
  48 | 	_damping: Types.UsedAs<number>,
  49 | 	_goal: Types.UsedAs<T>,
  50 | 	_stopwatch: Stopwatch.Stopwatch
  51 | }
  52 | 
  53 | local class = {}
  54 | class.type = "State"
  55 | class.kind = "Spring"
  56 | class.timeliness = "eager"
  57 | 
  58 | local METATABLE = table.freeze {__index = class}
  59 | 
  60 | local function Spring<T>(
  61 | 	scope: Types.Scope<unknown>,
  62 | 	goal: Types.UsedAs<T>,
  63 | 	speed: Types.UsedAs<number>?,
  64 | 	damping: Types.UsedAs<number>?
  65 | ): Types.Spring<T>
  66 | 	local createdAt = os.clock()
  67 | 	if typeof(scope) ~= "table" or castToState(scope) ~= nil then
  68 | 		External.logError("scopeMissing", nil, "Springs", "myScope:Spring(goalState, speed, damping)")
  69 | 	end
  70 | 
  71 | 	local goalState = castToState(goal)
  72 | 	local stopwatch = nil
  73 | 	if goalState ~= nil then
  74 | 		stopwatch = Stopwatch(scope, ExternalTime(scope))
  75 | 		stopwatch:unpause()
  76 | 	end
  77 | 
  78 | 	local speed = speed or 10
  79 | 	local damping = damping or 1
  80 | 
  81 | 	local self: Self<T> = setmetatable(
  82 | 		{
  83 | 			createdAt = createdAt,
  84 | 			dependencySet = {},
  85 | 			dependentSet = {},
  86 | 			lastChange = nil,
  87 | 			scope = scope,
  88 | 			validity = "invalid",
  89 | 			_activeDamping = -1,
  90 | 			_activeGoal = nil,
  91 | 			_activeLatestP = {},
  92 | 			_activeLatestV = {},
  93 | 			_activeNumSprings = 0,
  94 | 			_activeSpeed = -1,
  95 | 			_activeStartP = {},
  96 | 			_activeStartV = {},
  97 | 			_activeTargetP = {},
  98 | 			_activeType = "",
  99 | 			_damping = damping,
 100 | 			_EXTREMELY_DANGEROUS_usedAsValue = peek(goal),
 101 | 			_goal = goal,
 102 | 			_speed = speed,
 103 | 			_stopwatch = stopwatch
 104 | 		},
 105 | 		METATABLE
 106 | 	) :: any
 107 | 	local destroy = function()
 108 | 		self.scope = nil
 109 | 		for dependency in pairs(self.dependencySet) do
 110 | 			dependency.dependentSet[self] = nil
 111 | 		end
 112 | 	end
 113 | 	self.oldestTask = destroy
 114 | 	nicknames[self.oldestTask] = "Spring"
 115 | 	table.insert(scope, destroy)
 116 | 	
 117 | 	if goalState ~= nil then
 118 | 		checkLifetime.bOutlivesA(
 119 | 			scope, self.oldestTask,
 120 | 			goalState.scope, goalState.oldestTask,
 121 | 			checkLifetime.formatters.animationGoal
 122 | 		)
 123 | 	end
 124 | 	local speedState = castToState(speed)
 125 | 	if speedState ~= nil then
 126 | 		checkLifetime.bOutlivesA(
 127 | 			scope, self.oldestTask,
 128 | 			speedState.scope, speedState.oldestTask,
 129 | 			checkLifetime.formatters.parameter, "speed"
 130 | 		)
 131 | 	end
 132 | 	local dampingState = castToState(damping)
 133 | 	if dampingState ~= nil then
 134 | 		checkLifetime.bOutlivesA(
 135 | 			scope, self.oldestTask,
 136 | 			dampingState.scope, dampingState.oldestTask,
 137 | 			checkLifetime.formatters.parameter, "damping"
 138 | 		)
 139 | 	end
 140 | 
 141 | 	-- Eagerly evaluated objects need to evaluate themselves so that they're
 142 | 	-- valid at all times.
 143 | 	evaluate(self, true)
 144 | 
 145 | 	return self
 146 | end
 147 | 
 148 | function class.addVelocity<T>(
 149 | 	self: Self<T>,
 150 | 	deltaValue: T
 151 | ): ()
 152 | 	evaluate(self, false) -- ensure the _active params are up to date
 153 | 	local deltaType = typeof(deltaValue)
 154 | 	if deltaType ~= self._activeType then
 155 | 		External.logError("springTypeMismatch", nil, deltaType, self._activeType)
 156 | 	end
 157 | 	local newStartV = unpackType(deltaValue, deltaType)
 158 | 	for index, velocity in self._activeLatestV do
 159 | 		newStartV[index] += velocity
 160 | 	end
 161 | 	self._activeStartP = table.clone(self._activeLatestP)
 162 | 	self._activeStartV = newStartV
 163 | 	self._stopwatch:zero()
 164 | 	self._stopwatch:unpause()
 165 | 	change(self)
 166 | end
 167 | 
 168 | function class.get<T>(
 169 | 	self: Self<T>
 170 | ): never
 171 | 	return External.logError("stateGetWasRemoved")
 172 | end
 173 | 
 174 | function class.setPosition<T>(
 175 | 	self: Self<T>,
 176 | 	newValue: T
 177 | ): ()
 178 | 	evaluate(self, false) -- ensure the _active params are up to date
 179 | 	local newType = typeof(newValue)
 180 | 	if newType ~= self._activeType then
 181 | 		External.logError("springTypeMismatch", nil, newType, self._activeType)
 182 | 	end
 183 | 	self._activeStartP = unpackType(newValue, newType)
 184 | 	self._activeStartV = table.clone(self._activeLatestV)
 185 | 	self._stopwatch:zero()
 186 | 	self._stopwatch:unpause()
 187 | 	change(self)
 188 | end
 189 | 
 190 | function class.setVelocity<T>(
 191 | 	self: Self<T>,
 192 | 	newValue: T
 193 | ): ()
 194 | 	evaluate(self, false) -- ensure the _active params are up to date
 195 | 	local newType = typeof(newValue)
 196 | 	if newType ~= self._activeType then
 197 | 		External.logError("springTypeMismatch", nil, newType, self._activeType)
 198 | 	end
 199 | 	self._activeStartP = table.clone(self._activeLatestP)
 200 | 	self._activeStartV = unpackType(newValue, newType)
 201 | 	self._stopwatch:zero()
 202 | 	self._stopwatch:unpause()
 203 | 	change(self)
 204 | end
 205 | 
 206 | function class._evaluate<T>(
 207 | 	self: Self<T>
 208 | ): boolean
 209 | 	local goal = castToState(self._goal)
 210 | 	-- Allow non-state goals to pass through transparently.
 211 | 	if goal == nil then
 212 | 		self._EXTREMELY_DANGEROUS_usedAsValue = self._goal :: T
 213 | 		return false
 214 | 	end
 215 | 	-- depend(self, goal)
 216 | 	local nextFrameGoal = peek(goal)
 217 | 	-- Protect against NaN goals.
 218 | 	if nextFrameGoal ~= nextFrameGoal then
 219 | 		External.logWarn("springNanGoal")
 220 | 		return false
 221 | 	end
 222 | 	local nextFrameGoalType = typeof(nextFrameGoal)
 223 | 	local discontinuous = nextFrameGoalType ~= self._activeType
 224 | 
 225 | 	local stopwatch = self._stopwatch :: Stopwatch.Stopwatch
 226 | 	local elapsed = peek(stopwatch)
 227 | 	depend(self, stopwatch)
 228 | 
 229 | 	local oldValue = self._EXTREMELY_DANGEROUS_usedAsValue
 230 | 	local newValue: T
 231 | 
 232 | 	if discontinuous then
 233 | 		-- Propagate changes in type instantly throughout the whole reactive
 234 | 		-- graph, even if simulation is logically one frame behind, because it
 235 | 		-- makes the whole graph behave more consistently.
 236 | 		newValue = nextFrameGoal
 237 | 	elseif elapsed <= 0 then
 238 | 		newValue = oldValue
 239 | 	else
 240 | 		-- Calculate spring motion.
 241 | 		-- IMPORTANT: use the parameters from last frame, not this frame. We're
 242 | 		-- integrating the motion that happened over the last frame, after all.
 243 | 		-- The stopwatch will have captured the length of time needed correctly.
 244 | 		local posPos, posVel, velPos, velVel = springCoefficients(
 245 | 			elapsed, 
 246 | 			self._activeDamping, 
 247 | 			self._activeSpeed
 248 | 		)
 249 | 		local isMoving = false
 250 | 		for index = 1, self._activeNumSprings do
 251 | 			local startP = self._activeStartP[index]
 252 | 			local targetP = self._activeTargetP[index]
 253 | 			local startV = self._activeStartV[index]
 254 | 			local startD = startP - targetP
 255 | 			local latestD = startD * posPos + startV * posVel
 256 | 			local latestV = startD * velPos + startV * velVel
 257 | 			if latestD ~= latestD or latestV ~= latestV then
 258 | 				External.logWarn("springNanMotion")
 259 | 				latestD, latestV = 0, 0
 260 | 			end
 261 | 			if math.abs(latestD) > EPSILON or math.abs(latestV) > EPSILON then
 262 | 				isMoving = true
 263 | 			end
 264 | 			local latestP = latestD + targetP
 265 | 			self._activeLatestP[index] = latestP
 266 | 			self._activeLatestV[index] = latestV
 267 | 		end
 268 | 		-- Sleep and snap to goal if the motion has decayed to a negligible amount.
 269 | 		if not isMoving then
 270 | 			for index = 1, self._activeNumSprings do
 271 | 				self._activeLatestP[index] = self._activeTargetP[index]
 272 | 			end
 273 | 			-- TODO: figure out how to do sleeping correctly for single frame
 274 | 			-- changes
 275 | 			-- stopwatch:pause()
 276 | 			-- stopwatch:zero()
 277 | 		end
 278 | 		-- Pack springs into final value.
 279 | 		newValue = packType(self._activeLatestP, self._activeType) :: any
 280 | 	end
 281 | 
 282 | 	-- Reconfigure spring when any of its parameters are changed.
 283 | 	-- This should happen after integrating the last frame's motion.
 284 | 	-- NOTE: don't need to add a dependency on these objects! they do not cause
 285 | 	-- a spring to wake from sleep, so the stopwatch dependency is sufficient.
 286 | 	local nextFrameSpeed = peek(self._speed) :: number
 287 | 	local nextFrameDamping = peek(self._damping) :: number
 288 | 	if
 289 | 		discontinuous or
 290 | 		nextFrameGoal ~= self._activeGoal or
 291 | 		nextFrameSpeed ~= self._activeSpeed or
 292 | 		nextFrameDamping ~= self._activeDamping
 293 | 	then
 294 | 		self._activeTargetP = unpackType(nextFrameGoal, nextFrameGoalType)
 295 | 		self._activeNumSprings = #self._activeTargetP
 296 | 		if discontinuous then
 297 | 			self._activeStartP = table.clone(self._activeTargetP)
 298 | 			self._activeLatestP = table.clone(self._activeTargetP)
 299 | 			self._activeStartV = table.create(self._activeNumSprings, 0)
 300 | 			self._activeLatestV = table.create(self._activeNumSprings, 0)
 301 | 		else
 302 | 			self._activeStartP = table.clone(self._activeLatestP)
 303 | 			self._activeStartV = table.clone(self._activeLatestV)
 304 | 		end
 305 | 		self._activeType = nextFrameGoalType
 306 | 		self._activeGoal = nextFrameGoal
 307 | 		self._activeDamping = nextFrameDamping
 308 | 		self._activeSpeed = nextFrameSpeed
 309 | 		stopwatch:zero()
 310 | 		stopwatch:unpause()
 311 | 	end
 312 | 
 313 | 	-- Push update and check for similarity.
 314 | 	-- Don't need to use the similarity test here because this code doesn't
 315 | 	-- deal with tables, and NaN is already guarded against, so the similarity
 316 | 	-- test doesn't actually add any new safety here.
 317 | 	self._EXTREMELY_DANGEROUS_usedAsValue = newValue
 318 | 	return oldValue ~= newValue
 319 | end
 320 | 
 321 | table.freeze(class)
 322 | return Spring :: Types.SpringConstructor
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/Animation/springCoefficients.luau`
<details>
<summary>View Source (80 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 | 	Returns a 2x2 matrix of coefficients for a given time, damping and angular
   8 | 	frequency (aka 'speed').
   9 | 	
  10 | 	Specifically, this returns four coefficients - posPos, posVel, velPos, and
  11 | 	velVel - which can be multiplied with position and velocity like so:
  12 | 
  13 | 	local newPosition = oldPosition * posPos + oldVelocity * posVel
  14 | 	local newVelocity = oldPosition * velPos + oldVelocity * velVel
  15 | 
  16 | 	For speed = 1 and damping = 0, the result is a simple harmonic oscillator
  17 | 	with a period of tau.
  18 | 
  19 | 	Special thanks to AxisAngle for helping to improve numerical precision.
  20 | ]]
  21 | 
  22 | local function springCoefficients(
  23 | 	time: number,
  24 | 	damping: number,
  25 | 	speed: number
  26 | ): (number, number, number, number)
  27 | 	-- if time or speed is 0, then the spring won't move
  28 | 	if time == 0 or speed == 0 then
  29 | 		return 1, 0, 0, 1
  30 | 	end
  31 | 	local posPos, posVel, velPos, velVel
  32 | 
  33 | 	if damping > 1 then
  34 | 		-- overdamped spring
  35 | 
  36 | 		local alpha = math.sqrt(damping^2 - 1)
  37 | 		local negHalf_over_alpha_speed = -0.5 / (alpha * speed)
  38 | 		local z1 = speed * (alpha + damping) * -1
  39 | 		local z2 = speed * (alpha - damping)
  40 | 		local exp1 = math.exp(time * z1)
  41 | 		local exp2 = math.exp(time * z2)
  42 | 
  43 | 		posPos = (exp2 * z1 - exp1 * z2) * negHalf_over_alpha_speed
  44 | 		posVel = (exp1 - exp2) * negHalf_over_alpha_speed / speed
  45 | 		velPos = (exp2 - exp1) * negHalf_over_alpha_speed * speed
  46 | 		velVel = (exp1 * z1 - exp2 * z2) * negHalf_over_alpha_speed
  47 | 
  48 | 	elseif damping == 1 then
  49 | 		-- critically damped spring
  50 | 
  51 | 		local time_speed = time * speed
  52 | 		local time_speed_neg1 = time_speed * -1
  53 | 		local exp = math.exp(time_speed_neg1)
  54 | 
  55 | 		posPos = exp * (time_speed + 1)
  56 | 		posVel = exp * time
  57 | 		velPos = exp * (time_speed_neg1 * speed)
  58 | 		velVel = exp * (time_speed_neg1 + 1)
  59 | 	else
  60 | 		-- underdamped spring
  61 | 
  62 | 		local alpha = speed * math.sqrt(1 - damping^2)
  63 | 		local overAlpha = 1 / alpha
  64 | 		local exp = math.exp(-1 * time * speed * damping)
  65 | 		local sin = math.sin(alpha * time)
  66 | 		local cos = math.cos(alpha * time)
  67 | 		local exp_sin = exp * sin
  68 | 		local exp_cos = exp * cos
  69 | 		local exp_sin_speed_damping_overAlpha = exp_sin * speed * damping * overAlpha
  70 | 
  71 | 		posPos = exp_sin_speed_damping_overAlpha + exp_cos
  72 | 		posVel = exp_sin * overAlpha
  73 | 		velPos = -1 * ( exp_sin * alpha + speed * damping * exp_sin_speed_damping_overAlpha )
  74 | 		velVel = exp_cos - exp_sin_speed_damping_overAlpha
  75 | 	end
  76 | 
  77 | 	return posPos, posVel, velPos, velVel
  78 | end
  79 | 
  80 | return springCoefficients
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/Animation/Stopwatch.luau`
<details>
<summary>View Source (127 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 | 	State object for measuring time since an event using a reference timer.
   8 | 
   9 | 	TODO: this should not be exposed to users until it has a proper reactive API
  10 | 	surface
  11 | ]]
  12 | 
  13 | local Package = script.Parent.Parent
  14 | local Types = require(Package.Types)
  15 | -- Memory
  16 | local checkLifetime = require(Package.Memory.checkLifetime)
  17 | -- Graph
  18 | local depend = require(Package.Graph.depend)
  19 | local change = require(Package.Graph.change)
  20 | -- State
  21 | local peek = require(Package.State.peek)
  22 | -- Utility
  23 | local nicknames = require(Package.Utility.nicknames)
  24 | 
  25 | export type Stopwatch = Types.StateObject<number> & {
  26 | 	zero: (Stopwatch) -> (),
  27 | 	pause: (Stopwatch) -> (),
  28 | 	unpause: (Stopwatch) -> ()
  29 | }
  30 | 
  31 | type Self = Stopwatch & {
  32 | 	_measureTimeSince: number,
  33 | 	_playing: boolean,
  34 | 	_timer: Types.StateObject<number>
  35 | }
  36 | 
  37 | local class = {}
  38 | class.type = "State"
  39 | class.kind = "Stopwatch"
  40 | class.timeliness = "lazy"
  41 | 
  42 | local METATABLE = table.freeze {__index = class}
  43 | 
  44 | local function Stopwatch(
  45 | 	scope: Types.Scope<unknown>,
  46 | 	timer: Types.StateObject<number>
  47 | ): Stopwatch
  48 | 	local createdAt = os.clock()
  49 | 	local self: Self = setmetatable(
  50 | 		{
  51 | 			awake = true,
  52 | 			createdAt = createdAt,
  53 | 			dependencySet = {},
  54 | 			dependentSet = {},
  55 | 			lastChange = nil,
  56 | 			scope = scope,
  57 | 			validity = "invalid",
  58 | 			_EXTREMELY_DANGEROUS_usedAsValue = 0,
  59 | 			_measureTimeSince = 0, -- this should be set on unpause
  60 | 			_playing = false,
  61 | 			_timer = timer
  62 | 		}, 
  63 | 		METATABLE
  64 | 	) :: any
  65 | 	local destroy = function()
  66 | 		self.scope = nil
  67 | 	end
  68 | 	self.oldestTask = destroy
  69 | 	nicknames[self.oldestTask] = "Stopwatch"
  70 | 	table.insert(scope, destroy)
  71 | 
  72 | 	checkLifetime.bOutlivesA(
  73 | 		scope, self.oldestTask,
  74 | 		timer.scope, timer.oldestTask,
  75 | 		checkLifetime.formatters.parameter, "timer"
  76 | 	)
  77 | 	depend(self, timer)
  78 | 	return self
  79 | end
  80 | 
  81 | function class.zero(
  82 | 	self: Self
  83 | ): ()
  84 | 	local newTimepoint = peek(self._timer)
  85 | 	if newTimepoint ~= self._measureTimeSince then
  86 | 		self._measureTimeSince = newTimepoint
  87 | 		self._EXTREMELY_DANGEROUS_usedAsValue = 0
  88 | 		change(self)
  89 | 	end
  90 | end
  91 | 
  92 | function class.pause(
  93 | 	self: Self
  94 | ): ()
  95 | 	if self._playing == true then
  96 | 		self._playing = false
  97 | 		change(self)
  98 | 	end
  99 | end
 100 | 
 101 | function class.unpause(
 102 | 	self: Self
 103 | ): ()
 104 | 	if self._playing == false then
 105 | 		self._playing = true
 106 | 		self._measureTimeSince = peek(self._timer) - self._EXTREMELY_DANGEROUS_usedAsValue
 107 | 		change(self)
 108 | 	end
 109 | end
 110 | 
 111 | function class._evaluate(
 112 | 	self: Self
 113 | ): boolean
 114 | 	if self._playing then
 115 | 		depend(self, self._timer)
 116 | 		local currentTime = peek(self._timer)
 117 | 		local oldValue = self._EXTREMELY_DANGEROUS_usedAsValue
 118 | 		local newValue = currentTime - self._measureTimeSince
 119 | 		self._EXTREMELY_DANGEROUS_usedAsValue = newValue
 120 | 		return oldValue ~= newValue
 121 | 	else
 122 | 		return false
 123 | 	end
 124 | 	
 125 | end
 126 | 
 127 | table.freeze(class)
 128 | return Stopwatch
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/Animation/Tween.luau`
<details>
<summary>View Source (187 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 | 	A specialised state object for following a goal state smoothly over time,
   8 | 	using a TweenInfo to shape the motion.
   9 | 
  10 | 	https://elttob.uk/Fusion/0.3/api-reference/animation/types/tween/
  11 | ]]
  12 | 
  13 | local Package = script.Parent.Parent
  14 | local Types = require(Package.Types)
  15 | local External = require(Package.External)
  16 | -- Memory
  17 | local checkLifetime = require(Package.Memory.checkLifetime)
  18 | -- Graph
  19 | local depend = require(Package.Graph.depend)
  20 | local evaluate = require(Package.Graph.evaluate)
  21 | -- State
  22 | local castToState = require(Package.State.castToState)
  23 | local peek = require(Package.State.peek)
  24 | -- Animation
  25 | local ExternalTime = require(Package.Animation.ExternalTime)
  26 | local Stopwatch = require(Package.Animation.Stopwatch)
  27 | local lerpType = require(Package.Animation.lerpType)
  28 | local getTweenRatio = require(Package.Animation.getTweenRatio)
  29 | local getTweenDuration = require(Package.Animation.getTweenDuration)
  30 | -- Utility
  31 | local nicknames = require(Package.Utility.nicknames)
  32 | 
  33 | export type Self<T> = Types.Tween<T> & {
  34 | 	_activeDuration: number,
  35 | 	_activeElapsed: number,
  36 | 	_activeFrom: T,
  37 | 	_activeTo: T,
  38 | 	_activeTweenInfo: TweenInfo,
  39 | 	_goal: Types.UsedAs<T>,
  40 | 	_stopwatch: Stopwatch.Stopwatch?,
  41 | 	_tweenInfo: Types.UsedAs<TweenInfo>,
  42 | }
  43 | 
  44 | local class = {}
  45 | class.type = "State"
  46 | class.kind = "Tween"
  47 | class.timeliness = "eager"
  48 | 
  49 | local METATABLE = table.freeze {__index = class}
  50 | 
  51 | local function Tween<T>(
  52 | 	scope: Types.Scope<unknown>,
  53 | 	goal: Types.UsedAs<T>,
  54 | 	tweenInfo: Types.UsedAs<TweenInfo>?
  55 | ): Types.Tween<T>
  56 | 	local createdAt = os.clock()
  57 | 	if castToState(scope) then
  58 | 		External.logError("scopeMissing", nil, "Tweens", "myScope:Tween(goalState, tweenInfo)")
  59 | 	end
  60 | 
  61 | 	local goalState = castToState(goal)
  62 | 	local stopwatch = nil
  63 | 	if goalState ~= nil then
  64 | 		stopwatch = Stopwatch(scope, ExternalTime(scope))
  65 | 	end
  66 | 
  67 | 	local self: Self<T> = setmetatable(
  68 | 		{
  69 | 			createdAt = createdAt,
  70 | 			dependencySet = {},
  71 | 			dependentSet = {},
  72 | 			lastChange = nil,
  73 | 			scope = scope,
  74 | 			validity = "invalid",
  75 | 			_activeDuration = nil,
  76 | 			_activeElapsed = nil,
  77 | 			_activeFrom = nil,
  78 | 			_activeTo = nil,
  79 | 			_activeTweenInfo = nil,
  80 | 			_EXTREMELY_DANGEROUS_usedAsValue = peek(goal),
  81 | 			_goal = goal,
  82 | 			_stopwatch = stopwatch,
  83 | 			_tweenInfo = tweenInfo or TweenInfo.new()
  84 | 		},
  85 | 		METATABLE
  86 | 	) :: any
  87 | 	local destroy = function()
  88 | 		self.scope = nil
  89 | 		for dependency in pairs(self.dependencySet) do
  90 | 			dependency.dependentSet[self] = nil
  91 | 		end
  92 | 	end
  93 | 	self.oldestTask = destroy
  94 | 	nicknames[self.oldestTask] = "Tween"
  95 | 	table.insert(scope, destroy)
  96 | 
  97 | 	if goalState ~= nil then
  98 | 		checkLifetime.bOutlivesA(
  99 | 			scope, self.oldestTask,
 100 | 			goalState.scope, goalState.oldestTask,
 101 | 			checkLifetime.formatters.animationGoal
 102 | 		)
 103 | 	end
 104 | 
 105 | 	local tweenInfoState = castToState(tweenInfo)
 106 | 	if tweenInfoState ~= nil then
 107 | 		checkLifetime.bOutlivesA(
 108 | 			scope, self.oldestTask,
 109 | 			tweenInfoState.scope, tweenInfoState.oldestTask,
 110 | 			checkLifetime.formatters.parameter, "tween info"
 111 | 		)
 112 | 	end
 113 | 
 114 | 	-- Eagerly evaluated objects need to evaluate themselves so that they're
 115 | 	-- valid at all times.
 116 | 	evaluate(self, true)
 117 | 
 118 | 	return self
 119 | end
 120 | 
 121 | function class.get<T>(
 122 | 	self: Self<T>
 123 | ): never
 124 | 	return External.logError("stateGetWasRemoved")
 125 | end
 126 | 
 127 | function class._evaluate<T>(
 128 | 	self: Self<T>
 129 | ): boolean
 130 | 	local goal = castToState(self._goal)
 131 | 	-- Allow non-state goals to pass through transparently.
 132 | 	if goal == nil then
 133 | 		self._EXTREMELY_DANGEROUS_usedAsValue = self._goal :: T
 134 | 		return false
 135 | 	end
 136 | 	depend(self, goal)
 137 | 	local newTweenTo = peek(goal)
 138 | 	-- Protect against NaN goals.
 139 | 	if newTweenTo ~= newTweenTo then
 140 | 		External.logWarn("tweenNanGoal")
 141 | 		return false
 142 | 	end
 143 | 	local stopwatch = self._stopwatch :: Stopwatch.Stopwatch
 144 | 	local tweenInfo = peek(self._tweenInfo) :: TweenInfo
 145 | 	-- Restart animation when the goal changes, or if the tween info changes
 146 | 	-- partway through another animation.
 147 | 	if 
 148 | 		self._activeTo ~= newTweenTo or
 149 | 		(self._activeElapsed < self._activeDuration and self._activeTweenInfo ~= tweenInfo)
 150 | 	then
 151 | 		self._activeDuration = getTweenDuration(tweenInfo)
 152 | 		self._activeFrom = self._EXTREMELY_DANGEROUS_usedAsValue
 153 | 		self._activeTo = newTweenTo
 154 | 		self._activeTweenInfo = tweenInfo
 155 | 		stopwatch:zero()
 156 | 		stopwatch:unpause()
 157 | 	end
 158 | 	depend(self, stopwatch)
 159 | 	self._activeElapsed = peek(stopwatch)
 160 | 	if
 161 | 		self._activeFrom == self._activeTo or -- endpoints match
 162 | 		self._activeElapsed >= self._activeDuration or -- animation is done
 163 | 		typeof(self._activeTo) ~= typeof(self._activeFrom) -- type difference
 164 | 	then
 165 | 		self._activeFrom = self._activeTo
 166 | 		self._activeElapsed = self._activeDuration
 167 | 		stopwatch:pause()
 168 | 	end
 169 | 	-- Compute actual tweened value.
 170 | 	local ratio = getTweenRatio(tweenInfo, self._activeElapsed)
 171 | 	local oldValue = self._EXTREMELY_DANGEROUS_usedAsValue
 172 | 	local newValue = lerpType(self._activeFrom, self._activeTo, ratio) :: T
 173 | 	-- Protect against NaN after motion.
 174 | 	if newValue ~= newValue then
 175 | 		External.logWarn("tweenNanMotion")
 176 | 		newValue = self._activeTo
 177 | 	end
 178 | 	-- Push update and check for similarity.
 179 | 	-- Don't need to use the similarity test here because this code doesn't
 180 | 	-- deal with tables, and NaN is already guarded against, so the similarity
 181 | 	-- test doesn't actually add any new safety here.
 182 | 	self._EXTREMELY_DANGEROUS_usedAsValue = newValue
 183 | 	return oldValue ~= newValue
 184 | end
 185 | 
 186 | table.freeze(class)
 187 | return Tween :: Types.TweenConstructor
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/Animation/unpackType.luau`
<details>
<summary>View Source (102 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 | 	Unpacks an animatable type into an array of numbers.
   8 | 	If the type is not animatable, an empty array will be returned.
   9 | ]]
  10 | 
  11 | local Package = script.Parent.Parent
  12 | local Oklab = require(Package.Colour.Oklab)
  13 | 
  14 | local function unpackType(
  15 | 	value: unknown,
  16 | 	typeString: string
  17 | ): {number}
  18 | 	if typeString == "number" then
  19 | 		local value = value :: number
  20 | 		return {value}
  21 | 
  22 | 	elseif typeString == "CFrame" then
  23 | 		local value = value :: CFrame
  24 | 		-- FUTURE: is there a better way of doing this? doing distance
  25 | 		-- calculations on `angle` may be incorrect
  26 | 		local axis, angle = value:ToAxisAngle()
  27 | 		return {value.X, value.Y, value.Z, axis.X, axis.Y, axis.Z, angle}
  28 | 
  29 | 	elseif typeString == "Color3" then
  30 | 		local value = value :: Color3
  31 | 		local lab = Oklab.fromSRGB(value)
  32 | 		return {lab.X, lab.Y, lab.Z}
  33 | 
  34 | 	elseif typeString == "ColorSequenceKeypoint" then
  35 | 		local value = value :: ColorSequenceKeypoint
  36 | 		local lab = Oklab.fromSRGB(value.Value)
  37 | 		return {lab.X, lab.Y, lab.Z, value.Time}
  38 | 
  39 | 	elseif typeString == "DateTime" then
  40 | 		local value = value :: DateTime
  41 | 		return {value.UnixTimestampMillis}
  42 | 
  43 | 	elseif typeString == "NumberRange" then
  44 | 		local value = value :: NumberRange
  45 | 		return {value.Min, value.Max}
  46 | 
  47 | 	elseif typeString == "NumberSequenceKeypoint" then
  48 | 		local value = value :: NumberSequenceKeypoint
  49 | 		return {value.Value, value.Time, value.Envelope}
  50 | 
  51 | 	elseif typeString == "PhysicalProperties" then
  52 | 		local value = value :: PhysicalProperties
  53 | 		return {value.Density, value.Friction, value.Elasticity, value.FrictionWeight, value.ElasticityWeight}
  54 | 
  55 | 	elseif typeString == "Ray" then
  56 | 		local value = value :: Ray
  57 | 		return {value.Origin.X, value.Origin.Y, value.Origin.Z, value.Direction.X, value.Direction.Y, value.Direction.Z}
  58 | 
  59 | 	elseif typeString == "Rect" then
  60 | 		local value = value :: Rect
  61 | 		return {value.Min.X, value.Min.Y, value.Max.X, value.Max.Y}
  62 | 
  63 | 	elseif typeString == "Region3" then
  64 | 		local value = value :: Region3
  65 | 		-- FUTURE: support rotated Region3s if/when they become constructable
  66 | 		return {
  67 | 			value.CFrame.X, value.CFrame.Y, value.CFrame.Z,
  68 | 			value.Size.X, value.Size.Y, value.Size.Z
  69 | 		}
  70 | 
  71 | 	elseif typeString == "Region3int16" then
  72 | 		local value = value :: Region3int16
  73 | 		return {value.Min.X, value.Min.Y, value.Min.Z, value.Max.X, value.Max.Y, value.Max.Z}
  74 | 
  75 | 	elseif typeString == "UDim" then
  76 | 		local value = value :: UDim
  77 | 		return {value.Scale, value.Offset}
  78 | 
  79 | 	elseif typeString == "UDim2" then
  80 | 		local value = value :: UDim2
  81 | 		return {value.X.Scale, value.X.Offset, value.Y.Scale, value.Y.Offset}
  82 | 
  83 | 	elseif typeString == "Vector2" then
  84 | 		local value = value :: Vector2
  85 | 		return {value.X, value.Y}
  86 | 
  87 | 	elseif typeString == "Vector2int16" then
  88 | 		local value = value :: Vector2int16
  89 | 		return {value.X, value.Y}
  90 | 
  91 | 	elseif typeString == "Vector3" then
  92 | 		local value = value :: Vector3
  93 | 		return {value.X, value.Y, value.Z}
  94 | 
  95 | 	elseif typeString == "Vector3int16" then
  96 | 		local value = value :: Vector3int16
  97 | 		return {value.X, value.Y, value.Z}
  98 | 	else
  99 | 		return {}
 100 | 	end
 101 | end
 102 | 
 103 | return unpackType
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/Colour/Oklab.luau`
<details>
<summary>View Source (70 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 | 	Provides functions for converting Color3s into Oklab space, for more
   8 | 	perceptually uniform colour blending.
   9 | 
  10 | 	See: https://bottosson.github.io/posts/oklab/
  11 | ]]
  12 | 
  13 | local sRGB = require(script.Parent.sRGB)
  14 | 
  15 | local Oklab = {}
  16 | 
  17 | -- Converts a Color3 in linear RGB space to a Vector3 in Oklab space.
  18 | function Oklab.fromLinear(rgb: Color3): Vector3
  19 | 
  20 | 	local l = rgb.R * 0.4122214708 + rgb.G * 0.5363325363 + rgb.B * 0.0514459929
  21 | 	local m = rgb.R * 0.2119034982 + rgb.G * 0.6806995451 + rgb.B * 0.1073969566
  22 | 	local s = rgb.R * 0.0883024619 + rgb.G * 0.2817188376 + rgb.B * 0.6299787005
  23 | 
  24 | 	local lRoot = l ^ (1/3)
  25 | 	local mRoot = m ^ (1/3)
  26 | 	local sRoot = s ^ (1/3)
  27 | 
  28 | 	return Vector3.new(
  29 | 		lRoot * 0.2104542553 + mRoot * 0.7936177850 - sRoot * 0.0040720468,
  30 | 		lRoot * 1.9779984951 - mRoot * 2.4285922050 + sRoot * 0.4505937099,
  31 | 		lRoot * 0.0259040371 + mRoot * 0.7827717662 - sRoot * 0.8086757660
  32 | 	)
  33 | end
  34 | 
  35 | -- Converts a Color3 in sRGB space to a Vector3 in Oklab space.
  36 | function Oklab.fromSRGB(srgb: Color3): Vector3
  37 | 	return Oklab.fromLinear(sRGB.toLinear(srgb))
  38 | end
  39 | 
  40 | -- Converts a Vector3 in Oklab space to a Color3 in linear RGB space.
  41 | -- The Color3 will be clamped by default unless specified otherwise.
  42 | function Oklab.toLinear(lab: Vector3, unclamped: boolean?): Color3
  43 | 	local lRoot = lab.X + lab.Y * 0.3963377774 + lab.Z * 0.2158037573
  44 | 	local mRoot = lab.X - lab.Y * 0.1055613458 - lab.Z * 0.0638541728
  45 | 	local sRoot = lab.X - lab.Y * 0.0894841775 - lab.Z * 1.2914855480
  46 | 
  47 | 	local l = lRoot ^ 3
  48 | 	local m = mRoot ^ 3
  49 | 	local s = sRoot ^ 3
  50 | 
  51 | 	local red = l * 4.0767416621 - m * 3.3077115913 + s * 0.2309699292
  52 | 	local green = l * -1.2684380046 + m * 2.6097574011 - s * 0.3413193965
  53 | 	local blue = l * -0.0041960863 - m * 0.7034186147 + s * 1.7076147010
  54 | 
  55 | 	if not unclamped then
  56 | 		red = math.clamp(red, 0, 1)
  57 | 		green = math.clamp(green, 0, 1)
  58 | 		blue = math.clamp(blue, 0, 1)
  59 | 	end
  60 | 
  61 | 	return Color3.new(red, green, blue)
  62 | end
  63 | 
  64 | -- Converts a Vector3 in Oklab space to a Color3 in sRGB space.
  65 | -- The Color3 will be clamped by default unless specified otherwise.
  66 | function Oklab.toSRGB(lab: Vector3, unclamped: boolean?): Color3
  67 | 	return sRGB.fromLinear(Oklab.toLinear(lab, unclamped))
  68 | end
  69 | 
  70 | return Oklab
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/Colour/sRGB.luau`
<details>
<summary>View Source (54 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 |     Provides transformation functions for converting linear RGB values
   8 |     into sRGB values.
   9 | 
  10 |     RGB color channel transformations are outlined here:
  11 |     https://bottosson.github.io/posts/colorwrong/#what-can-we-do%3F
  12 | ]]
  13 | 
  14 | local sRGB = {}
  15 | 
  16 | -- Equivalent to f_inv. Takes a linear sRGB channel and returns
  17 | -- the sRGB channel
  18 | local function transform(channel: number): number
  19 |     if channel >= 0.04045 then
  20 |         return ((channel + 0.055)/(1 + 0.055))^2.4
  21 |     else
  22 |         return channel / 12.92
  23 |     end
  24 | end
  25 | 
  26 | -- Equivalent to f. Takes an sRGB channel and returns
  27 | -- the linear sRGB channel
  28 | local function inverse(channel: number): number
  29 |     if channel >= 0.0031308 then
  30 |         return (1.055) * channel^(1.0/2.4) - 0.055
  31 |     else
  32 |         return 12.92 * channel
  33 |     end
  34 | end
  35 | 
  36 | -- Uses a tranformation to convert linear RGB into sRGB.
  37 | function sRGB.fromLinear(rgb: Color3): Color3
  38 |     return Color3.new(
  39 |         transform(rgb.R),
  40 |         transform(rgb.G),
  41 |         transform(rgb.B)
  42 |     )
  43 | end
  44 | 
  45 | -- Converts an sRGB into linear RGB using a
  46 | -- (The inverse of sRGB.fromLinear).
  47 | function sRGB.toLinear(srgb: Color3): Color3
  48 |     return Color3.new(
  49 |         inverse(srgb.R),
  50 |         inverse(srgb.G),
  51 |         inverse(srgb.B)
  52 |     )
  53 | end
  54 | 
  55 | return sRGB
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/External.luau`
<details>
<summary>View Source (167 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 | 	Abstraction layer between Fusion internals and external environments,
   8 | 	allowing for flexible integration with schedulers and test mocks.
   9 | ]]
  10 | 
  11 | local Package = script.Parent
  12 | local formatError = require(Package.Logging.formatError)
  13 | local Types = require(Package.Types)
  14 | 
  15 | local ERROR_INFO_URL = "https://elttob.uk/Fusion/0.3/api-reference/general/errors/#"
  16 | 
  17 | local External = {}
  18 | 
  19 | -- Indicates that a highly time-critical passage of code is running. During
  20 | -- critical periods of a program, Fusion might decide to change some of its
  21 | -- internal behaviour to be more performance friendly.
  22 | local timeCritical = false
  23 | 
  24 | -- Multiplier for running-time safety checks across the Fusion codebase. Used to
  25 | -- stricten tests on infinite loop detection during unit testing.
  26 | External.safetyTimerMultiplier = 1
  27 | 
  28 | local updateStepCallbacks = {}
  29 | local currentProvider: Types.ExternalProvider? = nil
  30 | local lastUpdateStep = 0
  31 | 
  32 | --[[
  33 | 	Swaps to a new provider for external operations.
  34 | 	Returns the old provider, so it can be used again later.
  35 | ]]
  36 | function External.setExternalProvider(
  37 | 	newProvider: Types.ExternalProvider?
  38 | ): Types.ExternalProvider?
  39 | 	local oldProvider = currentProvider
  40 | 	if oldProvider ~= nil then
  41 | 		oldProvider.stopScheduler()
  42 | 	end
  43 | 	currentProvider = newProvider
  44 | 	if newProvider ~= nil then
  45 | 		newProvider.startScheduler()
  46 | 	end
  47 | 	return oldProvider
  48 | end
  49 | 
  50 | --[[
  51 | 	Returns true if a highly time-critical passage of code is running.
  52 | ]]
  53 | function External.isTimeCritical(): boolean
  54 | 	return timeCritical
  55 | end
  56 | 
  57 | --[[
  58 |    Sends an immediate task to the external provider. Throws if none is set.
  59 | ]]
  60 | function External.doTaskImmediate(
  61 | 	resume: () -> ()
  62 | )
  63 | 	if currentProvider == nil then
  64 | 		External.logError("noTaskScheduler")
  65 | 	else
  66 | 		currentProvider.doTaskImmediate(resume)
  67 | 	end
  68 | end
  69 | 
  70 | --[[
  71 | 	Sends a deferred task to the external provider. Throws if none is set.
  72 | ]]
  73 | function External.doTaskDeferred(
  74 | 	resume: () -> ()
  75 | )
  76 | 	if currentProvider == nil then
  77 | 		External.logError("noTaskScheduler")
  78 | 	else
  79 | 		currentProvider.doTaskDeferred(resume)
  80 | 	end
  81 | end
  82 | 
  83 | --[[
  84 | 	Errors in the current thread and halts execution.
  85 | ]]
  86 | function External.logError(
  87 | 	messageID: string,
  88 | 	errObj: Types.Error?,
  89 | 	...: unknown
  90 | ): never
  91 | 	error(formatError(currentProvider, messageID, errObj, ...), 0)
  92 | end
  93 | 
  94 | --[[
  95 | 	Errors in a different thread to preserve the flow of execution.
  96 | ]]
  97 | function External.logErrorNonFatal(
  98 | 	messageID: string,
  99 | 	errObj: Types.Error?,
 100 | 	...: unknown
 101 | ): ()
 102 | 	local errorString = formatError(currentProvider, messageID, errObj, ...)
 103 | 	if currentProvider ~= nil then
 104 | 		currentProvider.logErrorNonFatal(errorString)
 105 | 	else
 106 | 		print(errorString)
 107 | 	end
 108 | end
 109 | 
 110 | --[[
 111 | 	Shows a warning message in the output.
 112 | ]]
 113 | function External.logWarn(
 114 | 	messageID: string,
 115 | 	...: unknown
 116 | ): ()
 117 | 	local errorString = formatError(currentProvider, messageID, debug.traceback(nil, 2), ...)
 118 | 	if currentProvider ~= nil then
 119 | 		currentProvider.logWarn(errorString)
 120 | 	else
 121 | 		print(errorString)
 122 | 	end
 123 | end
 124 | 
 125 | --[[
 126 | 	Registers a callback to the update step of the external provider.
 127 | 	Returns a function that can be used to disconnect later.
 128 | 
 129 | 	Callbacks are given the current number of seconds since an arbitrary epoch.
 130 | 	
 131 | 	TODO: This epoch may change between providers. We could investigate ways
 132 | 	of allowing providers to co-operate to keep the epoch the same, so that
 133 | 	monotonicity can be better preserved.
 134 | ]]
 135 | function External.bindToUpdateStep(
 136 | 	callback: (
 137 | 		now: number
 138 | 	) -> ()
 139 | ): () -> ()
 140 | 	local uniqueIdentifier = {}
 141 | 	updateStepCallbacks[uniqueIdentifier] = callback
 142 | 	return function()
 143 | 		updateStepCallbacks[uniqueIdentifier] = nil
 144 | 	end
 145 | end
 146 | 
 147 | --[[
 148 | 	Steps time-dependent systems with the current number of seconds since an
 149 | 	arbitrary epoch. This should be called as early as possible in the external
 150 | 	provider's update cycle.
 151 | ]]
 152 | function External.performUpdateStep(
 153 | 	now: number
 154 | )
 155 | 	lastUpdateStep = now
 156 | 	for _, callback in updateStepCallbacks do
 157 | 		callback(now)
 158 | 	end
 159 | end
 160 | 
 161 | --[[
 162 | 	Returns the timestamp of the last update step.
 163 | ]]
 164 | function External.lastUpdateStep()
 165 | 	return lastUpdateStep
 166 | end
 167 | 
 168 | return External
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/ExternalDebug.luau`
<details>
<summary>View Source (69 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 | 	Abstraction layer between Fusion internals and external debuggers, allowing
   8 | 	for deep introspection using function hooks.
   9 | 
  10 | 	Unlike `External`, attaching a debugger is optional, and all debugger
  11 | 	functions are expected to be infallible and non-blocking.
  12 | ]]
  13 | 
  14 | local Package = script.Parent
  15 | local Types = require(Package.Types)
  16 | 
  17 | local currentProvider: Types.ExternalDebugger? = nil
  18 | local lastUpdateStep = 0
  19 | 
  20 | local Debugger = {}
  21 | 
  22 | --[[
  23 | 	Swaps to a new debugger.
  24 | 	Returns the old debugger, so it can be used again later.
  25 | ]]
  26 | function Debugger.setDebugger(
  27 | 	newProvider: Types.ExternalDebugger?
  28 | ): Types.ExternalDebugger?
  29 | 	local oldProvider = currentProvider
  30 | 	if oldProvider ~= nil then
  31 | 		oldProvider.stopDebugging()
  32 | 	end
  33 | 	currentProvider = newProvider
  34 | 	if newProvider ~= nil then
  35 | 		newProvider.startDebugging()
  36 | 	end
  37 | 	return oldProvider
  38 | end
  39 | 
  40 | --[[
  41 | 	Called at the earliest moment after a scope is created or removed from the
  42 | 	scope pool, but not before the scope has finished being prepared by the
  43 | 	library, so that debuggers can register its existence and track changes
  44 | 	to the scope over time.
  45 | ]]
  46 | function Debugger.trackScope(
  47 | 	scope: Types.Scope<unknown>
  48 | ): ()
  49 | 	if currentProvider == nil then
  50 | 		return
  51 | 	end
  52 | 	currentProvider.trackScope(scope)
  53 | end
  54 | 
  55 | --[[
  56 | 	Called at the final moment before a scope is poisoned or added to the scope
  57 | 	pool, after all cleanup tasks have completed, so that debuggers can erase 
  58 | 	the scope from internal trackers. Note that, due to scope pooling and user
  59 | 	code, never assume that this correlates with garbage collection events.
  60 | ]]
  61 | function Debugger.untrackScope(
  62 | 	scope: Types.Scope<unknown>
  63 | ): ()
  64 | 	if currentProvider == nil then
  65 | 		return
  66 | 	end
  67 | 	currentProvider.trackScope(scope)
  68 | end
  69 | 
  70 | return Debugger
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/Graph/castToGraph.luau`
<details>
<summary>View Source (28 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 | 	Returns the input *only* if it is a graph object.
   8 | ]]
   9 | 
  10 | local Package = script.Parent.Parent
  11 | local Types = require(Package.Types)
  12 | 
  13 | local function castToGraph(
  14 | 	target: any
  15 | ): Types.GraphObject?
  16 | 	if 
  17 | 		typeof(target) == "table" and
  18 | 		typeof(target.validity) == "string" and
  19 | 		typeof(target.timeliness) == "string" and
  20 | 		typeof(target.dependencySet) == "table" and
  21 | 		typeof(target.dependentSet) == "table"
  22 | 	then
  23 | 		return target
  24 | 	else
  25 | 		return nil
  26 | 	end
  27 | end
  28 | 
  29 | return castToGraph
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/Graph/change.luau`
<details>
<summary>View Source (80 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 | 	Prompts a graph object to re-evaluate its own value. If it meaningfully
   8 | 	changes, then dependents will have to re-evaluate their own values in the
   9 | 	future.
  10 | 
  11 | 	https://fluff.blog/2024/04/16/monotonic-painting.html
  12 | ]]
  13 | 
  14 | local Package = script.Parent.Parent
  15 | local Types = require(Package.Types)
  16 | local External = require(Package.External)
  17 | local evaluate = require(Package.Graph.evaluate)
  18 | 
  19 | -- How long should this function run before it's considered to be in an infinite
  20 | -- cycle and error out?
  21 | local TERMINATION_TIME = 1
  22 | 
  23 | local function change(
  24 | 	target: Types.GraphObject
  25 | ): ()
  26 | 	if target.validity == "busy" then
  27 | 		return External.logError("infiniteLoop")
  28 | 	end
  29 | 
  30 | 	local meaningfullyChanged = evaluate(target, true)
  31 | 	if not meaningfullyChanged then
  32 | 		return
  33 | 	end
  34 | 
  35 | 	local searchInNow: {Types.GraphObject} = {}
  36 | 	local searchInNext: {Types.GraphObject} = {}
  37 | 	local invalidateList: {Types.GraphObject} = {}
  38 | 
  39 | 	searchInNow[1] = target
  40 | 	local terminateBy = os.clock() + TERMINATION_TIME * External.safetyTimerMultiplier
  41 | 	repeat
  42 | 		if os.clock() > terminateBy then
  43 | 			return External.logError("infiniteLoop")
  44 | 		end
  45 | 		local done = true
  46 | 		for _, searchTarget in searchInNow do
  47 | 			for dependent in searchTarget.dependentSet do
  48 | 				if dependent.validity == "valid" then
  49 | 					done = false
  50 | 					table.insert(invalidateList, dependent)
  51 | 					table.insert(searchInNext, dependent)
  52 | 				elseif dependent.validity == "busy" then
  53 | 					return External.logError("infiniteLoop")
  54 | 				end
  55 | 			end
  56 | 		end
  57 | 		searchInNow, searchInNext = searchInNext, searchInNow
  58 | 		table.clear(searchInNext)
  59 | 	until done
  60 | 
  61 | 	local eagerList: {Types.GraphObject} = {}
  62 | 
  63 | 	for _, invalidateTarget in invalidateList do
  64 | 		invalidateTarget.validity = "invalid"
  65 | 		if invalidateTarget.timeliness == "eager" then
  66 | 			table.insert(eagerList, invalidateTarget)
  67 | 		end
  68 | 	end
  69 | 	-- If objects are not executed in order of creations, then dynamic graphs
  70 | 	-- may experience 'glitches' where nested graph objects see intermediate
  71 | 	-- values before being destroyed.
  72 | 	-- https://fluff.blog/2024/07/14/glitches-in-dynamic-reactive-graphs.html
  73 | 	table.sort(eagerList, function(a, b)
  74 | 		return a.createdAt < b.createdAt
  75 | 	end)
  76 | 	for _, eagerTarget in eagerList do
  77 | 		evaluate(eagerTarget, false)
  78 | 	end
  79 | end
  80 | 
  81 | return change
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/Graph/depend.luau`
<details>
<summary>View Source (32 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 | 	Forms a dependency on a graph object.
   8 | ]]
   9 | 
  10 | local Package = script.Parent.Parent
  11 | local Types = require(Package.Types)
  12 | local External = require(Package.External)
  13 | local evaluate = require(Package.Graph.evaluate)
  14 | local nameOf = require(Package.Utility.nameOf)
  15 | 
  16 | local function depend<T>(
  17 | 	dependent: Types.GraphObject,
  18 | 	dependency: Types.GraphObject
  19 | ): ()
  20 | 	-- Ensure dependencies are evaluated and up-to-date
  21 | 	-- when they are depended on. Also, newly created objects
  22 | 	-- might not have any transitive dependencies captured yet,
  23 | 	-- so ensure that they're present.
  24 | 	evaluate(dependency, false)
  25 | 
  26 | 	if table.isfrozen(dependent.dependencySet) or table.isfrozen(dependency.dependentSet) then
  27 | 		External.logError("cannotDepend", nil, nameOf(dependent, "Dependent"), nameOf(dependency, "dependency"))
  28 | 	end
  29 | 	dependency.dependentSet[dependent] = true
  30 | 	dependent.dependencySet[dependency] = true
  31 | end
  32 | 
  33 | return depend
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/Graph/evaluate.luau`
<details>
<summary>View Source (55 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 | 	Evaluates the graph object if necessary, so that it is up to date.
   8 | 	Returns true if it meaningfully changed.
   9 | 
  10 | 	https://fluff.blog/2024/04/16/monotonic-painting.html
  11 | ]]
  12 | 
  13 | local Package = script.Parent.Parent
  14 | local Types = require(Package.Types)
  15 | local External = require(Package.External)
  16 | 
  17 | local function evaluate(
  18 | 	target: Types.GraphObject,
  19 | 	forceComputation: boolean
  20 | ): boolean
  21 | 	if target.validity == "busy" then
  22 | 		return External.logError("infiniteLoop")
  23 | 	end
  24 | 	local firstEvaluation = target.lastChange == nil
  25 | 	local isInvalid = target.validity == "invalid"
  26 | 	if firstEvaluation or isInvalid or forceComputation then
  27 | 		local needsComputation = firstEvaluation or forceComputation
  28 | 		if not needsComputation then
  29 | 			for dependency in target.dependencySet do
  30 | 				evaluate(dependency, false)
  31 | 				if dependency.lastChange > target.lastChange then
  32 | 					needsComputation = true
  33 | 					break
  34 | 				end
  35 | 			end
  36 | 		end
  37 | 		local targetMeaningfullyChanged = false
  38 | 		if needsComputation then
  39 | 			for dependency in target.dependencySet do
  40 | 				dependency.dependentSet[target] = nil
  41 | 				target.dependencySet[dependency] = nil
  42 | 			end
  43 | 			target.validity = "busy"
  44 | 			targetMeaningfullyChanged = target:_evaluate() or firstEvaluation
  45 | 		end
  46 | 		if targetMeaningfullyChanged then
  47 | 			target.lastChange = os.clock()
  48 | 		end
  49 | 		target.validity = "valid"
  50 | 		return targetMeaningfullyChanged
  51 | 	else
  52 | 		return false
  53 | 	end
  54 | end
  55 | 
  56 | return evaluate
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/Graph/Observer.luau`
<details>
<summary>View Source (113 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 | 	A graph object that runs user code when it's updated by the reactive graph.
   8 | 
   9 | 	http://elttob.uk/Fusion/0.3/api-reference/state/types/observer/
  10 | ]]
  11 | 
  12 | local Package = script.Parent.Parent
  13 | local Types = require(Package.Types)
  14 | local External = require(Package.External)
  15 | -- Memory
  16 | local checkLifetime = require(Package.Memory.checkLifetime)
  17 | -- Graph
  18 | local castToGraph = require(Package.Graph.castToGraph)
  19 | local depend = require(Package.Graph.depend)
  20 | local evaluate = require(Package.Graph.evaluate)
  21 | -- Utility
  22 | local nicknames = require(Package.Utility.nicknames)
  23 | 
  24 | type Self = Types.Observer & {
  25 | 	_watchingGraph: Types.GraphObject?,
  26 | 	_changeListeners: {[unknown]: () -> ()}
  27 | }
  28 | 
  29 | local class = {}
  30 | class.type = "Observer"
  31 | class.timeliness = "eager"
  32 | class.dependentSet = table.freeze {}
  33 | 
  34 | local METATABLE = table.freeze {__index = class}
  35 | 
  36 | local function Observer(
  37 | 	scope: Types.Scope<unknown>,
  38 | 	watching: unknown
  39 | ): Types.Observer
  40 | 	local createdAt = os.clock()
  41 | 	if watching == nil then
  42 | 		External.logError("scopeMissing", nil, "Observers", "myScope:Observer(watching)")
  43 | 	end
  44 | 
  45 | 	local self: Self = setmetatable(
  46 | 		{
  47 | 			scope = scope,
  48 | 			createdAt = createdAt,
  49 | 			dependencySet = {},
  50 | 			lastChange = nil,
  51 | 			validity = "invalid",
  52 | 			_watchingGraph = castToGraph(watching),
  53 | 			_changeListeners = {}
  54 | 		},
  55 | 		METATABLE
  56 | 	) :: any
  57 | 	local destroy = function()
  58 | 		self.scope = nil
  59 | 		for dependency in pairs(self.dependencySet) do
  60 | 			dependency.dependentSet[self] = nil
  61 | 		end
  62 | 	end
  63 | 	self.oldestTask = destroy
  64 | 	nicknames[self.oldestTask] = "Observer"
  65 | 	table.insert(scope, destroy)
  66 | 
  67 | 	if self._watchingGraph ~= nil then
  68 | 		checkLifetime.bOutlivesA(
  69 | 			scope, self.oldestTask,
  70 | 			self._watchingGraph.scope, self._watchingGraph.oldestTask,
  71 | 			checkLifetime.formatters.observer
  72 | 		)
  73 | 	end
  74 | 
  75 | 	-- Eagerly evaluated objects need to evaluate themselves so that they're
  76 | 	-- valid at all times.
  77 | 	evaluate(self, true)
  78 | 
  79 | 	return self
  80 | end
  81 | 
  82 | function class.onBind(
  83 | 	self: Self,
  84 | 	callback: () -> ()
  85 | ): () -> ()
  86 | 	External.doTaskImmediate(callback)
  87 | 	return self:onChange(callback)
  88 | end
  89 | 
  90 | function class.onChange(
  91 | 	self: Self,
  92 | 	callback: () -> ()
  93 | ): () -> ()
  94 | 	local uniqueIdentifier = table.freeze {}
  95 | 	self._changeListeners[uniqueIdentifier] = callback
  96 | 	return function()
  97 | 		self._changeListeners[uniqueIdentifier] = nil
  98 | 	end
  99 | end
 100 | 
 101 | function class._evaluate(
 102 | 	self: Self
 103 | ): ()
 104 | 	if self._watchingGraph ~= nil then
 105 | 		depend(self, self._watchingGraph)
 106 | 	end
 107 | 	for _, callback in self._changeListeners do
 108 | 		External.doTaskImmediate(callback)
 109 | 	end
 110 | 	return true
 111 | end
 112 | 
 113 | table.freeze(class)
 114 | return Observer :: Types.ObserverConstructor
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/init.luau`
<details>
<summary>View Source (82 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | --[[
   6 | 	The entry point for the Fusion library.
   7 | ]]
   8 | 
   9 | local Types = require(script.Types)
  10 | local External = require(script.External)
  11 | 
  12 | type Fusion = Types.Fusion
  13 | 
  14 | export type Animatable = Types.Animatable
  15 | export type UsedAs<T> = Types.UsedAs<T>
  16 | export type Child = Types.Child
  17 | export type Computed<T> = Types.Computed<T>
  18 | export type Contextual<T> = Types.Contextual<T>
  19 | export type GraphObject = Types.GraphObject
  20 | export type For<KO, VO> = Types.For<KO, VO>
  21 | export type Observer = Types.Observer
  22 | export type PropertyTable = Types.PropertyTable
  23 | export type Scope<Constructors = Fusion> = Types.Scope<Constructors>
  24 | export type ScopedObject = Types.ScopedObject
  25 | export type SpecialKey = Types.SpecialKey
  26 | export type Spring<T> = Types.Spring<T>
  27 | export type StateObject<T> = Types.StateObject<T>
  28 | export type Task = Types.Task
  29 | export type Tween<T> = Types.Tween<T>
  30 | export type Use = Types.Use
  31 | export type Value<T, S = T> = Types.Value<T, S>
  32 | export type Version = Types.Version
  33 | 
  34 | -- Down the line, this will be conditional based on whether Fusion is being
  35 | -- compiled for Roblox.
  36 | do
  37 | 	local RobloxExternal = require(script.RobloxExternal)
  38 | 	External.setExternalProvider(RobloxExternal)
  39 | end
  40 | 
  41 | local Fusion: Fusion = table.freeze {
  42 | 	-- General
  43 | 	version = {major = 0, minor = 3, isRelease = true},
  44 | 	Contextual = require(script.Utility.Contextual),
  45 | 	Safe = require(script.Utility.Safe),
  46 | 
  47 | 	-- Memory
  48 | 	cleanup = require(script.Memory.legacyCleanup),
  49 | 	deriveScope = require(script.Memory.deriveScope),
  50 | 	doCleanup = require(script.Memory.doCleanup),
  51 | 	innerScope = require(script.Memory.innerScope),
  52 | 	scoped = require(script.Memory.scoped),
  53 | 	
  54 | 	-- Graph
  55 | 	Observer = require(script.Graph.Observer),
  56 | 
  57 | 	-- State
  58 | 	Computed = require(script.State.Computed),
  59 | 	ForKeys = require(script.State.ForKeys) :: Types.ForKeysConstructor,
  60 | 	ForPairs = require(script.State.ForPairs) :: Types.ForPairsConstructor,
  61 | 	ForValues = require(script.State.ForValues) :: Types.ForValuesConstructor,
  62 | 	peek = require(script.State.peek),
  63 | 	Value = require(script.State.Value),
  64 | 
  65 | 	-- Roblox API
  66 | 	Attribute = require(script.Instances.Attribute),
  67 | 	AttributeChange = require(script.Instances.AttributeChange),
  68 | 	AttributeOut = require(script.Instances.AttributeOut),
  69 | 	Child = require(script.Instances.Child),
  70 | 	Children = require(script.Instances.Children),
  71 | 	Hydrate = require(script.Instances.Hydrate),
  72 | 	New = require(script.Instances.New),
  73 | 	OnChange = require(script.Instances.OnChange),
  74 | 	OnEvent = require(script.Instances.OnEvent),
  75 | 	Out = require(script.Instances.Out),
  76 | 
  77 | 	-- Animation
  78 | 	Tween = require(script.Animation.Tween),
  79 | 	Spring = require(script.Animation.Spring),
  80 | }
  81 | 
  82 | return Fusion
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/Instances/applyInstanceProps.luau`
<details>
<summary>View Source (148 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 | 	Applies a table of properties to an instance, including binding to any
   8 | 	given state objects and applying any special keys.
   9 | 
  10 | 	No strong reference is kept by default - special keys should take care not
  11 | 	to accidentally hold strong references to instances forever.
  12 | 
  13 | 	If a key is used twice, an error will be thrown. This is done to avoid
  14 | 	double assignments or double bindings. However, some special keys may want
  15 | 	to enable such assignments - in which case unique keys should be used for
  16 | 	each occurence.
  17 | ]]
  18 | 
  19 | local Package = script.Parent.Parent
  20 | local Types = require(Package.Types)
  21 | local External = require(Package.External)
  22 | -- Logging
  23 | local parseError = require(Package.Logging.parseError)
  24 | -- Memory
  25 | local checkLifetime = require(Package.Memory.checkLifetime)
  26 | -- Graph
  27 | local Observer = require(Package.Graph.Observer)
  28 | -- State
  29 | local castToState = require(Package.State.castToState)
  30 | local peek = require(Package.State.peek)
  31 | -- Utility
  32 | local xtypeof = require(Package.Utility.xtypeof)
  33 | 
  34 | local function setProperty_unsafe(
  35 | 	instance: Instance,
  36 | 	property: string,
  37 | 	value: unknown
  38 | )
  39 | 	(instance :: any)[property] = value
  40 | end
  41 | 
  42 | local function testPropertyAssignable(
  43 | 	instance: Instance,
  44 | 	property: string
  45 | )
  46 | 	(instance :: any)[property] = (instance :: any)[property]
  47 | end
  48 | 
  49 | local function setProperty(
  50 | 	instance: Instance,
  51 | 	property: string,
  52 | 	value: unknown
  53 | )
  54 | 	local success, err = xpcall(setProperty_unsafe :: any, parseError, instance, property, value)
  55 | 
  56 | 	if not success then
  57 | 		if not pcall(testPropertyAssignable, instance, property) then
  58 | 			External.logErrorNonFatal("cannotAssignProperty", nil, instance.ClassName, property)
  59 | 		else
  60 | 			-- property is assignable, but this specific assignment failed
  61 | 			-- this typically implies the wrong type was received
  62 | 			local givenType = typeof(value)
  63 | 			local expectedType = typeof((instance :: any)[property])
  64 | 
  65 | 			if givenType == expectedType then
  66 | 				External.logErrorNonFatal("propertySetError", err)
  67 | 			else
  68 | 				External.logErrorNonFatal("invalidPropertyType", nil, instance.ClassName, property, expectedType, givenType)
  69 | 			end
  70 | 		end
  71 | 	end
  72 | end
  73 | 
  74 | local function bindProperty(
  75 | 	scope: Types.Scope<unknown>,
  76 | 	instance: Instance,
  77 | 	property: string,
  78 | 	value: Types.UsedAs<unknown>
  79 | )
  80 | 	if castToState(value) then
  81 | 		local value = value :: Types.StateObject<unknown>
  82 | 		checkLifetime.bOutlivesA(
  83 | 			scope, instance,
  84 | 			value.scope, value.oldestTask,
  85 | 			checkLifetime.formatters.boundProperty, property
  86 | 		)
  87 | 		-- value is a state object - bind to changes
  88 | 		Observer(scope, value :: any):onBind(function()
  89 | 			setProperty(instance, property, peek(value))
  90 | 		end)
  91 | 	else
  92 | 		-- value is a constant - assign once only
  93 | 		setProperty(instance, property, value)
  94 | 	end
  95 | end
  96 | 
  97 | local function applyInstanceProps(
  98 | 	scope: Types.Scope<unknown>,
  99 | 	props: Types.PropertyTable,
 100 | 	applyTo: Instance
 101 | )
 102 | 	local specialKeys = {
 103 | 		self = {} :: {[Types.SpecialKey]: unknown},
 104 | 		descendants = {} :: {[Types.SpecialKey]: unknown},
 105 | 		ancestor = {} :: {[Types.SpecialKey]: unknown},
 106 | 		observer = {} :: {[Types.SpecialKey]: unknown}
 107 | 	}
 108 | 
 109 | 	for key, value in pairs(props) do
 110 | 		local keyType = xtypeof(key)
 111 | 
 112 | 		if keyType == "string" then
 113 | 			if key ~= "Parent" then
 114 | 				bindProperty(scope, applyTo, key :: string, value)
 115 | 			end
 116 | 		elseif keyType == "SpecialKey" then
 117 | 			local stage = (key :: Types.SpecialKey).stage
 118 | 			local keys = specialKeys[stage]
 119 | 			if keys == nil then
 120 | 				External.logError("unrecognisedPropertyStage", nil, stage)
 121 | 			else
 122 | 				keys[key] = value
 123 | 			end
 124 | 		else
 125 | 			-- we don't recognise what this key is supposed to be
 126 | 			External.logError("unrecognisedPropertyKey", nil, keyType)
 127 | 		end
 128 | 	end
 129 | 
 130 | 	for key, value in pairs(specialKeys.self) do
 131 | 		key:apply(scope, value, applyTo)
 132 | 	end
 133 | 	for key, value in pairs(specialKeys.descendants) do
 134 | 		key:apply(scope, value, applyTo)
 135 | 	end
 136 | 
 137 | 	if props.Parent ~= nil then
 138 | 		bindProperty(scope, applyTo, "Parent", props.Parent)
 139 | 	end
 140 | 
 141 | 	for key, value in pairs(specialKeys.ancestor) do
 142 | 		key:apply(scope, value, applyTo)
 143 | 	end
 144 | 	for key, value in pairs(specialKeys.observer) do
 145 | 		key:apply(scope, value, applyTo)
 146 | 	end
 147 | end
 148 | 
 149 | return applyInstanceProps
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/Instances/Attribute.luau`
<details>
<summary>View Source (57 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 | 	A special key for property tables, which allows users to apply custom
   8 | 	attributes to instances
   9 | ]]
  10 | 
  11 | local Package = script.Parent.Parent
  12 | local Types = require(Package.Types)
  13 | -- Memory
  14 | local checkLifetime = require(Package.Memory.checkLifetime)
  15 | -- Graph
  16 | local Observer = require(Package.Graph.Observer)
  17 | -- State
  18 | local castToState = require(Package.State.castToState)
  19 | local peek = require(Package.State.peek)
  20 | 
  21 | local keyCache: {[string]: Types.SpecialKey} = {}
  22 | 
  23 | local function Attribute(
  24 | 	attributeName: string
  25 | ): Types.SpecialKey
  26 | 	local key = keyCache[attributeName]
  27 | 	if key == nil then
  28 | 		key = {
  29 | 			type = "SpecialKey",
  30 | 			kind = "Attribute",
  31 | 			stage = "self",
  32 | 			apply = function(
  33 | 				self: Types.SpecialKey,
  34 | 				scope: Types.Scope<unknown>,
  35 | 				value: unknown,
  36 | 				applyTo: Instance
  37 | 			)
  38 | 				if castToState(value) then
  39 | 					local value = value :: Types.StateObject<unknown>
  40 | 					checkLifetime.bOutlivesA(
  41 | 						scope, applyTo,
  42 | 						value.scope, value.oldestTask,
  43 | 						checkLifetime.formatters.boundAttribute, attributeName
  44 | 					)
  45 | 					Observer(scope, value :: any):onBind(function()
  46 | 						applyTo:SetAttribute(attributeName, peek(value))
  47 | 					end)
  48 | 				else
  49 | 					applyTo:SetAttribute(attributeName, value)
  50 | 				end
  51 | 			end
  52 | 		}
  53 | 		keyCache[attributeName] = key
  54 | 	end
  55 | 	return key
  56 | end
  57 | 
  58 | return Attribute
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/Instances/AttributeChange.luau`
<details>
<summary>View Source (46 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 | 	A special key for property tables, which allows users to connect to
   8 | 	an attribute change on an instance.
   9 | ]]
  10 | 
  11 | local Package = script.Parent.Parent
  12 | local Types = require(Package.Types)
  13 | local External = require(Package.External)
  14 | 
  15 | local keyCache: {[string]: Types.SpecialKey} = {}
  16 | 
  17 | local function AttributeChange(
  18 | 	attributeName: string
  19 | ): Types.SpecialKey
  20 | 	local key = keyCache[attributeName]
  21 | 	if key == nil then
  22 | 		key = {
  23 | 			type = "SpecialKey",
  24 | 			kind = "AttributeChange",
  25 | 			stage = "observer",
  26 | 			apply = function(
  27 | 				self: Types.SpecialKey,
  28 | 				scope: Types.Scope<unknown>,
  29 | 				value: unknown,
  30 | 				applyTo: Instance
  31 | 			)
  32 | 				if typeof(value) ~= "function" then
  33 | 					External.logError("invalidAttributeChangeHandler", nil, attributeName)
  34 | 				end
  35 | 				local value = value :: (...unknown) -> (...unknown)
  36 | 				local event = applyTo:GetAttributeChangedSignal(attributeName)
  37 | 				table.insert(scope, event:Connect(function()
  38 | 					value((applyTo :: any):GetAttribute(attributeName))
  39 | 				end))
  40 | 			end
  41 | 		}
  42 | 		keyCache[attributeName] = key
  43 | 	end
  44 | 	return key
  45 | end
  46 | 
  47 | return AttributeChange
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/Instances/AttributeOut.luau`
<details>
<summary>View Source (63 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 | 	A special key for property tables, which allows users to save instance attributes
   8 | 	into state objects
   9 | ]]
  10 | 
  11 | local Package = script.Parent.Parent
  12 | local Types = require(Package.Types)
  13 | local External = require(Package.External)
  14 | -- Memory
  15 | local checkLifetime = require(Package.Memory.checkLifetime)
  16 | -- State
  17 | local castToState = require(Package.State.castToState)
  18 | 
  19 | local keyCache: {[string]: Types.SpecialKey} = {}
  20 | 
  21 | local function AttributeOut(
  22 | 	attributeName: string
  23 | ): Types.SpecialKey
  24 | 	local key = keyCache[attributeName]
  25 | 	if key == nil then
  26 | 		key = {
  27 | 			type = "SpecialKey",
  28 | 			kind = "AttributeOut",
  29 | 			stage = "observer",
  30 | 			apply = function(
  31 | 				self: Types.SpecialKey,
  32 | 				scope: Types.Scope<unknown>,
  33 | 				value: unknown,
  34 | 				applyTo: Instance
  35 | 			)
  36 | 				local event = applyTo:GetAttributeChangedSignal(attributeName)
  37 | 	
  38 | 				if not castToState(value) then
  39 | 					External.logError("invalidAttributeOutType")
  40 | 				end
  41 | 				local value = value :: Types.StateObject<unknown>
  42 | 				if value.kind ~= "Value" then
  43 | 					External.logError("invalidAttributeOutType")
  44 | 				end
  45 | 				local value = value :: Types.Value<unknown>
  46 | 				checkLifetime.bOutlivesA(
  47 | 					scope, applyTo,
  48 | 					value.scope, value.oldestTask,
  49 | 					checkLifetime.formatters.attributeOutputsTo, attributeName
  50 | 				)
  51 | 
  52 | 				value:set((applyTo :: any):GetAttribute(attributeName))
  53 | 				table.insert(scope, event:Connect(function()	
  54 | 					value:set((applyTo :: any):GetAttribute(attributeName))
  55 | 				end))
  56 | 			end
  57 | 		}
  58 | 		keyCache[attributeName] = key
  59 | 	end
  60 | 	return key
  61 | end
  62 | 
  63 | return AttributeOut
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/Instances/Child.luau`
<details>
<summary>View Source (21 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 | 	Helper function for type checking purposes. Casts the input to a `Child`
   8 | 	type, while constraining the input to be an array of `Child` - this prevents
   9 | 	Luau from erroneously inferring a different array type for the input.
  10 | ]]
  11 | 
  12 | local Package = script.Parent.Parent
  13 | local Types = require(Package.Types)
  14 | 
  15 | local function Child(
  16 | 	x: {Types.Child}
  17 | ): Types.Child
  18 | 	return x
  19 | end
  20 | 
  21 | return Child
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/Instances/Children.luau`
<details>
<summary>View Source (147 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 | 	A special key for property tables, which parents any given descendants into
   8 | 	an instance.
   9 | ]]
  10 | 
  11 | local Package = script.Parent.Parent
  12 | local Types = require(Package.Types)
  13 | local External = require(Package.External)
  14 | local Observer = require(Package.Graph.Observer)
  15 | local peek = require(Package.State.peek)
  16 | local castToState = require(Package.State.castToState)
  17 | local doCleanup = require(Package.Memory.doCleanup)
  18 | 
  19 | type Set<T> = {[T]: unknown}
  20 | 
  21 | -- Experimental flag: name children based on the key used in the [Children] table
  22 | local EXPERIMENTAL_AUTO_NAMING = false
  23 | 
  24 | return {
  25 | 	type = "SpecialKey",
  26 | 	kind = "Children",
  27 | 	stage = "descendants",
  28 | 	apply = function(
  29 | 		self: Types.SpecialKey,
  30 | 		scope: Types.Scope<unknown>,
  31 | 		value: unknown,
  32 | 		applyTo: Instance
  33 | 	)
  34 | 		local newParented: Set<Instance> = {}
  35 | 		local oldParented: Set<Instance> = {}
  36 | 	
  37 | 		-- save scopes for state object observers
  38 | 		local newScopes: {[Types.StateObject<unknown>]: Types.Scope<unknown>} = {}
  39 | 		local oldScopes: {[Types.StateObject<unknown>]: Types.Scope<unknown>} = {}
  40 | 	
  41 | 		-- Rescans this key's value to find new instances to parent and state objects
  42 | 		-- to observe for changes; then unparents instances no longer found and
  43 | 		-- disconnects observers for state objects no longer present.
  44 | 		local function updateChildren()
  45 | 			oldParented, newParented = newParented, oldParented
  46 | 			oldScopes, newScopes = newScopes, oldScopes
  47 | 	
  48 | 			local function processChild(
  49 | 				child: unknown,
  50 | 				autoName: string?
  51 | 			)
  52 | 				local childType = typeof(child)
  53 | 	
  54 | 				if childType == "Instance" then
  55 | 					-- case 1; single instance
  56 | 					local child = child :: Instance
  57 | 	
  58 | 					newParented[child] = true
  59 | 					if oldParented[child] == nil then
  60 | 						-- wasn't previously present
  61 | 	
  62 | 						-- TODO: check for ancestry conflicts here
  63 | 						child.Parent = applyTo
  64 | 					else
  65 | 						-- previously here; we want to reuse, so remove from old
  66 | 						-- set so we don't encounter it during unparenting
  67 | 						oldParented[child] = nil
  68 | 					end
  69 | 	
  70 | 					if EXPERIMENTAL_AUTO_NAMING and autoName ~= nil then
  71 | 						child.Name = autoName
  72 | 					end
  73 | 	
  74 | 				elseif castToState(child) then
  75 | 					-- case 2; state object
  76 | 					local child = child :: Types.StateObject<unknown>
  77 | 	
  78 | 					local value = peek(child)
  79 | 					-- allow nil to represent the absence of a child
  80 | 					if value ~= nil then
  81 | 						processChild(value, autoName)
  82 | 					end
  83 | 	
  84 | 					local childScope = oldScopes[child]
  85 | 					if childScope == nil then
  86 | 						-- wasn't previously present
  87 | 						childScope = {}
  88 | 						Observer(childScope, child):onChange(updateChildren)
  89 | 					else
  90 | 						-- previously here; we want to reuse, so remove from old
  91 | 						-- set so we don't encounter it during unparenting
  92 | 						oldScopes[child] = nil
  93 | 					end
  94 | 	
  95 | 					newScopes[child] = childScope
  96 | 	
  97 | 				elseif childType == "table" then
  98 | 					-- case 3; table of objects
  99 | 					local child = child :: {[unknown]: unknown}
 100 | 	
 101 | 					for key, subChild in pairs(child) do
 102 | 						local keyType = typeof(key)
 103 | 						local subAutoName: string? = nil
 104 | 	
 105 | 						if keyType == "string" then
 106 | 							local key = key :: string
 107 | 							subAutoName = key
 108 | 						elseif keyType == "number" and autoName ~= nil then
 109 | 							local key = key :: number
 110 | 							subAutoName = autoName .. "_" .. key
 111 | 						end
 112 | 	
 113 | 						processChild(subChild, subAutoName)
 114 | 					end
 115 | 	
 116 | 				else
 117 | 					External.logWarn("unrecognisedChildType", childType)
 118 | 				end
 119 | 			end
 120 | 	
 121 | 			if value ~= nil then
 122 | 				-- `propValue` is set to nil on cleanup, so we don't process children
 123 | 				-- in that case
 124 | 				processChild(value)
 125 | 			end
 126 | 	
 127 | 			-- unparent any children that are no longer present
 128 | 			for oldInstance in pairs(oldParented) do
 129 | 				oldInstance.Parent = nil
 130 | 			end
 131 | 			table.clear(oldParented)
 132 | 	
 133 | 			-- disconnect observers which weren't reused
 134 | 			for oldState, childScope in pairs(oldScopes) do
 135 | 				doCleanup(childScope)
 136 | 			end
 137 | 			table.clear(oldScopes)
 138 | 		end
 139 | 	
 140 | 		table.insert(scope, function()
 141 | 			value = nil
 142 | 			updateChildren()
 143 | 		end)
 144 | 	
 145 | 		-- perform initial child parenting
 146 | 		updateChildren()
 147 | 	end
 148 | } :: Types.SpecialKey
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/Instances/defaultProps.luau`
<details>
<summary>View Source (194 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 | 	Stores 'sensible default' properties to be applied to instances created by
   8 | 	the New function.
   9 | ]]
  10 | 
  11 | return {
  12 | 	ScreenGui = {
  13 | 		ResetOnSpawn = false,
  14 | 		ZIndexBehavior = Enum.ZIndexBehavior.Sibling
  15 | 	},
  16 | 
  17 | 	BillboardGui = {
  18 | 		ResetOnSpawn = false,
  19 | 		ZIndexBehavior = Enum.ZIndexBehavior.Sibling,
  20 | 		Active = true
  21 | 	},
  22 | 
  23 | 	SurfaceGui = {
  24 | 		ResetOnSpawn = false,
  25 | 		ZIndexBehavior = Enum.ZIndexBehavior.Sibling,
  26 | 
  27 | 		SizingMode = Enum.SurfaceGuiSizingMode.PixelsPerStud,
  28 | 		PixelsPerStud = 50
  29 | 	},
  30 | 
  31 | 	Frame = {
  32 | 		BackgroundColor3 = Color3.new(1, 1, 1),
  33 | 		BorderColor3 = Color3.new(0, 0, 0),
  34 | 		BorderSizePixel = 0
  35 | 	},
  36 | 
  37 | 	ScrollingFrame = {
  38 | 		BackgroundColor3 = Color3.new(1, 1, 1),
  39 | 		BorderColor3 = Color3.new(0, 0, 0),
  40 | 		BorderSizePixel = 0,
  41 | 
  42 | 		ScrollBarImageColor3 = Color3.new(0, 0, 0)
  43 | 	},
  44 | 
  45 | 	TextLabel = {
  46 | 		BackgroundColor3 = Color3.new(1, 1, 1),
  47 | 		BorderColor3 = Color3.new(0, 0, 0),
  48 | 		BorderSizePixel = 0,
  49 | 
  50 | 		Font = Enum.Font.SourceSans,
  51 | 		Text = "",
  52 | 		TextColor3 = Color3.new(0, 0, 0),
  53 | 		TextSize = 14
  54 | 	},
  55 | 
  56 | 	TextButton = {
  57 | 		BackgroundColor3 = Color3.new(1, 1, 1),
  58 | 		BorderColor3 = Color3.new(0, 0, 0),
  59 | 		BorderSizePixel = 0,
  60 | 
  61 | 		AutoButtonColor = false,
  62 | 
  63 | 		Font = Enum.Font.SourceSans,
  64 | 		Text = "",
  65 | 		TextColor3 = Color3.new(0, 0, 0),
  66 | 		TextSize = 14
  67 | 	},
  68 | 
  69 | 	TextBox = {
  70 | 		BackgroundColor3 = Color3.new(1, 1, 1),
  71 | 		BorderColor3 = Color3.new(0, 0, 0),
  72 | 		BorderSizePixel = 0,
  73 | 
  74 | 		ClearTextOnFocus = false,
  75 | 
  76 | 		Font = Enum.Font.SourceSans,
  77 | 		Text = "",
  78 | 		TextColor3 = Color3.new(0, 0, 0),
  79 | 		TextSize = 14
  80 | 	},
  81 | 
  82 | 	ImageLabel = {
  83 | 		BackgroundColor3 = Color3.new(1, 1, 1),
  84 | 		BorderColor3 = Color3.new(0, 0, 0),
  85 | 		BorderSizePixel = 0
  86 | 	},
  87 | 
  88 | 	ImageButton = {
  89 | 		BackgroundColor3 = Color3.new(1, 1, 1),
  90 | 		BorderColor3 = Color3.new(0, 0, 0),
  91 | 		BorderSizePixel = 0,
  92 | 
  93 | 		AutoButtonColor = false
  94 | 	},
  95 | 
  96 | 	ViewportFrame = {
  97 | 		BackgroundColor3 = Color3.new(1, 1, 1),
  98 | 		BorderColor3 = Color3.new(0, 0, 0),
  99 | 		BorderSizePixel = 0
 100 | 	},
 101 | 
 102 | 	VideoFrame = {
 103 | 		BackgroundColor3 = Color3.new(1, 1, 1),
 104 | 		BorderColor3 = Color3.new(0, 0, 0),
 105 | 		BorderSizePixel = 0
 106 | 	},
 107 | 	
 108 | 	CanvasGroup = {
 109 | 		BackgroundColor3 = Color3.new(1, 1, 1),
 110 | 		BorderColor3 = Color3.new(0, 0, 0),
 111 | 		BorderSizePixel = 0
 112 | 	},
 113 | 
 114 | 	SpawnLocation = {
 115 | 		Duration = 0
 116 | 	},
 117 | 
 118 | 	BoxHandleAdornment = {
 119 | 		ZIndex = 0
 120 | 	},
 121 | 	ConeHandleAdornment = {
 122 | 		ZIndex = 0
 123 | 	},
 124 | 	CylinderHandleAdornment = {
 125 | 		ZIndex = 0
 126 | 	},
 127 | 	ImageHandleAdornment = {
 128 | 		ZIndex = 0
 129 | 	},
 130 | 	LineHandleAdornment = {
 131 | 		ZIndex = 0
 132 | 	},
 133 | 	SphereHandleAdornment = {
 134 | 		ZIndex = 0
 135 | 	},
 136 | 	WireframeHandleAdornment = {
 137 | 		ZIndex = 0
 138 | 	},
 139 | 	
 140 | 	Part = {
 141 | 		Anchored = true,
 142 | 		Size = Vector3.one,
 143 | 		FrontSurface = Enum.SurfaceType.Smooth,
 144 | 		BackSurface = Enum.SurfaceType.Smooth,
 145 | 		LeftSurface = Enum.SurfaceType.Smooth,
 146 | 		RightSurface = Enum.SurfaceType.Smooth,
 147 | 		TopSurface = Enum.SurfaceType.Smooth,
 148 | 		BottomSurface = Enum.SurfaceType.Smooth,
 149 | 	},
 150 | 	
 151 | 	TrussPart = {
 152 | 		Anchored = true,
 153 | 		Size = Vector3.one * 2,
 154 | 		FrontSurface = Enum.SurfaceType.Smooth,
 155 | 		BackSurface = Enum.SurfaceType.Smooth,
 156 | 		LeftSurface = Enum.SurfaceType.Smooth,
 157 | 		RightSurface = Enum.SurfaceType.Smooth,
 158 | 		TopSurface = Enum.SurfaceType.Smooth,
 159 | 		BottomSurface = Enum.SurfaceType.Smooth,
 160 | 	},
 161 | 
 162 | 	MeshPart = {
 163 | 		Anchored = true,
 164 | 		Size = Vector3.one,
 165 | 		FrontSurface = Enum.SurfaceType.Smooth,
 166 | 		BackSurface = Enum.SurfaceType.Smooth,
 167 | 		LeftSurface = Enum.SurfaceType.Smooth,
 168 | 		RightSurface = Enum.SurfaceType.Smooth,
 169 | 		TopSurface = Enum.SurfaceType.Smooth,
 170 | 		BottomSurface = Enum.SurfaceType.Smooth,
 171 | 	},
 172 | 
 173 | 	CornerWedgePart = {
 174 | 		Anchored = true,
 175 | 		Size = Vector3.one,
 176 | 		FrontSurface = Enum.SurfaceType.Smooth,
 177 | 		BackSurface = Enum.SurfaceType.Smooth,
 178 | 		LeftSurface = Enum.SurfaceType.Smooth,
 179 | 		RightSurface = Enum.SurfaceType.Smooth,
 180 | 		TopSurface = Enum.SurfaceType.Smooth,
 181 | 		BottomSurface = Enum.SurfaceType.Smooth,
 182 | 	},
 183 | 
 184 | 	VehicleSeat = {
 185 | 		Anchored = true,
 186 | 		Size = Vector3.one,
 187 | 		FrontSurface = Enum.SurfaceType.Smooth,
 188 | 		BackSurface = Enum.SurfaceType.Smooth,
 189 | 		LeftSurface = Enum.SurfaceType.Smooth,
 190 | 		RightSurface = Enum.SurfaceType.Smooth,
 191 | 		TopSurface = Enum.SurfaceType.Smooth,
 192 | 		BottomSurface = Enum.SurfaceType.Smooth,
 193 | 	},
 194 | }
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/Instances/Hydrate.luau`
<details>
<summary>View Source (32 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 | 	Processes and returns an existing instance, with options for setting
   8 | 	properties, event handlers and other attributes on the instance.
   9 | ]]
  10 | 
  11 | local Package = script.Parent.Parent
  12 | local Types = require(Package.Types)
  13 | local External = require(Package.External)
  14 | local applyInstanceProps = require(Package.Instances.applyInstanceProps)
  15 | 
  16 | local function Hydrate(
  17 | 	scope: Types.Scope<unknown>,
  18 | 	target: Instance
  19 | )
  20 | 	if target :: any == nil then
  21 | 		External.logError("scopeMissing", nil, "instances using Hydrate", "myScope:Hydrate (instance) { ... }")
  22 | 	end
  23 | 	return function(
  24 | 		props: Types.PropertyTable
  25 | 	): Instance
  26 | 	
  27 | 		table.insert(scope, target)
  28 | 		applyInstanceProps(scope, props, target)
  29 | 		return target
  30 | 	end
  31 | end
  32 | 
  33 | return Hydrate
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/Instances/New.luau`
<details>
<summary>View Source (52 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 | 	Constructs and returns a new instance, with options for setting properties,
   8 | 	event handlers and other attributes on the instance right away.
   9 | ]]
  10 | 
  11 | local Package = script.Parent.Parent
  12 | local Types = require(Package.Types)
  13 | local External = require(Package.External)
  14 | local defaultProps = require(Package.Instances.defaultProps)
  15 | local applyInstanceProps = require(Package.Instances.applyInstanceProps)
  16 | 
  17 | type Component = (Types.PropertyTable) -> Instance
  18 | 
  19 | local function New(
  20 | 	scope: Types.Scope<unknown>,
  21 | 	className: string
  22 | )
  23 | 	if (className :: any) == nil then
  24 | 		local scope = (scope :: any) :: string
  25 | 		External.logError("scopeMissing", nil, "instances using New", "myScope:New \"" .. scope .. "\" { ... }")
  26 | 	end
  27 | 
  28 | 	-- This might look appealing to try and cache. But please don't. The scope
  29 | 	-- upvalue is shared between the two curried function calls, so this will
  30 | 	-- open incredible cross-codebase wormholes like you've never seen before.
  31 | 	return function(
  32 | 		props: Types.PropertyTable
  33 | 	): Instance
  34 | 		local ok, instance = pcall(Instance.new, className)
  35 | 		if not ok then
  36 | 			External.logError("cannotCreateClass", nil, className)
  37 | 		end
  38 | 
  39 | 		local classDefaults = defaultProps[className]
  40 | 		if classDefaults ~= nil then
  41 | 			for defaultProp, defaultValue in pairs(classDefaults) do
  42 | 				(instance :: any)[defaultProp] = defaultValue
  43 | 			end
  44 | 		end
  45 | 
  46 | 		table.insert(scope, instance)
  47 | 		applyInstanceProps(scope, props, instance)
  48 | 
  49 | 		return instance
  50 | 	end
  51 | end
  52 | 
  53 | return New
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/Instances/OnChange.luau`
<details>
<summary>View Source (49 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 | 	Constructs special keys for property tables which connect property change
   8 | 	listeners to an instance.
   9 | ]]
  10 | 
  11 | local Package = script.Parent.Parent
  12 | local Types = require(Package.Types)
  13 | local External = require(Package.External)
  14 | 
  15 | local keyCache: {[string]: Types.SpecialKey} = {}
  16 | 
  17 | local function OnChange(
  18 | 	propertyName: string
  19 | ): Types.SpecialKey
  20 | 	local key = keyCache[propertyName]
  21 | 	if key == nil then
  22 | 		key = {
  23 | 			type = "SpecialKey",
  24 | 			kind = "OnChange",
  25 | 			stage = "observer",
  26 | 			apply = function(
  27 | 				self: Types.SpecialKey,
  28 | 				scope: Types.Scope<unknown>,
  29 | 				callback: unknown,
  30 | 				applyTo: Instance
  31 | 			)
  32 | 				local ok, event = pcall(applyTo.GetPropertyChangedSignal, applyTo, propertyName)
  33 | 				if not ok then
  34 | 					External.logError("cannotConnectChange", nil, applyTo.ClassName, propertyName)
  35 | 				elseif typeof(callback) ~= "function" then
  36 | 					External.logError("invalidChangeHandler", nil, propertyName)
  37 | 				else
  38 | 					local callback = callback :: (...unknown) -> (...unknown)
  39 | 					table.insert(scope, event:Connect(function()
  40 | 						callback((applyTo :: any)[propertyName])
  41 | 					end))
  42 | 				end
  43 | 			end
  44 | 		}
  45 | 		keyCache[propertyName] = key
  46 | 	end
  47 | 	return key
  48 | end
  49 | 
  50 | return OnChange
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/Instances/OnEvent.luau`
<details>
<summary>View Source (53 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 | 	Constructs special keys for property tables which connect event listeners to
   8 | 	an instance.
   9 | ]]
  10 | 
  11 | local Package = script.Parent.Parent
  12 | local Types = require(Package.Types)
  13 | local External = require(Package.External)
  14 | 
  15 | local keyCache: {[string]: Types.SpecialKey} = {}
  16 | 
  17 | local function getProperty_unsafe(
  18 | 	instance: Instance,
  19 | 	property: string
  20 | )
  21 | 	return (instance :: any)[property]
  22 | end
  23 | 
  24 | local function OnEvent(
  25 | 	eventName: string
  26 | ): Types.SpecialKey
  27 | 	local key = keyCache[eventName]
  28 | 	if key == nil then
  29 | 		key = {
  30 | 			type = "SpecialKey",
  31 | 			kind = "OnEvent",
  32 | 			stage = "observer",
  33 | 			apply = function(
  34 | 				self: Types.SpecialKey,
  35 | 				scope: Types.Scope<unknown>,
  36 | 				callback: unknown,
  37 | 				applyTo: Instance
  38 | 			)
  39 | 				local ok, event = pcall(getProperty_unsafe, applyTo, eventName)
  40 | 				if not ok or typeof(event) ~= "RBXScriptSignal" then
  41 | 					External.logError("cannotConnectEvent", nil, applyTo.ClassName, eventName)
  42 | 				elseif typeof(callback) ~= "function" then
  43 | 					External.logError("invalidEventHandler", nil, eventName)
  44 | 				else
  45 | 					table.insert(scope, event:Connect(callback :: any))
  46 | 				end
  47 | 			end
  48 | 		}
  49 | 		keyCache[eventName] = key
  50 | 	end
  51 | 	return key
  52 | end
  53 | 
  54 | return OnEvent
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/Instances/Out.luau`
<details>
<summary>View Source (69 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 | 	A special key for property tables, which allows users to extract values from
   8 | 	an instance into an automatically-updated Value object.
   9 | ]]
  10 | 
  11 | local Package = script.Parent.Parent
  12 | local Types = require(Package.Types)
  13 | local External = require(Package.External)
  14 | -- Memory
  15 | local checkLifetime = require(Package.Memory.checkLifetime)
  16 | -- State
  17 | local castToState = require(Package.State.castToState)
  18 | 
  19 | local keyCache: {[string]: Types.SpecialKey} = {}
  20 | 
  21 | local function Out(
  22 | 	propertyName: string
  23 | ): Types.SpecialKey
  24 | 	local key = keyCache[propertyName]
  25 | 	if key == nil then
  26 | 		key = {
  27 | 			type = "SpecialKey",
  28 | 			kind = "Out",
  29 | 			stage = "observer",
  30 | 			apply = function(
  31 | 				self: Types.SpecialKey,
  32 | 				scope: Types.Scope<unknown>,
  33 | 				value: unknown,
  34 | 				applyTo: Instance
  35 | 			)
  36 | 				local ok, event = pcall(applyTo.GetPropertyChangedSignal, applyTo, propertyName)
  37 | 				if not ok then
  38 | 					External.logError("invalidOutProperty", nil, applyTo.ClassName, propertyName)
  39 | 				end
  40 | 	
  41 | 				if not castToState(value) then
  42 | 					External.logError("invalidOutType")
  43 | 				end
  44 | 				local value = value :: Types.StateObject<unknown>
  45 | 				if value.kind ~= "Value" then
  46 | 					External.logError("invalidOutType")
  47 | 				end
  48 | 				local value = value :: Types.Value<unknown>
  49 | 				checkLifetime.bOutlivesA(
  50 | 					scope, applyTo, 
  51 | 					value.scope, value.oldestTask,
  52 | 					checkLifetime.formatters.propertyOutputsTo, propertyName
  53 | 				)
  54 | 
  55 | 				value:set((applyTo :: any)[propertyName])
  56 | 				table.insert(
  57 | 					scope,
  58 | 					event:Connect(function()
  59 | 						value:set((applyTo :: any)[propertyName])
  60 | 					end)
  61 | 				)
  62 | 			end
  63 | 		}
  64 | 		keyCache[propertyName] = key
  65 | 	end
  66 | 	return key
  67 | end
  68 | 
  69 | return Out
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/Logging/formatError.luau`
<details>
<summary>View Source (48 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 | 	Formats a Fusion-specific error message.
   8 | ]]
   9 | 
  10 | local Package = script.Parent.Parent
  11 | local Types = require(Package.Types)
  12 | local messages = require(Package.Logging.messages)
  13 | 
  14 | local ERROR_INFO_URL = "https://elttob.uk/Fusion/0.3/api-reference/general/errors/#"
  15 | 
  16 | local function formatError(
  17 | 	externalProvider: Types.ExternalProvider?,
  18 | 	messageID: string,
  19 | 	errorOrTrace: Types.Error | string | nil,
  20 | 	...: unknown
  21 | ): string
  22 | 	local originalMessageID = messageID
  23 | 	local error: Types.Error? = if typeof(errorOrTrace) == "table" then errorOrTrace else nil
  24 | 	local trace: string? = if typeof(errorOrTrace) == "table" then errorOrTrace.trace else errorOrTrace
  25 | 	local messageText = messages[messageID]
  26 | 	if messageText == nil then
  27 | 		messageID = "unknownMessage"
  28 | 		messageText = messages[messageID]
  29 | 	end
  30 | 	messageText = messageText:format(...)
  31 | 	if error ~= nil then
  32 | 		messageText = messageText:gsub("ERROR_MESSAGE", error.message)
  33 | 		if error.context ~= nil then
  34 | 			messageText ..= ` ({error.context})`
  35 | 		end
  36 | 	else
  37 | 		messageText = messageText:gsub("ERROR_MESSAGE", originalMessageID)
  38 | 	end
  39 | 	messageText = `[Fusion] {messageText} \nID: {messageID}`
  40 | 	if externalProvider ~= nil and externalProvider.policies.allowWebLinks then
  41 | 		messageText ..= `\nLearn more: {ERROR_INFO_URL}{messageID:lower()}`
  42 | 	end
  43 | 	if trace ~= nil then
  44 | 		messageText ..= ` \n---- Stack trace ----\n{trace}`
  45 | 	end
  46 | 	return messageText:gsub("\n", "\n    ")
  47 | end
  48 | 
  49 | return formatError
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/Logging/messages.luau`
<details>
<summary>View Source (51 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 | 	Stores templates for different kinds of logging messages.
   8 | ]]
   9 | 
  10 | return {
  11 | 	callbackError = "Error in callback:\nERROR_MESSAGE",
  12 | 	cannotAssignProperty = "The class type '%s' has no assignable property '%s'.",
  13 | 	cannotConnectChange = "The %s class doesn't have a property called '%s'.",
  14 | 	cannotConnectEvent = "The %s class doesn't have an event called '%s'.",
  15 | 	cannotCreateClass = "Can't create a new instance of class '%s'.",
  16 | 	cannotDepend = "%s can't depend on %s.",
  17 | 	cleanupWasRenamed = "`Fusion.cleanup` was renamed to `Fusion.doCleanup`. This will be an error in future versions of Fusion.",
  18 | 	destroyedTwice = "`doCleanup()` was given something that it is already cleaning up. Unclear how to proceed.",
  19 | 	destructorRedundant = "%s destructors no longer do anything. If you wish to run code on destroy, `table.insert` a function into the `scope` argument. See discussion #292 on GitHub for advice.",
  20 | 	forKeyCollision = "The key '%s' was returned multiple times simultaneously, which is not allowed in `For` objects.",
  21 | 	infiniteLoop = "Detected an infinite loop. Consider adding an explicit breakpoint to your code to prevent a cyclic dependency.",
  22 | 	invalidAttributeChangeHandler = "The change handler for the '%s' attribute must be a function.",
  23 | 	invalidAttributeOutType = "[AttributeOut] properties must be given Value objects.",
  24 | 	invalidChangeHandler = "The change handler for the '%s' property must be a function.",
  25 | 	invalidEventHandler = "The handler for the '%s' event must be a function.",
  26 | 	invalidOutProperty = "The %s class doesn't have a property called '%s'.",
  27 | 	invalidOutType = "[Out] properties must be given Value objects.",
  28 | 	invalidPropertyType = "'%s.%s' expected a '%s' type, but got a '%s' type.",
  29 | 	invalidRefType = "Instance refs must be Value objects.",
  30 | 	invalidSpringDamping = "The damping ratio for a spring must be >= 0. (damping was %.2f)",
  31 | 	invalidSpringSpeed = "The speed of a spring must be >= 0. (speed was %.2f)",
  32 | 	mergeConflict = "Multiple definitions for '%s' found while merging.",
  33 | 	mistypedSpringDamping = "The damping ratio for a spring must be a number. (got a %s)",
  34 | 	mistypedSpringSpeed = "The speed of a spring must be a number. (got a %s)",
  35 | 	mistypedTweenInfo = "The tween info of a tween must be a TweenInfo. (got a %s)",
  36 | 	noTaskScheduler = "Fusion is not connected to an external task scheduler.",
  37 | 	poisonedScope = "Attempted to use a scope after it's been destroyed; %s",
  38 | 	possiblyOutlives = "%s will be destroyed before %s; %s. To fix this, review the order they're created in, and what scopes they belong to. See discussion #292 on GitHub for advice.",
  39 | 	propertySetError = "Error setting property:\nERROR_MESSAGE",
  40 | 	scopeMissing = "To create %s, provide a scope. (e.g. `%s`). See discussion #292 on GitHub for advice.",
  41 | 	springNanGoal = "A spring was given a NaN goal, so some simulation has been skipped. Ensure no springs have NaN goals.",
  42 | 	springNanMotion = "A spring encountered NaN during motion, so has snapped to the goal position. Ensure no springs have NaN positions or velocities.",
  43 | 	springTypeMismatch = "The type '%s' doesn't match the spring's type '%s'.",
  44 | 	stateGetWasRemoved = "`StateObject:get()` has been replaced by `use()` and `peek()` - see discussion #217 on GitHub.",
  45 | 	tweenNanGoal = "A tween was given a NaN goal, so some animation has been skipped. Ensure no tweens have NaN goals.",
  46 | 	tweenNanMotion = "A tween encountered NaN during motion, so has snapped to the goal. Ensure no tweens have NaN in their tween infos.",
  47 | 	unknownMessage = "Unknown error:\nERROR_MESSAGE",
  48 | 	unrecognisedChildType = "'%s' type children aren't accepted by `[Children]`.",
  49 | 	unrecognisedPropertyKey = "'%s' keys aren't accepted in property tables.",
  50 | 	unrecognisedPropertyStage = "'%s' isn't a valid stage for a special key to be applied at.",
  51 | 	useAfterDestroy = "%s is no longer valid - it was destroyed before %s. See discussion #292 on GitHub for advice."
  52 | }
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/Logging/parseError.luau`
<details>
<summary>View Source (24 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 | 	An xpcall() error handler to collect and parse useful information about
   8 | 	errors, such as clean messages and stack traces.
   9 | ]]
  10 | 
  11 | local Package = script.Parent.Parent
  12 | local Types = require(Package.Types)
  13 | 
  14 | local function parseError(
  15 | 	err: string
  16 | ): Types.Error
  17 | 	return {
  18 | 		type = "Error",
  19 | 		raw = err,
  20 | 		message = err:gsub("^.+:%d+:%s*", ""),
  21 | 		trace = debug.traceback(nil, 2)
  22 | 	}
  23 | end
  24 | 
  25 | return parseError
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/Memory/checkLifetime.luau`
<details>
<summary>View Source (133 lines)</summary>

```lua
   1 | 
   2 | 
   3 | --!strict
   4 | --!nolint LocalUnused
   5 | --!nolint LocalShadow
   6 | local task = nil -- Disable usage of Roblox's task scheduler
   7 | 
   8 | --[[
   9 | 	Procedures for checking lifetimes and printing helpful warnings about them.
  10 | ]]
  11 | 
  12 | local Package = script.Parent.Parent
  13 | local Types = require(Package.Types)
  14 | local External = require(Package.External)
  15 | local whichLivesLonger = require(Package.Memory.whichLivesLonger)
  16 | local nameOf = require(Package.Utility.nameOf)
  17 | 
  18 | local checkLifetime = {}
  19 | 
  20 | checkLifetime.formatters = {}
  21 | 
  22 | function checkLifetime.formatters.useFunction(
  23 | 	self: unknown,
  24 | 	used: unknown
  25 | ): (string, string)
  26 | 	local selfName = nameOf(self, "object")
  27 | 	local usedName = nameOf(used, "object")
  28 | 	return `The use()-d {usedName}`, `the {selfName}`
  29 | end
  30 | 	
  31 | function checkLifetime.formatters.boundProperty(
  32 | 	instance: Instance,
  33 | 	bound: unknown,
  34 | 	property: string
  35 | ): (string, string)
  36 | 	local selfName = instance.Name
  37 | 	local boundName = nameOf(bound, "value")
  38 | 	return `The {boundName} (bound to the {property} property)`, `the {selfName} instance`
  39 | end
  40 | 
  41 | function checkLifetime.formatters.boundAttribute(
  42 | 	instance: Instance,
  43 | 	bound: unknown,
  44 | 	attribute: string
  45 | ): (string, string)
  46 | 	local selfName = instance.Name
  47 | 	local boundName = nameOf(bound, "value")
  48 | 	return `The {boundName} (bound to the {attribute} attribute)`, `the {selfName} instance`
  49 | end
  50 | 
  51 | function checkLifetime.formatters.propertyOutputsTo(
  52 | 	instance: Instance,
  53 | 	bound: unknown,
  54 | 	property: string
  55 | ): (string, string)
  56 | 	local selfName = instance.Name
  57 | 	local boundName = nameOf(bound, "object")
  58 | 	return `The {boundName} (which the {property} property outputs to)`, `the {selfName} instance`
  59 | end
  60 | 
  61 | function checkLifetime.formatters.attributeOutputsTo(
  62 | 	instance: Instance,
  63 | 	bound: unknown,
  64 | 	attribute: string
  65 | ): (string, string)
  66 | 	local selfName = instance.Name
  67 | 	local boundName = nameOf(bound, "object")
  68 | 	return `The {boundName} (which the {attribute} attribute outputs to)`, `the {selfName} instance`
  69 | end
  70 | 
  71 | function checkLifetime.formatters.refOutputsTo(
  72 | 	instance: Instance,
  73 | 	bound: unknown
  74 | ): (string, string)
  75 | 	local selfName = instance.Name
  76 | 	local boundName = nameOf(bound, "object")
  77 | 	return `The {boundName} (which the Ref key outputs to)`, `the {selfName} instance`
  78 | end
  79 | 
  80 | function checkLifetime.formatters.animationGoal(
  81 | 	self: unknown,
  82 | 	goal: unknown
  83 | ): (string, string)
  84 | 	local selfName = nameOf(self, "object")
  85 | 	local goalName = nameOf(goal, "object")
  86 | 	return `The goal {goalName}`, `the {selfName} that is following it`
  87 | end
  88 | 
  89 | function checkLifetime.formatters.parameter(
  90 | 	self: unknown,
  91 | 	used: unknown,
  92 | 	parameterName: string | false
  93 | ): (string, string)
  94 | 	local selfName = nameOf(self, "object")
  95 | 	local usedName = nameOf(used, "object")
  96 | 	if parameterName == false then
  97 | 		return `The {usedName} parameter`, `the {selfName} that it was used for`
  98 | 	else
  99 | 		return `The {usedName} representing the {parameterName} parameter`, `the {selfName} that it was used for`
 100 | 	end
 101 | end
 102 | 
 103 | function checkLifetime.formatters.observer(
 104 | 	self: unknown,
 105 | 	watched: unknown
 106 | ): (string, string)
 107 | 	local selfName = nameOf(self, "object")
 108 | 	local watchedName = nameOf(watched, "object")
 109 | 	return `The watched {watchedName}`, `the {selfName} that's observing it for changes`
 110 | end
 111 | 
 112 | function checkLifetime.bOutlivesA<A, B, Args...>(
 113 | 	scopeA: Types.Scope<unknown>,
 114 | 	a: A,
 115 | 	scopeB: Types.Scope<unknown>?,
 116 | 	b: B,
 117 | 	formatter: (a: A, b: B, Args...) -> (string, string),
 118 | 	...: Args...
 119 | )
 120 | 	if scopeB == nil then
 121 | 		External.logError("useAfterDestroy", nil, formatter(a, b, ...))
 122 | 	elseif whichLivesLonger(scopeA, a, scopeB, b) == "definitely-a" then
 123 | 		local aName, bName = formatter(a, b, ...)
 124 | 		External.logWarn(
 125 | 			"possiblyOutlives",
 126 | 			aName, bName, 
 127 | 			if scopeA == scopeB then
 128 | 				"they're in the same scope, but the latter is destroyed too quickly"
 129 | 			else
 130 | 				"the latter is in a different scope that gets destroyed too quickly"
 131 | 		)
 132 | 	end
 133 | end
 134 | return checkLifetime
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/Memory/deriveScope.luau`
<details>
<summary>View Source (23 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 | 	Creates an empty scope with the same metatables as the original scope. Used
   8 | 	for preserving access to constructors when creating inner scopes.
   9 | 
  10 | 	This is the public version of the function, which implements external
  11 | 	debugging hooks.
  12 | ]]
  13 | local Package = script.Parent.Parent
  14 | local Types = require(Package.Types)
  15 | local ExternalDebug = require(Package.ExternalDebug)
  16 | local deriveScopeImpl = require(Package.Memory.deriveScopeImpl)
  17 | 
  18 | local function deriveScope(...)
  19 | 	local scope = deriveScopeImpl(...)
  20 | 	ExternalDebug.trackScope(scope)
  21 | 	return scope
  22 | end
  23 | 
  24 | return deriveScope :: Types.DeriveScopeConstructor
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/Memory/deriveScopeImpl.luau`
<details>
<summary>View Source (44 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 | 	Creates an empty scope with the same metatables as the original scope. Used
   8 | 	for preserving access to constructors when creating inner scopes.
   9 | 
  10 | 	This is the internal version of the function, which does not implement
  11 | 	external debugging hooks.
  12 | ]]
  13 | local Package = script.Parent.Parent
  14 | local Types = require(Package.Types)
  15 | local merge = require(Package.Utility.merge)
  16 | local scopePool = require(Package.Memory.scopePool)
  17 | 
  18 | -- This return type is technically a lie, but it's required for useful type
  19 | -- checking behaviour.
  20 | local function deriveScopeImpl<T>(
  21 | 	existing: Types.Scope<T>,
  22 | 	methods: {[unknown]: unknown}?,
  23 | 	...: {[unknown]: unknown}
  24 | ): any
  25 | 	local metatable = getmetatable(existing)
  26 | 	if methods ~= nil then
  27 | 		metatable = table.clone(metatable)
  28 | 		metatable.__index = merge(
  29 | 			true, {}, 
  30 | 			metatable.__index, 
  31 | 			merge(
  32 | 				false, {},
  33 | 				methods, 
  34 | 				...
  35 | 			)
  36 | 		)
  37 | 	end
  38 | 	local scope = setmetatable(
  39 | 		scopePool.reuseAny() :: any or {},
  40 | 		metatable
  41 | 	)
  42 | 	return scope
  43 | end
  44 | 
  45 | return (deriveScopeImpl :: any) :: Types.DeriveScopeConstructor
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/Memory/doCleanup.luau`
<details>
<summary>View Source (78 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 | 	Cleans up the tasks passed in as the arguments.
   8 | 	A task can be any of the following:
   9 | 
  10 | 	- an Instance - will be destroyed
  11 | 	- an RBXScriptConnection - will be disconnected
  12 | 	- a function - will be run
  13 | 	- a table with a `Destroy` or `destroy` function - will be called
  14 | 	- an array - `cleanup` will be called on each item
  15 | ]]
  16 | local Package = script.Parent.Parent
  17 | local Types = require(Package.Types)
  18 | local External = require(Package.External)
  19 | local scopePool = require(Package.Memory.scopePool)
  20 | local poisonScope = require(Package.Memory.poisonScope)
  21 | 
  22 | local alreadyDestroying: {[Types.Task]: true} = {}
  23 | 
  24 | local function doCleanup(
  25 | 	task: Types.Task
  26 | ): ()
  27 | 	if alreadyDestroying[task] then
  28 | 		return External.logError("destroyedTwice")
  29 | 	end
  30 | 	alreadyDestroying[task] = true
  31 | 
  32 | 	-- case 1: Instance
  33 | 	if typeof(task) == "Instance" then
  34 | 		task:Destroy()
  35 | 
  36 | 	-- case 2: RBXScriptConnection
  37 | 	elseif typeof(task) == "RBXScriptConnection" then
  38 | 		task:Disconnect()
  39 | 
  40 | 	-- case 3: callback
  41 | 	elseif typeof(task) == "function" then
  42 | 		task()
  43 | 
  44 | 	elseif typeof(task) == "table" then
  45 | 		local task = (task :: any) :: {Destroy: (...unknown) -> (...unknown)?, destroy: (...unknown) -> (...unknown)?}
  46 | 
  47 | 		-- case 4: destroy() function
  48 | 		if typeof(task.destroy) == "function" then
  49 | 			local task = (task :: any) :: {destroy: (...unknown) -> (...unknown)}
  50 | 			task:destroy()
  51 | 
  52 | 		-- case 5: Destroy() function
  53 | 		elseif typeof(task.Destroy) == "function" then
  54 | 			local task = (task :: any) :: {Destroy: (...unknown) -> (...unknown)}
  55 | 			task:Destroy()
  56 | 
  57 | 		-- case 6: table of tasks with an array part
  58 | 		elseif task[1] ~= nil then
  59 | 			local task = task :: {Types.Task}
  60 | 
  61 | 			-- It is important to iterate backwards through the table, since
  62 | 			-- objects are added in order of construction.
  63 | 			for index = #task, 1, -1 do
  64 | 				doCleanup(task[index])
  65 | 				task[index] = nil
  66 | 			end
  67 | 
  68 | 			if External.isTimeCritical() then
  69 | 				scopePool.giveIfEmpty(task)
  70 | 			else
  71 | 				poisonScope(task, "`doCleanup()` was previously called on this scope. Ensure you are not reusing scopes after cleanup.")
  72 | 			end
  73 | 		end
  74 | 	end
  75 | 	
  76 | 	alreadyDestroying[task] = nil
  77 | end
  78 | 
  79 | return doCleanup
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/Memory/innerScope.luau`
<details>
<summary>View Source (33 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 | 	Derives a new scope that's destroyed exactly once, whether by the user or by
   8 | 	the scope that it's inside of.
   9 | ]]
  10 | local Package = script.Parent.Parent
  11 | local Types = require(Package.Types)
  12 | local ExternalDebug = require(Package.ExternalDebug)
  13 | local deriveScopeImpl = require(Package.Memory.deriveScopeImpl)
  14 | 
  15 | local function innerScope<T>(
  16 | 	existing: Types.Scope<T>,
  17 | 	...: {[unknown]: unknown}
  18 | ): any
  19 | 	local new = deriveScopeImpl(existing, ...)
  20 | 	table.insert(existing, new)
  21 | 	table.insert(
  22 | 		new, 
  23 | 		function()
  24 | 			local index = table.find(existing, new)
  25 | 			if index ~= nil then
  26 | 				table.remove(existing, index)
  27 | 			end
  28 | 		end
  29 | 	)
  30 | 	ExternalDebug.trackScope(new)
  31 | 	return new
  32 | end
  33 | 
  34 | return (innerScope :: any) :: Types.DeriveScopeConstructor
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/Memory/legacyCleanup.luau`
<details>
<summary>View Source (17 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | local Package = script.Parent.Parent
   7 | local Types = require(Package.Types)
   8 | local External = require(Package.External)
   9 | local doCleanup = require(Package.Memory.doCleanup)
  10 | 
  11 | local function legacyCleanup(
  12 | 	value: Types.Task
  13 | )
  14 | 	External.logWarn("cleanupWasRenamed")
  15 | 	return doCleanup(value)
  16 | end
  17 | 
  18 | return legacyCleanup
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/Memory/needsDestruction.luau`
<details>
<summary>View Source (16 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 | 	Returns true if the given value is not automatically memory managed, and
   8 | 	requires manual cleanup.
   9 | ]]
  10 | 
  11 | local function needsDestruction(
  12 | 	x: unknown
  13 | ): boolean
  14 | 	return typeof(x) == "Instance"
  15 | end
  16 | 
  17 | return needsDestruction
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/Memory/poisonScope.luau`
<details>
<summary>View Source (33 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 | 	'Poisons' the given scope; if the scope is used again, then it will cause
   8 | 	the program to crash.
   9 | ]]
  10 | local Package = script.Parent.Parent
  11 | local Types = require(Package.Types)
  12 | local External = require(Package.External)
  13 | 
  14 | local function poisonScope(
  15 | 	scope: Types.Scope,
  16 | 	context: string
  17 | ): ()
  18 | 	local mt = getmetatable(scope)
  19 | 	if typeof(mt) == "table" and mt._FUSION_POISONED then
  20 | 		return
  21 | 	end
  22 | 	table.clear(scope)
  23 | 	setmetatable(scope :: any, {
  24 | 		_FUSION_POISONED = true,
  25 | 		__index = function()
  26 | 			External.logError("poisonedScope", nil, context)
  27 | 		end,
  28 | 		__newindex = function()
  29 | 			External.logError("poisonedScope", nil, context)
  30 | 		end
  31 | 	})
  32 | end
  33 | 
  34 | return poisonScope
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/Memory/scoped.luau`
<details>
<summary>View Source (26 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 | 	Creates cleanup tables with access to constructors as methods.
   8 | ]]
   9 | 
  10 | local Package = script.Parent.Parent
  11 | local Types = require(Package.Types)
  12 | local ExternalDebug = require(Package.ExternalDebug)
  13 | local merge = require(Package.Utility.merge)
  14 | local scopePool = require(Package.Memory.scopePool)
  15 | 
  16 | local function scoped(
  17 | 	...: {[unknown]: unknown}
  18 | ): any
  19 | 	local scope = setmetatable(
  20 | 		scopePool.reuseAny() :: any or {},
  21 | 		{__index = merge(false, {}, ...)}
  22 | 	) :: any
  23 | 	ExternalDebug.trackScope(scope)
  24 | 	return scope
  25 | end
  26 | 
  27 | return (scoped :: any) :: Types.ScopedConstructor
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/Memory/scopePool.luau`
<details>
<summary>View Source (54 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | local Package = script.Parent.Parent
   7 | local Types = require(Package.Types)
   8 | local poisonScope = require(Package.Memory.poisonScope)
   9 | local ExternalDebug = require(Package.ExternalDebug)
  10 | 
  11 | local ENABLE_POOLING = false
  12 | local MAX_POOL_SIZE = 16 -- TODO: need to test what an ideal number for this is
  13 | 
  14 | local pool = {}
  15 | local poolSize = 0
  16 | 
  17 | return {
  18 | 	giveIfEmpty = function<S>(
  19 | 		scope: Types.Scope<S>
  20 | 	): Types.Scope<S>?
  21 | 		if next(scope) == nil then
  22 | 			ExternalDebug.untrackScope(scope)
  23 | 			if ENABLE_POOLING and poolSize < MAX_POOL_SIZE then
  24 | 				poolSize += 1
  25 | 				pool[poolSize] = scope
  26 | 			else
  27 | 				poisonScope(scope, "previously passed to the internal scope pool, which indicates a Fusion bug.")
  28 | 			end
  29 | 			return nil
  30 | 		else
  31 | 			return scope
  32 | 		end
  33 | 	end,
  34 | 	clearAndGive = function(
  35 | 		scope: Types.Scope<unknown>
  36 | 	)
  37 | 		ExternalDebug.untrackScope(scope)
  38 | 		table.clear(scope)
  39 | 		if ENABLE_POOLING and poolSize < MAX_POOL_SIZE then
  40 | 			poolSize += 1
  41 | 			pool[poolSize] = scope :: any
  42 | 		else
  43 | 			poisonScope(scope, "previously passed to the internal scope pool, which indicates a Fusion bug.")
  44 | 		end
  45 | 	end,
  46 | 	reuseAny = function(): Types.Scope<unknown>
  47 | 		if poolSize == 0 then
  48 | 			return nil :: any
  49 | 		else
  50 | 			local scope = pool[poolSize]
  51 | 			poolSize -= 1
  52 | 			return scope
  53 | 		end
  54 | 	end
  55 | }
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/Memory/whichLivesLonger.luau`
<details>
<summary>View Source (74 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 | 	Calculates how the lifetimes of the two values relate. Specifically, it
   8 | 	calculates which value will be destroyed earlier or later, if it is possible
   9 | 	to infer this from their scopes.
  10 | ]]
  11 | local Package = script.Parent.Parent
  12 | local Types = require(Package.Types)
  13 | local External = require(Package.External)
  14 | 
  15 | local function whichScopeLivesLonger(
  16 | 	scopeA: Types.Scope<unknown>,
  17 | 	scopeB: Types.Scope<unknown>
  18 | ): "definitely-a" | "definitely-b" | "unsure"
  19 | 	-- If we can prove one scope is inside of the other scope, then the outer
  20 | 	-- scope must live longer than the inner scope (assuming idiomatic scopes).
  21 | 	-- So, we will search the scopes recursively until we find one of them, at
  22 | 	-- which point we know they must have been found inside the other scope.
  23 | 	local openSet: {Types.Scope<unknown>} = {scopeA, scopeB}
  24 | 	local nextOpenSet: {Types.Scope<unknown>} = {}
  25 | 	local openSetSize, nextOpenSetSize = 2, 0
  26 | 	local closedSet = {}
  27 | 	while openSetSize > 0 do
  28 | 		for _, scope in openSet do
  29 | 			closedSet[scope] = true
  30 | 			for _, inScope in ipairs(scope) do
  31 | 				if inScope == scopeA then
  32 | 					return "definitely-b"
  33 | 				elseif inScope == scopeB then
  34 | 					return "definitely-a"
  35 | 				elseif typeof(inScope) == "table" then
  36 | 					local inScope = inScope :: {unknown}
  37 | 					if inScope[1] ~= nil and closedSet[scope] == nil then
  38 | 						nextOpenSetSize += 1
  39 | 						nextOpenSet[nextOpenSetSize] = inScope :: Types.Scope<unknown>
  40 | 					end
  41 | 				end 
  42 | 			end
  43 | 		end
  44 | 		table.clear(openSet)
  45 | 		openSet, nextOpenSet = nextOpenSet, openSet
  46 | 		openSetSize, nextOpenSetSize = nextOpenSetSize, 0
  47 | 	end
  48 | 	return "unsure"
  49 | end
  50 | 
  51 | local function whichLivesLonger(
  52 | 	scopeA: Types.Scope<unknown>,
  53 | 	a: unknown,
  54 | 	scopeB: Types.Scope<unknown>,
  55 | 	b: unknown
  56 | ): "definitely-a" | "definitely-b" | "unsure"
  57 | 	if External.isTimeCritical() then
  58 | 		return "unsure"
  59 | 	elseif scopeA == scopeB then
  60 | 		local scopeA: {unknown} = scopeA
  61 | 		for index = #scopeA, 1, -1 do
  62 | 			local value = scopeA[index]
  63 | 			if value == a then
  64 | 				return "definitely-b"
  65 | 			elseif value == b then
  66 | 				return "definitely-a"
  67 | 			end
  68 | 		end
  69 | 		return "unsure"
  70 | 	else
  71 | 		return whichScopeLivesLonger(scopeA, scopeB)
  72 | 	end
  73 | end
  74 | 
  75 | return whichLivesLonger
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/RobloxExternal.luau`
<details>
<summary>View Source (97 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | 
   5 | --[[
   6 | 	Roblox implementation for Fusion's abstract provider layer.
   7 | ]]
   8 | 
   9 | local RunService = game:GetService("RunService")
  10 | local HttpService = game:GetService("HttpService")
  11 | 
  12 | local Package = script.Parent
  13 | local External = require(Package.External)
  14 | 
  15 | local RobloxExternal = {}
  16 | 
  17 | RobloxExternal.policies = {
  18 | 	allowWebLinks = RunService:IsStudio()
  19 | }
  20 | 
  21 | --[[
  22 |    Sends an immediate task to the external provider. Throws if none is set.
  23 | ]]
  24 | function RobloxExternal.doTaskImmediate(
  25 | 	resume: () -> ()
  26 | )
  27 |    task.spawn(resume)
  28 | end
  29 | 
  30 | --[[
  31 | 	Sends a deferred task to the external provider. Throws if none is set.
  32 | ]]
  33 | function RobloxExternal.doTaskDeferred(
  34 | 	resume: () -> ()
  35 | )
  36 | 	task.defer(resume)
  37 | end
  38 | 
  39 | --[[
  40 | 	Errors in a different thread to preserve the flow of execution.
  41 | ]]
  42 | function RobloxExternal.logErrorNonFatal(
  43 | 	errorString: string
  44 | )
  45 | 	task.spawn(error, errorString, 0)
  46 | end
  47 | 
  48 | --[[
  49 | 	Shows a warning message in the output.
  50 | ]]
  51 | RobloxExternal.logWarn = warn
  52 | 
  53 | --[[
  54 | 	Sends an update step to Fusion using the Roblox clock time.
  55 | ]]
  56 | local function performUpdateStep()
  57 | 	External.performUpdateStep(os.clock())
  58 | end
  59 | 
  60 | --[[
  61 | 	Binds Fusion's update step to RunService step events.
  62 | ]]
  63 | local stopSchedulerFunc = nil :: (() -> ())?
  64 | function RobloxExternal.startScheduler()
  65 | 	if stopSchedulerFunc ~= nil then
  66 | 		return
  67 | 	end
  68 | 	if RunService:IsClient() then
  69 | 		-- In cases where multiple Fusion modules are running simultaneously,
  70 | 		-- this prevents collisions.
  71 | 		local id = "FusionUpdateStep_" .. HttpService:GenerateGUID()
  72 | 		RunService:BindToRenderStep(
  73 | 			id,
  74 | 			Enum.RenderPriority.First.Value,
  75 | 			performUpdateStep
  76 | 		)
  77 | 		stopSchedulerFunc = function()
  78 | 			RunService:UnbindFromRenderStep(id)
  79 | 		end
  80 | 	else
  81 | 		local connection = RunService.Heartbeat:Connect(performUpdateStep)
  82 | 		stopSchedulerFunc = function()
  83 | 			connection:Disconnect()
  84 | 		end
  85 | 	end
  86 | end
  87 | 
  88 | --[[
  89 | 	Unbinds Fusion's update step from RunService step events.
  90 | ]]
  91 | function RobloxExternal.stopScheduler()
  92 | 	if stopSchedulerFunc ~= nil then
  93 | 		stopSchedulerFunc()
  94 | 		stopSchedulerFunc = nil
  95 | 	end
  96 | end
  97 | 
  98 | return RobloxExternal
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/State/castToState.luau`
<details>
<summary>View Source (25 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 | 	Returns the input *only* if it is a state object.
   8 | ]]
   9 | 
  10 | local Package = script.Parent.Parent
  11 | local Types = require(Package.Types)
  12 | 
  13 | local function castToState<T>(
  14 | 	target: Types.UsedAs<T>
  15 | ): Types.StateObject<T>?
  16 | 	if
  17 | 		typeof(target) == "table" and
  18 | 		target.type == "State" 
  19 | 	then
  20 | 		return target
  21 | 	else
  22 | 		return nil
  23 | 	end
  24 | end
  25 | 
  26 | return castToState
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/State/Computed.luau`
<details>
<summary>View Source (138 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 | 	A specialised state object for tracking single values computed from a
   8 | 	user-defined computation.
   9 | 
  10 | 	https://elttob.uk/Fusion/0.3/api-reference/state/types/computed/
  11 | ]]
  12 | 
  13 | local Package = script.Parent.Parent
  14 | local Types = require(Package.Types)
  15 | local External = require(Package.External)
  16 | -- Logging
  17 | local parseError = require(Package.Logging.parseError)
  18 | -- Utility
  19 | local isSimilar = require(Package.Utility.isSimilar)
  20 | local never = require(Package.Utility.never)
  21 | -- Graph
  22 | local depend = require(Package.Graph.depend)
  23 | -- State
  24 | local castToState = require(Package.State.castToState)
  25 | local peek = require(Package.State.peek)
  26 | -- Memory
  27 | local doCleanup = require(Package.Memory.doCleanup)
  28 | local deriveScope = require(Package.Memory.deriveScope)
  29 | local checkLifetime = require(Package.Memory.checkLifetime)
  30 | local scopePool = require(Package.Memory.scopePool)
  31 | -- Utility
  32 | local nicknames = require(Package.Utility.nicknames)
  33 | 
  34 | type Self<T, S> = Types.Computed<T> & {
  35 | 	_innerScope: Types.Scope<S>?,
  36 | 	_processor: (Types.Use, Types.Scope<S>) -> T
  37 | }
  38 | 
  39 | local class = {}
  40 | class.type = "State"
  41 | class.kind = "Computed"
  42 | class.timeliness = "lazy"
  43 | 
  44 | local METATABLE = table.freeze {__index = class}
  45 | 
  46 | local function Computed<T, S>(
  47 | 	scope: S & Types.Scope<unknown>,
  48 | 	processor: (Types.Use, S) -> T,
  49 | 	destructor: unknown?
  50 | ): Types.Computed<T>
  51 | 	local createdAt = os.clock()
  52 | 	if typeof(scope) == "function" then
  53 | 		External.logError("scopeMissing", nil, "Computeds", "myScope:Computed(function(use, scope) ... end)")
  54 | 	elseif destructor ~= nil then
  55 | 		External.logWarn("destructorRedundant", "Computed")
  56 | 	end
  57 | 	local self: Self<T, S> = setmetatable(
  58 | 		{
  59 | 			createdAt = createdAt,
  60 | 			dependencySet = {},
  61 | 			dependentSet = {},
  62 | 			lastChange = nil,
  63 | 			scope = scope,
  64 | 			validity = "invalid",
  65 | 			_EXTREMELY_DANGEROUS_usedAsValue = nil,
  66 | 			_innerScope = nil,
  67 | 			_processor = processor
  68 | 		}, 
  69 | 		METATABLE
  70 | 	) :: any
  71 | 	local destroy = function()
  72 | 		self.scope = nil
  73 | 		for dependency in pairs(self.dependencySet) do
  74 | 			dependency.dependentSet[self] = nil
  75 | 		end
  76 | 		if self._innerScope ~= nil then
  77 | 			doCleanup(self._innerScope)
  78 | 		end
  79 | 	end
  80 | 	self.oldestTask = destroy
  81 | 	nicknames[self.oldestTask] = "Computed"
  82 | 	table.insert(scope, destroy)
  83 | 	return self
  84 | end
  85 | 
  86 | function class.get<T, S>(
  87 | 	_self: Self<T, S>
  88 | ): never
  89 | 	External.logError("stateGetWasRemoved")
  90 | 	return never()
  91 | end
  92 | 
  93 | function class._evaluate<T, S>(
  94 | 	self: Self<T, S>
  95 | ): boolean
  96 | 	if self.scope == nil then
  97 | 		return false
  98 | 	end
  99 | 	local outerScope = self.scope :: S & Types.Scope<unknown>
 100 | 	local innerScope = deriveScope(outerScope)
 101 | 	local function use<T>(target: Types.UsedAs<T>): T
 102 | 		local targetState = castToState(target)
 103 | 		if targetState ~= nil then
 104 | 			checkLifetime.bOutlivesA(
 105 | 				outerScope, self.oldestTask, 
 106 | 				targetState.scope, targetState.oldestTask, 
 107 | 				checkLifetime.formatters.useFunction
 108 | 			)
 109 | 			depend(self, targetState)
 110 | 		end
 111 | 		return peek(target)
 112 | 	end
 113 | 	local ok, newValue = xpcall(self._processor, parseError, use, innerScope)
 114 | 	local innerScope = scopePool.giveIfEmpty(innerScope)
 115 | 	if ok then
 116 | 		local similar = isSimilar(self._EXTREMELY_DANGEROUS_usedAsValue, newValue)
 117 | 		if self._innerScope ~= nil then
 118 | 			doCleanup(self._innerScope)
 119 | 		end
 120 | 		self._innerScope = innerScope
 121 | 
 122 | 		self._EXTREMELY_DANGEROUS_usedAsValue = newValue
 123 | 		return not similar
 124 | 	else
 125 | 		local errorObj = (newValue :: any) :: Types.Error
 126 | 		if innerScope ~= nil then
 127 | 			doCleanup(innerScope)
 128 | 		end
 129 | 		innerScope = nil
 130 | 		
 131 | 		-- this needs to be non-fatal, because otherwise it'd disrupt the
 132 | 		-- update process
 133 | 		External.logErrorNonFatal("callbackError", errorObj)
 134 | 		return false
 135 | 	end
 136 | end
 137 | 
 138 | table.freeze(class)
 139 | return Computed :: Types.ComputedConstructor
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/State/For/Disassembly.luau`
<details>
<summary>View Source (210 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 | 	Breaks down an input table into reactive sub-objects for each pair.
   8 | ]]
   9 | 
  10 | local Package = script.Parent.Parent.Parent
  11 | local Types = require(Package.Types)
  12 | local External = require(Package.External)
  13 | -- Graph
  14 | local depend = require(Package.Graph.depend)
  15 | -- State
  16 | local peek = require(Package.State.peek)
  17 | local castToState = require(Package.State.castToState)
  18 | local ForTypes = require(Package.State.For.ForTypes)
  19 | -- Memory
  20 | local doCleanup = require(Package.Memory.doCleanup)
  21 | local deriveScope = require(Package.Memory.deriveScope)
  22 | local scopePool = require(Package.Memory.scopePool)
  23 | -- Utility
  24 | local nameOf = require(Package.Utility.nameOf)
  25 | local nicknames = require(Package.Utility.nicknames)
  26 | 
  27 | type Self<S, KI, KO, VI, VO> = ForTypes.Disassembly<S, KI, KO, VI, KO> & {
  28 | 	scope: (S & Types.Scope<unknown>)?,
  29 | 	_inputTable: Types.UsedAs<{[KI]: VI}>,
  30 | 	_constructor: (
  31 | 		Types.Scope<S>,
  32 | 		initialKey: KI,
  33 | 		initialValue: VI
  34 | 	) -> ForTypes.SubObject<S, KI, KO, VI, VO>,
  35 | 	_subObjects: {[ForTypes.SubObject<S, KI, KO, VI, VO>]: true}
  36 | }
  37 | 
  38 | 
  39 | local class = {}
  40 | class.type = "Graph"
  41 | class.kind = "For.Disassembly"
  42 | class.timeliness = "lazy"
  43 | 
  44 | local METATABLE = table.freeze {__index = class}
  45 | 
  46 | local function Disassembly<S, KI, KO, VI, VO>(
  47 | 	scope: S & Types.Scope<unknown>,
  48 | 	inputTable: Types.UsedAs<{[KI]: VI}>,
  49 | 	constructor: (
  50 | 		Types.Scope<S>,
  51 | 		initialKey: KI,
  52 | 		initialValue: VI
  53 | 	) -> ForTypes.SubObject<S, KI, KO, VI, VO>
  54 | ): ForTypes.Disassembly<S, KI, KO, VI, KO>
  55 | 	local createdAt = os.clock()
  56 | 	local self = setmetatable(
  57 | 		{
  58 | 			createdAt = createdAt,
  59 | 			dependencySet = {},
  60 | 			dependentSet = {},
  61 | 			scope = scope,
  62 | 			validity = "invalid",
  63 | 			_inputTable = inputTable,
  64 | 			_constructor = constructor,
  65 | 			_subObjects = {}
  66 | 		}, 
  67 | 		METATABLE
  68 | 	) :: any
  69 | 
  70 | 	local destroy = function()
  71 | 		self.scope = nil
  72 | 		for dependency in pairs(self.dependencySet) do
  73 | 			dependency.dependentSet[self] = nil
  74 | 		end
  75 | 		for subObject in self._subObjects do
  76 | 			if subObject.maybeScope ~= nil then
  77 | 				doCleanup(subObject.maybeScope)
  78 | 				subObject.maybeScope = nil
  79 | 			end
  80 | 		end
  81 | 	end
  82 | 	self.oldestTask = destroy
  83 | 	nicknames[self.oldestTask] = "For (internal disassembler)"
  84 | 	table.insert(scope, destroy)
  85 | 	
  86 | 	return self
  87 | end
  88 | 
  89 | function class.populate<S, KI, KO, VI, VO>(
  90 | 	self: Self<S, KI, KO, VI, VO>,
  91 | 	use: Types.Use,
  92 | 	output: {[KO]: VO}
  93 | ): ()
  94 | 	local minArrayIndex = math.huge
  95 | 	local maxArrayIndex = -math.huge
  96 | 	local hasHoles = false
  97 | 	for subObject in self._subObjects do
  98 | 		local outputKey, outputValue = subObject:useOutputPair(use)
  99 | 		if outputKey == nil or outputValue == nil then
 100 | 			hasHoles = true
 101 | 			continue
 102 | 		elseif output[outputKey] ~= nil then
 103 | 			External.logErrorNonFatal("forKeyCollision", nil, tostring(outputKey))
 104 | 			continue
 105 | 		end
 106 | 		output[outputKey] = outputValue
 107 | 		if typeof(outputKey) == "number" then
 108 | 			minArrayIndex = math.min(minArrayIndex, outputKey)
 109 | 			maxArrayIndex = math.max(maxArrayIndex, outputKey)
 110 | 		end
 111 | 	end
 112 | 	-- Be careful of NaN here
 113 | 	if hasHoles and maxArrayIndex > minArrayIndex then
 114 | 		local output: {[number]: VO} = output :: any
 115 | 		local moveToIndex = minArrayIndex
 116 | 		for moveFromIndex = minArrayIndex, maxArrayIndex do
 117 | 			local outputValue = output[moveFromIndex]
 118 | 			if outputValue == nil then
 119 | 				continue
 120 | 			end
 121 | 			-- The ordering is important in case the indices are the same
 122 | 			output[moveFromIndex] = nil
 123 | 			output[moveToIndex] = outputValue
 124 | 			moveToIndex += 1
 125 | 		end
 126 | 	end
 127 | end
 128 | 
 129 | function class._evaluate<S, KI, KO, VI, VO>(
 130 | 	self: Self<S, KI, KO, VI, VO>
 131 | ): boolean
 132 | 	local outerScope = self.scope :: S & Types.Scope<unknown>
 133 | 	local inputState = castToState(self._inputTable)
 134 | 	if inputState ~= nil then
 135 | 		if inputState.scope == nil then
 136 | 			External.logError(
 137 | 				"useAfterDestroy",
 138 | 				nil,
 139 | 				`The input {nameOf(inputState, "table")}`,
 140 | 				`the For object that is watching it`
 141 | 			)
 142 | 		end
 143 | 		depend(self, inputState)
 144 | 	end
 145 | 
 146 | 	local pendingPairs = {} :: {[KI]: VI}
 147 | 	for key, value in peek(self._inputTable) do
 148 | 		pendingPairs[key] = value
 149 | 	end
 150 | 
 151 | 	local newSubObjects = {} :: typeof(self._subObjects)
 152 | 
 153 | 	for subObject in self._subObjects do
 154 | 		local reused = false
 155 | 		local oldInputKey = subObject.inputKey
 156 | 		local oldInputValue = subObject.inputValue
 157 | 		local newInputKey: KI
 158 | 		-- Reuse when the keys are identical.
 159 | 		if not subObject.roamKeys and pendingPairs[oldInputKey] ~= nil then
 160 | 			reused = true
 161 | 			newInputKey = oldInputKey
 162 | 		else -- Try and reuse some other pair instead.
 163 | 			for pendingKey, pendingValue in pendingPairs do
 164 | 				reused = true
 165 | 				newInputKey = pendingKey
 166 | 				if subObject.roamValues then
 167 | 					break
 168 | 				end
 169 | 				if pendingValue == oldInputValue then
 170 | 					-- If the values are the same, then no need to update those,
 171 | 					-- so prefer this choice to any other.
 172 | 					break 
 173 | 				end
 174 | 			end
 175 | 		end
 176 | 		if reused then
 177 | 			local newInputValue = pendingPairs[newInputKey]
 178 | 			newSubObjects[subObject] = true
 179 | 			if newInputKey ~= oldInputKey then
 180 | 				subObject.inputKey = newInputKey
 181 | 				subObject:invalidateInputKey()
 182 | 			end
 183 | 			if newInputValue ~= oldInputValue then
 184 | 				subObject.inputValue = newInputValue
 185 | 				subObject:invalidateInputValue()
 186 | 			end
 187 | 			pendingPairs[newInputKey] = nil
 188 | 		else -- Too many sub objects for the number of pairs.
 189 | 			if subObject.maybeScope ~= nil then
 190 | 				doCleanup(subObject.maybeScope)
 191 | 				subObject.maybeScope = nil
 192 | 			end
 193 | 		end
 194 | 	end
 195 | 
 196 | 	-- Generate new objects if needed to cover the remaining pending pairs.
 197 | 	for pendingKey, pendingValue in pendingPairs do
 198 | 		local subObject = self._constructor(deriveScope(outerScope), pendingKey, pendingValue)
 199 | 		if subObject.maybeScope ~= nil then
 200 | 			subObject.maybeScope = scopePool.giveIfEmpty(subObject.maybeScope)
 201 | 		end
 202 | 		newSubObjects[subObject] = true
 203 | 	end
 204 | 
 205 | 	self._subObjects = newSubObjects
 206 | 
 207 | 	return true
 208 | end
 209 | 
 210 | table.freeze(class)
 211 | return Disassembly
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/State/For/ForTypes.luau`
<details>
<summary>View Source (30 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 | 	Stores types that are commonly used between For objects.
   8 | ]]
   9 | 
  10 | local Package = script.Parent.Parent.Parent
  11 | local Types = require(Package.Types)
  12 | 
  13 | export type SubObject<S, KI, KO, VI, VO> = {
  14 | 	-- Not all sub objects need to store a scope, for example if the scope
  15 | 	-- remains empty, it'll be given back to the scope pool.
  16 | 	maybeScope: Types.Scope<S>?,
  17 | 	inputKey: KI,
  18 | 	inputValue: VI,
  19 | 	roamKeys: boolean,
  20 | 	roamValues: boolean,
  21 | 	invalidateInputKey: (SubObject<S, KI, KO, VI, VO>) -> (),
  22 | 	invalidateInputValue: (SubObject<S, KI, KO, VI, VO>) -> (),
  23 | 	useOutputPair: (SubObject<S, KI, KO, VI, VO>, Types.Use) -> (KO?, VO?)
  24 | }
  25 | 
  26 | export type Disassembly<S, KI, KO, VI, VO> = Types.GraphObject & {
  27 | 	populate: (Disassembly<S, KI, KO, VI, VO>, Types.Use, output: {[KO]: VO}) -> ()
  28 | }
  29 | 
  30 | return nil
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/State/For/init.luau`
<details>
<summary>View Source (109 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 | 	The generic implementation for all `For` objects.
   8 | ]]
   9 | 
  10 | local Package = script.Parent.Parent
  11 | local Types = require(Package.Types)
  12 | local External = require(Package.External)
  13 | -- Graph
  14 | local depend = require(Package.Graph.depend)
  15 | -- State
  16 | local peek = require(Package.State.peek)
  17 | local castToState = require(Package.State.castToState)
  18 | local ForTypes = require(Package.State.For.ForTypes)
  19 | -- Utility
  20 | local never = require(Package.Utility.never)
  21 | local nicknames = require(Package.Utility.nicknames)
  22 | 
  23 | local Disassembly = require(Package.State.For.Disassembly)
  24 | 
  25 | type Self<S, KI, KO, VI, VO> = Types.For<KO, VO> & {
  26 | 	_disassembly: ForTypes.Disassembly<S, KI, KO, VI, VO>
  27 | }
  28 | 
  29 | local class = {}
  30 | class.type = "State"
  31 | class.kind = "For"
  32 | class.timeliness = "lazy"
  33 | 
  34 | local METATABLE = table.freeze {__index = class}
  35 | 
  36 | local function For<S, KI, KO, VI, VO>(
  37 | 	scope: Types.Scope<S>,
  38 | 	inputTable: Types.UsedAs<{[KI]: VI}>,
  39 | 	constructor: (
  40 | 		Types.Scope<S>,
  41 | 		initialKey: KI,
  42 | 		initialValue: VI
  43 | 	) -> ForTypes.SubObject<S, KI, KO, VI, VO>
  44 | ): Types.For<KO, VO>
  45 | 	local createdAt = os.clock()
  46 | 	local self: Self<S, KI, KO, VI, VO> = setmetatable(
  47 | 		{
  48 | 			createdAt = createdAt,
  49 | 			dependencySet = {},
  50 | 			dependentSet = {},
  51 | 			scope = scope,
  52 | 			validity = "invalid",
  53 | 			_EXTREMELY_DANGEROUS_usedAsValue = {},
  54 | 			_disassembly = Disassembly(
  55 | 				scope,
  56 | 				inputTable,
  57 | 				constructor
  58 | 			)
  59 | 		}, 
  60 | 		METATABLE
  61 | 	) :: any
  62 | 
  63 | 	local destroy = function()
  64 | 		self.scope = nil
  65 | 		for dependency in pairs(self.dependencySet) do
  66 | 			dependency.dependentSet[self] = nil
  67 | 		end
  68 | 	end
  69 | 	self.oldestTask = destroy
  70 | 	nicknames[self.oldestTask] = "For"
  71 | 	table.insert(scope, destroy)
  72 | 
  73 | 	return self
  74 | end
  75 | 
  76 | function class.get<S, KI, KO, VI, VO>(
  77 | 	_self: Self<S, KI, KO, VI, VO>
  78 | ): never
  79 | 	External.logError("stateGetWasRemoved")
  80 | 	return never()
  81 | end
  82 | 
  83 | function class._evaluate<S, KI, KO, VI, VO>(
  84 | 	self: Self<S, KI, KO, VI, VO>
  85 | ): boolean
  86 | 	if self.scope == nil then
  87 | 		return false
  88 | 	end
  89 | 	local outerScope = self.scope :: S & Types.Scope<unknown>
  90 | 
  91 | 	depend(self, self._disassembly)
  92 | 	table.clear(self._EXTREMELY_DANGEROUS_usedAsValue)
  93 | 	self._disassembly:populate(
  94 | 		function<T>(
  95 | 			maybeState: Types.UsedAs<T>
  96 | 		): T
  97 | 			local state = castToState(maybeState)
  98 | 			if state ~= nil then
  99 | 				depend(self, state)
 100 | 			end
 101 | 			return peek(maybeState)
 102 | 		end,
 103 | 		self._EXTREMELY_DANGEROUS_usedAsValue
 104 | 	)
 105 | 
 106 | 	return true
 107 | end
 108 | 
 109 | table.freeze(class)
 110 | return For
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/State/ForKeys.luau`
<details>
<summary>View Source (93 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 | 	Constructs and returns a new For state object which processes keys and
   8 | 	preserves values.
   9 | 
  10 | 	https://elttob.uk/Fusion/0.3/api-reference/state/members/forkeys/
  11 | 
  12 | 	TODO: the sub objects constructed here can be more efficiently implemented
  13 | 	as a dedicated state object.
  14 | ]]
  15 | 
  16 | local Package = script.Parent.Parent
  17 | local Types = require(Package.Types)
  18 | local External = require(Package.External)
  19 | -- Memory
  20 | local doCleanup = require(Package.Memory.doCleanup)
  21 | -- State
  22 | local For = require(Package.State.For)
  23 | local Value = require(Package.State.Value)
  24 | local Computed = require(Package.State.Computed)
  25 | local ForTypes = require(Package.State.For.ForTypes)
  26 | -- Logging
  27 | local parseError = require(Package.Logging.parseError)
  28 | 
  29 | local SUB_OBJECT_META = {
  30 | 	__index = {
  31 | 		roamKeys = false,
  32 | 		roamValues = true,
  33 | 		invalidateInputKey = function(self): ()
  34 | 			self._inputKeyState:set(self.inputKey)
  35 | 		end,
  36 | 		invalidateInputValue = function(self): ()
  37 | 			-- do nothing
  38 | 		end,
  39 | 		useOutputPair = function(self, use)
  40 | 			return use(self._outputKeyState), self.inputValue
  41 | 		end
  42 | 	}
  43 | }
  44 | 
  45 | local function SubObject<KI, KO, V, S>(
  46 | 	scope: Types.Scope<S>,
  47 | 	initialKey: KI,
  48 | 	initialValue: V,
  49 | 	processor: (Types.Use, Types.Scope<S>, KI) -> KO
  50 | ): ForTypes.SubObject<S, KI, KO, V, V>
  51 | 	local self = {}
  52 | 	self.maybeScope = scope
  53 | 	self.inputKey = initialKey
  54 | 	self.inputValue = initialValue
  55 | 	self._inputKeyState = Value(scope, initialKey)
  56 | 	self._processor = processor
  57 | 	self._outputKeyState = Computed(scope, function(use, scope): KO?
  58 | 		local inputKey = use(self._inputKeyState)
  59 | 		local ok, outputKey = xpcall(self._processor, parseError, use, scope, inputKey)
  60 | 		if ok then
  61 | 			return outputKey
  62 | 		else
  63 | 			local error: Types.Error = outputKey :: any
  64 | 			error.context = `while processing key {tostring(inputKey)}`
  65 | 			External.logErrorNonFatal("callbackError", error)
  66 | 			doCleanup(scope)
  67 | 			table.clear(scope)
  68 | 			return nil
  69 | 		end
  70 | 	end)
  71 | 	return setmetatable(self, SUB_OBJECT_META) :: any
  72 | end
  73 | 
  74 | local function ForKeys<KI, KO, V, S>(
  75 | 	scope: Types.Scope<S>,
  76 | 	inputTable: Types.UsedAs<{[KI]: V}>,
  77 | 	processor: (Types.Use, Types.Scope<S>, KI) -> KO,
  78 | 	destructor: unknown?
  79 | ): Types.For<KO, V>
  80 | 	if typeof(inputTable) == "function" then
  81 | 		External.logError("scopeMissing", nil, "ForKeys", "myScope:ForKeys(inputTable, function(scope, use, key) ... end)")
  82 | 	elseif destructor ~= nil then
  83 | 		External.logWarn("destructorRedundant", "ForKeys")
  84 | 	end
  85 | 	return For(
  86 | 		scope, 
  87 | 		inputTable, 
  88 | 		function(scope, initialKey, initialValue)
  89 | 			return SubObject(scope, initialKey, initialValue, processor)
  90 | 		end
  91 | 	)
  92 | end
  93 | 
  94 | return ForKeys :: Types.ForKeysConstructor
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/State/ForPairs.luau`
<details>
<summary>View Source (96 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 | 	Constructs and returns a new For state object which processes keys and
   8 | 	values in pairs.
   9 | 
  10 | 	https://elttob.uk/Fusion/0.3/api-reference/state/members/forpairs/
  11 | 
  12 | 	TODO: the sub objects constructed here can be more efficiently implemented
  13 | 	as a dedicated state object.
  14 | ]]
  15 | 
  16 | local Package = script.Parent.Parent
  17 | local Types = require(Package.Types)
  18 | local External = require(Package.External)
  19 | -- State
  20 | local For = require(Package.State.For)
  21 | local Value = require(Package.State.Value)
  22 | local Computed = require(Package.State.Computed)
  23 | local ForTypes = require(Package.State.For.ForTypes)
  24 | -- Logging
  25 | local parseError = require(Package.Logging.parseError)
  26 | -- Memory
  27 | local doCleanup = require(Package.Memory.doCleanup)
  28 | 
  29 | local SUB_OBJECT_META = {
  30 | 	__index = {
  31 | 		roamKeys = false,
  32 | 		roamValues = false,
  33 | 		invalidateInputKey = function(self): ()
  34 | 			self._inputKeyState:set(self.inputKey)
  35 | 		end,
  36 | 		invalidateInputValue = function(self): ()
  37 | 			self._inputValueState:set(self.inputValue)
  38 | 		end,
  39 | 		useOutputPair = function(self, use)
  40 | 			local pair = use(self._outputPairState)
  41 | 			return pair.key, pair.value
  42 | 		end
  43 | 	}
  44 | }
  45 | 
  46 | local function SubObject<KI, KO, VI, VO, S>(
  47 | 	scope: Types.Scope<S>,
  48 | 	initialKey: KI,
  49 | 	initialValue: VI,
  50 | 	processor: (Types.Use, Types.Scope<S>, KI, VI) -> (KO, VO)
  51 | ): ForTypes.SubObject<S, KI, KO, VI, VO>
  52 | 	local self = {}
  53 | 	self.maybeScope = scope
  54 | 	self.inputKey = initialKey
  55 | 	self.inputValue = initialValue
  56 | 	self._inputKeyState = Value(scope, initialKey)
  57 | 	self._inputValueState = Value(scope, initialValue)
  58 | 	self._processor = processor
  59 | 	self._outputPairState = Computed(scope, function(use, scope): {key: KO?, value: VO?}
  60 | 		local inputKey = use(self._inputKeyState)
  61 | 		local inputValue = use(self._inputValueState)
  62 | 		local ok, outputKey, outputValue = xpcall(self._processor, parseError, use, scope, inputKey, inputValue)
  63 | 		if ok then
  64 | 			return {key = outputKey, value = outputValue}
  65 | 		else
  66 | 			local error: Types.Error = outputKey :: any
  67 | 			error.context = `while processing key {tostring(inputValue)} and value {tostring(inputValue)}`
  68 | 			External.logErrorNonFatal("callbackError", error)
  69 | 			doCleanup(scope)
  70 | 			table.clear(scope)
  71 | 			return {key = nil, value = nil}
  72 | 		end
  73 | 	end)
  74 | 	return setmetatable(self, SUB_OBJECT_META) :: any
  75 | end
  76 | 
  77 | local function ForPairs<KI, KO, VI, VO, S>(
  78 | 	scope: Types.Scope<S>,
  79 | 	inputTable: Types.UsedAs<{[KI]: VI}>,
  80 | 	processor: (Types.Use, Types.Scope<S>, KI, VI) -> (KO, VO),
  81 | 	destructor: unknown?
  82 | ): Types.For<KO, VO>
  83 | 	if typeof(inputTable) == "function" then
  84 | 		External.logError("scopeMissing", nil, "ForPairs", "myScope:ForPairs(inputTable, function(scope, use, key, value) ... end)")
  85 | 	elseif destructor ~= nil then
  86 | 		External.logWarn("destructorRedundant", "ForPairs")
  87 | 	end
  88 | 	return For(
  89 | 		scope,
  90 | 		inputTable,
  91 | 		function(scope, initialKey, initialValue)
  92 | 			return SubObject(scope, initialKey, initialValue, processor)
  93 | 		end
  94 | 	)
  95 | end
  96 | 
  97 | return ForPairs :: Types.ForPairsConstructor
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/State/ForValues.luau`
<details>
<summary>View Source (93 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 | 	Constructs and returns a new For state object which processes values and
   8 | 	preserves keys.
   9 | 
  10 | 	https://elttob.uk/Fusion/0.3/api-reference/state/members/forvalues/
  11 | 
  12 | 	TODO: the sub objects constructed here can be more efficiently implemented
  13 | 	as a dedicated state object.
  14 | ]]
  15 | 
  16 | local Package = script.Parent.Parent
  17 | local Types = require(Package.Types)
  18 | local External = require(Package.External)
  19 | -- State
  20 | local For = require(Package.State.For)
  21 | local Value = require(Package.State.Value)
  22 | local Computed = require(Package.State.Computed)
  23 | local ForTypes = require(Package.State.For.ForTypes)
  24 | -- Logging
  25 | local parseError = require(Package.Logging.parseError)
  26 | -- Memory
  27 | local doCleanup = require(Package.Memory.doCleanup)
  28 | 
  29 | local SUB_OBJECT_META = {
  30 | 	__index = {
  31 | 		roamKeys = true,
  32 | 		roamValues = false,
  33 | 		invalidateInputKey = function(self): ()
  34 | 			-- do nothing
  35 | 		end,
  36 | 		invalidateInputValue = function(self): ()
  37 | 			self._inputValueState:set(self.inputValue)
  38 | 		end,
  39 | 		useOutputPair = function(self, use)
  40 | 			return self.inputKey, use(self._outputValueState)
  41 | 		end
  42 | 	}
  43 | }
  44 | 
  45 | local function SubObject<K, VI, VO, S>(
  46 | 	scope: Types.Scope<S>,
  47 | 	initialKey: K,
  48 | 	initialValue: VI,
  49 | 	processor: (Types.Use, Types.Scope<S>, VI) -> VO
  50 | ): ForTypes.SubObject<S, K, K, VI, VO>
  51 | 	local self = {}
  52 | 	self.maybeScope = scope
  53 | 	self.inputKey = initialKey
  54 | 	self.inputValue = initialValue
  55 | 	self._inputValueState = Value(scope, initialValue)
  56 | 	self._processor = processor
  57 | 	self._outputValueState = Computed(scope, function(use, scope): VO?
  58 | 		local inputValue = use(self._inputValueState)
  59 | 		local ok, outputValue = xpcall(self._processor, parseError, use, scope, inputValue)
  60 | 		if ok then
  61 | 			return outputValue
  62 | 		else
  63 | 			local error: Types.Error = outputValue :: any
  64 | 			error.context = `while processing value {tostring(inputValue)}`
  65 | 			External.logErrorNonFatal("callbackError", error)
  66 | 			doCleanup(scope)
  67 | 			table.clear(scope)
  68 | 			return nil
  69 | 		end
  70 | 	end)
  71 | 	return setmetatable(self, SUB_OBJECT_META) :: any
  72 | end
  73 | 
  74 | local function ForValues<K, VI, VO, S>(
  75 | 	scope: Types.Scope<S>,
  76 | 	inputTable: Types.UsedAs<{[K]: VI}>,
  77 | 	processor: (Types.Use, Types.Scope<S>, VI) -> VO,
  78 | 	destructor: unknown?
  79 | ): Types.For<K, VO>
  80 | 	if typeof(inputTable) == "function" then
  81 | 		External.logError("scopeMissing", nil, "ForValues", "myScope:ForValues(inputTable, function(scope, use, value) ... end)")
  82 | 	elseif destructor ~= nil then
  83 | 		External.logWarn("destructorRedundant", "ForValues")
  84 | 	end
  85 | 	return For(
  86 | 		scope,
  87 | 		inputTable,
  88 | 		function(scope, initialKey, initialValue)
  89 | 			return SubObject(scope, initialKey, initialValue, processor)
  90 | 		end
  91 | 	)
  92 | end
  93 | 
  94 | return ForValues :: Types.ForValuesConstructor
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/State/peek.luau`
<details>
<summary>View Source (30 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 | 	Extracts a value of type T from its input.
   8 | 
   9 | 	https://elttob.uk/Fusion/0.3/api-reference/state/members/peek/
  10 | ]]
  11 | 
  12 | local Package = script.Parent.Parent
  13 | local Types = require(Package.Types)
  14 | -- State
  15 | local castToState = require(Package.State.castToState)
  16 | -- Graph
  17 | local evaluate = require(Package.Graph.evaluate)
  18 | 
  19 | local function peek<T>(
  20 | 	target: Types.UsedAs<T>
  21 | ): T
  22 | 	local targetState = castToState(target)
  23 | 	if targetState ~= nil then
  24 | 		evaluate(targetState, false)
  25 | 		return targetState._EXTREMELY_DANGEROUS_usedAsValue :: T
  26 | 	else
  27 | 		return target :: T
  28 | 	end
  29 | end
  30 | 
  31 | return peek
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/State/updateAll.luau`
<details>
<summary>View Source (0 lines)</summary>

```lua
   1 | return nil -- dummy file so I can write tests
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/State/Value.luau`
<details>
<summary>View Source (87 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 | 	A state object which allows regular Luau code to control its value.
   8 | 
   9 | 	https://elttob.uk/Fusion/0.3/api-reference/state/types/value/
  10 | ]]
  11 | 
  12 | local Package = script.Parent.Parent
  13 | local Types = require(Package.Types)
  14 | local External = require(Package.External)
  15 | -- Graph
  16 | local change = require(Package.Graph.change)
  17 | -- Utility
  18 | local isSimilar = require(Package.Utility.isSimilar)
  19 | local never = require(Package.Utility.never)
  20 | local nicknames = require(Package.Utility.nicknames)
  21 | 
  22 | type Self<T, S> = Types.Value<T, S>
  23 | 
  24 | local class = {}
  25 | class.type = "State"
  26 | class.kind = "Value"
  27 | class.timeliness = "lazy"
  28 | class.dependencySet = table.freeze {}
  29 | 
  30 | local METATABLE = table.freeze {__index = class}
  31 | 
  32 | local function Value<T>(
  33 | 	scope: Types.Scope<unknown>,
  34 | 	initialValue: T
  35 | ): Types.Value<T, any>
  36 | 	local createdAt = os.clock()
  37 | 	if initialValue == nil and (typeof(scope) ~= "table" or (scope[1] == nil and next(scope) ~= nil)) then
  38 | 		External.logError("scopeMissing", nil, "Value", "myScope:Value(initialValue)")
  39 | 	end
  40 | 	local self: Self<T, any> = setmetatable(
  41 | 		{
  42 | 			createdAt = createdAt,
  43 | 			dependentSet = {},
  44 | 			lastChange = os.clock(),
  45 | 			scope = scope,
  46 | 			validity = "valid",
  47 | 			_EXTREMELY_DANGEROUS_usedAsValue = initialValue
  48 | 		}, 
  49 | 		METATABLE
  50 | 	) :: any
  51 | 	local destroy = function()
  52 | 		self.scope = nil
  53 | 	end
  54 | 	self.oldestTask = destroy
  55 | 	nicknames[self.oldestTask] = "Value"
  56 | 	table.insert(scope, destroy)
  57 | 	return self
  58 | end
  59 | 
  60 | function class:get<T, S>(
  61 | 	_self: Self<T, S>
  62 | ): never
  63 | 	External.logError("stateGetWasRemoved")
  64 | 	return never()
  65 | end
  66 | 
  67 | function class.set<T, S>(
  68 | 	self: Self<T, S>,
  69 | 	newValue: S
  70 | ): S
  71 | 	local oldValue = self._EXTREMELY_DANGEROUS_usedAsValue
  72 | 	if not isSimilar(oldValue, newValue) then
  73 | 		self._EXTREMELY_DANGEROUS_usedAsValue = newValue :: any
  74 | 		change(self)
  75 | 	end
  76 | 	return newValue
  77 | end
  78 | 
  79 | function class._evaluate<T, S>(
  80 | 	_self: Self<T, S>
  81 | ): boolean
  82 | 	-- The similarity test is done in advance when the value is set, so this
  83 | 	-- should be fine.
  84 | 	return true
  85 | end
  86 | 
  87 | table.freeze(class)
  88 | return Value :: Types.ValueConstructor
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/Types.luau`
<details>
<summary>View Source (314 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 | 	Stores common public-facing type information for Fusion APIs.
   8 | ]]
   9 | 
  10 | export type Error = {
  11 | 	type: "Error",
  12 | 	raw: string,
  13 | 	message: string,
  14 | 	trace: string,
  15 | 	context: string?
  16 | }
  17 | 
  18 | -- Types that can be expressed as vectors of numbers, and so can be animated.
  19 | export type Animatable =
  20 | 	number |
  21 | 	CFrame |
  22 | 	Color3 |
  23 | 	ColorSequenceKeypoint |
  24 | 	DateTime |
  25 | 	NumberRange |
  26 | 	NumberSequenceKeypoint |
  27 | 	PhysicalProperties |
  28 | 	Ray |
  29 | 	Rect |
  30 | 	Region3 |
  31 | 	Region3int16 |
  32 | 	UDim |
  33 | 	UDim2 |
  34 | 	Vector2 |
  35 | 	Vector2int16 |
  36 | 	Vector3 |
  37 | 	Vector3int16
  38 | 
  39 | -- A task which can be accepted for cleanup.
  40 | export type Task =
  41 | 	Instance |
  42 | 	RBXScriptConnection |
  43 | 	() -> () |
  44 | 	{destroy: (unknown) -> ()} |
  45 | 	{Destroy: (unknown) -> ()} |
  46 | 	{Task}
  47 | 
  48 | -- A scope of tasks to clean up.
  49 | export type Scope<Constructors = any> = {Task} & Constructors
  50 | 
  51 | -- An object which uses a scope to dictate how long it lives.
  52 | export type ScopedObject = {
  53 | 	scope: Scope<unknown>?,
  54 | 	oldestTask: unknown
  55 | }
  56 | 
  57 | -- Script-readable version information.
  58 | export type Version = {
  59 | 	major: number,
  60 | 	minor: number,
  61 | 	isRelease: boolean
  62 | }
  63 | 
  64 | -- An object which stores a value scoped in time.
  65 | export type Contextual<T> = {
  66 | 	type: "Contextual",
  67 | 	now: (Contextual<T>) -> T,
  68 | 	is: (Contextual<T>, T) -> ContextualIsMethods
  69 | }
  70 | 
  71 | type ContextualIsMethods = {
  72 | 	during: <R, A...>(ContextualIsMethods, (A...) -> R, A...) -> R
  73 | }
  74 | 
  75 | -- A graph object which can have dependencies and dependencies.
  76 | export type GraphObject = ScopedObject & {
  77 | 	createdAt: number,
  78 | 	dependencySet: {[GraphObject]: unknown},
  79 | 	dependentSet: {[GraphObject]: unknown},
  80 | 	lastChange: number?,
  81 | 	timeliness: "lazy" | "eager",
  82 | 	validity: "valid" | "invalid" | "busy",
  83 | 	_evaluate: (GraphObject) -> boolean
  84 | }
  85 | 
  86 | -- An object which stores a piece of reactive state.
  87 | export type StateObject<T> = GraphObject & {
  88 | 	type: "State",
  89 | 	kind: string,
  90 | 	_EXTREMELY_DANGEROUS_usedAsValue: T
  91 | }
  92 | 
  93 | -- Passing values of this type to `Use` returns `T`.
  94 | export type UsedAs<T> = StateObject<T> | T
  95 | 
  96 | -- Function signature for use callbacks.
  97 | export type Use = <T>(target: UsedAs<T>) -> T
  98 | 
  99 | -- A state object whose value can be set at any time by the user.
 100 | export type Value<T, S = T> = StateObject<T> & {
 101 | 	kind: "State",
 102 | 	timeliness: "lazy",
 103 |  	set: (Value<T, S>, newValue: S, force: boolean?) -> S,
 104 | 	____phantom_setType: (never) -> S -- phantom data so this contains S
 105 | }
 106 | export type ValueConstructor = <T>(
 107 | 	scope: Scope<unknown>,
 108 | 	initialValue: T
 109 | ) -> Value<T, any>
 110 | 
 111 | -- A state object whose value is derived from other objects using a callback.
 112 | export type Computed<T> = StateObject<T> & {
 113 | 	kind: "Computed",
 114 | 	timeliness: "lazy"
 115 | }
 116 | export type ComputedConstructor = <T, S>(
 117 | 	scope: S & Scope<unknown>,
 118 | 	callback: (Use, S) -> T
 119 | ) -> Computed<T>
 120 | 
 121 | -- A state object which maps over keys and/or values in another table.
 122 | export type For<KO, VO> = StateObject<{[KO]: VO}>  & {
 123 | 	kind: "For"
 124 | }
 125 | export type ForPairsConstructor =  <KI, KO, VI, VO, S>(
 126 | 	scope: S & Scope<unknown>,
 127 | 	inputTable: UsedAs<{[KI]: VI}>,
 128 | 	processor: (Use, S, key: KI, value: VI) -> (KO, VO)
 129 | ) -> For<KO, VO>
 130 | export type ForKeysConstructor =  <KI, KO, V, S>(
 131 | 	scope: S & Scope<unknown>,
 132 | 	inputTable: UsedAs<{[KI]: V}>,
 133 | 	processor: (Use, S, key: KI) -> KO
 134 | ) -> For<KO, V>
 135 | export type ForValuesConstructor =  <K, VI, VO, S>(
 136 | 	scope: S & Scope<unknown>,
 137 | 	inputTable: UsedAs<{[K]: VI}>,
 138 | 	processor: (Use, S, value: VI) -> VO
 139 | ) -> For<K, VO>
 140 | 
 141 | -- An object which can listen for updates on another state object.
 142 | export type Observer = GraphObject & {
 143 | 	type: "Observer",
 144 | 	timeliness: "eager",
 145 | 	onChange: (Observer, callback: () -> ()) -> (() -> ()),
 146 | 	onBind: (Observer, callback: () -> ()) -> (() -> ())
 147 | }
 148 | export type ObserverConstructor = (
 149 | 	scope: Scope<unknown>,
 150 | 	watching: unknown
 151 | ) -> Observer
 152 | 
 153 | -- A state object which follows another state object using tweens.
 154 | export type Tween<T> = StateObject<T> & {
 155 | 	kind: "Tween"
 156 | }
 157 | export type TweenConstructor = <T>(
 158 | 	scope: Scope<unknown>,
 159 | 	goalState: UsedAs<T>,
 160 | 	tweenInfo: UsedAs<TweenInfo>?
 161 | ) -> Tween<T>
 162 | 
 163 | -- A state object which follows another state object using spring simulation.
 164 | export type Spring<T> = StateObject<T>  & {
 165 | 	kind: "Spring",
 166 | 	setPosition: (Spring<T>, newPosition: T) -> (),
 167 | 	setVelocity: (Spring<T>, newVelocity: T) -> (),
 168 | 	addVelocity: (Spring<T>, deltaVelocity: T) -> ()
 169 | }
 170 | export type SpringConstructor = <T>(
 171 | 	scope: Scope<unknown>,
 172 | 	goalState: UsedAs<T>,
 173 | 	speed: UsedAs<number>?,
 174 | 	damping: UsedAs<number>?
 175 | ) -> Spring<T>
 176 | 
 177 | -- Denotes children instances in an instance or component's property table.
 178 | export type SpecialKey = {
 179 | 	type: "SpecialKey",
 180 | 	kind: string,
 181 | 	stage: "self" | "descendants" | "ancestor" | "observer",
 182 | 	apply: (
 183 | 		self: SpecialKey,
 184 | 		scope: Scope<unknown>,
 185 | 		value: unknown,
 186 | 		applyTo: Instance
 187 | 	) -> ()
 188 | }
 189 | 
 190 | -- A collection of instances that may be parented to another instance.
 191 | export type Child = Instance | StateObject<Child> | {[unknown]: Child}
 192 | 
 193 | -- A table that defines an instance's properties, handlers and children.
 194 | export type PropertyTable = {[string | SpecialKey]: unknown}
 195 | 
 196 | export type NewConstructor = (
 197 | 	scope: Scope<unknown>,
 198 | 	className: string
 199 | ) -> (propertyTable: PropertyTable) -> Instance
 200 | 
 201 | export type HydrateConstructor = (
 202 | 	scope: Scope<unknown>,
 203 | 	target: Instance
 204 | ) -> (propertyTable: PropertyTable) -> Instance
 205 | 
 206 | -- Is there a sane way to write out this type?
 207 | -- ... I sure hope so.
 208 | 
 209 | export type DeriveScopeConstructor = (<S>(Scope<S>) -> Scope<S>)
 210 | 	& (<S, A>(Scope<S>, A & {}) -> Scope<S & A>)
 211 | 	& (<S, A, B>(Scope<S>, A & {}, B & {}) -> Scope<S & A & B>)
 212 | 	& (<S, A, B, C>(Scope<S>, A & {}, B & {}, C & {}) -> Scope<S & A & B & C>)
 213 | 	& (<S, A, B, C, D>(Scope<S>, A & {}, B & {}, C & {}, D & {}) -> Scope<S & A & B & C & D>)
 214 | 	& (<S, A, B, C, D, E>(Scope<S>, A & {}, B & {}, C & {}, D & {}, E & {}) -> Scope<S & A & B & C & D & E>)
 215 | 	& (<S, A, B, C, D, E, F>(Scope<S>, A & {}, B & {}, C & {}, D & {}, E & {}, F & {}) -> Scope<S & A & B & C & D & E & F>)
 216 | 	& (<S, A, B, C, D, E, F, G>(Scope<S>, A & {}, B & {}, C & {}, D & {}, E & {}, F & {}, G & {}) -> Scope<S & A & B & C & D & E & F & G>)
 217 | 	& (<S, A, B, C, D, E, F, G, H>(Scope<S>, A & {}, B & {}, C & {}, D & {}, E & {}, F & {}, G & {}, H & {}) -> Scope<S & A & B & C & D & E & F & G & H>)
 218 | 	& (<S, A, B, C, D, E, F, G, H, I>(Scope<S>, A & {}, B & {}, C & {}, D & {}, E & {}, F & {}, G & {}, H & {}, I & {}) -> Scope<S & A & B & C & D & E & F & G & H & I>)
 219 | 	& (<S, A, B, C, D, E, F, G, H, I, J>(Scope<S>, A & {}, B & {}, C & {}, D & {}, E & {}, F & {}, G & {}, H & {}, I & {}, J & {}) -> Scope<S & A & B & C & D & E & F & G & H & I & J>)
 220 | 	& (<S, A, B, C, D, E, F, G, H, I, J, K>(Scope<S>, A & {}, B & {}, C & {}, D & {}, E & {}, F & {}, G & {}, H & {}, I & {}, J & {}, K & {}) -> Scope<S & A & B & C & D & E & F & G & H & I & J & K>)
 221 | 	& (<S, A, B, C, D, E, F, G, H, I, J, K, L>(Scope<S>, A & {}, B & {}, C & {}, D & {}, E & {}, F & {}, G & {}, H & {}, I & {}, J & {}, K & {}, L & {}) -> Scope<S & A & B & C & D & E & F & G & H & I & J & K & L>)
 222 | 
 223 | export type ScopedConstructor = (() -> Scope<{}>)
 224 | 	& (<A>(A & {}) -> Scope<A>)
 225 | 	& (<A, B>(A & {}, B & {}) -> Scope<A & B>)
 226 | 	& (<A, B, C>(A & {}, B & {}, C & {}) -> Scope<A & B & C>)
 227 | 	& (<A, B, C, D>(A & {}, B & {}, C & {}, D & {}) -> Scope<A & B & C & D>)
 228 | 	& (<A, B, C, D, E>(A & {}, B & {}, C & {}, D & {}, E & {}) -> Scope<A & B & C & D & E>)
 229 | 	& (<A, B, C, D, E, F>(A & {}, B & {}, C & {}, D & {}, E & {}, F & {}) -> Scope<A & B & C & D & E & F>)
 230 | 	& (<A, B, C, D, E, F, G>(A & {}, B & {}, C & {}, D & {}, E & {}, F & {}, G & {}) -> Scope<A & B & C & D & E & F & G>)
 231 | 	& (<A, B, C, D, E, F, G, H>(A & {}, B & {}, C & {}, D & {}, E & {}, F & {}, G & {}, H & {}) -> Scope<A & B & C & D & E & F & G & H>)
 232 | 	& (<A, B, C, D, E, F, G, H, I>(A & {}, B & {}, C & {}, D & {}, E & {}, F & {}, G & {}, H & {}, I & {}) -> Scope<A & B & C & D & E & F & G & H & I>)
 233 | 	& (<A, B, C, D, E, F, G, H, I, J>(A & {}, B & {}, C & {}, D & {}, E & {}, F & {}, G & {}, H & {}, I & {}, J & {}) -> Scope<A & B & C & D & E & F & G & H & I & J>)
 234 | 	& (<A, B, C, D, E, F, G, H, I, J, K>(A & {}, B & {}, C & {}, D & {}, E & {}, F & {}, G & {}, H & {}, I & {}, J & {}, K & {}) -> Scope<A & B & C & D & E & F & G & H & I & J & K>)
 235 | 	& (<A, B, C, D, E, F, G, H, I, J, K, L>(A & {}, B & {}, C & {}, D & {}, E & {}, F & {}, G & {}, H & {}, I & {}, J & {}, K & {}, L & {}) -> Scope<A & B & C & D & E & F & G & H & I & J & K & L>)
 236 | 
 237 | export type ContextualConstructor = <T>(defaultValue: T) -> Contextual<T>
 238 | 
 239 | export type Safe = <Success, Fail>(
 240 | 	callbacks: {
 241 | 		try: () -> Success,
 242 | 		fallback: (err: unknown) -> Fail
 243 | 	}
 244 | ) -> Success | Fail
 245 | 
 246 | export type Fusion = {
 247 | 	version: Version,
 248 | 	Contextual: ContextualConstructor,
 249 | 	Safe: Safe,
 250 | 
 251 | 	doCleanup: (Task) -> (),
 252 | 	scoped: ScopedConstructor,
 253 | 	deriveScope: DeriveScopeConstructor,
 254 | 	innerScope: DeriveScopeConstructor,
 255 | 
 256 | 	peek: Use,
 257 | 	Value: ValueConstructor,
 258 | 	Computed: ComputedConstructor,
 259 | 	ForPairs: ForPairsConstructor,
 260 | 	ForKeys: ForKeysConstructor,
 261 | 	ForValues: ForValuesConstructor,
 262 | 	Observer: ObserverConstructor,
 263 | 
 264 | 	Tween: TweenConstructor,
 265 | 	Spring: SpringConstructor,
 266 | 
 267 | 	New: NewConstructor,
 268 | 	Hydrate: HydrateConstructor,
 269 | 
 270 | 	Child: ({Child}) -> Child,
 271 | 	Children: SpecialKey,
 272 | 	Out: (propertyName: string) -> SpecialKey,
 273 | 	OnEvent: (eventName: string) -> SpecialKey,
 274 | 	OnChange: (propertyName: string) -> SpecialKey,
 275 | 	Attribute: (attributeName: string) -> SpecialKey,
 276 | 	AttributeChange: (attributeName: string) -> SpecialKey,
 277 | 	AttributeOut: (attributeName: string) -> SpecialKey,
 278 | }
 279 | 
 280 | export type ExternalProvider = {
 281 | 	policies: {
 282 | 		allowWebLinks: boolean
 283 | 	},
 284 | 
 285 | 	logErrorNonFatal: (
 286 | 		errorString: string
 287 | 	) -> (),
 288 | 	logWarn: (
 289 | 		errorString: string
 290 | 	) -> (),
 291 | 	
 292 | 	doTaskImmediate: (
 293 | 		resume: () -> ()
 294 | 	) -> (),
 295 | 	doTaskDeferred: (
 296 | 		resume: () -> ()
 297 | 	) -> (),
 298 | 	startScheduler: () -> (),
 299 | 	stopScheduler: () -> ()
 300 | }
 301 | 
 302 | export type ExternalDebugger = {
 303 | 	startDebugging: () -> (),
 304 | 	stopDebugging: () -> (),
 305 | 
 306 | 	trackScope: (
 307 | 		scope: Scope<unknown>
 308 | 	) -> (),
 309 | 	untrackScope: (
 310 | 		scope: Scope<unknown>
 311 | 	) -> ()
 312 | }
 313 | 
 314 | return nil
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/Utility/Contextual.luau`
<details>
<summary>View Source (90 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 |     Time-based contextual values, to allow for transparently passing values down
   8 | 	the call stack.
   9 | ]]
  10 | 
  11 | local Package = script.Parent.Parent
  12 | local Types = require(Package.Types)
  13 | local External = require(Package.External)
  14 | -- Logging
  15 | local parseError = require(Package.Logging.parseError)
  16 | 
  17 | export type Self<T> = Types.Contextual<T> & {
  18 | 	_valuesNow: {[thread]: {value: T}},
  19 | 	_defaultValue: T
  20 | }
  21 | 
  22 | local class = {}
  23 | class.type = "Contextual"
  24 | 
  25 | local METATABLE = table.freeze {__index = class}
  26 | local WEAK_KEYS_METATABLE = table.freeze {__mode = "k"}
  27 | 
  28 | local function Contextual<T>(
  29 | 	defaultValue: T
  30 | ): Types.Contextual<T>
  31 | 	local self: Self<T> = setmetatable(
  32 | 		{
  33 | 			-- if we held strong references to threads here, then if a thread was
  34 | 			-- killed before this contextual had a chance to finish executing its
  35 | 			-- callback, it would be held strongly in this table forever
  36 | 			_valuesNow = setmetatable({}, WEAK_KEYS_METATABLE),
  37 | 			_defaultValue = defaultValue
  38 | 		}, 
  39 | 		METATABLE
  40 | 	) :: any
  41 | 
  42 | 	return self
  43 | end
  44 | 
  45 | --[[
  46 | 	Returns the current value of this contextual.
  47 | ]]
  48 | function class.now<T>(
  49 | 	self: Self<T>
  50 | ): T
  51 | 	local thread = coroutine.running()
  52 | 	local value = self._valuesNow[thread]
  53 | 	if typeof(value) ~= "table" then
  54 | 		return self._defaultValue
  55 | 	else
  56 | 		return value.value
  57 | 	end
  58 | end
  59 | 
  60 | --[[
  61 | 	Temporarily assigns a value to this contextual.
  62 | ]]
  63 | function class.is<T>(
  64 | 	self: Self<T>,
  65 | 	newValue: T
  66 | )
  67 | 	local methods = {}
  68 | 	
  69 | 	function methods.during<T, A...>(
  70 | 		_: any, -- during is called with colon syntax but we don't care
  71 | 		callback: (A...) -> T,
  72 | 		...: A...
  73 | 	): T
  74 | 		local thread = coroutine.running()
  75 | 		local prevValue = self._valuesNow[thread]
  76 | 		-- Storing the value in this format allows us to distinguish storing
  77 | 		-- `nil` from not calling `:during()` at all.
  78 | 		self._valuesNow[thread] = { value = newValue }
  79 | 		local ok, value = xpcall(callback, parseError, ...)
  80 | 		self._valuesNow[thread] = prevValue
  81 | 		if not ok then
  82 | 			External.logError("callbackError", value :: any)
  83 | 		end
  84 | 		return value
  85 | 	end
  86 | 
  87 | 	return methods
  88 | end
  89 | 
  90 | table.freeze(class)
  91 | return Contextual
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/Utility/isSimilar.luau`
<details>
<summary>View Source (29 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 | 	Implements the 'similarity test' used to determine whether two values have
   8 | 	a meaningful difference.
   9 | 
  10 | 	https://elttob.uk/Fusion/0.3/tutorials/best-practices/optimisation/#similarity
  11 | ]]
  12 | 
  13 | local function isSimilar(
  14 | 	a: unknown, 
  15 | 	b: unknown
  16 | ): boolean
  17 | 	local typeA = typeof(a)
  18 | 	local isTable = typeA == "table"
  19 | 	local isUserdata = typeA == "userdata"
  20 | 	return
  21 | 		if not (isTable or isUserdata) then
  22 | 			a == b or a ~= a and b ~= b
  23 | 		elseif typeA == typeof(b) and (isUserdata or table.isfrozen(a :: any) or getmetatable(a :: any) ~= nil) then
  24 | 			a == b
  25 | 		else
  26 | 			false
  27 | end
  28 | 
  29 | return isSimilar
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/Utility/merge.luau`
<details>
<summary>View Source (35 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 | 	Attempts to merge a variadic number of tables together.
   8 | ]]
   9 | 
  10 | local Package = script.Parent.Parent
  11 | local External = require(Package.External)
  12 | 
  13 | local function merge(
  14 | 	overwrite: boolean,
  15 | 	into: {[unknown]: unknown},
  16 | 	...: {[unknown]: unknown}
  17 | ): {[unknown]: unknown}
  18 | 	local fromTables = {...}
  19 | 	if #fromTables < 1 then
  20 | 		return into
  21 | 	else
  22 | 		for _, fromTable in fromTables do
  23 | 			for key, value in fromTable do
  24 | 				if into[key] == nil then
  25 | 					into[key] = value
  26 | 				elseif not overwrite then
  27 | 					External.logError("mergeConflict", nil, tostring(key))
  28 | 				end
  29 | 			end
  30 | 		end
  31 | 		return into
  32 | 	end
  33 | end
  34 | 
  35 | return merge
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/Utility/nameOf.luau`
<details>
<summary>View Source (34 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 | 	Returns the most specific custom name for the given object.
   8 | ]]
   9 | 
  10 | local Package = script.Parent.Parent
  11 | -- Utility
  12 | local nicknames = require(Package.Utility.nicknames)
  13 | 
  14 | local function nameOf(
  15 | 	x: unknown,
  16 | 	defaultName: string
  17 | ): string
  18 | 	local nickname = nicknames[x]
  19 | 	if typeof(nickname) == "string" then
  20 | 		return nickname
  21 | 	end
  22 | 	if typeof(x) == "table" then
  23 | 		local x = x :: {[any]: any}
  24 | 		if typeof(x.name) == "string" then
  25 | 			return x.name
  26 | 		elseif typeof(x.kind) == "string" then
  27 | 			return x.kind
  28 | 		elseif typeof(x.type) == "string" then
  29 | 			return x.type
  30 | 		end
  31 | 	end
  32 | 	return defaultName
  33 | end
  34 | 
  35 | return nameOf
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/Utility/never.luau`
<details>
<summary>View Source (13 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 | 	Never returns.
   8 | ]]
   9 | 
  10 | local function never(): never
  11 | 	error("This codepath should not be reachable")
  12 | end
  13 | 
  14 | return never
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/Utility/nicknames.luau`
<details>
<summary>View Source (10 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 | 	Stores nicknames for values that don't support metatables, so that `nameOf`
   8 | 	can return values for them.
   9 | ]]
  10 | 
  11 | return setmetatable({}, {__mode = "k"})
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/Utility/Safe.luau`
<details>
<summary>View Source (22 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 |     A variant of xpcall() designed for inline usage, letting you define fallback
   8 | 	values based on caught errors.
   9 | ]]
  10 | 
  11 | local Package = script.Parent.Parent
  12 | 
  13 | local function Safe<Success, Fail>(
  14 | 	callbacks: {
  15 | 		try: () -> Success,
  16 | 		fallback: (err: unknown) -> Fail
  17 | 	}
  18 | ): Success | Fail
  19 | 	local _, value = xpcall(callbacks.try, callbacks.fallback)
  20 | 	return value
  21 | end
  22 | 
  23 | return Safe
```
</details>

## ğŸŒ™ `Packages/_Index/elttob_fusion@0.3.0/fusion/src/Utility/xtypeof.luau`
<details>
<summary>View Source (26 lines)</summary>

```lua
   1 | --!strict
   2 | --!nolint LocalUnused
   3 | --!nolint LocalShadow
   4 | local task = nil -- Disable usage of Roblox's task scheduler
   5 | 
   6 | --[[
   7 | 	Extended typeof, designed for identifying custom objects.
   8 | 	If given a table with a `type` string, returns that.
   9 | 	Otherwise, returns `typeof()` the argument.
  10 | ]]
  11 | 
  12 | local function xtypeof(
  13 | 	x: unknown
  14 | ): string
  15 | 	local typeString = typeof(x)
  16 | 
  17 | 	if typeString == "table" then
  18 | 		local x = x :: {type: unknown?}
  19 | 		if typeof(x.type) == "string" then
  20 | 			return x.type
  21 | 		end
  22 | 	end
  23 | 
  24 | 	return typeString
  25 | end
  26 | 
  27 | return xtypeof
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/lib/init.lua`
<details>
<summary>View Source (2068 lines)</summary>

```lua
   1 | --[[
   2 | 	An implementation of Promises similar to Promise/A+.
   3 | ]]
   4 | 
   5 | local ERROR_NON_PROMISE_IN_LIST = "Non-promise value passed into %s at index %s"
   6 | local ERROR_NON_LIST = "Please pass a list of promises to %s"
   7 | local ERROR_NON_FUNCTION = "Please pass a handler function to %s!"
   8 | local MODE_KEY_METATABLE = { __mode = "k" }
   9 | 
  10 | local function isCallable(value)
  11 | 	if type(value) == "function" then
  12 | 		return true
  13 | 	end
  14 | 
  15 | 	if type(value) == "table" then
  16 | 		local metatable = getmetatable(value)
  17 | 		if metatable and type(rawget(metatable, "__call")) == "function" then
  18 | 			return true
  19 | 		end
  20 | 	end
  21 | 
  22 | 	return false
  23 | end
  24 | 
  25 | --[[
  26 | 	Creates an enum dictionary with some metamethods to prevent common mistakes.
  27 | ]]
  28 | local function makeEnum(enumName, members)
  29 | 	local enum = {}
  30 | 
  31 | 	for _, memberName in ipairs(members) do
  32 | 		enum[memberName] = memberName
  33 | 	end
  34 | 
  35 | 	return setmetatable(enum, {
  36 | 		__index = function(_, k)
  37 | 			error(string.format("%s is not in %s!", k, enumName), 2)
  38 | 		end,
  39 | 		__newindex = function()
  40 | 			error(string.format("Creating new members in %s is not allowed!", enumName), 2)
  41 | 		end,
  42 | 	})
  43 | end
  44 | 
  45 | --[=[
  46 | 	An object to represent runtime errors that occur during execution.
  47 | 	Promises that experience an error like this will be rejected with
  48 | 	an instance of this object.
  49 | 
  50 | 	@class Error
  51 | ]=]
  52 | local Error
  53 | do
  54 | 	Error = {
  55 | 		Kind = makeEnum("Promise.Error.Kind", {
  56 | 			"ExecutionError",
  57 | 			"AlreadyCancelled",
  58 | 			"NotResolvedInTime",
  59 | 			"TimedOut",
  60 | 		}),
  61 | 	}
  62 | 	Error.__index = Error
  63 | 
  64 | 	function Error.new(options, parent)
  65 | 		options = options or {}
  66 | 		return setmetatable({
  67 | 			error = tostring(options.error) or "[This error has no error text.]",
  68 | 			trace = options.trace,
  69 | 			context = options.context,
  70 | 			kind = options.kind,
  71 | 			parent = parent,
  72 | 			createdTick = os.clock(),
  73 | 			createdTrace = debug.traceback(),
  74 | 		}, Error)
  75 | 	end
  76 | 
  77 | 	function Error.is(anything)
  78 | 		if type(anything) == "table" then
  79 | 			local metatable = getmetatable(anything)
  80 | 
  81 | 			if type(metatable) == "table" then
  82 | 				return rawget(anything, "error") ~= nil and type(rawget(metatable, "extend")) == "function"
  83 | 			end
  84 | 		end
  85 | 
  86 | 		return false
  87 | 	end
  88 | 
  89 | 	function Error.isKind(anything, kind)
  90 | 		assert(kind ~= nil, "Argument #2 to Promise.Error.isKind must not be nil")
  91 | 
  92 | 		return Error.is(anything) and anything.kind == kind
  93 | 	end
  94 | 
  95 | 	function Error:extend(options)
  96 | 		options = options or {}
  97 | 
  98 | 		options.kind = options.kind or self.kind
  99 | 
 100 | 		return Error.new(options, self)
 101 | 	end
 102 | 
 103 | 	function Error:getErrorChain()
 104 | 		local runtimeErrors = { self }
 105 | 
 106 | 		while runtimeErrors[#runtimeErrors].parent do
 107 | 			table.insert(runtimeErrors, runtimeErrors[#runtimeErrors].parent)
 108 | 		end
 109 | 
 110 | 		return runtimeErrors
 111 | 	end
 112 | 
 113 | 	function Error:__tostring()
 114 | 		local errorStrings = {
 115 | 			string.format("-- Promise.Error(%s) --", self.kind or "?"),
 116 | 		}
 117 | 
 118 | 		for _, runtimeError in ipairs(self:getErrorChain()) do
 119 | 			table.insert(
 120 | 				errorStrings,
 121 | 				table.concat({
 122 | 					runtimeError.trace or runtimeError.error,
 123 | 					runtimeError.context,
 124 | 				}, "\n")
 125 | 			)
 126 | 		end
 127 | 
 128 | 		return table.concat(errorStrings, "\n")
 129 | 	end
 130 | end
 131 | 
 132 | --[[
 133 | 	Packs a number of arguments into a table and returns its length.
 134 | 
 135 | 	Used to cajole varargs without dropping sparse values.
 136 | ]]
 137 | local function pack(...)
 138 | 	return select("#", ...), { ... }
 139 | end
 140 | 
 141 | --[[
 142 | 	Returns first value (success), and packs all following values.
 143 | ]]
 144 | local function packResult(success, ...)
 145 | 	return success, select("#", ...), { ... }
 146 | end
 147 | 
 148 | local function makeErrorHandler(traceback)
 149 | 	assert(traceback ~= nil, "traceback is nil")
 150 | 
 151 | 	return function(err)
 152 | 		-- If the error object is already a table, forward it directly.
 153 | 		-- Should we extend the error here and add our own trace?
 154 | 
 155 | 		if type(err) == "table" then
 156 | 			return err
 157 | 		end
 158 | 
 159 | 		return Error.new({
 160 | 			error = err,
 161 | 			kind = Error.Kind.ExecutionError,
 162 | 			trace = debug.traceback(tostring(err), 2),
 163 | 			context = "Promise created at:\n\n" .. traceback,
 164 | 		})
 165 | 	end
 166 | end
 167 | 
 168 | --[[
 169 | 	Calls a Promise executor with error handling.
 170 | ]]
 171 | local function runExecutor(traceback, callback, ...)
 172 | 	return packResult(xpcall(callback, makeErrorHandler(traceback), ...))
 173 | end
 174 | 
 175 | --[[
 176 | 	Creates a function that invokes a callback with correct error handling and
 177 | 	resolution mechanisms.
 178 | ]]
 179 | local function createAdvancer(traceback, callback, resolve, reject)
 180 | 	return function(...)
 181 | 		local ok, resultLength, result = runExecutor(traceback, callback, ...)
 182 | 
 183 | 		if ok then
 184 | 			resolve(unpack(result, 1, resultLength))
 185 | 		else
 186 | 			reject(result[1])
 187 | 		end
 188 | 	end
 189 | end
 190 | 
 191 | local function isEmpty(t)
 192 | 	return next(t) == nil
 193 | end
 194 | 
 195 | --[=[
 196 | 	An enum value used to represent the Promise's status.
 197 | 	@interface Status
 198 | 	@tag enum
 199 | 	@within Promise
 200 | 	.Started "Started" -- The Promise is executing, and not settled yet.
 201 | 	.Resolved "Resolved" -- The Promise finished successfully.
 202 | 	.Rejected "Rejected" -- The Promise was rejected.
 203 | 	.Cancelled "Cancelled" -- The Promise was cancelled before it finished.
 204 | ]=]
 205 | --[=[
 206 | 	@prop Status Status
 207 | 	@within Promise
 208 | 	@readonly
 209 | 	@tag enums
 210 | 	A table containing all members of the `Status` enum, e.g., `Promise.Status.Resolved`.
 211 | ]=]
 212 | --[=[
 213 | 	A Promise is an object that represents a value that will exist in the future, but doesn't right now.
 214 | 	Promises allow you to then attach callbacks that can run once the value becomes available (known as *resolving*),
 215 | 	or if an error has occurred (known as *rejecting*).
 216 | 
 217 | 	@class Promise
 218 | 	@__index prototype
 219 | ]=]
 220 | local Promise = {
 221 | 	Error = Error,
 222 | 	Status = makeEnum("Promise.Status", { "Started", "Resolved", "Rejected", "Cancelled" }),
 223 | 	_getTime = os.clock,
 224 | 	_timeEvent = game:GetService("RunService").Heartbeat,
 225 | 	_unhandledRejectionCallbacks = {},
 226 | }
 227 | Promise.prototype = {}
 228 | Promise.__index = Promise.prototype
 229 | 
 230 | function Promise._new(traceback, callback, parent)
 231 | 	if parent ~= nil and not Promise.is(parent) then
 232 | 		error("Argument #2 to Promise.new must be a promise or nil", 2)
 233 | 	end
 234 | 
 235 | 	local self = {
 236 | 		-- The executor thread.
 237 | 		_thread = nil,
 238 | 
 239 | 		-- Used to locate where a promise was created
 240 | 		_source = traceback,
 241 | 
 242 | 		_status = Promise.Status.Started,
 243 | 
 244 | 		-- A table containing a list of all results, whether success or failure.
 245 | 		-- Only valid if _status is set to something besides Started
 246 | 		_values = nil,
 247 | 
 248 | 		-- Lua doesn't like sparse arrays very much, so we explicitly store the
 249 | 		-- length of _values to handle middle nils.
 250 | 		_valuesLength = -1,
 251 | 
 252 | 		-- Tracks if this Promise has no error observers..
 253 | 		_unhandledRejection = true,
 254 | 
 255 | 		-- Queues representing functions we should invoke when we update!
 256 | 		_queuedResolve = {},
 257 | 		_queuedReject = {},
 258 | 		_queuedFinally = {},
 259 | 
 260 | 		-- The function to run when/if this promise is cancelled.
 261 | 		_cancellationHook = nil,
 262 | 
 263 | 		-- The "parent" of this promise in a promise chain. Required for
 264 | 		-- cancellation propagation upstream.
 265 | 		_parent = parent,
 266 | 
 267 | 		-- Consumers are Promises that have chained onto this one.
 268 | 		-- We track them for cancellation propagation downstream.
 269 | 		_consumers = setmetatable({}, MODE_KEY_METATABLE),
 270 | 	}
 271 | 
 272 | 	if parent and parent._status == Promise.Status.Started then
 273 | 		parent._consumers[self] = true
 274 | 	end
 275 | 
 276 | 	setmetatable(self, Promise)
 277 | 
 278 | 	local function resolve(...)
 279 | 		self:_resolve(...)
 280 | 	end
 281 | 
 282 | 	local function reject(...)
 283 | 		self:_reject(...)
 284 | 	end
 285 | 
 286 | 	local function onCancel(cancellationHook)
 287 | 		if cancellationHook then
 288 | 			if self._status == Promise.Status.Cancelled then
 289 | 				cancellationHook()
 290 | 			else
 291 | 				self._cancellationHook = cancellationHook
 292 | 			end
 293 | 		end
 294 | 
 295 | 		return self._status == Promise.Status.Cancelled
 296 | 	end
 297 | 
 298 | 	self._thread = coroutine.create(function()
 299 | 		local ok, _, result = runExecutor(self._source, callback, resolve, reject, onCancel)
 300 | 
 301 | 		if not ok then
 302 | 			reject(result[1])
 303 | 		end
 304 | 	end)
 305 | 
 306 | 	task.spawn(self._thread)
 307 | 
 308 | 	return self
 309 | end
 310 | 
 311 | --[=[
 312 | 	Construct a new Promise that will be resolved or rejected with the given callbacks.
 313 | 
 314 | 	If you `resolve` with a Promise, it will be chained onto.
 315 | 
 316 | 	You can safely yield within the executor function and it will not block the creating thread.
 317 | 
 318 | 	```lua
 319 | 	local myFunction()
 320 | 		return Promise.new(function(resolve, reject, onCancel)
 321 | 			wait(1)
 322 | 			resolve("Hello world!")
 323 | 		end)
 324 | 	end
 325 | 
 326 | 	myFunction():andThen(print)
 327 | 	```
 328 | 
 329 | 	You do not need to use `pcall` within a Promise. Errors that occur during execution will be caught and turned into a rejection automatically. If `error()` is called with a table, that table will be the rejection value. Otherwise, string errors will be converted into `Promise.Error(Promise.Error.Kind.ExecutionError)` objects for tracking debug information.
 330 | 
 331 | 	You may register an optional cancellation hook by using the `onCancel` argument:
 332 | 
 333 | 	* This should be used to abort any ongoing operations leading up to the promise being settled.
 334 | 	* Call the `onCancel` function with a function callback as its only argument to set a hook which will in turn be called when/if the promise is cancelled.
 335 | 	* `onCancel` returns `true` if the Promise was already cancelled when you called `onCancel`.
 336 | 	* Calling `onCancel` with no argument will not override a previously set cancellation hook, but it will still return `true` if the Promise is currently cancelled.
 337 | 	* You can set the cancellation hook at any time before resolving.
 338 | 	* When a promise is cancelled, calls to `resolve` or `reject` will be ignored, regardless of if you set a cancellation hook or not.
 339 | 
 340 | 	:::caution
 341 | 	If the Promise is cancelled, the `executor` thread is closed with `coroutine.close` after the cancellation hook is called.
 342 | 
 343 | 	You must perform any cleanup code in the cancellation hook: any time your executor yields, it **may never resume**.
 344 | 	:::
 345 | 
 346 | 	@param executor (resolve: (...: any) -> (), reject: (...: any) -> (), onCancel: (abortHandler?: () -> ()) -> boolean) -> ()
 347 | 	@return Promise
 348 | ]=]
 349 | function Promise.new(executor)
 350 | 	return Promise._new(debug.traceback(nil, 2), executor)
 351 | end
 352 | 
 353 | function Promise:__tostring()
 354 | 	return string.format("Promise(%s)", self._status)
 355 | end
 356 | 
 357 | --[=[
 358 | 	The same as [Promise.new](/api/Promise#new), except execution begins after the next `Heartbeat` event.
 359 | 
 360 | 	This is a spiritual replacement for `spawn`, but it does not suffer from the same [issues](https://eryn.io/gist/3db84579866c099cdd5bb2ff37947cec) as `spawn`.
 361 | 
 362 | 	```lua
 363 | 	local function waitForChild(instance, childName, timeout)
 364 | 	  return Promise.defer(function(resolve, reject)
 365 | 		local child = instance:WaitForChild(childName, timeout)
 366 | 
 367 | 		;(child and resolve or reject)(child)
 368 | 	  end)
 369 | 	end
 370 | 	```
 371 | 
 372 | 	@param executor (resolve: (...: any) -> (), reject: (...: any) -> (), onCancel: (abortHandler?: () -> ()) -> boolean) -> ()
 373 | 	@return Promise
 374 | ]=]
 375 | function Promise.defer(executor)
 376 | 	local traceback = debug.traceback(nil, 2)
 377 | 	local promise
 378 | 	promise = Promise._new(traceback, function(resolve, reject, onCancel)
 379 | 		local connection
 380 | 		connection = Promise._timeEvent:Connect(function()
 381 | 			connection:Disconnect()
 382 | 			local ok, _, result = runExecutor(traceback, executor, resolve, reject, onCancel)
 383 | 
 384 | 			if not ok then
 385 | 				reject(result[1])
 386 | 			end
 387 | 		end)
 388 | 	end)
 389 | 
 390 | 	return promise
 391 | end
 392 | 
 393 | -- Backwards compatibility
 394 | Promise.async = Promise.defer
 395 | 
 396 | --[=[
 397 | 	Creates an immediately resolved Promise with the given value.
 398 | 
 399 | 	```lua
 400 | 	-- Example using Promise.resolve to deliver cached values:
 401 | 	function getSomething(name)
 402 | 		if cache[name] then
 403 | 			return Promise.resolve(cache[name])
 404 | 		else
 405 | 			return Promise.new(function(resolve, reject)
 406 | 				local thing = getTheThing()
 407 | 				cache[name] = thing
 408 | 
 409 | 				resolve(thing)
 410 | 			end)
 411 | 		end
 412 | 	end
 413 | 	```
 414 | 
 415 | 	@param ... any
 416 | 	@return Promise<...any>
 417 | ]=]
 418 | function Promise.resolve(...)
 419 | 	local length, values = pack(...)
 420 | 	return Promise._new(debug.traceback(nil, 2), function(resolve)
 421 | 		resolve(unpack(values, 1, length))
 422 | 	end)
 423 | end
 424 | 
 425 | --[=[
 426 | 	Creates an immediately rejected Promise with the given value.
 427 | 
 428 | 	:::caution
 429 | 	Something needs to consume this rejection (i.e. `:catch()` it), otherwise it will emit an unhandled Promise rejection warning on the next frame. Thus, you should not create and store rejected Promises for later use. Only create them on-demand as needed.
 430 | 	:::
 431 | 
 432 | 	@param ... any
 433 | 	@return Promise<...any>
 434 | ]=]
 435 | function Promise.reject(...)
 436 | 	local length, values = pack(...)
 437 | 	return Promise._new(debug.traceback(nil, 2), function(_, reject)
 438 | 		reject(unpack(values, 1, length))
 439 | 	end)
 440 | end
 441 | 
 442 | --[[
 443 | 	Runs a non-promise-returning function as a Promise with the
 444 |   given arguments.
 445 | ]]
 446 | function Promise._try(traceback, callback, ...)
 447 | 	local valuesLength, values = pack(...)
 448 | 
 449 | 	return Promise._new(traceback, function(resolve)
 450 | 		resolve(callback(unpack(values, 1, valuesLength)))
 451 | 	end)
 452 | end
 453 | 
 454 | --[=[
 455 | 	Begins a Promise chain, calling a function and returning a Promise resolving with its return value. If the function errors, the returned Promise will be rejected with the error. You can safely yield within the Promise.try callback.
 456 | 
 457 | 	:::info
 458 | 	`Promise.try` is similar to [Promise.promisify](#promisify), except the callback is invoked immediately instead of returning a new function.
 459 | 	:::
 460 | 
 461 | 	```lua
 462 | 	Promise.try(function()
 463 | 		return math.random(1, 2) == 1 and "ok" or error("Oh an error!")
 464 | 	end)
 465 | 		:andThen(function(text)
 466 | 			print(text)
 467 | 		end)
 468 | 		:catch(function(err)
 469 | 			warn("Something went wrong")
 470 | 		end)
 471 | 	```
 472 | 
 473 | 	@param callback (...: T...) -> ...any
 474 | 	@param ... T... -- Additional arguments passed to `callback`
 475 | 	@return Promise
 476 | ]=]
 477 | function Promise.try(callback, ...)
 478 | 	return Promise._try(debug.traceback(nil, 2), callback, ...)
 479 | end
 480 | 
 481 | --[[
 482 | 	Returns a new promise that:
 483 | 		* is resolved when all input promises resolve
 484 | 		* is rejected if ANY input promises reject
 485 | ]]
 486 | function Promise._all(traceback, promises, amount)
 487 | 	if type(promises) ~= "table" then
 488 | 		error(string.format(ERROR_NON_LIST, "Promise.all"), 3)
 489 | 	end
 490 | 
 491 | 	-- We need to check that each value is a promise here so that we can produce
 492 | 	-- a proper error rather than a rejected promise with our error.
 493 | 	for i, promise in pairs(promises) do
 494 | 		if not Promise.is(promise) then
 495 | 			error(string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.all", tostring(i)), 3)
 496 | 		end
 497 | 	end
 498 | 
 499 | 	-- If there are no values then return an already resolved promise.
 500 | 	if #promises == 0 or amount == 0 then
 501 | 		return Promise.resolve({})
 502 | 	end
 503 | 
 504 | 	return Promise._new(traceback, function(resolve, reject, onCancel)
 505 | 		-- An array to contain our resolved values from the given promises.
 506 | 		local resolvedValues = {}
 507 | 		local newPromises = {}
 508 | 
 509 | 		-- Keep a count of resolved promises because just checking the resolved
 510 | 		-- values length wouldn't account for promises that resolve with nil.
 511 | 		local resolvedCount = 0
 512 | 		local rejectedCount = 0
 513 | 		local done = false
 514 | 
 515 | 		local function cancel()
 516 | 			for _, promise in ipairs(newPromises) do
 517 | 				promise:cancel()
 518 | 			end
 519 | 		end
 520 | 
 521 | 		-- Called when a single value is resolved and resolves if all are done.
 522 | 		local function resolveOne(i, ...)
 523 | 			if done then
 524 | 				return
 525 | 			end
 526 | 
 527 | 			resolvedCount = resolvedCount + 1
 528 | 
 529 | 			if amount == nil then
 530 | 				resolvedValues[i] = ...
 531 | 			else
 532 | 				resolvedValues[resolvedCount] = ...
 533 | 			end
 534 | 
 535 | 			if resolvedCount >= (amount or #promises) then
 536 | 				done = true
 537 | 				resolve(resolvedValues)
 538 | 				cancel()
 539 | 			end
 540 | 		end
 541 | 
 542 | 		onCancel(cancel)
 543 | 
 544 | 		-- We can assume the values inside `promises` are all promises since we
 545 | 		-- checked above.
 546 | 		for i, promise in ipairs(promises) do
 547 | 			newPromises[i] = promise:andThen(function(...)
 548 | 				resolveOne(i, ...)
 549 | 			end, function(...)
 550 | 				rejectedCount = rejectedCount + 1
 551 | 
 552 | 				if amount == nil or #promises - rejectedCount < amount then
 553 | 					cancel()
 554 | 					done = true
 555 | 
 556 | 					reject(...)
 557 | 				end
 558 | 			end)
 559 | 		end
 560 | 
 561 | 		if done then
 562 | 			cancel()
 563 | 		end
 564 | 	end)
 565 | end
 566 | 
 567 | --[=[
 568 | 	Accepts an array of Promises and returns a new promise that:
 569 | 	* is resolved after all input promises resolve.
 570 | 	* is rejected if *any* input promises reject.
 571 | 
 572 | 	:::info
 573 | 	Only the first return value from each promise will be present in the resulting array.
 574 | 	:::
 575 | 
 576 | 	After any input Promise rejects, all other input Promises that are still pending will be cancelled if they have no other consumers.
 577 | 
 578 | 	```lua
 579 | 	local promises = {
 580 | 		returnsAPromise("example 1"),
 581 | 		returnsAPromise("example 2"),
 582 | 		returnsAPromise("example 3"),
 583 | 	}
 584 | 
 585 | 	return Promise.all(promises)
 586 | 	```
 587 | 
 588 | 	@param promises {Promise<T>}
 589 | 	@return Promise<{T}>
 590 | ]=]
 591 | function Promise.all(promises)
 592 | 	return Promise._all(debug.traceback(nil, 2), promises)
 593 | end
 594 | 
 595 | --[=[
 596 | 	Folds an array of values or promises into a single value. The array is traversed sequentially.
 597 | 
 598 | 	The reducer function can return a promise or value directly. Each iteration receives the resolved value from the previous, and the first receives your defined initial value.
 599 | 
 600 | 	The folding will stop at the first rejection encountered.
 601 | 	```lua
 602 | 	local basket = {"blueberry", "melon", "pear", "melon"}
 603 | 	Promise.fold(basket, function(cost, fruit)
 604 | 		if fruit == "blueberry" then
 605 | 			return cost -- blueberries are free!
 606 | 		else
 607 | 			-- call a function that returns a promise with the fruit price
 608 | 			return fetchPrice(fruit):andThen(function(fruitCost)
 609 | 				return cost + fruitCost
 610 | 			end)
 611 | 		end
 612 | 	end, 0)
 613 | 	```
 614 | 
 615 | 	@since v3.1.0
 616 | 	@param list {T | Promise<T>}
 617 | 	@param reducer (accumulator: U, value: T, index: number) -> U | Promise<U>
 618 | 	@param initialValue U
 619 | ]=]
 620 | function Promise.fold(list, reducer, initialValue)
 621 | 	assert(type(list) == "table", "Bad argument #1 to Promise.fold: must be a table")
 622 | 	assert(isCallable(reducer), "Bad argument #2 to Promise.fold: must be a function")
 623 | 
 624 | 	local accumulator = Promise.resolve(initialValue)
 625 | 	return Promise.each(list, function(resolvedElement, i)
 626 | 		accumulator = accumulator:andThen(function(previousValueResolved)
 627 | 			return reducer(previousValueResolved, resolvedElement, i)
 628 | 		end)
 629 | 	end):andThen(function()
 630 | 		return accumulator
 631 | 	end)
 632 | end
 633 | 
 634 | --[=[
 635 | 	Accepts an array of Promises and returns a Promise that is resolved as soon as `count` Promises are resolved from the input array. The resolved array values are in the order that the Promises resolved in. When this Promise resolves, all other pending Promises are cancelled if they have no other consumers.
 636 | 
 637 | 	`count` 0 results in an empty array. The resultant array will never have more than `count` elements.
 638 | 
 639 | 	```lua
 640 | 	local promises = {
 641 | 		returnsAPromise("example 1"),
 642 | 		returnsAPromise("example 2"),
 643 | 		returnsAPromise("example 3"),
 644 | 	}
 645 | 
 646 | 	return Promise.some(promises, 2) -- Only resolves with first 2 promises to resolve
 647 | 	```
 648 | 
 649 | 	@param promises {Promise<T>}
 650 | 	@param count number
 651 | 	@return Promise<{T}>
 652 | ]=]
 653 | function Promise.some(promises, count)
 654 | 	assert(type(count) == "number", "Bad argument #2 to Promise.some: must be a number")
 655 | 
 656 | 	return Promise._all(debug.traceback(nil, 2), promises, count)
 657 | end
 658 | 
 659 | --[=[
 660 | 	Accepts an array of Promises and returns a Promise that is resolved as soon as *any* of the input Promises resolves. It will reject only if *all* input Promises reject. As soon as one Promises resolves, all other pending Promises are cancelled if they have no other consumers.
 661 | 
 662 | 	Resolves directly with the value of the first resolved Promise. This is essentially [[Promise.some]] with `1` count, except the Promise resolves with the value directly instead of an array with one element.
 663 | 
 664 | 	```lua
 665 | 	local promises = {
 666 | 		returnsAPromise("example 1"),
 667 | 		returnsAPromise("example 2"),
 668 | 		returnsAPromise("example 3"),
 669 | 	}
 670 | 
 671 | 	return Promise.any(promises) -- Resolves with first value to resolve (only rejects if all 3 rejected)
 672 | 	```
 673 | 
 674 | 	@param promises {Promise<T>}
 675 | 	@return Promise<T>
 676 | ]=]
 677 | function Promise.any(promises)
 678 | 	return Promise._all(debug.traceback(nil, 2), promises, 1):andThen(function(values)
 679 | 		return values[1]
 680 | 	end)
 681 | end
 682 | 
 683 | --[=[
 684 | 	Accepts an array of Promises and returns a new Promise that resolves with an array of in-place Statuses when all input Promises have settled. This is equivalent to mapping `promise:finally` over the array of Promises.
 685 | 
 686 | 	```lua
 687 | 	local promises = {
 688 | 		returnsAPromise("example 1"),
 689 | 		returnsAPromise("example 2"),
 690 | 		returnsAPromise("example 3"),
 691 | 	}
 692 | 
 693 | 	return Promise.allSettled(promises)
 694 | 	```
 695 | 
 696 | 	@param promises {Promise<T>}
 697 | 	@return Promise<{Status}>
 698 | ]=]
 699 | function Promise.allSettled(promises)
 700 | 	if type(promises) ~= "table" then
 701 | 		error(string.format(ERROR_NON_LIST, "Promise.allSettled"), 2)
 702 | 	end
 703 | 
 704 | 	-- We need to check that each value is a promise here so that we can produce
 705 | 	-- a proper error rather than a rejected promise with our error.
 706 | 	for i, promise in pairs(promises) do
 707 | 		if not Promise.is(promise) then
 708 | 			error(string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.allSettled", tostring(i)), 2)
 709 | 		end
 710 | 	end
 711 | 
 712 | 	-- If there are no values then return an already resolved promise.
 713 | 	if #promises == 0 then
 714 | 		return Promise.resolve({})
 715 | 	end
 716 | 
 717 | 	return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
 718 | 		-- An array to contain our resolved values from the given promises.
 719 | 		local fates = {}
 720 | 		local newPromises = {}
 721 | 
 722 | 		-- Keep a count of resolved promises because just checking the resolved
 723 | 		-- values length wouldn't account for promises that resolve with nil.
 724 | 		local finishedCount = 0
 725 | 
 726 | 		-- Called when a single value is resolved and resolves if all are done.
 727 | 		local function resolveOne(i, ...)
 728 | 			finishedCount = finishedCount + 1
 729 | 
 730 | 			fates[i] = ...
 731 | 
 732 | 			if finishedCount >= #promises then
 733 | 				resolve(fates)
 734 | 			end
 735 | 		end
 736 | 
 737 | 		onCancel(function()
 738 | 			for _, promise in ipairs(newPromises) do
 739 | 				promise:cancel()
 740 | 			end
 741 | 		end)
 742 | 
 743 | 		-- We can assume the values inside `promises` are all promises since we
 744 | 		-- checked above.
 745 | 		for i, promise in ipairs(promises) do
 746 | 			newPromises[i] = promise:finally(function(...)
 747 | 				resolveOne(i, ...)
 748 | 			end)
 749 | 		end
 750 | 	end)
 751 | end
 752 | 
 753 | --[=[
 754 | 	Accepts an array of Promises and returns a new promise that is resolved or rejected as soon as any Promise in the array resolves or rejects.
 755 | 
 756 | 	:::warning
 757 | 	If the first Promise to settle from the array settles with a rejection, the resulting Promise from `race` will reject.
 758 | 
 759 | 	If you instead want to tolerate rejections, and only care about at least one Promise resolving, you should use [Promise.any](#any) or [Promise.some](#some) instead.
 760 | 	:::
 761 | 
 762 | 	All other Promises that don't win the race will be cancelled if they have no other consumers.
 763 | 
 764 | 	```lua
 765 | 	local promises = {
 766 | 		returnsAPromise("example 1"),
 767 | 		returnsAPromise("example 2"),
 768 | 		returnsAPromise("example 3"),
 769 | 	}
 770 | 
 771 | 	return Promise.race(promises) -- Only returns 1st value to resolve or reject
 772 | 	```
 773 | 
 774 | 	@param promises {Promise<T>}
 775 | 	@return Promise<T>
 776 | ]=]
 777 | function Promise.race(promises)
 778 | 	assert(type(promises) == "table", string.format(ERROR_NON_LIST, "Promise.race"))
 779 | 
 780 | 	for i, promise in pairs(promises) do
 781 | 		assert(Promise.is(promise), string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.race", tostring(i)))
 782 | 	end
 783 | 
 784 | 	return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)
 785 | 		local newPromises = {}
 786 | 		local finished = false
 787 | 
 788 | 		local function cancel()
 789 | 			for _, promise in ipairs(newPromises) do
 790 | 				promise:cancel()
 791 | 			end
 792 | 		end
 793 | 
 794 | 		local function finalize(callback)
 795 | 			return function(...)
 796 | 				cancel()
 797 | 				finished = true
 798 | 				return callback(...)
 799 | 			end
 800 | 		end
 801 | 
 802 | 		if onCancel(finalize(reject)) then
 803 | 			return
 804 | 		end
 805 | 
 806 | 		for i, promise in ipairs(promises) do
 807 | 			newPromises[i] = promise:andThen(finalize(resolve), finalize(reject))
 808 | 		end
 809 | 
 810 | 		if finished then
 811 | 			cancel()
 812 | 		end
 813 | 	end)
 814 | end
 815 | 
 816 | --[=[
 817 | 	Iterates serially over the given an array of values, calling the predicate callback on each value before continuing.
 818 | 
 819 | 	If the predicate returns a Promise, we wait for that Promise to resolve before moving on to the next item
 820 | 	in the array.
 821 | 
 822 | 	:::info
 823 | 	`Promise.each` is similar to `Promise.all`, except the Promises are ran in order instead of all at once.
 824 | 
 825 | 	But because Promises are eager, by the time they are created, they're already running. Thus, we need a way to defer creation of each Promise until a later time.
 826 | 
 827 | 	The predicate function exists as a way for us to operate on our data instead of creating a new closure for each Promise. If you would prefer, you can pass in an array of functions, and in the predicate, call the function and return its return value.
 828 | 	:::
 829 | 
 830 | 	```lua
 831 | 	Promise.each({
 832 | 		"foo",
 833 | 		"bar",
 834 | 		"baz",
 835 | 		"qux"
 836 | 	}, function(value, index)
 837 | 		return Promise.delay(1):andThen(function()
 838 | 		print(("%d) Got %s!"):format(index, value))
 839 | 		end)
 840 | 	end)
 841 | 
 842 | 	--[[
 843 | 		(1 second passes)
 844 | 		> 1) Got foo!
 845 | 		(1 second passes)
 846 | 		> 2) Got bar!
 847 | 		(1 second passes)
 848 | 		> 3) Got baz!
 849 | 		(1 second passes)
 850 | 		> 4) Got qux!
 851 | 	]]
 852 | 	```
 853 | 
 854 | 	If the Promise a predicate returns rejects, the Promise from `Promise.each` is also rejected with the same value.
 855 | 
 856 | 	If the array of values contains a Promise, when we get to that point in the list, we wait for the Promise to resolve before calling the predicate with the value.
 857 | 
 858 | 	If a Promise in the array of values is already Rejected when `Promise.each` is called, `Promise.each` rejects with that value immediately (the predicate callback will never be called even once). If a Promise in the list is already Cancelled when `Promise.each` is called, `Promise.each` rejects with `Promise.Error(Promise.Error.Kind.AlreadyCancelled`). If a Promise in the array of values is Started at first, but later rejects, `Promise.each` will reject with that value and iteration will not continue once iteration encounters that value.
 859 | 
 860 | 	Returns a Promise containing an array of the returned/resolved values from the predicate for each item in the array of values.
 861 | 
 862 | 	If this Promise returned from `Promise.each` rejects or is cancelled for any reason, the following are true:
 863 | 	- Iteration will not continue.
 864 | 	- Any Promises within the array of values will now be cancelled if they have no other consumers.
 865 | 	- The Promise returned from the currently active predicate will be cancelled if it hasn't resolved yet.
 866 | 
 867 | 	@since 3.0.0
 868 | 	@param list {T | Promise<T>}
 869 | 	@param predicate (value: T, index: number) -> U | Promise<U>
 870 | 	@return Promise<{U}>
 871 | ]=]
 872 | function Promise.each(list, predicate)
 873 | 	assert(type(list) == "table", string.format(ERROR_NON_LIST, "Promise.each"))
 874 | 	assert(isCallable(predicate), string.format(ERROR_NON_FUNCTION, "Promise.each"))
 875 | 
 876 | 	return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)
 877 | 		local results = {}
 878 | 		local promisesToCancel = {}
 879 | 
 880 | 		local cancelled = false
 881 | 
 882 | 		local function cancel()
 883 | 			for _, promiseToCancel in ipairs(promisesToCancel) do
 884 | 				promiseToCancel:cancel()
 885 | 			end
 886 | 		end
 887 | 
 888 | 		onCancel(function()
 889 | 			cancelled = true
 890 | 
 891 | 			cancel()
 892 | 		end)
 893 | 
 894 | 		-- We need to preprocess the list of values and look for Promises.
 895 | 		-- If we find some, we must register our andThen calls now, so that those Promises have a consumer
 896 | 		-- from us registered. If we don't do this, those Promises might get cancelled by something else
 897 | 		-- before we get to them in the series because it's not possible to tell that we plan to use it
 898 | 		-- unless we indicate it here.
 899 | 
 900 | 		local preprocessedList = {}
 901 | 
 902 | 		for index, value in ipairs(list) do
 903 | 			if Promise.is(value) then
 904 | 				if value:getStatus() == Promise.Status.Cancelled then
 905 | 					cancel()
 906 | 					return reject(Error.new({
 907 | 						error = "Promise is cancelled",
 908 | 						kind = Error.Kind.AlreadyCancelled,
 909 | 						context = string.format(
 910 | 							"The Promise that was part of the array at index %d passed into Promise.each was already cancelled when Promise.each began.\n\nThat Promise was created at:\n\n%s",
 911 | 							index,
 912 | 							value._source
 913 | 						),
 914 | 					}))
 915 | 				elseif value:getStatus() == Promise.Status.Rejected then
 916 | 					cancel()
 917 | 					return reject(select(2, value:await()))
 918 | 				end
 919 | 
 920 | 				-- Chain a new Promise from this one so we only cancel ours
 921 | 				local ourPromise = value:andThen(function(...)
 922 | 					return ...
 923 | 				end)
 924 | 
 925 | 				table.insert(promisesToCancel, ourPromise)
 926 | 				preprocessedList[index] = ourPromise
 927 | 			else
 928 | 				preprocessedList[index] = value
 929 | 			end
 930 | 		end
 931 | 
 932 | 		for index, value in ipairs(preprocessedList) do
 933 | 			if Promise.is(value) then
 934 | 				local success
 935 | 				success, value = value:await()
 936 | 
 937 | 				if not success then
 938 | 					cancel()
 939 | 					return reject(value)
 940 | 				end
 941 | 			end
 942 | 
 943 | 			if cancelled then
 944 | 				return
 945 | 			end
 946 | 
 947 | 			local predicatePromise = Promise.resolve(predicate(value, index))
 948 | 
 949 | 			table.insert(promisesToCancel, predicatePromise)
 950 | 
 951 | 			local success, result = predicatePromise:await()
 952 | 
 953 | 			if not success then
 954 | 				cancel()
 955 | 				return reject(result)
 956 | 			end
 957 | 
 958 | 			results[index] = result
 959 | 		end
 960 | 
 961 | 		resolve(results)
 962 | 	end)
 963 | end
 964 | 
 965 | --[=[
 966 | 	Checks whether the given object is a Promise via duck typing. This only checks if the object is a table and has an `andThen` method.
 967 | 
 968 | 	@param object any
 969 | 	@return boolean -- `true` if the given `object` is a Promise.
 970 | ]=]
 971 | function Promise.is(object)
 972 | 	if type(object) ~= "table" then
 973 | 		return false
 974 | 	end
 975 | 
 976 | 	local objectMetatable = getmetatable(object)
 977 | 
 978 | 	if objectMetatable == Promise then
 979 | 		-- The Promise came from this library.
 980 | 		return true
 981 | 	elseif objectMetatable == nil then
 982 | 		-- No metatable, but we should still chain onto tables with andThen methods
 983 | 		return isCallable(object.andThen)
 984 | 	elseif
 985 | 		type(objectMetatable) == "table"
 986 | 		and type(rawget(objectMetatable, "__index")) == "table"
 987 | 		and isCallable(rawget(rawget(objectMetatable, "__index"), "andThen"))
 988 | 	then
 989 | 		-- Maybe this came from a different or older Promise library.
 990 | 		return true
 991 | 	end
 992 | 
 993 | 	return false
 994 | end
 995 | 
 996 | --[=[
 997 | 	Wraps a function that yields into one that returns a Promise.
 998 | 
 999 | 	Any errors that occur while executing the function will be turned into rejections.
1000 | 
1001 | 	:::info
1002 | 	`Promise.promisify` is similar to [Promise.try](#try), except the callback is returned as a callable function instead of being invoked immediately.
1003 | 	:::
1004 | 
1005 | 	```lua
1006 | 	local sleep = Promise.promisify(wait)
1007 | 
1008 | 	sleep(1):andThen(print)
1009 | 	```
1010 | 
1011 | 	```lua
1012 | 	local isPlayerInGroup = Promise.promisify(function(player, groupId)
1013 | 		return player:IsInGroup(groupId)
1014 | 	end)
1015 | 	```
1016 | 
1017 | 	@param callback (...: any) -> ...any
1018 | 	@return (...: any) -> Promise
1019 | ]=]
1020 | function Promise.promisify(callback)
1021 | 	return function(...)
1022 | 		return Promise._try(debug.traceback(nil, 2), callback, ...)
1023 | 	end
1024 | end
1025 | 
1026 | --[=[
1027 | 	Returns a Promise that resolves after `seconds` seconds have passed. The Promise resolves with the actual amount of time that was waited.
1028 | 
1029 | 	This function is **not** a wrapper around `wait`. `Promise.delay` uses a custom scheduler which provides more accurate timing. As an optimization, cancelling this Promise instantly removes the task from the scheduler.
1030 | 
1031 | 	:::warning
1032 | 	Passing `NaN`, infinity, or a number less than 1/60 is equivalent to passing 1/60.
1033 | 	:::
1034 | 
1035 | 	```lua
1036 | 		Promise.delay(5):andThenCall(print, "This prints after 5 seconds")
1037 | 	```
1038 | 
1039 | 	@function delay
1040 | 	@within Promise
1041 | 	@param seconds number
1042 | 	@return Promise<number>
1043 | ]=]
1044 | do
1045 | 	-- uses a sorted doubly linked list (queue) to achieve O(1) remove operations and O(n) for insert
1046 | 
1047 | 	-- the initial node in the linked list
1048 | 	local first
1049 | 	local connection
1050 | 
1051 | 	function Promise.delay(seconds)
1052 | 		assert(type(seconds) == "number", "Bad argument #1 to Promise.delay, must be a number.")
1053 | 		-- If seconds is -INF, INF, NaN, or less than 1 / 60, assume seconds is 1 / 60.
1054 | 		-- This mirrors the behavior of wait()
1055 | 		if not (seconds >= 1 / 60) or seconds == math.huge then
1056 | 			seconds = 1 / 60
1057 | 		end
1058 | 
1059 | 		return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
1060 | 			local startTime = Promise._getTime()
1061 | 			local endTime = startTime + seconds
1062 | 
1063 | 			local node = {
1064 | 				resolve = resolve,
1065 | 				startTime = startTime,
1066 | 				endTime = endTime,
1067 | 			}
1068 | 
1069 | 			if connection == nil then -- first is nil when connection is nil
1070 | 				first = node
1071 | 				connection = Promise._timeEvent:Connect(function()
1072 | 					local threadStart = Promise._getTime()
1073 | 
1074 | 					while first ~= nil and first.endTime < threadStart do
1075 | 						local current = first
1076 | 						first = current.next
1077 | 
1078 | 						if first == nil then
1079 | 							connection:Disconnect()
1080 | 							connection = nil
1081 | 						else
1082 | 							first.previous = nil
1083 | 						end
1084 | 
1085 | 						current.resolve(Promise._getTime() - current.startTime)
1086 | 					end
1087 | 				end)
1088 | 			else -- first is non-nil
1089 | 				if first.endTime < endTime then -- if `node` should be placed after `first`
1090 | 					-- we will insert `node` between `current` and `next`
1091 | 					-- (i.e. after `current` if `next` is nil)
1092 | 					local current = first
1093 | 					local next = current.next
1094 | 
1095 | 					while next ~= nil and next.endTime < endTime do
1096 | 						current = next
1097 | 						next = current.next
1098 | 					end
1099 | 
1100 | 					-- `current` must be non-nil, but `next` could be `nil` (i.e. last item in list)
1101 | 					current.next = node
1102 | 					node.previous = current
1103 | 
1104 | 					if next ~= nil then
1105 | 						node.next = next
1106 | 						next.previous = node
1107 | 					end
1108 | 				else
1109 | 					-- set `node` to `first`
1110 | 					node.next = first
1111 | 					first.previous = node
1112 | 					first = node
1113 | 				end
1114 | 			end
1115 | 
1116 | 			onCancel(function()
1117 | 				-- remove node from queue
1118 | 				local next = node.next
1119 | 
1120 | 				if first == node then
1121 | 					if next == nil then -- if `node` is the first and last
1122 | 						connection:Disconnect()
1123 | 						connection = nil
1124 | 					else -- if `node` is `first` and not the last
1125 | 						next.previous = nil
1126 | 					end
1127 | 					first = next
1128 | 				else
1129 | 					local previous = node.previous
1130 | 					-- since `node` is not `first`, then we know `previous` is non-nil
1131 | 					previous.next = next
1132 | 
1133 | 					if next ~= nil then
1134 | 						next.previous = previous
1135 | 					end
1136 | 				end
1137 | 			end)
1138 | 		end)
1139 | 	end
1140 | end
1141 | 
1142 | --[=[
1143 | 	Returns a new Promise that resolves if the chained Promise resolves within `seconds` seconds, or rejects if execution time exceeds `seconds`. The chained Promise will be cancelled if the timeout is reached.
1144 | 
1145 | 	Rejects with `rejectionValue` if it is non-nil. If a `rejectionValue` is not given, it will reject with a `Promise.Error(Promise.Error.Kind.TimedOut)`. This can be checked with [[Error.isKind]].
1146 | 
1147 | 	```lua
1148 | 	getSomething():timeout(5):andThen(function(something)
1149 | 		-- got something and it only took at max 5 seconds
1150 | 	end):catch(function(e)
1151 | 		-- Either getting something failed or the time was exceeded.
1152 | 
1153 | 		if Promise.Error.isKind(e, Promise.Error.Kind.TimedOut) then
1154 | 			warn("Operation timed out!")
1155 | 		else
1156 | 			warn("Operation encountered an error!")
1157 | 		end
1158 | 	end)
1159 | 	```
1160 | 
1161 | 	Sugar for:
1162 | 
1163 | 	```lua
1164 | 	Promise.race({
1165 | 		Promise.delay(seconds):andThen(function()
1166 | 			return Promise.reject(
1167 | 				rejectionValue == nil
1168 | 				and Promise.Error.new({ kind = Promise.Error.Kind.TimedOut })
1169 | 				or rejectionValue
1170 | 			)
1171 | 		end),
1172 | 		promise
1173 | 	})
1174 | 	```
1175 | 
1176 | 	@param seconds number
1177 | 	@param rejectionValue? any -- The value to reject with if the timeout is reached
1178 | 	@return Promise
1179 | ]=]
1180 | function Promise.prototype:timeout(seconds, rejectionValue)
1181 | 	local traceback = debug.traceback(nil, 2)
1182 | 
1183 | 	return Promise.race({
1184 | 		Promise.delay(seconds):andThen(function()
1185 | 			return Promise.reject(rejectionValue == nil and Error.new({
1186 | 				kind = Error.Kind.TimedOut,
1187 | 				error = "Timed out",
1188 | 				context = string.format(
1189 | 					"Timeout of %d seconds exceeded.\n:timeout() called at:\n\n%s",
1190 | 					seconds,
1191 | 					traceback
1192 | 				),
1193 | 			}) or rejectionValue)
1194 | 		end),
1195 | 		self,
1196 | 	})
1197 | end
1198 | 
1199 | --[=[
1200 | 	Returns the current Promise status.
1201 | 
1202 | 	@return Status
1203 | ]=]
1204 | function Promise.prototype:getStatus()
1205 | 	return self._status
1206 | end
1207 | 
1208 | --[[
1209 | 	Creates a new promise that receives the result of this promise.
1210 | 
1211 | 	The given callbacks are invoked depending on that result.
1212 | ]]
1213 | function Promise.prototype:_andThen(traceback, successHandler, failureHandler)
1214 | 	self._unhandledRejection = false
1215 | 
1216 | 	-- If we are already cancelled, we return a cancelled Promise
1217 | 	if self._status == Promise.Status.Cancelled then
1218 | 		local promise = Promise.new(function() end)
1219 | 		promise:cancel()
1220 | 
1221 | 		return promise
1222 | 	end
1223 | 
1224 | 	-- Create a new promise to follow this part of the chain
1225 | 	return Promise._new(traceback, function(resolve, reject, onCancel)
1226 | 		-- Our default callbacks just pass values onto the next promise.
1227 | 		-- This lets success and failure cascade correctly!
1228 | 
1229 | 		local successCallback = resolve
1230 | 		if successHandler then
1231 | 			successCallback = createAdvancer(traceback, successHandler, resolve, reject)
1232 | 		end
1233 | 
1234 | 		local failureCallback = reject
1235 | 		if failureHandler then
1236 | 			failureCallback = createAdvancer(traceback, failureHandler, resolve, reject)
1237 | 		end
1238 | 
1239 | 		if self._status == Promise.Status.Started then
1240 | 			-- If we haven't resolved yet, put ourselves into the queue
1241 | 			table.insert(self._queuedResolve, successCallback)
1242 | 			table.insert(self._queuedReject, failureCallback)
1243 | 
1244 | 			onCancel(function()
1245 | 				-- These are guaranteed to exist because the cancellation handler is guaranteed to only
1246 | 				-- be called at most once
1247 | 				if self._status == Promise.Status.Started then
1248 | 					table.remove(self._queuedResolve, table.find(self._queuedResolve, successCallback))
1249 | 					table.remove(self._queuedReject, table.find(self._queuedReject, failureCallback))
1250 | 				end
1251 | 			end)
1252 | 		elseif self._status == Promise.Status.Resolved then
1253 | 			-- This promise has already resolved! Trigger success immediately.
1254 | 			successCallback(unpack(self._values, 1, self._valuesLength))
1255 | 		elseif self._status == Promise.Status.Rejected then
1256 | 			-- This promise died a terrible death! Trigger failure immediately.
1257 | 			failureCallback(unpack(self._values, 1, self._valuesLength))
1258 | 		end
1259 | 	end, self)
1260 | end
1261 | 
1262 | --[=[
1263 | 	Chains onto an existing Promise and returns a new Promise.
1264 | 
1265 | 	:::warning
1266 | 	Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [[Error]] objects. If you want to treat it as a string for debugging, you should call `tostring` on it first.
1267 | 	:::
1268 | 
1269 | 	You can return a Promise from the success or failure handler and it will be chained onto.
1270 | 
1271 | 	Calling `andThen` on a cancelled Promise returns a cancelled Promise.
1272 | 
1273 | 	:::tip
1274 | 	If the Promise returned by `andThen` is cancelled, `successHandler` and `failureHandler` will not run.
1275 | 
1276 | 	To run code no matter what, use [Promise:finally].
1277 | 	:::
1278 | 
1279 | 	@param successHandler (...: any) -> ...any
1280 | 	@param failureHandler? (...: any) -> ...any
1281 | 	@return Promise<...any>
1282 | ]=]
1283 | function Promise.prototype:andThen(successHandler, failureHandler)
1284 | 	assert(successHandler == nil or isCallable(successHandler), string.format(ERROR_NON_FUNCTION, "Promise:andThen"))
1285 | 	assert(failureHandler == nil or isCallable(failureHandler), string.format(ERROR_NON_FUNCTION, "Promise:andThen"))
1286 | 
1287 | 	return self:_andThen(debug.traceback(nil, 2), successHandler, failureHandler)
1288 | end
1289 | 
1290 | --[=[
1291 | 	Shorthand for `Promise:andThen(nil, failureHandler)`.
1292 | 
1293 | 	Returns a Promise that resolves if the `failureHandler` worked without encountering an additional error.
1294 | 
1295 | 	:::warning
1296 | 	Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [[Error]] objects. If you want to treat it as a string for debugging, you should call `tostring` on it first.
1297 | 	:::
1298 | 
1299 | 	Calling `catch` on a cancelled Promise returns a cancelled Promise.
1300 | 
1301 | 	:::tip
1302 | 	If the Promise returned by `catch` is cancelled,  `failureHandler` will not run.
1303 | 
1304 | 	To run code no matter what, use [Promise:finally].
1305 | 	:::
1306 | 
1307 | 	@param failureHandler (...: any) -> ...any
1308 | 	@return Promise<...any>
1309 | ]=]
1310 | function Promise.prototype:catch(failureHandler)
1311 | 	assert(failureHandler == nil or isCallable(failureHandler), string.format(ERROR_NON_FUNCTION, "Promise:catch"))
1312 | 	return self:_andThen(debug.traceback(nil, 2), nil, failureHandler)
1313 | end
1314 | 
1315 | --[=[
1316 | 	Similar to [Promise.andThen](#andThen), except the return value is the same as the value passed to the handler. In other words, you can insert a `:tap` into a Promise chain without affecting the value that downstream Promises receive.
1317 | 
1318 | 	```lua
1319 | 		getTheValue()
1320 | 		:tap(print)
1321 | 		:andThen(function(theValue)
1322 | 			print("Got", theValue, "even though print returns nil!")
1323 | 		end)
1324 | 	```
1325 | 
1326 | 	If you return a Promise from the tap handler callback, its value will be discarded but `tap` will still wait until it resolves before passing the original value through.
1327 | 
1328 | 	@param tapHandler (...: any) -> ...any
1329 | 	@return Promise<...any>
1330 | ]=]
1331 | function Promise.prototype:tap(tapHandler)
1332 | 	assert(isCallable(tapHandler), string.format(ERROR_NON_FUNCTION, "Promise:tap"))
1333 | 	return self:_andThen(debug.traceback(nil, 2), function(...)
1334 | 		local callbackReturn = tapHandler(...)
1335 | 
1336 | 		if Promise.is(callbackReturn) then
1337 | 			local length, values = pack(...)
1338 | 			return callbackReturn:andThen(function()
1339 | 				return unpack(values, 1, length)
1340 | 			end)
1341 | 		end
1342 | 
1343 | 		return ...
1344 | 	end)
1345 | end
1346 | 
1347 | --[=[
1348 | 	Attaches an `andThen` handler to this Promise that calls the given callback with the predefined arguments. The resolved value is discarded.
1349 | 
1350 | 	```lua
1351 | 		promise:andThenCall(someFunction, "some", "arguments")
1352 | 	```
1353 | 
1354 | 	This is sugar for
1355 | 
1356 | 	```lua
1357 | 		promise:andThen(function()
1358 | 		return someFunction("some", "arguments")
1359 | 		end)
1360 | 	```
1361 | 
1362 | 	@param callback (...: any) -> any
1363 | 	@param ...? any -- Additional arguments which will be passed to `callback`
1364 | 	@return Promise
1365 | ]=]
1366 | function Promise.prototype:andThenCall(callback, ...)
1367 | 	assert(isCallable(callback), string.format(ERROR_NON_FUNCTION, "Promise:andThenCall"))
1368 | 	local length, values = pack(...)
1369 | 	return self:_andThen(debug.traceback(nil, 2), function()
1370 | 		return callback(unpack(values, 1, length))
1371 | 	end)
1372 | end
1373 | 
1374 | --[=[
1375 | 	Attaches an `andThen` handler to this Promise that discards the resolved value and returns the given value from it.
1376 | 
1377 | 	```lua
1378 | 		promise:andThenReturn("some", "values")
1379 | 	```
1380 | 
1381 | 	This is sugar for
1382 | 
1383 | 	```lua
1384 | 		promise:andThen(function()
1385 | 			return "some", "values"
1386 | 		end)
1387 | 	```
1388 | 
1389 | 	:::caution
1390 | 	Promises are eager, so if you pass a Promise to `andThenReturn`, it will begin executing before `andThenReturn` is reached in the chain. Likewise, if you pass a Promise created from [[Promise.reject]] into `andThenReturn`, it's possible that this will trigger the unhandled rejection warning. If you need to return a Promise, it's usually best practice to use [[Promise.andThen]].
1391 | 	:::
1392 | 
1393 | 	@param ... any -- Values to return from the function
1394 | 	@return Promise
1395 | ]=]
1396 | function Promise.prototype:andThenReturn(...)
1397 | 	local length, values = pack(...)
1398 | 	return self:_andThen(debug.traceback(nil, 2), function()
1399 | 		return unpack(values, 1, length)
1400 | 	end)
1401 | end
1402 | 
1403 | --[=[
1404 | 	Cancels this promise, preventing the promise from resolving or rejecting. Does not do anything if the promise is already settled.
1405 | 
1406 | 	Cancellations will propagate upwards and downwards through chained promises.
1407 | 
1408 | 	Promises will only be cancelled if all of their consumers are also cancelled. This is to say that if you call `andThen` twice on the same promise, and you cancel only one of the child promises, it will not cancel the parent promise until the other child promise is also cancelled.
1409 | 
1410 | 	```lua
1411 | 		promise:cancel()
1412 | 	```
1413 | ]=]
1414 | function Promise.prototype:cancel()
1415 | 	if self._status ~= Promise.Status.Started then
1416 | 		return
1417 | 	end
1418 | 
1419 | 	self._status = Promise.Status.Cancelled
1420 | 
1421 | 	if self._cancellationHook then
1422 | 		self._cancellationHook()
1423 | 	end
1424 | 
1425 | 	coroutine.close(self._thread)
1426 | 
1427 | 	if self._parent then
1428 | 		self._parent:_consumerCancelled(self)
1429 | 	end
1430 | 
1431 | 	for child in pairs(self._consumers) do
1432 | 		child:cancel()
1433 | 	end
1434 | 
1435 | 	self:_finalize()
1436 | end
1437 | 
1438 | --[[
1439 | 	Used to decrease the number of consumers by 1, and if there are no more,
1440 | 	cancel this promise.
1441 | ]]
1442 | function Promise.prototype:_consumerCancelled(consumer)
1443 | 	if self._status ~= Promise.Status.Started then
1444 | 		return
1445 | 	end
1446 | 
1447 | 	self._consumers[consumer] = nil
1448 | 
1449 | 	if next(self._consumers) == nil then
1450 | 		self:cancel()
1451 | 	end
1452 | end
1453 | 
1454 | --[[
1455 | 	Used to set a handler for when the promise resolves, rejects, or is
1456 | 	cancelled.
1457 | ]]
1458 | function Promise.prototype:_finally(traceback, finallyHandler)
1459 | 	self._unhandledRejection = false
1460 | 
1461 | 	local promise = Promise._new(traceback, function(resolve, reject, onCancel)
1462 | 		local handlerPromise
1463 | 
1464 | 		onCancel(function()
1465 | 			-- The finally Promise is not a proper consumer of self. We don't care about the resolved value.
1466 | 			-- All we care about is running at the end. Therefore, if self has no other consumers, it's safe to
1467 | 			-- cancel. We don't need to hold out cancelling just because there's a finally handler.
1468 | 			self:_consumerCancelled(self)
1469 | 
1470 | 			if handlerPromise then
1471 | 				handlerPromise:cancel()
1472 | 			end
1473 | 		end)
1474 | 
1475 | 		local finallyCallback = resolve
1476 | 		if finallyHandler then
1477 | 			finallyCallback = function(...)
1478 | 				local callbackReturn = finallyHandler(...)
1479 | 
1480 | 				if Promise.is(callbackReturn) then
1481 | 					handlerPromise = callbackReturn
1482 | 
1483 | 					callbackReturn
1484 | 						:finally(function(status)
1485 | 							if status ~= Promise.Status.Rejected then
1486 | 								resolve(self)
1487 | 							end
1488 | 						end)
1489 | 						:catch(function(...)
1490 | 							reject(...)
1491 | 						end)
1492 | 				else
1493 | 					resolve(self)
1494 | 				end
1495 | 			end
1496 | 		end
1497 | 
1498 | 		if self._status == Promise.Status.Started then
1499 | 			-- The promise is not settled, so queue this.
1500 | 			table.insert(self._queuedFinally, finallyCallback)
1501 | 		else
1502 | 			-- The promise already settled or was cancelled, run the callback now.
1503 | 			finallyCallback(self._status)
1504 | 		end
1505 | 	end)
1506 | 
1507 | 	return promise
1508 | end
1509 | 
1510 | --[=[
1511 | 	Set a handler that will be called regardless of the promise's fate. The handler is called when the promise is
1512 | 	resolved, rejected, *or* cancelled.
1513 | 
1514 | 	Returns a new Promise that:
1515 | 	- resolves with the same values that this Promise resolves with.
1516 | 	- rejects with the same values that this Promise rejects with.
1517 | 	- is cancelled if this Promise is cancelled.
1518 | 
1519 | 	If the value you return from the handler is a Promise:
1520 | 	- We wait for the Promise to resolve, but we ultimately discard the resolved value.
1521 | 	- If the returned Promise rejects, the Promise returned from `finally` will reject with the rejected value from the
1522 | 	*returned* promise.
1523 | 	- If the `finally` Promise is cancelled, and you returned a Promise from the handler, we cancel that Promise too.
1524 | 
1525 | 	Otherwise, the return value from the `finally` handler is entirely discarded.
1526 | 
1527 | 	:::note Cancellation
1528 | 	As of Promise v4, `Promise:finally` does not count as a consumer of the parent Promise for cancellation purposes.
1529 | 	This means that if all of a Promise's consumers are cancelled and the only remaining callbacks are finally handlers,
1530 | 	the Promise is cancelled and the finally callbacks run then and there.
1531 | 
1532 | 	Cancellation still propagates through the `finally` Promise though: if you cancel the `finally` Promise, it can cancel
1533 | 	its parent Promise if it had no other consumers. Likewise, if the parent Promise is cancelled, the `finally` Promise
1534 | 	will also be cancelled.
1535 | 	:::
1536 | 
1537 | 	```lua
1538 | 	local thing = createSomething()
1539 | 
1540 | 	doSomethingWith(thing)
1541 | 		:andThen(function()
1542 | 			print("It worked!")
1543 | 			-- do something..
1544 | 		end)
1545 | 		:catch(function()
1546 | 			warn("Oh no it failed!")
1547 | 		end)
1548 | 		:finally(function()
1549 | 			-- either way, destroy thing
1550 | 
1551 | 			thing:Destroy()
1552 | 		end)
1553 | 
1554 | 	```
1555 | 
1556 | 	@param finallyHandler (status: Status) -> ...any
1557 | 	@return Promise<...any>
1558 | ]=]
1559 | function Promise.prototype:finally(finallyHandler)
1560 | 	assert(finallyHandler == nil or isCallable(finallyHandler), string.format(ERROR_NON_FUNCTION, "Promise:finally"))
1561 | 	return self:_finally(debug.traceback(nil, 2), finallyHandler)
1562 | end
1563 | 
1564 | --[=[
1565 | 	Same as `andThenCall`, except for `finally`.
1566 | 
1567 | 	Attaches a `finally` handler to this Promise that calls the given callback with the predefined arguments.
1568 | 
1569 | 	@param callback (...: any) -> any
1570 | 	@param ...? any -- Additional arguments which will be passed to `callback`
1571 | 	@return Promise
1572 | ]=]
1573 | function Promise.prototype:finallyCall(callback, ...)
1574 | 	assert(isCallable(callback), string.format(ERROR_NON_FUNCTION, "Promise:finallyCall"))
1575 | 	local length, values = pack(...)
1576 | 	return self:_finally(debug.traceback(nil, 2), function()
1577 | 		return callback(unpack(values, 1, length))
1578 | 	end)
1579 | end
1580 | 
1581 | --[=[
1582 | 	Attaches a `finally` handler to this Promise that discards the resolved value and returns the given value from it.
1583 | 
1584 | 	```lua
1585 | 		promise:finallyReturn("some", "values")
1586 | 	```
1587 | 
1588 | 	This is sugar for
1589 | 
1590 | 	```lua
1591 | 		promise:finally(function()
1592 | 			return "some", "values"
1593 | 		end)
1594 | 	```
1595 | 
1596 | 	@param ... any -- Values to return from the function
1597 | 	@return Promise
1598 | ]=]
1599 | function Promise.prototype:finallyReturn(...)
1600 | 	local length, values = pack(...)
1601 | 	return self:_finally(debug.traceback(nil, 2), function()
1602 | 		return unpack(values, 1, length)
1603 | 	end)
1604 | end
1605 | 
1606 | --[=[
1607 | 	Yields the current thread until the given Promise completes. Returns the Promise's status, followed by the values that the promise resolved or rejected with.
1608 | 
1609 | 	@yields
1610 | 	@return Status -- The Status representing the fate of the Promise
1611 | 	@return ...any -- The values the Promise resolved or rejected with.
1612 | ]=]
1613 | function Promise.prototype:awaitStatus()
1614 | 	self._unhandledRejection = false
1615 | 
1616 | 	if self._status == Promise.Status.Started then
1617 | 		local thread = coroutine.running()
1618 | 
1619 | 		self
1620 | 			:finally(function()
1621 | 				task.spawn(thread)
1622 | 			end)
1623 | 			-- The finally promise can propagate rejections, so we attach a catch handler to prevent the unhandled
1624 | 			-- rejection warning from appearing
1625 | 			:catch(
1626 | 				function() end
1627 | 			)
1628 | 
1629 | 		coroutine.yield()
1630 | 	end
1631 | 
1632 | 	if self._status == Promise.Status.Resolved then
1633 | 		return self._status, unpack(self._values, 1, self._valuesLength)
1634 | 	elseif self._status == Promise.Status.Rejected then
1635 | 		return self._status, unpack(self._values, 1, self._valuesLength)
1636 | 	end
1637 | 
1638 | 	return self._status
1639 | end
1640 | 
1641 | local function awaitHelper(status, ...)
1642 | 	return status == Promise.Status.Resolved, ...
1643 | end
1644 | 
1645 | --[=[
1646 | 	Yields the current thread until the given Promise completes. Returns true if the Promise resolved, followed by the values that the promise resolved or rejected with.
1647 | 
1648 | 	:::caution
1649 | 	If the Promise gets cancelled, this function will return `false`, which is indistinguishable from a rejection. If you need to differentiate, you should use [[Promise.awaitStatus]] instead.
1650 | 	:::
1651 | 
1652 | 	```lua
1653 | 		local worked, value = getTheValue():await()
1654 | 
1655 | 	if worked then
1656 | 		print("got", value)
1657 | 	else
1658 | 		warn("it failed")
1659 | 	end
1660 | 	```
1661 | 
1662 | 	@yields
1663 | 	@return boolean -- `true` if the Promise successfully resolved
1664 | 	@return ...any -- The values the Promise resolved or rejected with.
1665 | ]=]
1666 | function Promise.prototype:await()
1667 | 	return awaitHelper(self:awaitStatus())
1668 | end
1669 | 
1670 | local function expectHelper(status, ...)
1671 | 	if status ~= Promise.Status.Resolved then
1672 | 		error((...) == nil and "Expected Promise rejected with no value." or (...), 3)
1673 | 	end
1674 | 
1675 | 	return ...
1676 | end
1677 | 
1678 | --[=[
1679 | 	Yields the current thread until the given Promise completes. Returns the values that the promise resolved with.
1680 | 
1681 | 	```lua
1682 | 	local worked = pcall(function()
1683 | 		print("got", getTheValue():expect())
1684 | 	end)
1685 | 
1686 | 	if not worked then
1687 | 		warn("it failed")
1688 | 	end
1689 | 	```
1690 | 
1691 | 	This is essentially sugar for:
1692 | 
1693 | 	```lua
1694 | 	select(2, assert(promise:await()))
1695 | 	```
1696 | 
1697 | 	**Errors** if the Promise rejects or gets cancelled.
1698 | 
1699 | 	@error any -- Errors with the rejection value if this Promise rejects or gets cancelled.
1700 | 	@yields
1701 | 	@return ...any -- The values the Promise resolved with.
1702 | ]=]
1703 | function Promise.prototype:expect()
1704 | 	return expectHelper(self:awaitStatus())
1705 | end
1706 | 
1707 | -- Backwards compatibility
1708 | Promise.prototype.awaitValue = Promise.prototype.expect
1709 | 
1710 | --[[
1711 | 	Intended for use in tests.
1712 | 
1713 | 	Similar to await(), but instead of yielding if the promise is unresolved,
1714 | 	_unwrap will throw. This indicates an assumption that a promise has
1715 | 	resolved.
1716 | ]]
1717 | function Promise.prototype:_unwrap()
1718 | 	if self._status == Promise.Status.Started then
1719 | 		error("Promise has not resolved or rejected.", 2)
1720 | 	end
1721 | 
1722 | 	local success = self._status == Promise.Status.Resolved
1723 | 
1724 | 	return success, unpack(self._values, 1, self._valuesLength)
1725 | end
1726 | 
1727 | function Promise.prototype:_resolve(...)
1728 | 	if self._status ~= Promise.Status.Started then
1729 | 		if Promise.is((...)) then
1730 | 			(...):_consumerCancelled(self)
1731 | 		end
1732 | 		return
1733 | 	end
1734 | 
1735 | 	-- If the resolved value was a Promise, we chain onto it!
1736 | 	if Promise.is((...)) then
1737 | 		-- Without this warning, arguments sometimes mysteriously disappear
1738 | 		if select("#", ...) > 1 then
1739 | 			local message = string.format(
1740 | 				"When returning a Promise from andThen, extra arguments are " .. "discarded! See:\n\n%s",
1741 | 				self._source
1742 | 			)
1743 | 			warn(message)
1744 | 		end
1745 | 
1746 | 		local chainedPromise = ...
1747 | 
1748 | 		local promise = chainedPromise:andThen(function(...)
1749 | 			self:_resolve(...)
1750 | 		end, function(...)
1751 | 			local maybeRuntimeError = chainedPromise._values[1]
1752 | 
1753 | 			-- Backwards compatibility < v2
1754 | 			if chainedPromise._error then
1755 | 				maybeRuntimeError = Error.new({
1756 | 					error = chainedPromise._error,
1757 | 					kind = Error.Kind.ExecutionError,
1758 | 					context = "[No stack trace available as this Promise originated from an older version of the Promise library (< v2)]",
1759 | 				})
1760 | 			end
1761 | 
1762 | 			if Error.isKind(maybeRuntimeError, Error.Kind.ExecutionError) then
1763 | 				return self:_reject(maybeRuntimeError:extend({
1764 | 					error = "This Promise was chained to a Promise that errored.",
1765 | 					trace = "",
1766 | 					context = string.format(
1767 | 						"The Promise at:\n\n%s\n...Rejected because it was chained to the following Promise, which encountered an error:\n",
1768 | 						self._source
1769 | 					),
1770 | 				}))
1771 | 			end
1772 | 
1773 | 			self:_reject(...)
1774 | 		end)
1775 | 
1776 | 		if promise._status == Promise.Status.Cancelled then
1777 | 			self:cancel()
1778 | 		elseif promise._status == Promise.Status.Started then
1779 | 			-- Adopt ourselves into promise for cancellation propagation.
1780 | 			self._parent = promise
1781 | 			promise._consumers[self] = true
1782 | 		end
1783 | 
1784 | 		return
1785 | 	end
1786 | 
1787 | 	self._status = Promise.Status.Resolved
1788 | 	self._valuesLength, self._values = pack(...)
1789 | 
1790 | 	-- We assume that these callbacks will not throw errors.
1791 | 	for _, callback in ipairs(self._queuedResolve) do
1792 | 		coroutine.wrap(callback)(...)
1793 | 	end
1794 | 
1795 | 	self:_finalize()
1796 | end
1797 | 
1798 | function Promise.prototype:_reject(...)
1799 | 	if self._status ~= Promise.Status.Started then
1800 | 		return
1801 | 	end
1802 | 
1803 | 	self._status = Promise.Status.Rejected
1804 | 	self._valuesLength, self._values = pack(...)
1805 | 
1806 | 	-- If there are any rejection handlers, call those!
1807 | 	if not isEmpty(self._queuedReject) then
1808 | 		-- We assume that these callbacks will not throw errors.
1809 | 		for _, callback in ipairs(self._queuedReject) do
1810 | 			coroutine.wrap(callback)(...)
1811 | 		end
1812 | 	else
1813 | 		-- At this point, no one was able to observe the error.
1814 | 		-- An error handler might still be attached if the error occurred
1815 | 		-- synchronously. We'll wait one tick, and if there are still no
1816 | 		-- observers, then we should put a message in the console.
1817 | 
1818 | 		local err = tostring((...))
1819 | 
1820 | 		coroutine.wrap(function()
1821 | 			Promise._timeEvent:Wait()
1822 | 
1823 | 			-- Someone observed the error, hooray!
1824 | 			if not self._unhandledRejection then
1825 | 				return
1826 | 			end
1827 | 
1828 | 			-- Build a reasonable message
1829 | 			local message = string.format("Unhandled Promise rejection:\n\n%s\n\n%s", err, self._source)
1830 | 
1831 | 			for _, callback in ipairs(Promise._unhandledRejectionCallbacks) do
1832 | 				task.spawn(callback, self, unpack(self._values, 1, self._valuesLength))
1833 | 			end
1834 | 
1835 | 			if Promise.TEST then
1836 | 				-- Don't spam output when we're running tests.
1837 | 				return
1838 | 			end
1839 | 
1840 | 			warn(message)
1841 | 		end)()
1842 | 	end
1843 | 
1844 | 	self:_finalize()
1845 | end
1846 | 
1847 | --[[
1848 | 	Calls any :finally handlers. We need this to be a separate method and
1849 | 	queue because we must call all of the finally callbacks upon a success,
1850 | 	failure, *and* cancellation.
1851 | ]]
1852 | function Promise.prototype:_finalize()
1853 | 	for _, callback in ipairs(self._queuedFinally) do
1854 | 		-- Purposefully not passing values to callbacks here, as it could be the
1855 | 		-- resolved values, or rejected errors. If the developer needs the values,
1856 | 		-- they should use :andThen or :catch explicitly.
1857 | 		coroutine.wrap(callback)(self._status)
1858 | 	end
1859 | 
1860 | 	self._queuedFinally = nil
1861 | 	self._queuedReject = nil
1862 | 	self._queuedResolve = nil
1863 | 
1864 | 	-- Clear references to other Promises to allow gc
1865 | 	if not Promise.TEST then
1866 | 		self._parent = nil
1867 | 		self._consumers = nil
1868 | 	end
1869 | 
1870 | 	task.defer(coroutine.close, self._thread)
1871 | end
1872 | 
1873 | --[=[
1874 | 	Chains a Promise from this one that is resolved if this Promise is already resolved, and rejected if it is not resolved at the time of calling `:now()`. This can be used to ensure your `andThen` handler occurs on the same frame as the root Promise execution.
1875 | 
1876 | 	```lua
1877 | 	doSomething()
1878 | 		:now()
1879 | 		:andThen(function(value)
1880 | 			print("Got", value, "synchronously.")
1881 | 		end)
1882 | 	```
1883 | 
1884 | 	If this Promise is still running, Rejected, or Cancelled, the Promise returned from `:now()` will reject with the `rejectionValue` if passed, otherwise with a `Promise.Error(Promise.Error.Kind.NotResolvedInTime)`. This can be checked with [[Error.isKind]].
1885 | 
1886 | 	@param rejectionValue? any -- The value to reject with if the Promise isn't resolved
1887 | 	@return Promise
1888 | ]=]
1889 | function Promise.prototype:now(rejectionValue)
1890 | 	local traceback = debug.traceback(nil, 2)
1891 | 	if self._status == Promise.Status.Resolved then
1892 | 		return self:_andThen(traceback, function(...)
1893 | 			return ...
1894 | 		end)
1895 | 	else
1896 | 		return Promise.reject(rejectionValue == nil and Error.new({
1897 | 			kind = Error.Kind.NotResolvedInTime,
1898 | 			error = "This Promise was not resolved in time for :now()",
1899 | 			context = ":now() was called at:\n\n" .. traceback,
1900 | 		}) or rejectionValue)
1901 | 	end
1902 | end
1903 | 
1904 | --[=[
1905 | 	Repeatedly calls a Promise-returning function up to `times` number of times, until the returned Promise resolves.
1906 | 
1907 | 	If the amount of retries is exceeded, the function will return the latest rejected Promise.
1908 | 
1909 | 	```lua
1910 | 	local function canFail(a, b, c)
1911 | 		return Promise.new(function(resolve, reject)
1912 | 			-- do something that can fail
1913 | 
1914 | 			local failed, thing = doSomethingThatCanFail(a, b, c)
1915 | 
1916 | 			if failed then
1917 | 				reject("it failed")
1918 | 			else
1919 | 				resolve(thing)
1920 | 			end
1921 | 		end)
1922 | 	end
1923 | 
1924 | 	local MAX_RETRIES = 10
1925 | 	local value = Promise.retry(canFail, MAX_RETRIES, "foo", "bar", "baz") -- args to send to canFail
1926 | 	```
1927 | 
1928 | 	@since 3.0.0
1929 | 	@param callback (...: P) -> Promise<T>
1930 | 	@param times number
1931 | 	@param ...? P
1932 | 	@return Promise<T>
1933 | ]=]
1934 | function Promise.retry(callback, times, ...)
1935 | 	assert(isCallable(callback), "Parameter #1 to Promise.retry must be a function")
1936 | 	assert(type(times) == "number", "Parameter #2 to Promise.retry must be a number")
1937 | 
1938 | 	local args, length = { ... }, select("#", ...)
1939 | 
1940 | 	return Promise.resolve(callback(...)):catch(function(...)
1941 | 		if times > 0 then
1942 | 			return Promise.retry(callback, times - 1, unpack(args, 1, length))
1943 | 		else
1944 | 			return Promise.reject(...)
1945 | 		end
1946 | 	end)
1947 | end
1948 | 
1949 | --[=[
1950 | 	Repeatedly calls a Promise-returning function up to `times` number of times, waiting `seconds` seconds between each
1951 | 	retry, until the returned Promise resolves.
1952 | 
1953 | 	If the amount of retries is exceeded, the function will return the latest rejected Promise.
1954 | 
1955 | 	@since v3.2.0
1956 | 	@param callback (...: P) -> Promise<T>
1957 | 	@param times number
1958 | 	@param seconds number
1959 | 	@param ...? P
1960 | 	@return Promise<T>
1961 | ]=]
1962 | function Promise.retryWithDelay(callback, times, seconds, ...)
1963 | 	assert(isCallable(callback), "Parameter #1 to Promise.retry must be a function")
1964 | 	assert(type(times) == "number", "Parameter #2 (times) to Promise.retry must be a number")
1965 | 	assert(type(seconds) == "number", "Parameter #3 (seconds) to Promise.retry must be a number")
1966 | 
1967 | 	local args, length = { ... }, select("#", ...)
1968 | 
1969 | 	return Promise.resolve(callback(...)):catch(function(...)
1970 | 		if times > 0 then
1971 | 			Promise.delay(seconds):await()
1972 | 
1973 | 			return Promise.retryWithDelay(callback, times - 1, seconds, unpack(args, 1, length))
1974 | 		else
1975 | 			return Promise.reject(...)
1976 | 		end
1977 | 	end)
1978 | end
1979 | 
1980 | --[=[
1981 | 	Converts an event into a Promise which resolves the next time the event fires.
1982 | 
1983 | 	The optional `predicate` callback, if passed, will receive the event arguments and should return `true` or `false`, based on if this fired event should resolve the Promise or not. If `true`, the Promise resolves. If `false`, nothing happens and the predicate will be rerun the next time the event fires.
1984 | 
1985 | 	The Promise will resolve with the event arguments.
1986 | 
1987 | 	:::tip
1988 | 	This function will work given any object with a `Connect` method. This includes all Roblox events.
1989 | 	:::
1990 | 
1991 | 	```lua
1992 | 	-- Creates a Promise which only resolves when `somePart` is touched
1993 | 	-- by a part named `"Something specific"`.
1994 | 	return Promise.fromEvent(somePart.Touched, function(part)
1995 | 		return part.Name == "Something specific"
1996 | 	end)
1997 | 	```
1998 | 
1999 | 	@since 3.0.0
2000 | 	@param event Event -- Any object with a `Connect` method. This includes all Roblox events.
2001 | 	@param predicate? (...: P) -> boolean -- A function which determines if the Promise should resolve with the given value, or wait for the next event to check again.
2002 | 	@return Promise<P>
2003 | ]=]
2004 | function Promise.fromEvent(event, predicate)
2005 | 	predicate = predicate or function()
2006 | 		return true
2007 | 	end
2008 | 
2009 | 	return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
2010 | 		local connection
2011 | 		local shouldDisconnect = false
2012 | 
2013 | 		local function disconnect()
2014 | 			connection:Disconnect()
2015 | 			connection = nil
2016 | 		end
2017 | 
2018 | 		-- We use shouldDisconnect because if the callback given to Connect is called before
2019 | 		-- Connect returns, connection will still be nil. This happens with events that queue up
2020 | 		-- events when there's nothing connected, such as RemoteEvents
2021 | 
2022 | 		connection = event:Connect(function(...)
2023 | 			local callbackValue = predicate(...)
2024 | 
2025 | 			if callbackValue == true then
2026 | 				resolve(...)
2027 | 
2028 | 				if connection then
2029 | 					disconnect()
2030 | 				else
2031 | 					shouldDisconnect = true
2032 | 				end
2033 | 			elseif type(callbackValue) ~= "boolean" then
2034 | 				error("Promise.fromEvent predicate should always return a boolean")
2035 | 			end
2036 | 		end)
2037 | 
2038 | 		if shouldDisconnect and connection then
2039 | 			return disconnect()
2040 | 		end
2041 | 
2042 | 		onCancel(disconnect)
2043 | 	end)
2044 | end
2045 | 
2046 | --[=[
2047 | 	Registers a callback that runs when an unhandled rejection happens. An unhandled rejection happens when a Promise
2048 | 	is rejected, and the rejection is not observed with `:catch`.
2049 | 
2050 | 	The callback is called with the actual promise that rejected, followed by the rejection values.
2051 | 
2052 | 	@since v3.2.0
2053 | 	@param callback (promise: Promise, ...: any) -- A callback that runs when an unhandled rejection happens.
2054 | 	@return () -> () -- Function that unregisters the `callback` when called
2055 | ]=]
2056 | function Promise.onUnhandledRejection(callback)
2057 | 	table.insert(Promise._unhandledRejectionCallbacks, callback)
2058 | 
2059 | 	return function()
2060 | 		local index = table.find(Promise._unhandledRejectionCallbacks, callback)
2061 | 
2062 | 		if index then
2063 | 			table.remove(Promise._unhandledRejectionCallbacks, index)
2064 | 		end
2065 | 	end
2066 | end
2067 | 
2068 | return Promise
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/init.lua`
<details>
<summary>View Source (0 lines)</summary>

```lua
   1 | return require((...) .. ".lib")
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/assign.lua`
<details>
<summary>View Source (16 lines)</summary>

```lua
   1 | --[[
   2 | 	An implementation of JavaScript's Object.assign
   3 | ]]
   4 | 
   5 | return function(target, ...)
   6 | 	for i = 1, select("#", ...) do
   7 | 		local source = select(i, ...)
   8 | 
   9 | 		if source ~= nil then
  10 | 			for key, value in pairs(source) do
  11 | 				target[key] = value
  12 | 			end
  13 | 		end
  14 | 	end
  15 | 
  16 | 	return target
  17 | end
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/baste.lua`
<details>
<summary>View Source (331 lines)</summary>

```lua
   1 | -- luacheck: ignore
   2 | 
   3 | --[[
   4 | 	Baste, a module system for Lua
   5 | 	Version 1.2.0-dev
   6 | 
   7 | 	MIT License
   8 | 
   9 | 	Copyright (c) 2017 Lucien Greathouse
  10 | 
  11 | 	Permission is hereby granted, free of charge, to any person obtaining a copy
  12 | 	of this software and associated documentation files (the "Software"), to deal
  13 | 	in the Software without restriction, including without limitation the rights
  14 | 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  15 | 	copies of the Software, and to permit persons to whom the Software is
  16 | 	furnished to do so, subject to the following conditions:
  17 | 
  18 | 	The above copyright notice and this permission notice shall be included in all
  19 | 	copies or substantial portions of the Software.
  20 | 
  21 | 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  22 | 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  23 | 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  24 | 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  25 | 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  26 | 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  27 | 	SOFTWARE.
  28 | ]]
  29 | 
  30 | local baste = {}
  31 | 
  32 | local function componentsFromPathString(input)
  33 | 	local components = {}
  34 | 	local sliceStart = 1
  35 | 	local sliceEnd = 0
  36 | 
  37 | 	for i = 1, #input do
  38 | 		local char = input:sub(i, i)
  39 | 
  40 | 		if char == "/" or char == "\\" then
  41 | 			if sliceEnd ~= 0 then
  42 | 				local slice = input:sub(sliceStart, sliceEnd)
  43 | 
  44 | 				if slice == ".." then
  45 | 					local lastComponent = components[#components]
  46 | 
  47 | 					if lastComponent ~= nil and lastComponent ~= ".." then
  48 | 						table.remove(components)
  49 | 					else
  50 | 						table.insert(components, slice)
  51 | 					end
  52 | 				elseif slice ~= "." then
  53 | 					table.insert(components, slice)
  54 | 				end
  55 | 			end
  56 | 
  57 | 			sliceStart = i + 1
  58 | 			sliceEnd = 0
  59 | 		else
  60 | 			sliceEnd = i
  61 | 		end
  62 | 	end
  63 | 
  64 | 	if sliceEnd ~= 0 then
  65 | 		local slice = input:sub(sliceStart, sliceEnd)
  66 | 		table.insert(components, slice)
  67 | 	end
  68 | 
  69 | 	return components
  70 | end
  71 | 
  72 | local Path = {}
  73 | Path.prototype = {}
  74 | Path.__index = Path.prototype
  75 | 
  76 | function Path.fromString(input)
  77 | 	if type(input) ~= "string" then
  78 | 		error("Path.fromString expects a string, but got " .. type(input), 2)
  79 | 	end
  80 | 
  81 | 	local isAbsolute = input:sub(1, 1) == "/"
  82 | 
  83 | 	local path = {
  84 | 		isAbsolute = isAbsolute,
  85 | 		components = componentsFromPathString(input),
  86 | 	}
  87 | 
  88 | 	setmetatable(path, Path)
  89 | 
  90 | 	return path
  91 | end
  92 | 
  93 | function Path:__tostring()
  94 | 	if self.__stringRepresentation ~= nil then
  95 | 		return self.__stringRepresentation
  96 | 	end
  97 | 
  98 | 	local output = table.concat(self.components, "/")
  99 | 
 100 | 	if self.isAbsolute then
 101 | 		output = "/" .. output
 102 | 	end
 103 | 
 104 | 	self.__stringRepresentation = output
 105 | 
 106 | 	return output
 107 | end
 108 | 
 109 | function Path.prototype:getExtension()
 110 | 	local lastComponent = self.components[#self.components]
 111 | 
 112 | 	if lastComponent == nil then
 113 | 		return nil
 114 | 	end
 115 | 
 116 | 	-- TODO: Handle files that start with a dot?
 117 | 
 118 | 	return lastComponent:match("%.[^.]+")
 119 | end
 120 | 
 121 | function Path.prototype:clone()
 122 | 	local components = {}
 123 | 
 124 | 	for _, component in ipairs(self.components) do
 125 | 		table.insert(components, component)
 126 | 	end
 127 | 
 128 | 	local newPath = {
 129 | 		isAbsolute = self.isAbsolute,
 130 | 		components = components,
 131 | 	}
 132 | 
 133 | 	setmetatable(newPath, getmetatable(self))
 134 | 
 135 | 	return newPath
 136 | end
 137 | 
 138 | function Path.prototype:push(input)
 139 | 	self = self:clone()
 140 | 
 141 | 	local newComponents = componentsFromPathString(input)
 142 | 
 143 | 	for _, component in ipairs(newComponents) do
 144 | 		if component == ".." then
 145 | 			if #self.components > 0 then
 146 | 				table.remove(self.components)
 147 | 			else
 148 | 				table.insert(self.components, component)
 149 | 			end
 150 | 		elseif component ~= "." then
 151 | 			table.insert(self.components, component)
 152 | 		end
 153 | 	end
 154 | 
 155 | 	return self
 156 | end
 157 | 
 158 | function Path.prototype:pop()
 159 | 	self = self:clone()
 160 | 	table.remove(self.components)
 161 | 
 162 | 	return self
 163 | end
 164 | 
 165 | function Path.prototype:addExtension(extension)
 166 | 	self = self:clone()
 167 | 	self.components[#self.components] = self.components[#self.components] .. extension
 168 | 
 169 | 	return self
 170 | end
 171 | 
 172 | baste._Path = Path
 173 | 
 174 | -- Abstraction over loadstring and load
 175 | local loadWithEnv
 176 | if setfenv then
 177 | 	-- 5.1, LuaJIT
 178 | 	loadWithEnv = function(source, name, env)
 179 | 		local chunk, err = loadstring(source, name)
 180 | 
 181 | 		if not chunk then
 182 | 			return nil, err
 183 | 		end
 184 | 
 185 | 		if env then
 186 | 			setfenv(chunk, env)
 187 | 		end
 188 | 
 189 | 		return chunk
 190 | 	end
 191 | else
 192 | 	-- 5.2+
 193 | 	loadWithEnv = function(source, name, env)
 194 | 		return load(source, name, "bt", env)
 195 | 	end
 196 | end
 197 | 
 198 | -- Abstraction over filesystem APIs
 199 | local function readFile(path)
 200 | 	local handle, err = io.open(path, "r")
 201 | 
 202 | 	if not handle then
 203 | 		return nil, err
 204 | 	end
 205 | 
 206 | 	local contents = handle:read("*all")
 207 | 	handle:close()
 208 | 
 209 | 	return contents
 210 | end
 211 | 
 212 | if love then
 213 | 	local oldReadFile = readFile
 214 | 
 215 | 	readFile = function(path)
 216 | 		local contents = love.filesystem.read(path)
 217 | 
 218 | 		-- It could still exist outside the sandbox!
 219 | 		if not contents then
 220 | 			return oldReadFile(path)
 221 | 		end
 222 | 
 223 | 		return contents
 224 | 	end
 225 | end
 226 | 
 227 | local loadedModules = {}
 228 | local moduleResults = {}
 229 | 
 230 | --[[
 231 | 	Because of tail-call optimization, trying to get the file location of a
 232 | 	chunk whose contents are just a return statement fails.
 233 | 
 234 | 	Using an 'import function factory' solves thie problem by injecting the
 235 | 	file's path into the generated function. This also reduces the number of
 236 | 	debug library calls.
 237 | ]]
 238 | local function makeImport(rootPath)
 239 | 	return function(modulePath)
 240 | 		local currentPath = rootPath
 241 | 
 242 | 		if currentPath == nil then
 243 | 			currentPath = Path.fromString(debug.getinfo(2, "S").source:gsub("^@", ""))
 244 | 		end
 245 | 
 246 | 		if type(modulePath) ~= "string" then
 247 | 			local message = "Bad argument #1 to import, expected string but got %s"
 248 | 			error(string.format(message, type(modulePath)), 2)
 249 | 		end
 250 | 
 251 | 		-- Relative import!
 252 | 		if modulePath:sub(1, 1) == "." then
 253 | 			local currentDirectory = currentPath:pop()
 254 | 			local relativeModulePath = currentDirectory:push(modulePath)
 255 | 
 256 | 			local pathsToTry = {relativeModulePath}
 257 | 
 258 | 			if Path.fromString(modulePath):getExtension() == nil then
 259 | 				table.insert(pathsToTry, relativeModulePath:addExtension(".lua"))
 260 | 				table.insert(pathsToTry, relativeModulePath:push("init.lua"))
 261 | 			end
 262 | 
 263 | 			-- TODO: Plug-in point for adding additional paths to try
 264 | 
 265 | 			-- Have we loaded this module before?
 266 | 			for _, path in ipairs(pathsToTry) do
 267 | 				if loadedModules[tostring(path)] then
 268 | 					return moduleResults[tostring(path)]
 269 | 				end
 270 | 			end
 271 | 
 272 | 			-- Let's try to load from these paths!
 273 | 			for _, path in ipairs(pathsToTry) do
 274 | 				-- Hand-craft an environment for the module we're loading
 275 | 				-- The module won't be able to iterate over globals!
 276 | 				local env = setmetatable({
 277 | 					import = makeImport(path),
 278 | 				}, {
 279 | 					__index = _G,
 280 | 					__newindex = _G,
 281 | 				})
 282 | 
 283 | 				-- TODO: Plug-in point for adding extra loaders
 284 | 
 285 | 				local source = readFile(tostring(path))
 286 | 
 287 | 				if source then
 288 | 					local chunk, err = loadWithEnv(source, "@" .. tostring(path), env)
 289 | 
 290 | 					if chunk then
 291 | 						local result = chunk()
 292 | 						loadedModules[tostring(path)] = true
 293 | 						moduleResults[tostring(path)] = result
 294 | 
 295 | 						return result
 296 | 					else
 297 | 						-- Syntax error!
 298 | 						error(err, 2)
 299 | 					end
 300 | 				end
 301 | 			end
 302 | 
 303 | 			local pathsToTryAsStrings = {}
 304 | 
 305 | 			for _, path in ipairs(pathsToTry) do
 306 | 				table.insert(pathsToTryAsStrings, tostring(path))
 307 | 			end
 308 | 
 309 | 			-- We didn't find any modules.
 310 | 			local message = string.format("Couldn't import %q from file %s, tried:\n\t%s",
 311 | 				modulePath,
 312 | 				tostring(currentPath),
 313 | 				table.concat(pathsToTryAsStrings, "\n\t")
 314 | 			)
 315 | 
 316 | 			error(message, 2)
 317 | 		else
 318 | 			-- TODO: check `baste_modules` folder (or similar)
 319 | 			return require(modulePath)
 320 | 		end
 321 | 	end
 322 | end
 323 | 
 324 | baste.import = makeImport()
 325 | 
 326 | function baste.global()
 327 | 	_G.import = baste.import
 328 | 
 329 | 	return baste
 330 | end
 331 | 
 332 | return baste
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/createEnum.lua`
<details>
<summary>View Source (58 lines)</summary>

```lua
   1 | local typeKey = import("./typeKey")
   2 | 
   3 | local function createEnumVariant(enum, variantName, variantValue)
   4 | 	local enumVariant = newproxy(true)
   5 | 
   6 | 	local internal = {
   7 | 		Value = variantValue,
   8 | 		Name = variantName,
   9 | 		EnumType = enum,
  10 | 	}
  11 | 
  12 | 	getmetatable(enumVariant)[typeKey] = "EnumItem"
  13 | 
  14 | 	getmetatable(enumVariant).__tostring = function()
  15 | 		return ("Enum.%s.%s"):format(tostring(enum), variantName)
  16 | 	end
  17 | 
  18 | 	getmetatable(enumVariant).__index = function(self, key)
  19 | 		local value = internal[key]
  20 | 
  21 | 		if value == nil then
  22 | 			error(("%s is not a valid member"):format(tostring(key)), 2)
  23 | 		end
  24 | 
  25 | 		return value
  26 | 	end
  27 | 
  28 | 	return enumVariant
  29 | end
  30 | 
  31 | local function createEnum(enumName, variantValues)
  32 | 	local enum = newproxy(true)
  33 | 
  34 | 	local variants = {}
  35 | 
  36 | 	for variantName, value in pairs(variantValues) do
  37 | 		variants[variantName] = createEnumVariant(enum, variantName, value)
  38 | 	end
  39 | 
  40 | 	getmetatable(enum)[typeKey] = "Enum"
  41 | 
  42 | 	getmetatable(enum).__tostring = function()
  43 | 		return enumName
  44 | 	end
  45 | 
  46 | 	getmetatable(enum).__index = function(self, key)
  47 | 		local variant = variants[key]
  48 | 
  49 | 		if variant == nil then
  50 | 			error(("%s is not a valid EnumItem"):format(tostring(key)), 2)
  51 | 		end
  52 | 
  53 | 		return variant
  54 | 	end
  55 | 
  56 | 	return enum
  57 | end
  58 | 
  59 | return createEnum
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/createEnum_spec.lua`
<details>
<summary>View Source (54 lines)</summary>

```lua
   1 | local createEnum = import("./createEnum")
   2 | local typeof = import("./functions/typeof")
   3 | 
   4 | describe("createEnum", function()
   5 | 	it("should stringify as the input name", function()
   6 | 		local enum = createEnum("Foo", {})
   7 | 
   8 | 		assert.equal(tostring(enum), "Foo")
   9 | 	end)
  10 | 
  11 | 	it("should have typeof 'Enum'", function()
  12 | 		local enum = createEnum("Bar", {})
  13 | 
  14 | 		assert.equal(typeof(enum), "Enum")
  15 | 	end)
  16 | 
  17 | 	it("should have members for each input", function()
  18 | 		local values = {
  19 | 			a = 1,
  20 | 			b = 2,
  21 | 		}
  22 | 
  23 | 		local enum = createEnum("Bar", values)
  24 | 
  25 | 		for name, value in pairs(values) do
  26 | 			local enumValue = enum[name]
  27 | 
  28 | 			assert.equal(typeof(enumValue), "EnumItem")
  29 | 			assert.equal(tostring(enumValue), string.format("Enum.Bar.%s", name))
  30 | 			assert.equal(enumValue.Value, value)
  31 | 			assert.equal(enumValue.Name, name)
  32 | 			assert.equal(enumValue.EnumType, enum)
  33 | 		end
  34 | 	end)
  35 | 
  36 | 	it("should throw when accessing invalid members", function()
  37 | 		local enum = createEnum("Frobulon", {})
  38 | 
  39 | 		assert.has.errors(function()
  40 | 			tostring(enum.whatever)
  41 | 		end)
  42 | 	end)
  43 | 
  44 | 	it("should throw when accessing invalid members of an enum variant", function()
  45 | 		local enum = createEnum("Mungulation", {
  46 | 			foo = 5,
  47 | 		})
  48 | 
  49 | 		local variant = enum.foo
  50 | 
  51 | 		assert.has.errors(function()
  52 | 			tostring(variant.something)
  53 | 		end)
  54 | 	end)
  55 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/createEnumGroup.lua`
<details>
<summary>View Source (33 lines)</summary>

```lua
   1 | local typeKey = import("./typeKey")
   2 | local typeof = import("./functions/typeof")
   3 | 
   4 | local function createEnumGroup(enums)
   5 | 	for enumName, enum in pairs(enums) do
   6 | 		if typeof(enum) ~= "Enum" then
   7 | 			error(("Invalid enum in enum group %s"):format(tostring(enumName)), 2)
   8 | 		end
   9 | 	end
  10 | 
  11 | 	local enumGroup = newproxy(true)
  12 | 
  13 | 	getmetatable(enumGroup)[typeKey] = "Enums"
  14 | 
  15 | 	getmetatable(enumGroup).__tostring = function()
  16 | 		return "Enums"
  17 | 	end
  18 | 
  19 | 	getmetatable(enumGroup).__index = function(self, key)
  20 | 		local enum = enums[key]
  21 | 
  22 | 		if enum == nil then
  23 | 			-- Roblox mistakenly says that we tried to access an EnumItem; this
  24 | 			-- message is corrected.
  25 | 			error(("%s is not a valid Enum"):format(tostring(key)), 2)
  26 | 		end
  27 | 
  28 | 		return enum
  29 | 	end
  30 | 
  31 | 	return enumGroup
  32 | end
  33 | 
  34 | return createEnumGroup
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/createEnumGroup_spec.lua`
<details>
<summary>View Source (42 lines)</summary>

```lua
   1 | local typeof = import("./functions/typeof")
   2 | local createEnum = import("./createEnum")
   3 | 
   4 | local createEnumGroup = import("./createEnumGroup")
   5 | 
   6 | describe("createEnumGroup", function()
   7 | 	it("should stringify as 'Enums'", function()
   8 | 		local group = createEnumGroup({})
   9 | 
  10 | 		assert.equal(tostring(group), "Enums")
  11 | 	end)
  12 | 
  13 | 	it("should have type 'Enums'", function()
  14 | 		local group = createEnumGroup({})
  15 | 
  16 | 		assert.equal(typeof(group), "Enums")
  17 | 	end)
  18 | 
  19 | 	it("should contain all input enums", function()
  20 | 		local Foo = createEnum("Foo", {})
  21 | 		local group = createEnumGroup({
  22 | 			Foo = Foo,
  23 | 		})
  24 | 
  25 | 		assert.equal(group.Foo, Foo)
  26 | 	end)
  27 | 
  28 | 	it("should throw when passing non-enum values in", function()
  29 | 		assert.has.errors(function()
  30 | 			createEnumGroup({
  31 | 				something = {},
  32 | 			})
  33 | 		end)
  34 | 	end)
  35 | 
  36 | 	it("should throw when indexing with unknown keys", function()
  37 | 		local group = createEnumGroup({})
  38 | 
  39 | 		assert.has.errors(function()
  40 | 			tostring(group.whatever)
  41 | 		end)
  42 | 	end)
  43 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/createEnvironment.lua`
<details>
<summary>View Source (55 lines)</summary>

```lua
   1 | local createSettings = import("./createSettings")
   2 | local functions = import("./functions")
   3 | local libs = import("./libs")
   4 | local taskFunctions = import("./taskFunctions")
   5 | local types = import("./types")
   6 | local Enum = import("./Enum")
   7 | local Instance = import("./Instance")
   8 | 
   9 | local baseEnvironment = {}
  10 | 
  11 | for key, value in pairs(_G) do
  12 | 	baseEnvironment[key] = value
  13 | end
  14 | 
  15 | for key, value in pairs(types) do
  16 | 	baseEnvironment[key] = value
  17 | end
  18 | 
  19 | for key, lib in pairs(libs) do
  20 | 	baseEnvironment[key] = lib
  21 | end
  22 | 
  23 | baseEnvironment.Instance = Instance
  24 | baseEnvironment.Enum = Enum
  25 | baseEnvironment.__LEMUR__ = true
  26 | 
  27 | --[[
  28 | 	Create a new script environment, suitable for use with the given habitat.
  29 | ]]
  30 | local function createEnvironment(habitat)
  31 | 	local environment = {}
  32 | 
  33 | 	for key, value in pairs(baseEnvironment) do
  34 | 		environment[key] = value
  35 | 	end
  36 | 
  37 | 	for key, fn in pairs(functions) do
  38 | 		environment[key] = fn
  39 | 	end
  40 | 
  41 | 	for key, fnCreator in pairs(taskFunctions) do
  42 | 		environment[key] = fnCreator(habitat.taskScheduler)
  43 | 	end
  44 | 
  45 | 	environment.settings = createSettings(habitat.settings)
  46 | 
  47 | 	environment.require = function(path)
  48 | 		return habitat:require(path)
  49 | 	end
  50 | 
  51 | 	environment.game = habitat.game
  52 | 
  53 | 	return environment
  54 | end
  55 | 
  56 | return createEnvironment
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/createSettings.lua`
<details>
<summary>View Source (68 lines)</summary>

```lua
   1 | --[[
   2 | 	This file creates the settings() method.
   3 | 	Since settings implements the GetFFlag method, we need to pass fast flags
   4 | 	from a Habitat instance.
   5 | ]]
   6 | local assign = import("./assign")
   7 | local RenderSettings = import("./functions/settings/RenderSettings")
   8 | 
   9 | local Settings = {}
  10 | 
  11 | setmetatable(Settings, {
  12 | 	__tostring = function()
  13 | 		return "Settings"
  14 | 	end,
  15 | })
  16 | 
  17 | local prototype = {}
  18 | 
  19 | --[[
  20 | 	GetFFlag will throw on missing fast flags if ignoreMissingFFlags setting is false/nil
  21 | ]]
  22 | function prototype:GetFFlag(name)
  23 | 	if self.settings.flags[name] == nil then
  24 | 		error(string.format("Fast flag %s does not exist", name), 2)
  25 | 	end
  26 | 
  27 | 	return self.settings.flags[name]
  28 | end
  29 | 
  30 | local metatable = {}
  31 | metatable.type = Settings
  32 | 
  33 | function metatable:__index(key)
  34 | 	local internal = getmetatable(self).internal
  35 | 
  36 | 	if internal[key] ~= nil then
  37 | 		return internal[key]
  38 | 	end
  39 | 
  40 | 	if prototype[key] ~= nil then
  41 | 		return prototype[key]
  42 | 	end
  43 | 
  44 | 	error(string.format("%s is not a valid member of Settings", tostring(key)), 2)
  45 | end
  46 | 
  47 | function Settings.new(settings)
  48 | 	local internalInstance = {
  49 | 		settings = settings or {},
  50 | 		Rendering = RenderSettings.new()
  51 | 	}
  52 | 
  53 | 	internalInstance.settings.flags = internalInstance.settings.flags or {}
  54 | 
  55 | 	local instance = newproxy(true)
  56 | 
  57 | 	assign(getmetatable(instance), metatable)
  58 | 	getmetatable(instance).internal = internalInstance
  59 | 
  60 | 	return instance
  61 | end
  62 | 
  63 | return function(settings)
  64 | 	local instance = Settings.new(settings)
  65 | 	return function()
  66 | 		return instance
  67 | 	end
  68 | end
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/createSettings_spec.lua`
<details>
<summary>View Source (91 lines)</summary>

```lua
   1 | local createSettings = import("./createSettings")
   2 | local typeof = import("./functions/typeof")
   3 | 
   4 | describe("functions.settings", function()
   5 | 	it("should be a function", function()
   6 | 		assert.is_function(createSettings)
   7 | 	end)
   8 | 
   9 | 	it("should return the actual settings() function", function()
  10 | 		local settings = createSettings({})
  11 | 		local instance = settings()
  12 | 		assert.equals(type(instance), "userdata")
  13 | 	end)
  14 | 
  15 | 	it("should always return the same object", function()
  16 | 		local settings = createSettings({})
  17 | 
  18 | 		local instance = settings()
  19 | 		local instance2 = settings()
  20 | 		assert.equals(instance, instance2)
  21 | 	end)
  22 | 
  23 | 	describe("GetFFlag", function()
  24 | 		it("should check fast flags", function()
  25 | 			local settings = createSettings({
  26 | 				flags = {
  27 | 					FFTest = true,
  28 | 					FFTest2 = true,
  29 | 					FFDoesSomethingHappen = false,
  30 | 				}
  31 | 			})
  32 | 
  33 | 			local instance = settings()
  34 | 			assert.True(instance:GetFFlag("FFTest"))
  35 | 			assert.True(instance:GetFFlag("FFTest2"))
  36 | 			assert.False(instance:GetFFlag("FFDoesSomethingHappen"))
  37 | 		end)
  38 | 
  39 | 		it("should throw if a fast flag does not exist", function()
  40 | 			local settings = createSettings({
  41 | 				flags = {
  42 | 					FFTest = true,
  43 | 					FFTest2 = true,
  44 | 					FFDoesSomethingHappen = false,
  45 | 				}
  46 | 			})
  47 | 			local instance = settings()
  48 | 
  49 | 			assert.has.errors(function()
  50 | 				instance:GetFFlag("FFUndefinedFastFlag")
  51 | 			end)
  52 | 		end)
  53 | 	end)
  54 | 
  55 | 	it("should have a property Rendering", function()
  56 | 		local settings = createSettings({})
  57 | 
  58 | 		local instance = settings()
  59 | 		local renderSettings = instance.Rendering
  60 | 
  61 | 		assert.not_nil(renderSettings)
  62 | 		assert.equals(typeof(renderSettings), "RenderSettings")
  63 | 	end)
  64 | 
  65 | 	it("should not allow me to set the Rendering property", function()
  66 | 		local settings = createSettings({})
  67 | 
  68 | 		local instance = settings()
  69 | 		assert.has.errors(function()
  70 | 			instance.Rendering = true
  71 | 		end)
  72 | 	end)
  73 | 
  74 | 	it("should not allow me to access undefined properties", function()
  75 | 		local settings = createSettings({})
  76 | 
  77 | 		local instance = settings()
  78 | 		assert.has.errors(function()
  79 | 			tostring(instance.thisDoesNotExist)
  80 | 		end)
  81 | 	end)
  82 | 
  83 | 	it("should not allow me to set undefined properties", function()
  84 | 		local settings = createSettings({})
  85 | 
  86 | 		local instance = settings()
  87 | 		assert.has.errors(function()
  88 | 			instance.thisDoesNotExist = "this should throw"
  89 | 		end)
  90 | 	end)
  91 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/Enum/ConnectionState.lua`
<details>
<summary>View Source (5 lines)</summary>

```lua
   1 | local createEnum = import("../createEnum")
   2 | 
   3 | return createEnum("ConnectionState", {
   4 | 	CONNECTED = 0,
   5 | 	DISCONNECTED = 1,
   6 | })
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/Enum/CreatorType.lua`
<details>
<summary>View Source (5 lines)</summary>

```lua
   1 | local createEnum = import("../createEnum")
   2 | 
   3 | return createEnum("CreatorType", {
   4 | 	User = 0,
   5 | 	Group = 1,
   6 | })
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/Enum/DataStoreRequestType.lua`
<details>
<summary>View Source (9 lines)</summary>

```lua
   1 | local createEnum = import("../createEnum")
   2 | 
   3 | return createEnum("DataStoreRequestType", {
   4 | 	GetAsync = 0,
   5 | 	SetIncrementAsync = 1,
   6 | 	UpdateAsync = 2,
   7 | 	GetSortedAsync = 3,
   8 | 	SetIncrementSortedAsync = 4,
   9 | 	OnUpdate = 5
  10 | })
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/Enum/EasingDirection.lua`
<details>
<summary>View Source (6 lines)</summary>

```lua
   1 | local createEnum = import("../createEnum")
   2 | 
   3 | return createEnum("EasingDirection", {
   4 | 	In = 0,
   5 | 	Out = 1,
   6 | 	InOut = 2,
   7 | })
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/Enum/EasingStyle.lua`
<details>
<summary>View Source (11 lines)</summary>

```lua
   1 | local createEnum = import("../createEnum")
   2 | 
   3 | return createEnum("EasingStyle", {
   4 | 	Linear = 0,
   5 | 	Sine = 1,
   6 | 	Back = 2,
   7 | 	Quad = 3,
   8 | 	Quart = 4,
   9 | 	Quint = 5,
  10 | 	Bounce = 6,
  11 | 	Elastic = 7,
  12 | })
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/Enum/FillDirection.lua`
<details>
<summary>View Source (5 lines)</summary>

```lua
   1 | local createEnum = import("../createEnum")
   2 | 
   3 | return createEnum("FillDirection", {
   4 | 	Horizontal = 0,
   5 | 	Vertical = 1,
   6 | })
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/Enum/Font.lua`
<details>
<summary>View Source (22 lines)</summary>

```lua
   1 | local createEnum = import("../createEnum")
   2 | 
   3 | return createEnum("Font", {
   4 | 	Legacy = 0,
   5 | 	Arial = 1,
   6 | 	ArialBold = 2,
   7 | 	SourceSans = 3,
   8 | 	SourceSansBold = 4,
   9 | 	SourceSansLight = 5,
  10 | 	SourceSansItalic = 6,
  11 | 	Bodoni = 7,
  12 | 	Garamond = 8,
  13 | 	Cartoon = 9,
  14 | 	Code = 10,
  15 | 	Highway = 11,
  16 | 	Scifi = 12,
  17 | 	Arcade = 13,
  18 | 	Fantasy = 14,
  19 | 	Antique = 15,
  20 | 	SourceSansSemiBold = 16,
  21 | 	Count = 17,
  22 | 	Fallback = 17,
  23 | })
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/Enum/HorizontalAlignment.lua`
<details>
<summary>View Source (6 lines)</summary>

```lua
   1 | local createEnum = import("../createEnum")
   2 | 
   3 | return createEnum("HorizontalAlignment", {
   4 | 	Center = 0,
   5 | 	Left = 1,
   6 | 	Right = 2,
   7 | })
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/Enum/HttpContentType.lua`
<details>
<summary>View Source (12 lines)</summary>

```lua
   1 | local createEnum = import("../createEnum")
   2 | 
   3 | return createEnum(
   4 | 	"HttpContentType",
   5 | 	{
   6 | 		ApplicationJson = 0,
   7 | 		ApplicationXml = 1,
   8 | 		ApplicationUrlEncoded = 2,
   9 | 		TextPlain = 3,
  10 | 		TextXml = 4,
  11 | 	}
  12 | )
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/Enum/InfoType.lua`
<details>
<summary>View Source (6 lines)</summary>

```lua
   1 | local createEnum = import("../createEnum")
   2 | 
   3 | return createEnum("InfoType", {
   4 | 	Asset = 0,
   5 | 	Product = 1,
   6 | 	GamePass = 2,
   7 | })
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/Enum/init.lua`
<details>
<summary>View Source (41 lines)</summary>

```lua
   1 | local createEnumGroup = import("../createEnumGroup")
   2 | 
   3 | local names = {
   4 | 	"ConnectionState",
   5 | 	"CreatorType",
   6 | 	"DataStoreRequestType",
   7 | 	"EasingDirection",
   8 | 	"EasingStyle",
   9 | 	"FillDirection",
  10 | 	"Font",
  11 | 	"HorizontalAlignment",
  12 | 	"HttpContentType",
  13 | 	"Platform",
  14 | 	"InfoType",
  15 | 	"KeyCode",
  16 | 	"MouseBehavior",
  17 | 	"PlaybackState",
  18 | 	"ScaleType",
  19 | 	"ScrollBarInset",
  20 | 	"ScrollingDirection",
  21 | 	"SizeConstraint",
  22 | 	"SortOrder",
  23 | 	"TextTruncate",
  24 | 	"TextXAlignment",
  25 | 	"TextYAlignment",
  26 | 	"ThumbnailSize",
  27 | 	"ThumbnailType",
  28 | 	"UserInputType",
  29 | 	"VerticalAlignment",
  30 | 	"VerticalScrollBarPosition",
  31 | 	"VirtualInputMode",
  32 | 	"ZIndexBehavior",
  33 | }
  34 | 
  35 | local enums = {}
  36 | 
  37 | for _, name in ipairs(names) do
  38 | 	enums[name] = import("./" .. name)
  39 | end
  40 | 
  41 | return createEnumGroup(enums)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/Enum/KeyCode.lua`
<details>
<summary>View Source (257 lines)</summary>

```lua
   1 | local createEnum = import("../createEnum")
   2 | 
   3 | return createEnum("KeyCode", {
   4 | 	Unknown = 0,
   5 | 	Backspace = 8,
   6 | 	Tab = 9,
   7 | 	Clear = 12,
   8 | 	Return = 13,
   9 | 	Pause = 19,
  10 | 	Escape = 27,
  11 | 	Space = 32,
  12 | 	QuotedDouble = 34,
  13 | 	Hash = 35,
  14 | 	Dollar = 36,
  15 | 	Percent = 37,
  16 | 	Ampersand = 38,
  17 | 	Quote = 39,
  18 | 	LeftParenthesis = 40,
  19 | 	RightParenthesis = 41,
  20 | 	Asterisk = 42,
  21 | 	Plus = 43,
  22 | 	Comma = 44,
  23 | 	Minus = 45,
  24 | 	Period = 46,
  25 | 	Slash = 47,
  26 | 	Zero = 48,
  27 | 	One = 49,
  28 | 	Two = 50,
  29 | 	Three = 51,
  30 | 	Four = 52,
  31 | 	Five = 53,
  32 | 	Six = 54,
  33 | 	Seven = 55,
  34 | 	Eight = 56,
  35 | 	Nine = 57,
  36 | 	Colon = 58,
  37 | 	Semicolon = 59,
  38 | 	LessThan = 60,
  39 | 	Equals = 61,
  40 | 	GreaterThan = 62,
  41 | 	Question = 63,
  42 | 	At = 64,
  43 | 	LeftBracket = 91,
  44 | 	BackSlash = 92,
  45 | 	RightBracket = 93,
  46 | 	Caret = 94,
  47 | 	Underscore = 95,
  48 | 	Backquote = 96,
  49 | 	A = 97,
  50 | 	B = 98,
  51 | 	C = 99,
  52 | 	D = 100,
  53 | 	E = 101,
  54 | 	F = 102,
  55 | 	G = 103,
  56 | 	H = 104,
  57 | 	I = 105,
  58 | 	J = 106,
  59 | 	K = 107,
  60 | 	L = 108,
  61 | 	M = 109,
  62 | 	N = 110,
  63 | 	O = 111,
  64 | 	P = 112,
  65 | 	Q = 113,
  66 | 	R = 114,
  67 | 	S = 115,
  68 | 	T = 116,
  69 | 	U = 117,
  70 | 	V = 118,
  71 | 	W = 119,
  72 | 	X = 120,
  73 | 	Y = 121,
  74 | 	Z = 122,
  75 | 	LeftCurly = 123,
  76 | 	Pipe = 124,
  77 | 	RightCurly = 125,
  78 | 	Tilde = 126,
  79 | 	Delete = 127,
  80 | 	KeypadZero = 256,
  81 | 	KeypadOne = 257,
  82 | 	KeypadTwo = 258,
  83 | 	KeypadThree = 259,
  84 | 	KeypadFour = 260,
  85 | 	KeypadFive = 261,
  86 | 	KeypadSix = 262,
  87 | 	KeypadSeven = 263,
  88 | 	KeypadEight = 264,
  89 | 	KeypadNine = 265,
  90 | 	KeypadPeriod = 266,
  91 | 	KeypadDivide = 267,
  92 | 	KeypadMultiply = 268,
  93 | 	KeypadMinus = 269,
  94 | 	KeypadPlus = 270,
  95 | 	KeypadEnter = 271,
  96 | 	KeypadEquals = 272,
  97 | 	Up = 273,
  98 | 	Down = 274,
  99 | 	Right = 275,
 100 | 	Left = 276,
 101 | 	Insert = 277,
 102 | 	Home = 278,
 103 | 	End = 279,
 104 | 	PageUp = 280,
 105 | 	PageDown = 281,
 106 | 	LeftShift = 304,
 107 | 	RightShift = 303,
 108 | 	LeftMeta = 310,
 109 | 	RightMeta = 309,
 110 | 	LeftAlt = 308,
 111 | 	RightAlt = 307,
 112 | 	LeftControl = 306,
 113 | 	RightControl = 305,
 114 | 	CapsLock = 301,
 115 | 	NumLock = 300,
 116 | 	ScrollLock = 302,
 117 | 	LeftSuper = 311,
 118 | 	RightSuper = 312,
 119 | 	Mode = 313,
 120 | 	Compose = 314,
 121 | 	Help = 315,
 122 | 	Print = 316,
 123 | 	SysReq = 317,
 124 | 	Break = 318,
 125 | 	Menu = 319,
 126 | 	Power = 320,
 127 | 	Euro = 321,
 128 | 	Undo = 322,
 129 | 	F1 = 282,
 130 | 	F2 = 283,
 131 | 	F3 = 284,
 132 | 	F4 = 285,
 133 | 	F5 = 286,
 134 | 	F6 = 287,
 135 | 	F7 = 288,
 136 | 	F8 = 289,
 137 | 	F9 = 290,
 138 | 	F10 = 291,
 139 | 	F11 = 292,
 140 | 	F12 = 293,
 141 | 	F13 = 294,
 142 | 	F14 = 295,
 143 | 	F15 = 296,
 144 | 	World0 = 160,
 145 | 	World1 = 161,
 146 | 	World2 = 162,
 147 | 	World3 = 163,
 148 | 	World4 = 164,
 149 | 	World5 = 165,
 150 | 	World6 = 166,
 151 | 	World7 = 167,
 152 | 	World8 = 168,
 153 | 	World9 = 169,
 154 | 	World10 = 170,
 155 | 	World11 = 171,
 156 | 	World12 = 172,
 157 | 	World13 = 173,
 158 | 	World14 = 174,
 159 | 	World15 = 175,
 160 | 	World16 = 176,
 161 | 	World17 = 177,
 162 | 	World18 = 178,
 163 | 	World19 = 179,
 164 | 	World20 = 180,
 165 | 	World21 = 181,
 166 | 	World22 = 182,
 167 | 	World23 = 183,
 168 | 	World24 = 184,
 169 | 	World25 = 185,
 170 | 	World26 = 186,
 171 | 	World27 = 187,
 172 | 	World28 = 188,
 173 | 	World29 = 189,
 174 | 	World30 = 190,
 175 | 	World31 = 191,
 176 | 	World32 = 192,
 177 | 	World33 = 193,
 178 | 	World34 = 194,
 179 | 	World35 = 195,
 180 | 	World36 = 196,
 181 | 	World37 = 197,
 182 | 	World38 = 198,
 183 | 	World39 = 199,
 184 | 	World40 = 200,
 185 | 	World41 = 201,
 186 | 	World42 = 202,
 187 | 	World43 = 203,
 188 | 	World44 = 204,
 189 | 	World45 = 205,
 190 | 	World46 = 206,
 191 | 	World47 = 207,
 192 | 	World48 = 208,
 193 | 	World49 = 209,
 194 | 	World50 = 210,
 195 | 	World51 = 211,
 196 | 	World52 = 212,
 197 | 	World53 = 213,
 198 | 	World54 = 214,
 199 | 	World55 = 215,
 200 | 	World56 = 216,
 201 | 	World57 = 217,
 202 | 	World58 = 218,
 203 | 	World59 = 219,
 204 | 	World60 = 220,
 205 | 	World61 = 221,
 206 | 	World62 = 222,
 207 | 	World63 = 223,
 208 | 	World64 = 224,
 209 | 	World65 = 225,
 210 | 	World66 = 226,
 211 | 	World67 = 227,
 212 | 	World68 = 228,
 213 | 	World69 = 229,
 214 | 	World70 = 230,
 215 | 	World71 = 231,
 216 | 	World72 = 232,
 217 | 	World73 = 233,
 218 | 	World74 = 234,
 219 | 	World75 = 235,
 220 | 	World76 = 236,
 221 | 	World77 = 237,
 222 | 	World78 = 238,
 223 | 	World79 = 239,
 224 | 	World80 = 240,
 225 | 	World81 = 241,
 226 | 	World82 = 242,
 227 | 	World83 = 243,
 228 | 	World84 = 244,
 229 | 	World85 = 245,
 230 | 	World86 = 246,
 231 | 	World87 = 247,
 232 | 	World88 = 248,
 233 | 	World89 = 249,
 234 | 	World90 = 250,
 235 | 	World91 = 251,
 236 | 	World92 = 252,
 237 | 	World93 = 253,
 238 | 	World94 = 254,
 239 | 	World95 = 255,
 240 | 	ButtonX = 1000,
 241 | 	ButtonY = 1001,
 242 | 	ButtonA = 1002,
 243 | 	ButtonB = 1003,
 244 | 	ButtonR1 = 1004,
 245 | 	ButtonL1 = 1005,
 246 | 	ButtonR2 = 1006,
 247 | 	ButtonL2 = 1007,
 248 | 	ButtonR3 = 1008,
 249 | 	ButtonL3 = 1009,
 250 | 	ButtonStart = 1010,
 251 | 	ButtonSelect = 1011,
 252 | 	DPadLeft = 1012,
 253 | 	DPadRight = 1013,
 254 | 	DPadUp = 1014,
 255 | 	DPadDown = 1015,
 256 | 	Thumbstick1 = 1016,
 257 | 	Thumbstick2 = 1017,
 258 | })
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/Enum/MouseBehavior.lua`
<details>
<summary>View Source (6 lines)</summary>

```lua
   1 | local createEnum = import("../createEnum")
   2 | 
   3 | return createEnum("MouseBehavior", {
   4 | 	Default = 0,
   5 | 	LockCenter = 1,
   6 | 	LockCurrentPosition = 2,
   7 | })
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/Enum/Platform.lua`
<details>
<summary>View Source (23 lines)</summary>

```lua
   1 | local createEnum = import("../createEnum")
   2 | 
   3 | return createEnum("Platform", {
   4 | 	Windows = 0,
   5 | 	OSX = 1,
   6 | 	IOS = 2,
   7 | 	Android = 3,
   8 | 	XBoxOne = 4,
   9 | 	PS4 = 5,
  10 | 	PS3 = 6,
  11 | 	XBox360 = 7,
  12 | 	WiiU = 8,
  13 | 	NX = 9,
  14 | 	Ouya = 10,
  15 | 	AndroidTV = 11,
  16 | 	Chromecast = 12,
  17 | 	Linux = 13,
  18 | 	SteamOS = 14,
  19 | 	WebOS = 15,
  20 | 	DOS = 16,
  21 | 	BeOS = 17,
  22 | 	UWP = 18,
  23 | 	None = 19,
  24 | })
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/Enum/PlaybackState.lua`
<details>
<summary>View Source (9 lines)</summary>

```lua
   1 | local createEnum = import("../createEnum")
   2 | 
   3 | return createEnum("PlaybackState", {
   4 | 	Begin = 0,
   5 | 	Delayed = 1,
   6 | 	Playing = 2,
   7 | 	Paused = 3,
   8 | 	Completed = 4,
   9 | 	Cancelled = 5,
  10 | })
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/Enum/ScaleType.lua`
<details>
<summary>View Source (8 lines)</summary>

```lua
   1 | local createEnum = import("../createEnum")
   2 | 
   3 | return createEnum("ScaleType", {
   4 | 	Stretch = 0,
   5 | 	Slice = 1,
   6 | 	Tile = 2,
   7 | 	Fit = 3,
   8 | 	Crop = 4,
   9 | })
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/Enum/ScrollBarInset.lua`
<details>
<summary>View Source (6 lines)</summary>

```lua
   1 | local createEnum = import("../createEnum")
   2 | 
   3 | return createEnum("ScrollBarInset", {
   4 | 	None = 0,
   5 | 	ScrollBar = 1,
   6 | 	Always = 2,
   7 | })
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/Enum/ScrollingDirection.lua`
<details>
<summary>View Source (6 lines)</summary>

```lua
   1 | local createEnum = import("../createEnum")
   2 | 
   3 | return createEnum("ScrollingDirection", {
   4 | 	X = 1,
   5 | 	Y = 2,
   6 | 	XY = 4,
   7 | })
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/Enum/SizeConstraint.lua`
<details>
<summary>View Source (6 lines)</summary>

```lua
   1 | local createEnum = import("../createEnum")
   2 | 
   3 | return createEnum("SizeConstraint", {
   4 | 	RelativeXY = 0,
   5 | 	RelativeXX = 1,
   6 | 	RelativeYY = 2,
   7 | })
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/Enum/SortOrder.lua`
<details>
<summary>View Source (6 lines)</summary>

```lua
   1 | local createEnum = import("../createEnum")
   2 | 
   3 | return createEnum("SortOrder", {
   4 | 	Name = 0,
   5 | 	Custom = 1,
   6 | 	LayoutOrder = 2,
   7 | })
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/Enum/TextTruncate.lua`
<details>
<summary>View Source (5 lines)</summary>

```lua
   1 | local createEnum = import("../createEnum")
   2 | 
   3 | return createEnum("TextTruncate", {
   4 | 	None = 0,
   5 | 	AtEnd = 1,
   6 | })
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/Enum/TextXAlignment.lua`
<details>
<summary>View Source (6 lines)</summary>

```lua
   1 | local createEnum = import("../createEnum")
   2 | 
   3 | return createEnum("TextXAlignment", {
   4 | 	Left = 0,
   5 | 	Right = 1,
   6 | 	Center = 2,
   7 | })
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/Enum/TextYAlignment.lua`
<details>
<summary>View Source (6 lines)</summary>

```lua
   1 | local createEnum = import("../createEnum")
   2 | 
   3 | return createEnum("TextYAlignment", {
   4 | 	Top = 0,
   5 | 	Center = 1,
   6 | 	Bottom = 2,
   7 | })
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/Enum/ThumbnailSize.lua`
<details>
<summary>View Source (10 lines)</summary>

```lua
   1 | local createEnum = import("../createEnum")
   2 | 
   3 | return createEnum("ThumbnailSize", {
   4 | 	Size48x48 = 0,
   5 | 	Size180x180 = 1,
   6 | 	Size420x420 = 2,
   7 | 	Size60x60 = 3,
   8 | 	Size100x100 = 4,
   9 | 	Size150x150 = 5,
  10 | 	Size352x352 = 6,
  11 | })
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/Enum/ThumbnailType.lua`
<details>
<summary>View Source (6 lines)</summary>

```lua
   1 | local createEnum = import("../createEnum")
   2 | 
   3 | return createEnum("ThumbnailType", {
   4 | 	HeadShot = 0,
   5 | 	AvatarBust = 1,
   6 | 	AvatarThumbnail = 2,
   7 | })
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/Enum/UserInputType.lua`
<details>
<summary>View Source (23 lines)</summary>

```lua
   1 | local createEnum = import("../createEnum")
   2 | 
   3 | return createEnum("UserInputType", {
   4 | 	MouseButton1 = 0,
   5 | 	MouseButton2 = 1,
   6 | 	MouseButton3 = 2,
   7 | 	MouseWheel = 3,
   8 | 	MouseMovement = 4,
   9 | 	Touch = 7,
  10 | 	Keyboard = 8,
  11 | 	Focus = 9,
  12 | 	Accelerometer = 10,
  13 | 	Gyro = 11,
  14 | 	Gamepad1 = 12,
  15 | 	Gamepad2 = 13,
  16 | 	Gamepad3 = 14,
  17 | 	Gamepad4 = 15,
  18 | 	Gamepad5 = 16,
  19 | 	Gamepad6 = 17,
  20 | 	Gamepad7 = 18,
  21 | 	Gamepad8 = 19,
  22 | 	TextInput = 20,
  23 | 	None = 21,
  24 | })
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/Enum/VerticalAlignment.lua`
<details>
<summary>View Source (6 lines)</summary>

```lua
   1 | local createEnum = import("../createEnum")
   2 | 
   3 | return createEnum("VerticalAlignment", {
   4 | 	Center = 0,
   5 | 	Top = 1,
   6 | 	Bottom = 2,
   7 | })
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/Enum/VerticalScrollBarPosition.lua`
<details>
<summary>View Source (5 lines)</summary>

```lua
   1 | local createEnum = import("../createEnum")
   2 | 
   3 | return createEnum("VerticalScrollBarPosition", {
   4 | 	Left = 1,
   5 | 	Right = 0,
   6 | })
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/Enum/VirtualInputMode.lua`
<details>
<summary>View Source (6 lines)</summary>

```lua
   1 | local createEnum = import("../createEnum")
   2 | 
   3 | return createEnum("VirtualInputMode", {
   4 | 	None = 0,
   5 | 	Recording = 1,
   6 | 	Playing = 2,
   7 | })
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/Enum/ZIndexBehavior.lua`
<details>
<summary>View Source (5 lines)</summary>

```lua
   1 | local createEnum = import("../createEnum")
   2 | 
   3 | return createEnum("ZIndexBehavior", {
   4 | 	Global = 0,
   5 | 	Sibling = 1,
   6 | })
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/fs.lua`
<details>
<summary>View Source (32 lines)</summary>

```lua
   1 | local ok, lfs = pcall(require, "lfs")
   2 | 
   3 | if not ok then
   4 | 	error("Lemur requires LuaFileSystem, which couldn't be found: " .. lfs)
   5 | end
   6 | 
   7 | local fs = {}
   8 | 
   9 | function fs.isFile(path)
  10 | 	return lfs.attributes(path, "mode") == "file"
  11 | end
  12 | 
  13 | function fs.isDirectory(path)
  14 | 	return lfs.attributes(path, "mode") == "directory"
  15 | end
  16 | 
  17 | function fs.read(path)
  18 | 	local handle, err = io.open(path, "r")
  19 | 
  20 | 	if not handle then
  21 | 		return nil, err
  22 | 	end
  23 | 
  24 | 	local contents = handle:read("*all")
  25 | 
  26 | 	handle:close()
  27 | 
  28 | 	return contents
  29 | end
  30 | 
  31 | fs.dir = lfs.dir
  32 | 
  33 | return fs
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/fs_spec.lua`
<details>
<summary>View Source (18 lines)</summary>

```lua
   1 | describe("fs", function()
   2 | 	local fs = import("./fs")
   3 | 
   4 | 	it("should return errors when failing to open a file", function()
   5 | 		local contents, err = fs.read("nuclear launch codes.txt")
   6 | 
   7 | 		assert.is_nil(contents)
   8 | 		assert.is_not_nil(err)
   9 | 	end)
  10 | 
  11 | 	it("should return contents of files read", function()
  12 | 		local contents, err = fs.read("init.lua")
  13 | 
  14 | 		assert.is_not_nil(contents)
  15 | 		assert.is_nil(err)
  16 | 		assert.is_true(#contents > 0)
  17 | 	end)
  18 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/functions/init.lua`
<details>
<summary>View Source (12 lines)</summary>

```lua
   1 | local names = {
   2 | 	"typeof",
   3 | 	"warn",
   4 | 	"tick",
   5 | }
   6 | 
   7 | local functions = {}
   8 | 
   9 | for _, name in ipairs(names) do
  10 | 	functions[name] = import("./" .. name)
  11 | end
  12 | 
  13 | return functions
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/functions/settings/RenderSettings.lua`
<details>
<summary>View Source (55 lines)</summary>

```lua
   1 | local assign = import("../../assign")
   2 | local typeKey = import("../../typeKey")
   3 | 
   4 | local RenderSettings = {}
   5 | 
   6 | setmetatable(RenderSettings, {
   7 | 	__tostring = function()
   8 | 		return "RenderSettings"
   9 | 	end,
  10 | })
  11 | 
  12 | local prototype = {}
  13 | 
  14 | local metatable = {}
  15 | metatable[typeKey] = "RenderSettings"
  16 | 
  17 | function metatable:__index(key)
  18 | 	local internal = getmetatable(self).internal
  19 | 
  20 | 	if internal[key] ~= nil then
  21 | 		return internal[key]
  22 | 	end
  23 | 
  24 | 	if prototype[key] ~= nil then
  25 | 		return prototype[key]
  26 | 	end
  27 | 
  28 | 	error(string.format("%s is not a valid member of RenderSettings", tostring(key)), 2)
  29 | end
  30 | 
  31 | function metatable:__newindex(key, value)
  32 | 	local internal = getmetatable(self).internal
  33 | 
  34 | 	if internal[key] ~= nil then
  35 | 		internal[key] = value
  36 | 		return
  37 | 	end
  38 | 
  39 | 	error(string.format("%q is not a valid member of RenderSettings", tostring(key)), 2)
  40 | end
  41 | 
  42 | 
  43 | function RenderSettings.new()
  44 | 	local internalInstance = {
  45 | 		QualityLevel = 0,
  46 | 	}
  47 | 
  48 | 	local instance = newproxy(true)
  49 | 
  50 | 	assign(getmetatable(instance), metatable)
  51 | 	getmetatable(instance).internal = internalInstance
  52 | 
  53 | 	return instance
  54 | end
  55 | 
  56 | return RenderSettings
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/functions/settings/RenderSettings_spec.lua`
<details>
<summary>View Source (39 lines)</summary>

```lua
   1 | local RenderSettings = import("./RenderSettings")
   2 | local typeof = import("../typeof")
   3 | 
   4 | describe("functions.settings.RenderSettings", function()
   5 | 	it("should be an object", function()
   6 | 		local instance = RenderSettings.new()
   7 | 		assert.not_nil(instance)
   8 | 		assert.equals(typeof(instance), "RenderSettings")
   9 | 	end)
  10 | 
  11 | 	it("should be of type RenderSettings", function()
  12 | 		local instance = RenderSettings.new()
  13 | 		assert.equals(typeof(instance), "RenderSettings")
  14 | 	end)
  15 | 
  16 | 	it("should have a property QualityLevel", function()
  17 | 		local instance = RenderSettings.new()
  18 | 		assert.equals(instance.QualityLevel, 0)
  19 | 	end)
  20 | 
  21 | 	it("should allow me to set the property QualityLevel", function()
  22 | 		local instance = RenderSettings.new()
  23 | 		instance.QualityLevel = 1
  24 | 		assert.equals(instance.QualityLevel, 1)
  25 | 	end)
  26 | 
  27 | 	it("should not allow me to access undefined properties", function()
  28 | 		local instance = RenderSettings.new()
  29 | 		assert.has.errors(function()
  30 | 			tostring(instance.thisDoesNotExist)
  31 | 		end)
  32 | 	end)
  33 | 
  34 | 	it("should not allow me to set undefined properties", function()
  35 | 		local instance = RenderSettings.new()
  36 | 		assert.has.errors(function()
  37 | 			instance.thisDoesNotExist = "this should throw"
  38 | 		end)
  39 | 	end)
  40 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/functions/tick.lua`
<details>
<summary>View Source (9 lines)</summary>

```lua
   1 | local success, socket = pcall(require, "socket")
   2 | 
   3 | local tick
   4 | if success then
   5 | 	tick = socket.gettime
   6 | else
   7 | 	tick = os.clock
   8 | end
   9 | 
  10 | return tick
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/functions/tick_spec.lua`
<details>
<summary>View Source (6 lines)</summary>

```lua
   1 | local tick = import("./tick")
   2 | 
   3 | describe("functions.tick", function()
   4 | 	it("returns a number", function()
   5 | 		assert.is.number(tick())
   6 | 	end)
   7 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/functions/typeof.lua`
<details>
<summary>View Source (20 lines)</summary>

```lua
   1 | local typeKey = import("../typeKey")
   2 | 
   3 | local function typeof(object)
   4 | 	local realType = type(object)
   5 | 
   6 | 	if realType == "userdata" then
   7 | 		local metatable = getmetatable(object)
   8 | 
   9 | 		if metatable == nil then
  10 | 			return "userdata"
  11 | 		end
  12 | 
  13 | 		if metatable[typeKey] ~= nil then
  14 | 			return metatable[typeKey]
  15 | 		end
  16 | 	end
  17 | 
  18 | 	return realType
  19 | end
  20 | 
  21 | return typeof
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/functions/typeof_spec.lua`
<details>
<summary>View Source (20 lines)</summary>

```lua
   1 | local typeof = import("./typeof")
   2 | 
   3 | describe("functions.typeof", function()
   4 | 	it("should identify all Lua primitives", function()
   5 | 		local values = {
   6 | 			true, false, 0, "hello", {}, newproxy(true),
   7 | 		}
   8 | 
   9 | 		for _, value in ipairs(values) do
  10 | 			assert.equal(type(value), typeof(value))
  11 | 		end
  12 | 	end)
  13 | 
  14 | 	it("should identify all Instances as Instance", function()
  15 | 		local instances = import("../instances")
  16 | 
  17 | 		for _, instance in pairs(instances) do
  18 | 			assert.equal("Instance", typeof(instance:new()))
  19 | 		end
  20 | 	end)
  21 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/functions/warn.lua`
<details>
<summary>View Source (14 lines)</summary>

```lua
   1 | local function warn(...)
   2 | 	local count = select("#", ...)
   3 | 	for i = 1, count do
   4 | 		local piece = select(i, ...)
   5 | 		io.stderr:write(tostring(piece))
   6 | 
   7 | 		if i < count then
   8 | 			io.stderr:write("\t")
   9 | 		end
  10 | 	end
  11 | 
  12 | 	io.stderr:write("\n")
  13 | end
  14 | 
  15 | return warn
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/functions/warn_spec.lua`
<details>
<summary>View Source (46 lines)</summary>

```lua
   1 | local warn = import("./warn")
   2 | 
   3 | local function setupWarnDetour()
   4 | 	local oldErr = io.stderr
   5 | 
   6 | 	local writeSpy = spy.new(function() end)
   7 | 
   8 | 	io.stderr = { -- luacheck: ignore
   9 | 		write = writeSpy
  10 | 	}
  11 | 
  12 | 	return oldErr, writeSpy
  13 | end
  14 | 
  15 | describe("functions.warn", function()
  16 | 	it("should be a function", function()
  17 | 		assert.is_function(warn)
  18 | 	end)
  19 | 
  20 | 	it("should warn", function()
  21 | 		local oldErr, writeSpy = setupWarnDetour()
  22 | 		warn("Doge has taken over the world!")
  23 | 		assert.spy(writeSpy).was_called_with(io.stderr, "Doge has taken over the world!")
  24 | 		io.stderr = oldErr -- luacheck: ignore
  25 | 	end)
  26 | 
  27 | 	it("should warn with multiple arguments", function()
  28 | 		local oldErr, writeSpy = setupWarnDetour()
  29 | 		warn("IT'S DOGE!", "AAH!")
  30 | 		assert.spy(writeSpy).was.called(4) -- IT'S DOGE, \t, AAH!, \n
  31 | 		io.stderr = oldErr -- luacheck: ignore
  32 | 	end)
  33 | 
  34 | 	it("should warn with a non-string argument", function()
  35 | 		local oldErr, writeSpy = setupWarnDetour()
  36 | 		warn(1)
  37 | 		assert.spy(writeSpy).was_called_with(io.stderr, "1")
  38 | 		io.stderr = oldErr -- luacheck: ignore
  39 | 	end)
  40 | 
  41 | 	it("should warn with non-string arguments", function()
  42 | 		local oldErr, writeSpy = setupWarnDetour()
  43 | 		warn(2, 3)
  44 | 		assert.spy(writeSpy).was.called(4) -- 2, \t, 3, \n
  45 | 		io.stderr = oldErr -- luacheck: ignore
  46 | 	end)
  47 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/Habitat.lua`
<details>
<summary>View Source (132 lines)</summary>

```lua
   1 | --[[
   2 | 	A Lemur Habitat is an instance of an emulated Roblox environment.
   3 | 
   4 | 	It is the root instance of the emulated hierarchy.
   5 | ]]
   6 | 
   7 | local Instance = import("./Instance")
   8 | local TaskScheduler = import("./TaskScheduler")
   9 | local createEnvironment = import("./createEnvironment")
  10 | local fs = import("./fs")
  11 | local Game = import("./instances/Game")
  12 | local validateType = import("./validateType")
  13 | local assign = import("./assign")
  14 | 
  15 | local defaultLoadFromFsOptions = {
  16 | 	loadInitModules = true,
  17 | }
  18 | 
  19 | local Habitat = {}
  20 | Habitat.__index = Habitat
  21 | 
  22 | function Habitat.new(settings)
  23 | 	local habitat = {
  24 | 		game = Game:new(),
  25 | 		taskScheduler = TaskScheduler.new(),
  26 | 		settings = settings or {},
  27 | 		environment = nil,
  28 | 	}
  29 | 
  30 | 	setmetatable(habitat, Habitat)
  31 | 
  32 | 	habitat.environment = createEnvironment(habitat)
  33 | 
  34 | 	return habitat
  35 | end
  36 | 
  37 | function Habitat:loadFromFs(path, passedOptions)
  38 | 	validateType("path", path, "string")
  39 | 
  40 | 	if passedOptions ~= nil then
  41 | 		validateType("passedOptions", passedOptions, "table")
  42 | 	end
  43 | 
  44 | 	local options = assign({}, defaultLoadFromFsOptions, passedOptions)
  45 | 
  46 | 	if fs.isFile(path) then
  47 | 		if path:find("%.lua$") then
  48 | 			local instance = Instance.new("ModuleScript")
  49 | 			local contents = assert(fs.read(path))
  50 | 
  51 | 			instance.Name = path:match("([^/]-)%.lua$")
  52 | 			instance.Source = contents
  53 | 
  54 | 			getmetatable(instance).instance.modulePath = path
  55 | 
  56 | 			return instance
  57 | 		end
  58 | 		-- Ignore non-lua files
  59 | 		return
  60 | 	elseif fs.isDirectory(path) then
  61 | 		local instance = Instance.new("Folder")
  62 | 		instance.Name = path:match("([^/]-)$")
  63 | 
  64 | 		for name in fs.dir(path) do
  65 | 			-- Why are these even in the iterator?
  66 | 			if name ~= "." and name ~= ".." then
  67 | 				local childPath = path .. "/" .. name
  68 | 
  69 | 				local childInstance = Habitat:loadFromFs(childPath, passedOptions)
  70 | 				if childInstance ~= nil then
  71 | 					childInstance.Parent = instance
  72 | 				end
  73 | 			end
  74 | 		end
  75 | 
  76 | 		if options.loadInitModules then
  77 | 			local init = instance:FindFirstChild("init")
  78 | 
  79 | 			if init ~= nil then
  80 | 				for _, child in ipairs(instance:GetChildren()) do
  81 | 					if child ~= init then
  82 | 						child.Parent = init
  83 | 					end
  84 | 				end
  85 | 
  86 | 				init.Name = instance.Name
  87 | 				init.Parent = nil
  88 | 
  89 | 				instance:Destroy()
  90 | 
  91 | 				instance = init
  92 | 			end
  93 | 		end
  94 | 
  95 | 		return instance
  96 | 	end
  97 | 
  98 | 	error(("loadFromFs failed: Path %s did not exist."):format(path), 2)
  99 | end
 100 | 
 101 | --[[
 102 | 	Equivalent to Roblox's 'require', called on an emulated Roblox instance.
 103 | ]]
 104 | function Habitat:require(instance)
 105 | 	validateType("instance", instance, "Instance")
 106 | 
 107 | 	if not instance:IsA("ModuleScript") then
 108 | 		local message = ("Attempted to require non-ModuleScript object %q (%s)"):format(
 109 | 			instance.Name,
 110 | 			instance.ClassName
 111 | 		)
 112 | 		error(message, 2)
 113 | 	end
 114 | 
 115 | 	local internalInstance = getmetatable(instance).instance
 116 | 	if internalInstance.moduleLoaded then
 117 | 		return internalInstance.moduleResult
 118 | 	end
 119 | 
 120 | 	local chunk = assert(loadstring(instance.Source, "@" .. internalInstance.modulePath))
 121 | 
 122 | 	local environment = assign({}, self.environment, { script = instance })
 123 | 	setfenv(chunk, environment)
 124 | 
 125 | 	local result = chunk()
 126 | 
 127 | 	internalInstance.moduleLoaded = true
 128 | 	internalInstance.moduleResult = result
 129 | 
 130 | 	return result
 131 | end
 132 | 
 133 | return Habitat
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/init.lua`
<details>
<summary>View Source (8 lines)</summary>

```lua
   1 | local baste = require((...) .. ".baste")
   2 | 
   3 | local Habitat = baste.import("./Habitat")
   4 | local Instance = baste.import("./Instance")
   5 | 
   6 | return {
   7 | 	Habitat = Habitat,
   8 | 	Instance = Instance,
   9 | }
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/init_spec.lua`
<details>
<summary>View Source (6 lines)</summary>

```lua
   1 | local lemur = require("lib")
   2 | 
   3 | describe("init", function()
   4 | 	it("should load", function()
   5 | 		assert.not_nil(lemur)
   6 | 	end)
   7 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/Instance.lua`
<details>
<summary>View Source (17 lines)</summary>

```lua
   1 | local instances = import("./instances")
   2 | 
   3 | local Instance = {}
   4 | 
   5 | function Instance.new(className, parent)
   6 | 	local class = instances[className]
   7 | 
   8 | 	if class == nil or not class.options.creatable then
   9 | 		error(string.format("Can't make an instance of type %q", tostring(className)), 2)
  10 | 	end
  11 | 
  12 | 	local instance = class:new()
  13 | 	instance.Parent = parent
  14 | 
  15 | 	return instance
  16 | end
  17 | 
  18 | return Instance
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/Instance_spec.lua`
<details>
<summary>View Source (32 lines)</summary>

```lua
   1 | local Instance = import("./Instance")
   2 | 
   3 | describe("Instance", function()
   4 | 	it("should create instances of objects", function()
   5 | 		local new = Instance.new("Folder")
   6 | 
   7 | 		assert.not_nil(new)
   8 | 	end)
   9 | 
  10 | 	it("should error when given invalid instance names", function()
  11 | 		assert.has.errors(function()
  12 | 			Instance.new("ugh no")
  13 | 		end)
  14 | 	end)
  15 | 
  16 | 	describe("Parent", function()
  17 | 		it("should be set to nil by default", function()
  18 | 			local instance = Instance.new("Folder")
  19 | 
  20 | 			assert.equal(instance.Parent, nil)
  21 | 		end)
  22 | 
  23 | 		it("should be set to the given value if available", function()
  24 | 			local parent = Instance.new("Folder")
  25 | 
  26 | 			local child = Instance.new("Folder", parent)
  27 | 			child.Name = "foo"
  28 | 
  29 | 			assert.equal(child.Parent, parent)
  30 | 			assert.equal(parent:FindFirstChild("foo"), child)
  31 | 		end)
  32 | 	end)
  33 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/InstanceProperty.lua`
<details>
<summary>View Source (64 lines)</summary>

```lua
   1 | local typeof = import("./functions/typeof")
   2 | local assign = import("./assign")
   3 | 
   4 | local InstanceProperty = {}
   5 | 
   6 | function InstanceProperty.normal(config)
   7 | 	return assign({}, {
   8 | 		get = function(self, key)
   9 | 			return getmetatable(self).instance.properties[key]
  10 | 		end,
  11 | 		set = function(self, key, value)
  12 | 			getmetatable(self).instance.properties[key] = value
  13 | 		end,
  14 | 		getDefault = function()
  15 | 			return nil
  16 | 		end,
  17 | 	}, config)
  18 | end
  19 | 
  20 | function InstanceProperty.readOnly(config)
  21 | 	return assign(InstanceProperty.normal(config), {
  22 | 		set = function(self, key, value)
  23 | 			error(string.format("Unable to assign property %s. Script write access is restricted.", key))
  24 | 		end,
  25 | 	}, config)
  26 | end
  27 | 
  28 | --[[
  29 | 	This method forces the value of a setter to be typed.
  30 | 
  31 | 	`type` is a string paramater that is compared to typeof(value)
  32 | ]]
  33 | function InstanceProperty.typed(type, config)
  34 | 	return assign(InstanceProperty.normal(config), {
  35 | 		set = function(self, key, value)
  36 | 			local passedType = typeof(value)
  37 | 
  38 | 			if passedType ~= type then
  39 | 				error(string.format("%s must be of type %s, received type %s", key, type, passedType), 2)
  40 | 			end
  41 | 
  42 | 			getmetatable(self).instance.properties[key] = value
  43 | 		end,
  44 | 	}, config)
  45 | end
  46 | 
  47 | function InstanceProperty.enum(enum, config)
  48 | 	return assign(InstanceProperty.normal(config), {
  49 | 		set = function(self, key, value)
  50 | 			local passedType = typeof(value)
  51 | 
  52 | 			if passedType ~= "EnumItem" then
  53 | 				error(string.format("Expected enum from %s, received type %s", tostring(enum), passedType), 2)
  54 | 			end
  55 | 
  56 | 			if value.EnumType ~= enum then
  57 | 				error(string.format("Expected enum from %s, got enum from %s", tostring(enum), tostring(value.EnumType)), 2)
  58 | 			end
  59 | 
  60 | 			getmetatable(self).instance.properties[key] = value
  61 | 		end,
  62 | 	}, config)
  63 | end
  64 | 
  65 | return InstanceProperty
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/AnalyticsService.lua`
<details>
<summary>View Source (3 lines)</summary>

```lua
   1 | local BaseInstance = import("./BaseInstance")
   2 | local AnalyticsService = BaseInstance:extend("AnalyticsService")
   3 | 
   4 | return AnalyticsService
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/AnalyticsService_spec.lua`
<details>
<summary>View Source (8 lines)</summary>

```lua
   1 | local AnalyticsService = import("./AnalyticsService")
   2 | 
   3 | describe("instances.AnalyticsService", function()
   4 | 	it("should instantiate", function()
   5 | 		local instance = AnalyticsService:new()
   6 | 
   7 | 		assert.not_nil(instance)
   8 | 	end)
   9 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/BaseInstance.lua`
<details>
<summary>View Source (394 lines)</summary>

```lua
   1 | --[[
   2 | 	Provides a base implementation for all Instances in Lemur.
   3 | 
   4 | 	When adding a new instance, you can define:
   5 | 	* properties, using helpers in InstanceProperty
   6 | 	* prototype, used for defining methods and static values
   7 | 	* init, called by the class's constructor
   8 | ]]
   9 | 
  10 | local assign = import("../assign")
  11 | local InstanceProperty = import("../InstanceProperty")
  12 | local Signal = import("../Signal")
  13 | local typeKey = import("../typeKey")
  14 | 
  15 | local function isInstance(value)
  16 | 	local metatable = getmetatable(value)
  17 | 
  18 | 	return metatable and metatable.instance ~= nil
  19 | end
  20 | 
  21 | local BaseInstance = {}
  22 | 
  23 | BaseInstance.options = {
  24 | 	creatable = false,
  25 | }
  26 | 
  27 | BaseInstance.name = "Instance"
  28 | 
  29 | BaseInstance.properties = {}
  30 | 
  31 | BaseInstance.properties.Name = InstanceProperty.normal({
  32 | 	getDefault = function(self)
  33 | 		return getmetatable(self).class.name
  34 | 	end,
  35 | })
  36 | 
  37 | BaseInstance.properties.ClassName = InstanceProperty.readOnly({
  38 | 	getDefault = function(self)
  39 | 		return getmetatable(self).class.name
  40 | 	end,
  41 | })
  42 | 
  43 | BaseInstance.properties.AncestryChanged = InstanceProperty.readOnly({
  44 | 	getDefault = function()
  45 | 		return Signal.new()
  46 | 	end,
  47 | })
  48 | 
  49 | BaseInstance.properties.Changed = InstanceProperty.readOnly({
  50 | 	getDefault = function()
  51 | 		return Signal.new()
  52 | 	end,
  53 | })
  54 | 
  55 | BaseInstance.properties.ChildAdded = InstanceProperty.readOnly({
  56 | 	getDefault = Signal.new
  57 | })
  58 | 
  59 | BaseInstance.properties.ChildRemoved = InstanceProperty.readOnly({
  60 | 	getDefault = Signal.new
  61 | })
  62 | 
  63 | BaseInstance.properties.Parent = InstanceProperty.normal({
  64 | 	set = function(self, key, value)
  65 | 		local instance = getmetatable(self).instance
  66 | 
  67 | 		if instance.destroyed then
  68 | 			error("Attempt to set parent after being destroyed!")
  69 | 		end
  70 | 
  71 | 		if instance.properties.Parent == value then
  72 | 			return
  73 | 		end
  74 | 
  75 | 		if value ~= nil and not isInstance(value) then
  76 | 			error(string.format("Can't set Parent to %q; Parent must be an Instance!"), tostring(value))
  77 | 		end
  78 | 
  79 | 		if instance.properties.Parent ~= nil then
  80 | 			getmetatable(instance.properties.Parent).instance.children[self] = nil
  81 | 			instance.properties.Parent.ChildRemoved:Fire(self)
  82 | 		end
  83 | 
  84 | 		instance.properties.Parent = value
  85 | 
  86 | 		if value ~= nil then
  87 | 			getmetatable(value).instance.children[self] = true
  88 | 			value.ChildAdded:Fire(self)
  89 | 		end
  90 | 
  91 | 		self:_PropagateAncestryChanged(self, value)
  92 | 	end,
  93 | })
  94 | 
  95 | BaseInstance.prototype = {}
  96 | 
  97 | function BaseInstance.prototype:ClearAllChildren()
  98 | 	local children = getmetatable(self).instance.children
  99 | 
 100 | 	for child in pairs(children) do
 101 | 		child:Destroy()
 102 | 	end
 103 | end
 104 | 
 105 | function BaseInstance.prototype:FindFirstAncestor(name)
 106 | 	local level = self.Parent
 107 | 
 108 | 	while level do
 109 | 		if level.Name == name then
 110 | 			return level
 111 | 		end
 112 | 
 113 | 		level = level.Parent
 114 | 	end
 115 | end
 116 | 
 117 | function BaseInstance.prototype:FindFirstAncestorOfClass(name)
 118 | 	local level = self.Parent
 119 | 
 120 | 	while level do
 121 | 		if level.ClassName == name then
 122 | 			return level
 123 | 		end
 124 | 
 125 | 		level = level.Parent
 126 | 	end
 127 | end
 128 | 
 129 | function BaseInstance.prototype:FindFirstAncestorWhichIsA(className)
 130 | 	local level = self.Parent
 131 | 
 132 | 	while level do
 133 | 		if level:IsA(className) then
 134 | 			return level
 135 | 		end
 136 | 
 137 | 		level = level.Parent
 138 | 	end
 139 | end
 140 | 
 141 | function BaseInstance.prototype:FindFirstChild(name)
 142 | 	local children = getmetatable(self).instance.children
 143 | 
 144 | 	-- Search for existing children
 145 | 	-- This is a set stored by child instead of by name, since names are not unique.
 146 | 	for child in pairs(children) do
 147 | 		if child.Name == name then
 148 | 			return child
 149 | 		end
 150 | 	end
 151 | 
 152 | 	return nil
 153 | end
 154 | 
 155 | function BaseInstance.prototype:FindFirstChildOfClass(className)
 156 | 	local children = getmetatable(self).instance.children
 157 | 
 158 | 	-- Search for existing children
 159 | 	-- This is a set stored by child instead of by name, since names are not unique.
 160 | 	for child in pairs(children) do
 161 | 		if child.ClassName == className then
 162 | 			return child
 163 | 		end
 164 | 	end
 165 | 
 166 | 	return nil
 167 | end
 168 | 
 169 | function BaseInstance.prototype:FindFirstChildWhichIsA(className)
 170 | 	local children = getmetatable(self).instance.children
 171 | 
 172 | 	-- Search for existing children
 173 | 	-- This is a set stored by child instead of by name, since names are not unique.
 174 | 	for child in pairs(children) do
 175 | 		if child:IsA(className) then
 176 | 			return child
 177 | 		end
 178 | 	end
 179 | 
 180 | 	return nil
 181 | end
 182 | 
 183 | function BaseInstance.prototype:GetChildren()
 184 | 	local children = getmetatable(self).instance.children
 185 | 	local result = {}
 186 | 
 187 | 	for child in pairs(children) do
 188 | 		table.insert(result, child)
 189 | 	end
 190 | 
 191 | 	return result
 192 | end
 193 | 
 194 | function BaseInstance.prototype:GetDescendants()
 195 | 	local stack = {}
 196 | 	local descendants = {}
 197 | 	local current = self
 198 | 
 199 | 	while current do
 200 | 		local children = current:GetChildren()
 201 | 
 202 | 		for _, child in pairs(children) do
 203 | 			descendants[#descendants + 1] = child
 204 | 			stack[#stack + 1] = child
 205 | 		end
 206 | 
 207 | 		current = stack[#stack]
 208 | 		stack[#stack] = nil
 209 | 	end
 210 | 
 211 | 	return descendants
 212 | end
 213 | 
 214 | function BaseInstance.prototype:IsA(className)
 215 | 	local currentClass = getmetatable(self).class
 216 | 
 217 | 	while currentClass ~= nil do
 218 | 		if currentClass.name == className then
 219 | 			return true
 220 | 		end
 221 | 
 222 | 		currentClass = currentClass.super
 223 | 	end
 224 | 
 225 | 	return false
 226 | end
 227 | 
 228 | function BaseInstance.prototype:IsDescendantOf(object)
 229 | 	local parent = self
 230 | 
 231 | 	repeat
 232 | 		parent = parent.Parent
 233 | 	until parent == nil or parent == object
 234 | 
 235 | 	return parent == object
 236 | end
 237 | 
 238 | function BaseInstance.prototype:Destroy()
 239 | 	self:ClearAllChildren()
 240 | 
 241 | 	if self.Parent ~= nil then
 242 | 		self.Parent = nil
 243 | 	end
 244 | 
 245 | 	self:_DisconnectAllChangedListeners()
 246 | 
 247 | 	getmetatable(self).instance.destroyed = true
 248 | end
 249 | 
 250 | function BaseInstance.prototype:GetPropertyChangedSignal(key)
 251 | 	local properties = getmetatable(self).class.properties
 252 | 	local propertySignals = getmetatable(self).instance.propertySignals
 253 | 
 254 | 	local listener = propertySignals[key]
 255 | 
 256 | 	if not listener then
 257 | 		assert(properties[key], key .. " is not a valid property name.")
 258 | 
 259 | 		listener = Signal.new()
 260 | 		propertySignals[key] = listener
 261 | 	end
 262 | 
 263 | 	return listener
 264 | end
 265 | 
 266 | function BaseInstance.prototype:GetFullName()
 267 | 	local name = self.Name
 268 | 	local level = self.Parent
 269 | 
 270 | 	while level and getmetatable(level).class.name ~= "DataModel" do
 271 | 		name = level.Name .. "." .. name
 272 | 		level = level.Parent
 273 | 	end
 274 | 
 275 | 	return name
 276 | end
 277 | 
 278 | function BaseInstance.prototype:WaitForChild(name, delay)
 279 | 	return self:FindFirstChild(name)
 280 | end
 281 | 
 282 | function BaseInstance.prototype:_DisconnectAllChangedListeners()
 283 | 	local propertySignals = getmetatable(self).instance.propertySignals
 284 | 
 285 | 	for _, signal in pairs(propertySignals) do
 286 | 		signal:_DisconnectAllListeners()
 287 | 	end
 288 | 
 289 | 	self.Changed:_DisconnectAllListeners()
 290 | end
 291 | 
 292 | function BaseInstance.prototype:_PropagateAncestryChanged(instance, parent)
 293 | 	self.AncestryChanged:Fire(instance, parent)
 294 | 
 295 | 	local children = getmetatable(self).instance.children
 296 | 
 297 | 	for child in pairs(children) do
 298 | 		child:_PropagateAncestryChanged(instance, parent)
 299 | 	end
 300 | end
 301 | 
 302 | BaseInstance.metatable = {}
 303 | BaseInstance.metatable[typeKey] = "Instance"
 304 | 
 305 | function BaseInstance.metatable.__index(self, key)
 306 | 	local class = getmetatable(self).class
 307 | 
 308 | 	if class.properties[key] then
 309 | 		return class.properties[key].get(self, key)
 310 | 	end
 311 | 
 312 | 	if class.prototype[key] then
 313 | 		return class.prototype[key]
 314 | 	end
 315 | 
 316 | 	local object = self:FindFirstChild(key)
 317 | 	if object then
 318 | 		return object
 319 | 	end
 320 | 
 321 | 	error(string.format("%q is not a valid member of %s", tostring(key), self.ClassName), 2)
 322 | end
 323 | 
 324 | function BaseInstance.metatable.__newindex(self, key, value)
 325 | 	local class = getmetatable(self).class
 326 | 
 327 | 	if class.properties[key] then
 328 | 		class.properties[key].set(self, key, value)
 329 | 
 330 | 		self.Changed:Fire(key)
 331 | 
 332 | 		local propertyChangedSignal = getmetatable(self).instance.propertySignals[key]
 333 | 
 334 | 		if propertyChangedSignal then
 335 | 			propertyChangedSignal:Fire()
 336 | 		end
 337 | 
 338 | 		return
 339 | 	end
 340 | 
 341 | 	error(string.format("%q is not a valid member of %s", tostring(key), self.ClassName), 2)
 342 | end
 343 | 
 344 | function BaseInstance.metatable:__tostring()
 345 | 	return self.Name
 346 | end
 347 | 
 348 | function BaseInstance:new(...)
 349 | 	local internalInstance = {
 350 | 		destroyed = false,
 351 | 		properties = {},
 352 | 		propertySignals = {},
 353 | 		children = {},
 354 | 	}
 355 | 
 356 | 	local instance = newproxy(true)
 357 | 
 358 | 	-- Because userdata have a fixed metatable, merge values onto it.
 359 | 	assign(getmetatable(instance), self.metatable)
 360 | 	getmetatable(instance).instance = internalInstance
 361 | 	getmetatable(instance).class = self
 362 | 
 363 | 	for key, property in pairs(self.properties) do
 364 | 		internalInstance.properties[key] = property.getDefault(instance)
 365 | 	end
 366 | 
 367 | 	self:init(instance, ...)
 368 | 
 369 | 	return instance
 370 | end
 371 | 
 372 | function BaseInstance:init(instance, ...)
 373 | end
 374 | 
 375 | --[[
 376 | 	Create a new instance class with the given name.
 377 | ]]
 378 | function BaseInstance:extend(name, options)
 379 | 	assert(type(name) == "string", "Expected string 'name' as argument #1.")
 380 | 	assert(type(options) == "table" or options == nil, "Expected optional table 'options' as argument #2.")
 381 | 
 382 | 	local newClass = assign({}, self)
 383 | 
 384 | 	newClass.name = name
 385 | 	newClass.super = self
 386 | 
 387 | 	newClass.properties = assign({}, self.properties)
 388 | 	newClass.prototype = assign({}, self.prototype)
 389 | 	newClass.metatable = assign({}, self.metatable)
 390 | 	newClass.options = assign({}, self.options, options or {})
 391 | 
 392 | 	return newClass
 393 | end
 394 | 
 395 | return BaseInstance
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/BaseInstance_spec.lua`
<details>
<summary>View Source (721 lines)</summary>

```lua
   1 | local Game = import("./Game")
   2 | local Folder = import("./Folder")
   3 | local typeof = import("../functions/typeof")
   4 | 
   5 | local BaseInstance = import("./BaseInstance")
   6 | 
   7 | describe("instances.BaseInstance", function()
   8 | 	it("should error when parenting instances to invalid objects", function()
   9 | 		local new = BaseInstance:new()
  10 | 
  11 | 		assert.has.errors(function()
  12 | 			new.Parent = 7
  13 | 		end)
  14 | 	end)
  15 | 
  16 | 	it("should error when setting unknown values", function()
  17 | 		local new = BaseInstance:new()
  18 | 
  19 | 		assert.has.errors(function()
  20 | 			new.frobulations = 6
  21 | 		end)
  22 | 	end)
  23 | 
  24 | 	it("should error when indexing invalid instances", function()
  25 | 		local instance = BaseInstance:new()
  26 | 
  27 | 		local function nop()
  28 | 		end
  29 | 
  30 | 		assert.has.errors(function()
  31 | 			nop(instance.neverWillEXIST)
  32 | 		end)
  33 | 	end)
  34 | 
  35 | 	it("should be identified by typeof", function()
  36 | 		local instance = BaseInstance:new()
  37 | 
  38 | 		assert.equal(typeof(instance), "Instance")
  39 | 	end)
  40 | 
  41 | 	it("should allow the change and read of Name", function()
  42 | 		local instance = BaseInstance:new()
  43 | 		assert.equal(instance.Name, "Instance")
  44 | 
  45 | 		instance.Name = "Foobar"
  46 | 		assert.equal(instance.Name, "Foobar")
  47 | 	end)
  48 | 
  49 | 	it("should not allow the change of ClassName", function()
  50 | 		local instance = BaseInstance:new()
  51 | 
  52 | 		assert.has.errors(function()
  53 | 			instance.ClassName = "Foobar"
  54 | 		end)
  55 | 	end)
  56 | 
  57 | 	describe("Parent", function()
  58 | 		it("should set to nil", function()
  59 | 			local parent = BaseInstance:new()
  60 | 
  61 | 			local child = BaseInstance:new()
  62 | 			child.Parent = parent
  63 | 			child.Name = "foo"
  64 | 
  65 | 			assert.equal(parent:FindFirstChild("foo"), child)
  66 | 
  67 | 			child.Parent = nil
  68 | 
  69 | 			assert.equal(parent:FindFirstChild("foo"), nil)
  70 | 		end)
  71 | 
  72 | 		it("should set to other instances", function()
  73 | 			local parent1 = BaseInstance:new()
  74 | 			local parent2 = BaseInstance:new()
  75 | 
  76 | 			local child = BaseInstance:new()
  77 | 			child.Parent = parent1
  78 | 			child.Name = "foo"
  79 | 
  80 | 			assert.equal(parent1:FindFirstChild("foo"), child)
  81 | 
  82 | 			child.Parent = parent2
  83 | 
  84 | 			assert.equal(parent1:FindFirstChild("foo"), nil)
  85 | 			assert.equal(child.Parent, parent2)
  86 | 			assert.equal(parent2:FindFirstChild("foo"), child)
  87 | 		end)
  88 | 
  89 | 		-- This may seem like a weird test, but it's for 100% coverage
  90 | 		it("shouldn't react differently when setting the parent to the existing parent", function()
  91 | 			local parent = BaseInstance:new()
  92 | 			local child = BaseInstance:new()
  93 | 			child.Parent = parent
  94 | 
  95 | 			assert.has_no_errors(function()
  96 | 				child.Parent = parent
  97 | 			end)
  98 | 		end)
  99 | 	end)
 100 | 
 101 | 	describe("FindFirstChild", function()
 102 | 		it("should never error on invalid index", function()
 103 | 			local instance = BaseInstance:new()
 104 | 
 105 | 			assert.equal(instance:FindFirstChild("NEVER. WILL. EXIST!"), nil)
 106 | 		end)
 107 | 	end)
 108 | 
 109 | 	describe("GetChildren", function()
 110 | 		it("should return no children for empty instances", function()
 111 | 			local instance = BaseInstance:new()
 112 | 
 113 | 			assert.equal(#instance:GetChildren(), 0)
 114 | 		end)
 115 | 
 116 | 		it("should yield all children", function()
 117 | 			local parent = BaseInstance:new()
 118 | 
 119 | 			local child1 = BaseInstance:new()
 120 | 			child1.Parent = parent
 121 | 
 122 | 			local child2 = BaseInstance:new()
 123 | 			child2.Parent = parent
 124 | 
 125 | 			assert.equal(#parent:GetChildren(), 2)
 126 | 
 127 | 			local child1Seen = false
 128 | 			local child2Seen = false
 129 | 			for _, child in ipairs(parent:GetChildren()) do
 130 | 				if child == child1 then
 131 | 					child1Seen = true
 132 | 				elseif child == child2 then
 133 | 					child2Seen = true
 134 | 				else
 135 | 					error("Invalid child found")
 136 | 				end
 137 | 			end
 138 | 
 139 | 			assert.equal(child1Seen, true)
 140 | 			assert.equal(child2Seen, true)
 141 | 		end)
 142 | 	end)
 143 | 
 144 | 	describe("GetDescendants", function()
 145 | 		it("should return no descendants for empty instances", function()
 146 | 			local instance = BaseInstance:new()
 147 | 
 148 | 			assert.equal(#instance:GetDescendants(), 0)
 149 | 		end)
 150 | 
 151 | 		it("should return all first level children", function()
 152 | 			local parent = BaseInstance:new()
 153 | 
 154 | 			local child1 = BaseInstance:new()
 155 | 			child1.Parent = parent
 156 | 
 157 | 			local child2 = BaseInstance:new()
 158 | 			child2.Parent = parent
 159 | 
 160 | 			assert.equal(#parent:GetDescendants(), 2)
 161 | 
 162 | 			local child1Seen = false
 163 | 			local child2Seen = false
 164 | 			for _, child in ipairs(parent:GetDescendants()) do
 165 | 				if child == child1 then
 166 | 					child1Seen = true
 167 | 				elseif child == child2 then
 168 | 					child2Seen = true
 169 | 				else
 170 | 					error("Invalid child found")
 171 | 				end
 172 | 			end
 173 | 
 174 | 			assert.equal(child1Seen, true)
 175 | 			assert.equal(child2Seen, true)
 176 | 		end)
 177 | 
 178 | 		it("should return all descendants", function()
 179 | 			local parent = BaseInstance:new()
 180 | 
 181 | 			local child1 = BaseInstance:new()
 182 | 			child1.Parent = parent
 183 | 
 184 | 			local child2 = BaseInstance:new()
 185 | 			child2.Parent = parent
 186 | 
 187 | 			local child3 = BaseInstance:new()
 188 | 			child3.Parent = child2
 189 | 
 190 | 			assert.equal(#parent:GetDescendants(), 3)
 191 | 
 192 | 			local child1Seen = false
 193 | 			local child2Seen = false
 194 | 			local child3Seen = false
 195 | 			for _, child in ipairs(parent:GetDescendants()) do
 196 | 				if child == child1 then
 197 | 					child1Seen = true
 198 | 				elseif child == child2 then
 199 | 					child2Seen = true
 200 | 				elseif child == child3 then
 201 | 					child3Seen = true
 202 | 				else
 203 | 					error("Invalid child found")
 204 | 				end
 205 | 			end
 206 | 
 207 | 			assert.equal(child1Seen, true)
 208 | 			assert.equal(child2Seen, true)
 209 | 			assert.equal(child3Seen, true)
 210 | 		end)
 211 | 	end)
 212 | 
 213 | 	describe("WaitForChild", function()
 214 | 		it("should work just like FindFirstChild", function()
 215 | 			local parent = BaseInstance:new()
 216 | 
 217 | 			local child = BaseInstance:new()
 218 | 			child.Parent = parent
 219 | 			child.Name = "foo"
 220 | 
 221 | 			local result = parent:WaitForChild("foo")
 222 | 			assert.equal(result, child)
 223 | 
 224 | 			child.Parent = nil
 225 | 			result = parent:WaitForChild("foo")
 226 | 			assert.equal(result, nil)
 227 | 		end)
 228 | 	end)
 229 | 
 230 | 	describe("Destroy", function()
 231 | 		it("should set the instance's Parent to nil", function()
 232 | 			local parent = BaseInstance:new()
 233 | 			local child = BaseInstance:new()
 234 | 			child.Parent = parent
 235 | 
 236 | 			assert.equal(child.Parent, parent)
 237 | 
 238 | 			child:Destroy()
 239 | 
 240 | 			assert.equal(child.Parent, nil)
 241 | 		end)
 242 | 
 243 | 		it("should set the children's parents to nil", function()
 244 | 			local parent = BaseInstance:new()
 245 | 			local child = BaseInstance:new()
 246 | 			child.Parent = parent
 247 | 
 248 | 			parent:Destroy()
 249 | 			assert.equal(child.Parent, nil)
 250 | 		end)
 251 | 
 252 | 		it("should lock the parent property", function()
 253 | 			local instance = BaseInstance:new()
 254 | 			local badParent = BaseInstance:new()
 255 | 
 256 | 			instance:Destroy()
 257 | 
 258 | 			assert.has.errors(function()
 259 | 				instance.Parent = badParent
 260 | 			end)
 261 | 		end)
 262 | 
 263 | 		it("should only lock its own instance, and not all of the same type", function()
 264 | 			local destroyFolder = BaseInstance:new()
 265 | 			destroyFolder:Destroy()
 266 | 			assert.equal(destroyFolder.Parent, nil)
 267 | 
 268 | 			local goodParent = BaseInstance:new()
 269 | 			local goodFolder = BaseInstance:new()
 270 | 
 271 | 			assert.has_no.errors(function()
 272 | 				goodFolder.Parent = goodParent
 273 | 			end)
 274 | 		end)
 275 | 
 276 | 		it("should disconnect all Changed listeners", function()
 277 | 			local instance = BaseInstance:new()
 278 | 
 279 | 			local calls = 0
 280 | 			instance.Changed:Connect(function()
 281 | 				calls = calls + 1
 282 | 			end)
 283 | 
 284 | 			instance.Name = "Foo"
 285 | 
 286 | 			assert.equal(calls, 1)
 287 | 
 288 | 			instance:Destroy()
 289 | 			instance.Name = "Bar"
 290 | 
 291 | 			assert.equal(calls, 1)
 292 | 		end)
 293 | 
 294 | 		it("should disconnect all GetPropertyChangedSignal listeners", function()
 295 | 			local instance = BaseInstance:new()
 296 | 
 297 | 			local callsA = 0
 298 | 			local callsB = 0
 299 | 
 300 | 			instance:GetPropertyChangedSignal("Name"):Connect(function()
 301 | 				callsA = callsA + 1
 302 | 			end)
 303 | 
 304 | 			instance:GetPropertyChangedSignal("Name"):Connect(function()
 305 | 				callsB = callsB + 1
 306 | 			end)
 307 | 
 308 | 			instance.Name = "Foo"
 309 | 
 310 | 			assert.equal(callsA, 1)
 311 | 			assert.equal(callsB, 1)
 312 | 
 313 | 			instance:Destroy()
 314 | 			instance.Name = "Bar"
 315 | 
 316 | 			assert.equal(callsA, 1)
 317 | 			assert.equal(callsB, 1)
 318 | 		end)
 319 | 	end)
 320 | 
 321 | 	describe("IsA", function()
 322 | 		it("should check the class's hierarchy", function()
 323 | 			local ClassA = BaseInstance:extend("ClassA")
 324 | 			local ClassB = ClassA:extend("ClassB")
 325 | 			local ClassC = ClassB:extend("ClassC")
 326 | 
 327 | 			local instance = BaseInstance:new()
 328 | 			local objA = ClassA:new()
 329 | 			local objB = ClassB:new()
 330 | 			local objC = ClassC:new()
 331 | 
 332 | 			assert.False(instance:IsA("ClassC"))
 333 | 			assert.False(instance:IsA("ClassB"))
 334 | 			assert.False(instance:IsA("ClassA"))
 335 | 			assert.True(instance:IsA("Instance"))
 336 | 
 337 | 			assert.False(objA:IsA("ClassC"))
 338 | 			assert.False(objA:IsA("ClassB"))
 339 | 			assert.True(objA:IsA("ClassA"))
 340 | 			assert.True(objA:IsA("Instance"))
 341 | 
 342 | 			assert.False(objB:IsA("ClassC"))
 343 | 			assert.True(objB:IsA("ClassB"))
 344 | 			assert.True(objB:IsA("ClassA"))
 345 | 			assert.True(objB:IsA("Instance"))
 346 | 
 347 | 			assert.True(objC:IsA("ClassC"))
 348 | 			assert.True(objC:IsA("ClassB"))
 349 | 			assert.True(objC:IsA("ClassA"))
 350 | 			assert.True(objC:IsA("Instance"))
 351 | 		end)
 352 | 	end)
 353 | 
 354 | 	describe("IsDescendantOf", function()
 355 | 		it("should return true when the instance is a descendant of the passed argument", function()
 356 | 			local parent = BaseInstance:new()
 357 | 
 358 | 			local child = BaseInstance:new()
 359 | 			child.Parent = parent
 360 | 			assert.True(child:IsDescendantOf(parent))
 361 | 
 362 | 			local descendant = BaseInstance:new()
 363 | 			descendant.Parent = child
 364 | 			assert.True(descendant:IsDescendantOf(parent))
 365 | 		end)
 366 | 
 367 | 		it("should return false when the instance is not a descendant of the passed argument", function()
 368 | 			local parent = BaseInstance:new()
 369 | 			local somethingElse = BaseInstance:new()
 370 | 			assert.False(parent:IsDescendantOf(somethingElse))
 371 | 
 372 | 			local child = BaseInstance:new()
 373 | 			child.Parent = parent
 374 | 			assert.False(child:IsDescendantOf(somethingElse))
 375 | 
 376 | 			local descendant = BaseInstance:new()
 377 | 			descendant.Parent = child
 378 | 			assert.False(descendant:IsDescendantOf(somethingElse))
 379 | 		end)
 380 | 
 381 | 		-- Weird, but documented, behavior (https://www.robloxdev.com/api-reference/function/Instance/IsDescendantOf).
 382 | 		it("should always return true for nil", function()
 383 | 			assert.True(BaseInstance:new():IsDescendantOf(nil))
 384 | 		end)
 385 | 	end)
 386 | 
 387 | 	describe("GetFullName", function()
 388 | 		it("should get the full name", function()
 389 | 			local instance = BaseInstance:new()
 390 | 			instance.Name = "Test"
 391 | 			local other = BaseInstance:new()
 392 | 			other.Name = "Parent"
 393 | 
 394 | 			instance.Parent = other
 395 | 
 396 | 			local fullName = instance:GetFullName()
 397 | 			assert.equal("Parent.Test", fullName)
 398 | 		end)
 399 | 
 400 | 		it("should exclude game", function()
 401 | 			local instance = BaseInstance:new()
 402 | 			instance.Name = "Test"
 403 | 			local other = Game:new()
 404 | 			other.Name = "Parent"
 405 | 
 406 | 			instance.Parent = other
 407 | 
 408 | 			local fullName = instance:GetFullName()
 409 | 			assert.equal("Test", fullName)
 410 | 		end)
 411 | 
 412 | 		it("should return the instance name if there is no parent", function()
 413 | 			local instance = BaseInstance:new()
 414 | 			instance.Name = "Test"
 415 | 
 416 | 			local fullName = instance:GetFullName()
 417 | 			assert.equal("Test", fullName)
 418 | 		end)
 419 | 	end)
 420 | 
 421 | 	describe("tostring", function()
 422 | 		it("should match the name of the instance", function()
 423 | 			local instance = BaseInstance:new()
 424 | 			instance.Name = "foo"
 425 | 
 426 | 			assert.equal(tostring(instance), "foo")
 427 | 		end)
 428 | 	end)
 429 | 
 430 | 	describe("Changed", function()
 431 | 		it("should fire Changed", function()
 432 | 			local instance = BaseInstance:new()
 433 | 
 434 | 			local changedSpy = spy.new(function() end)
 435 | 			instance.Changed:Connect(changedSpy)
 436 | 
 437 | 			instance.Name = "NameChange"
 438 | 			assert.spy(changedSpy).was.called_with("Name")
 439 | 		end)
 440 | 	end)
 441 | 
 442 | 	describe("GetPropertyChangedSignal", function()
 443 | 		it("should fire property signals for the right property", function()
 444 | 			local instance = BaseInstance:new()
 445 | 			local spy = spy.new(function() end)
 446 | 			instance:GetPropertyChangedSignal("Name"):Connect(spy)
 447 | 			instance.Name = "NameChange"
 448 | 			assert.spy(spy).was.called()
 449 | 		end)
 450 | 
 451 | 		it("should not fire property signals for the incorrect property", function()
 452 | 			local instance = BaseInstance:new()
 453 | 			local spy = spy.new(function() end)
 454 | 			instance:GetPropertyChangedSignal("Parent"):Connect(spy)
 455 | 			instance.Name = "NameChange2"
 456 | 			assert.spy(spy).was_not_called()
 457 | 		end)
 458 | 
 459 | 		it("should error when given an invalid property name", function()
 460 | 			local instance = BaseInstance:new()
 461 | 			assert.has.errors(function()
 462 | 				instance:GetPropertyChangedSignal("CanDestroyTheWorld"):Connect(function() end)
 463 | 			end)
 464 | 		end)
 465 | 	end)
 466 | 
 467 | 	describe("ClearAllChildren", function()
 468 | 		it("should clear children", function()
 469 | 			local parent = BaseInstance:new()
 470 | 			local child = BaseInstance:new()
 471 | 			child.Parent = parent
 472 | 
 473 | 			parent:ClearAllChildren()
 474 | 			assert.equal(child.Parent, nil)
 475 | 		end)
 476 | 	end)
 477 | 
 478 | 	describe("FindFirstAncestor", function()
 479 | 		it("should find ancestors", function()
 480 | 			local parent = BaseInstance:new()
 481 | 			parent.Name = "Ancestor"
 482 | 
 483 | 			local child = BaseInstance:new()
 484 | 			child.Parent = parent
 485 | 
 486 | 			assert.equal(child:FindFirstAncestor("Ancestor"), parent)
 487 | 		end)
 488 | 
 489 | 		it("should return nil with no matching ancestor", function()
 490 | 			local parent = BaseInstance:new()
 491 | 			local child = BaseInstance:new()
 492 | 			child.Parent = parent
 493 | 
 494 | 			assert.equal(child:FindFirstAncestor("Ancestor"), nil)
 495 | 		end)
 496 | 
 497 | 		it("should return nil with no ancestor", function()
 498 | 			local child = BaseInstance:new()
 499 | 
 500 | 			assert.equal(child:FindFirstAncestor("Ancestor"), nil)
 501 | 		end)
 502 | 	end)
 503 | 
 504 | 	describe("FindFirstAncestorOfClass", function()
 505 | 		it("should find ancestors", function()
 506 | 			local parent = BaseInstance:new()
 507 | 			local child = BaseInstance:new()
 508 | 			child.Parent = parent
 509 | 
 510 | 			assert.equal(child:FindFirstAncestorOfClass("Instance"), parent)
 511 | 		end)
 512 | 
 513 | 		it("should return nil with no matching ancestor", function()
 514 | 			local parent = BaseInstance:new()
 515 | 			local child = BaseInstance:new()
 516 | 			child.Parent = parent
 517 | 
 518 | 			assert.equal(child:FindFirstAncestorOfClass("Ancestor"), nil)
 519 | 		end)
 520 | 
 521 | 		it("should return nil with no ancestor", function()
 522 | 			local child = BaseInstance:new()
 523 | 
 524 | 			assert.equal(child:FindFirstAncestorOfClass("Instance"), nil)
 525 | 		end)
 526 | 	end)
 527 | 
 528 | 	describe("FindFirstAncestorWhichIsA", function()
 529 | 		it("should find ancestors", function()
 530 | 			local parent = BaseInstance:new()
 531 | 			local child = BaseInstance:new()
 532 | 			child.Parent = parent
 533 | 
 534 | 			assert.equal(child:FindFirstAncestorOfClass("Instance"), parent)
 535 | 		end)
 536 | 
 537 | 		it("should return nil with no matching ancestor", function()
 538 | 			local parent = BaseInstance:new()
 539 | 			local child = BaseInstance:new()
 540 | 			child.Parent = parent
 541 | 
 542 | 			assert.equal(child:FindFirstAncestorOfClass("Ancestor"), nil)
 543 | 		end)
 544 | 
 545 | 		it("should return nil with no ancestor", function()
 546 | 			local child = BaseInstance:new()
 547 | 
 548 | 			assert.equal(child:FindFirstAncestorOfClass("Instance"), nil)
 549 | 		end)
 550 | 
 551 | 		it("should handle narrower ancestor classes", function()
 552 | 			local child = BaseInstance:new()
 553 | 			local parent = Folder:new()
 554 | 			child.Parent = parent
 555 | 
 556 | 			assert.equal(child:FindFirstAncestorWhichIsA("Instance"), parent)
 557 | 		end)
 558 | 	end)
 559 | 
 560 | 	describe("FindFirstChildOfClass", function()
 561 | 		it("should find instances", function()
 562 | 			local parent = BaseInstance:new()
 563 | 			local childCorrect = BaseInstance:new()
 564 | 			childCorrect.Parent = parent
 565 | 
 566 | 			local childIncorrect = Folder:new()
 567 | 			childIncorrect.Parent = parent
 568 | 
 569 | 			assert.equal(parent:FindFirstChildOfClass("Instance"), childCorrect)
 570 | 		end)
 571 | 
 572 | 		it("should return nil with no matching child", function()
 573 | 			local parent = BaseInstance:new()
 574 | 
 575 | 			local childIncorrect = BaseInstance:new()
 576 | 			childIncorrect.Parent = parent
 577 | 
 578 | 			assert.equal(parent:FindFirstChildOfClass("Folder"), nil)
 579 | 		end)
 580 | 
 581 | 		it("should return nil with no children", function()
 582 | 			local parent = BaseInstance:new()
 583 | 
 584 | 			assert.equal(parent:FindFirstChildOfClass("Folder"), nil)
 585 | 		end)
 586 | 	end)
 587 | 
 588 | 	describe("FindFirstChildOfClass", function()
 589 | 		it("should find instances", function()
 590 | 			local parent = BaseInstance:new()
 591 | 			local childCorrect = BaseInstance:new()
 592 | 			childCorrect.Parent = parent
 593 | 
 594 | 			local childIncorrect = Folder:new()
 595 | 			childIncorrect.Parent = parent
 596 | 
 597 | 			assert.equal(parent:FindFirstChildWhichIsA("Instance"), childCorrect)
 598 | 		end)
 599 | 
 600 | 		it("should return nil with no matching child", function()
 601 | 			local parent = BaseInstance:new()
 602 | 
 603 | 			local childIncorrect = BaseInstance:new()
 604 | 			childIncorrect.Parent = parent
 605 | 
 606 | 			assert.equal(parent:FindFirstChildWhichIsA("Folder"), nil)
 607 | 		end)
 608 | 
 609 | 		it("should return nil with no children", function()
 610 | 			local parent = BaseInstance:new()
 611 | 
 612 | 			assert.equal(parent:FindFirstChildWhichIsA("Folder"), nil)
 613 | 		end)
 614 | 	end)
 615 | 
 616 | 	describe("super", function()
 617 | 		it("should reference the parent class", function()
 618 | 			local ClassA = BaseInstance:extend("ClassA")
 619 | 			local ClassB = ClassA:extend("ClassB")
 620 | 			local ClassC = ClassB:extend("ClassC")
 621 | 
 622 | 			assert.equals(ClassC.super, ClassB)
 623 | 			assert.equals(ClassB.super, ClassA)
 624 | 			assert.equals(ClassA.super, BaseInstance)
 625 | 			assert.equals(BaseInstance.super, nil)
 626 | 		end)
 627 | 	end)
 628 | 
 629 | 	describe("AncestryChanged", function()
 630 | 		it("should fire when my parent changes", function()
 631 | 			local parent = BaseInstance:new()
 632 | 			local parentSpy = spy.new(function() end)
 633 | 			parent.AncestryChanged:Connect(parentSpy)
 634 | 
 635 | 			local child = BaseInstance:new()
 636 | 			local childSpy = spy.new(function() end)
 637 | 			child.AncestryChanged:Connect(childSpy)
 638 | 
 639 | 			child.Parent = parent
 640 | 			assert.spy(parentSpy).was_not_called()
 641 | 			assert.spy(childSpy).was_called_with(child, parent)
 642 | 
 643 | 			child.Parent = nil
 644 | 			assert.spy(parentSpy).was_not_called()
 645 | 			assert.spy(childSpy).was_called_with(child, nil)
 646 | 		end)
 647 | 
 648 | 		it("should fire when my ancestor changes", function()
 649 | 			local parent = BaseInstance:new()
 650 | 			local parentSpy = spy.new(function() end)
 651 | 			parent.AncestryChanged:Connect(parentSpy)
 652 | 
 653 | 			local child = BaseInstance:new()
 654 | 			local childSpy = spy.new(function() end)
 655 | 			child.AncestryChanged:Connect(childSpy)
 656 | 
 657 | 			local grandchild = BaseInstance:new()
 658 | 			local grandchildSpy = spy.new(function() end)
 659 | 			grandchild.AncestryChanged:Connect(grandchildSpy)
 660 | 
 661 | 			grandchild.Parent = child
 662 | 			assert.spy(parentSpy).was_not_called()
 663 | 			assert.spy(childSpy).was_not_called()
 664 | 			assert.spy(grandchildSpy).was_called_with(grandchild, child)
 665 | 
 666 | 			parentSpy:clear()
 667 | 			childSpy:clear()
 668 | 			grandchildSpy:clear()
 669 | 
 670 | 			child.Parent = parent
 671 | 			assert.spy(parentSpy).was_not_called()
 672 | 			assert.spy(childSpy).was_called_with(child, parent)
 673 | 			assert.spy(grandchildSpy).was_called_with(child, parent)
 674 | 
 675 | 			parentSpy:clear()
 676 | 			childSpy:clear()
 677 | 			grandchildSpy:clear()
 678 | 
 679 | 			child.Parent = nil
 680 | 			assert.spy(parentSpy).was_not_called()
 681 | 			assert.spy(childSpy).was_called_with(child, nil)
 682 | 			assert.spy(grandchildSpy).was_called_with(child, nil)
 683 | 
 684 | 			parentSpy:clear()
 685 | 			childSpy:clear()
 686 | 			grandchildSpy:clear()
 687 | 
 688 | 			grandchild.Parent = nil
 689 | 			assert.spy(parentSpy).was_not_called()
 690 | 			assert.spy(childSpy).was_not_called()
 691 | 			assert.spy(grandchildSpy).was_called_with(grandchild, nil)
 692 | 		end)
 693 | 	end)
 694 | 
 695 | 	describe("ChildAdded", function()
 696 | 		it("should fire when a child is added", function()
 697 | 			local parent = BaseInstance:new()
 698 | 			local child = BaseInstance:new()
 699 | 
 700 | 			local spy = spy.new(function() end)
 701 | 			parent.ChildAdded:Connect(spy)
 702 | 
 703 | 			child.Parent = parent
 704 | 			assert.spy(spy).was_called_with(child)
 705 | 		end)
 706 | 	end)
 707 | 
 708 | 	describe("ChildRemoved", function()
 709 | 		it("should fire when a child is removed", function()
 710 | 			local parent = BaseInstance:new()
 711 | 			local child = BaseInstance:new()
 712 | 			child.Parent = parent
 713 | 
 714 | 			local spy = spy.new(function() end)
 715 | 			parent.ChildRemoved:Connect(spy)
 716 | 
 717 | 			child.Parent = nil
 718 | 
 719 | 			assert.spy(spy).was_called_with(child)
 720 | 		end)
 721 | 	end)
 722 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/BindableEvent.lua`
<details>
<summary>View Source (16 lines)</summary>

```lua
   1 | local Signal = import("../Signal")
   2 | local BaseInstance = import("./BaseInstance")
   3 | local InstanceProperty = import("../InstanceProperty")
   4 | 
   5 | local BindableEvent = BaseInstance:extend("BindableEvent", {
   6 | 	creatable = true,
   7 | })
   8 | 
   9 | BindableEvent.properties.Event = InstanceProperty.readOnly({
  10 | 	getDefault = Signal.new,
  11 | })
  12 | 
  13 | function BindableEvent.prototype:Fire(...)
  14 | 	self.Event:Fire(...)
  15 | end
  16 | 
  17 | return BindableEvent
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/BindableEvent_spec.lua`
<details>
<summary>View Source (20 lines)</summary>

```lua
   1 | local Instance = import("../Instance")
   2 | 
   3 | describe("instances.BindableEvent", function()
   4 | 	it("should instantiate", function()
   5 | 		local instance = Instance.new("BindableEvent")
   6 | 
   7 | 		assert.not_nil(instance)
   8 | 		assert.not_nil(instance.Event)
   9 | 	end)
  10 | 
  11 | 	it("should fire Event when fired", function()
  12 | 		local instance = Instance.new("BindableEvent")
  13 | 
  14 | 		local testSpy = spy.new(function() end)
  15 | 		instance.Event:Connect(testSpy)
  16 | 
  17 | 		instance:Fire()
  18 | 
  19 | 		assert.spy(testSpy).was_called(1)
  20 | 	end)
  21 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/BoolValue.lua`
<details>
<summary>View Source (17 lines)</summary>

```lua
   1 | local BaseInstance = import("./BaseInstance")
   2 | local InstanceProperty = import("../InstanceProperty")
   3 | 
   4 | local BoolValue = BaseInstance:extend("BoolValue", {
   5 | 	creatable = true,
   6 | })
   7 | 
   8 | BoolValue.properties.Value = InstanceProperty.normal({
   9 | 	getDefault = function()
  10 | 		return false
  11 | 	end,
  12 | })
  13 | 
  14 | function BoolValue:init(instance)
  15 | 	instance.Name = "Value"
  16 | end
  17 | 
  18 | return BoolValue
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/BoolValue_spec.lua`
<details>
<summary>View Source (10 lines)</summary>

```lua
   1 | local Instance = import("../Instance")
   2 | 
   3 | describe("instances.BoolValue", function()
   4 | 	it("should instantiate", function()
   5 | 		local instance = Instance.new("BoolValue")
   6 | 
   7 | 		assert.not_nil(instance)
   8 | 		assert.equal("Value", instance.Name)
   9 | 		assert.equal(false, instance.Value)
  10 | 	end)
  11 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/Camera.lua`
<details>
<summary>View Source (14 lines)</summary>

```lua
   1 | local BaseInstance = import("./BaseInstance")
   2 | local Vector2 = import("../types/Vector2")
   3 | local InstanceProperty = import("../InstanceProperty")
   4 | 
   5 | local Camera = BaseInstance:extend("Camera", {
   6 | 	creatable = true,
   7 | })
   8 | 
   9 | Camera.properties.ViewportSize = InstanceProperty.normal({
  10 | 	getDefault = function()
  11 | 		return Vector2.new(800, 600)
  12 | 	end,
  13 | })
  14 | 
  15 | return Camera
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/Camera_spec.lua`
<details>
<summary>View Source (14 lines)</summary>

```lua
   1 | local Instance = import("../Instance")
   2 | local typeof = import("../functions/typeof")
   3 | 
   4 | describe("instances.Camera", function()
   5 | 	it("should instantiate", function()
   6 | 		local instance = Instance.new("Camera")
   7 | 
   8 | 		assert.not_nil(instance)
   9 | 	end)
  10 | 
  11 | 	it("should have properties defined", function()
  12 | 		local instance = Instance.new("Camera")
  13 | 		assert.equal(typeof(instance.ViewportSize), "Vector2")
  14 | 	end)
  15 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/Configuration.lua`
<details>
<summary>View Source (4 lines)</summary>

```lua
   1 | local BaseInstance = import("./BaseInstance")
   2 | 
   3 | return BaseInstance:extend("Configuration", {
   4 | 	creatable = true,
   5 | })
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/Configuration_spec.lua`
<details>
<summary>View Source (8 lines)</summary>

```lua
   1 | local Instance = import("../Instance")
   2 | 
   3 | describe("instances.Configuration", function()
   4 | 	it("should instantiate", function()
   5 | 		local instance = Instance.new("Configuration")
   6 | 
   7 | 		assert.not_nil(instance)
   8 | 	end)
   9 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/ContentProvider.lua`
<details>
<summary>View Source (10 lines)</summary>

```lua
   1 | local BaseInstance = import("./BaseInstance")
   2 | local InstanceProperty = import("../InstanceProperty")
   3 | local ContentProvider = BaseInstance:extend("ContentProvider")
   4 | 
   5 | ContentProvider.properties.BaseUrl = InstanceProperty.normal({
   6 | 	getDefault = function()
   7 | 		return "https://www.roblox.com/"
   8 | 	end,
   9 | })
  10 | 
  11 | return ContentProvider
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/ContentProvider_spec.lua`
<details>
<summary>View Source (14 lines)</summary>

```lua
   1 | local ContentProvider = import("./ContentProvider")
   2 | 
   3 | describe("instances.ContentProvider", function()
   4 | 	it("should instantiate", function()
   5 | 		local instance = ContentProvider:new()
   6 | 
   7 | 		assert.not_nil(instance)
   8 | 	end)
   9 | 
  10 | 	it("should have a string property BaseUrl", function()
  11 | 		local instance = ContentProvider:new()
  12 | 
  13 | 		assert.equals(type(instance.BaseUrl), "string")
  14 | 	end)
  15 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/ContextActionService.lua`
<details>
<summary>View Source (23 lines)</summary>

```lua
   1 | local BaseInstance = import("./BaseInstance")
   2 | local validateType = import("../validateType")
   3 | local ContextActionService = BaseInstance:extend("ContextActionService")
   4 | 
   5 | --[[
   6 | 	These action binding and unbinding functions mimic Roblox's validation
   7 | 	of arguments, but are a little stricter about type expectations:
   8 | 	* Roblox only throws errors on the 'actionName' parameter if it can't cast it to a string
   9 | 
  10 | 	Additionally, Roblox does not throw error in either of these cases:
  11 | 	* Binding a different action to the same name (overwrites existing action)
  12 | 	* Unbinding actions that were never bound does not error
  13 | ]]
  14 | function ContextActionService.prototype:BindCoreAction(actionName, functionToBind, createTouchButton, ...)
  15 | 	validateType("actionName", actionName, "string")
  16 | 	validateType("functionToBind", functionToBind, "function")
  17 | 	validateType("createTouchButton", createTouchButton, "boolean")
  18 | end
  19 | 
  20 | function ContextActionService.prototype:UnbindCoreAction(actionName)
  21 | 	validateType("actionName", actionName, "string")
  22 | end
  23 | 
  24 | return ContextActionService
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/ContextActionService_spec.lua`
<details>
<summary>View Source (18 lines)</summary>

```lua
   1 | local ContextActionService = import("./ContextActionService")
   2 | 
   3 | describe("instances.ContextActionService", function()
   4 | 	it("should instantiate", function()
   5 | 		local instance = ContextActionService:new()
   6 | 
   7 | 		assert.not_nil(instance)
   8 | 	end)
   9 | 
  10 | 	it("should have core binding methods", function()
  11 | 		local instance = ContextActionService:new()
  12 | 
  13 | 		instance:BindCoreAction("Foo", function()
  14 | 			-- no op
  15 | 		end, false)
  16 | 
  17 | 		instance:UnbindCoreAction("Foo")
  18 | 	end)
  19 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/CoreGui.lua`
<details>
<summary>View Source (10 lines)</summary>

```lua
   1 | local BaseInstance = import("./BaseInstance")
   2 | local CoreGui = BaseInstance:extend("CoreGui")
   3 | local ScreenGui = import("./ScreenGui")
   4 | 
   5 | function CoreGui:init(instance)
   6 | 	local RobloxGui = ScreenGui:new()
   7 | 	RobloxGui.Name = "RobloxGui"
   8 | 	RobloxGui.Parent = instance
   9 | end
  10 | 
  11 | return CoreGui
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/CoreGui_spec.lua`
<details>
<summary>View Source (17 lines)</summary>

```lua
   1 | local CoreGui = import("./CoreGui")
   2 | 
   3 | describe("instances.CoreGui", function()
   4 | 	it("should instantiate", function()
   5 | 		local instance = CoreGui:new()
   6 | 
   7 | 		assert.not_nil(instance)
   8 | 	end)
   9 | 
  10 | 	it("should have a ScreenGui child named RobloxGui", function()
  11 | 		local instance = CoreGui:new()
  12 | 
  13 | 		local robloxGui = instance:FindFirstChild("RobloxGui")
  14 | 
  15 | 		assert.not_nil(robloxGui)
  16 | 		assert.equal(robloxGui.ClassName, "ScreenGui")
  17 | 	end)
  18 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/CorePackages.lua`
<details>
<summary>View Source (3 lines)</summary>

```lua
   1 | local BaseInstance = import("./BaseInstance")
   2 | local CorePackages = BaseInstance:extend("CorePackages")
   3 | 
   4 | return CorePackages
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/CorePackages_spec.lua`
<details>
<summary>View Source (8 lines)</summary>

```lua
   1 | local CorePackages = import("./CorePackages")
   2 | 
   3 | describe("instances.CorePackages", function()
   4 | 	it("should instantiate", function()
   5 | 		local instance = CorePackages:new()
   6 | 
   7 | 		assert.not_nil(instance)
   8 | 	end)
   9 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/Folder.lua`
<details>
<summary>View Source (4 lines)</summary>

```lua
   1 | local BaseInstance = import("./BaseInstance")
   2 | 
   3 | return BaseInstance:extend("Folder", {
   4 | 	creatable = true,
   5 | })
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/Folder_spec.lua`
<details>
<summary>View Source (8 lines)</summary>

```lua
   1 | local Instance = import("../Instance")
   2 | 
   3 | describe("instances.Folder", function()
   4 | 	it("should instantiate", function()
   5 | 		local instance = Instance.new("Folder")
   6 | 
   7 | 		assert.not_nil(instance)
   8 | 	end)
   9 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/Frame.lua`
<details>
<summary>View Source (4 lines)</summary>

```lua
   1 | local GuiObject = import("./GuiObject")
   2 | 
   3 | return GuiObject:extend("Frame", {
   4 | 	creatable = true,
   5 | })
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/Frame_spec.lua`
<details>
<summary>View Source (8 lines)</summary>

```lua
   1 | local Instance = import("../Instance")
   2 | 
   3 | describe("instances.Frame", function()
   4 | 	it("should instantiate", function()
   5 | 		local instance = Instance.new("Frame")
   6 | 
   7 | 		assert.not_nil(instance)
   8 | 	end)
   9 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/Game.lua`
<details>
<summary>View Source (122 lines)</summary>

```lua
   1 | local BaseInstance = import("./BaseInstance")
   2 | 
   3 | local AnalyticsService = import("./AnalyticsService")
   4 | local ContentProvider = import("./ContentProvider")
   5 | local CoreGui = import("./CoreGui")
   6 | local ContextActionService = import("./ContextActionService")
   7 | local CorePackages = import("./CorePackages")
   8 | local CreatorType = import("../Enum/CreatorType")
   9 | local GuiService = import("./GuiService")
  10 | local HttpRbxApiService = import("./HttpRbxApiService")
  11 | local HttpService = import("./HttpService")
  12 | local InsertService = import("./InsertService")
  13 | local InstanceProperty = import("../InstanceProperty")
  14 | local LocalizationService = import("./LocalizationService")
  15 | local MarketplaceService = import("./MarketplaceService")
  16 | local NotificationService = import("./NotificationService")
  17 | local Players = import("./Players")
  18 | local ReplicatedFirst = import("./ReplicatedFirst")
  19 | local ReplicatedStorage = import("./ReplicatedStorage")
  20 | local RunService = import("./RunService")
  21 | local ServerScriptService = import("./ServerScriptService")
  22 | local ServerStorage = import("./ServerStorage")
  23 | local StarterPlayer = import("./StarterPlayer")
  24 | local Stats = import("./Stats")
  25 | local TestService = import("./TestService")
  26 | local TextService = import("./TextService")
  27 | local TweenService = import("./TweenService")
  28 | local UserInputService = import("./UserInputService")
  29 | local VirtualInputManager = import("./VirtualInputManager")
  30 | local Workspace = import("./Workspace")
  31 | 
  32 | local Game = BaseInstance:extend("DataModel")
  33 | 
  34 | function Game:init(instance)
  35 | 	AnalyticsService:new().Parent = instance
  36 | 	ContentProvider:new().Parent = instance
  37 | 	CoreGui:new().Parent = instance
  38 | 	CorePackages:new().Parent = instance
  39 | 	ContextActionService:new().Parent = instance
  40 | 	GuiService:new().Parent = instance
  41 | 	HttpRbxApiService:new().Parent = instance
  42 | 	HttpService:new().Parent = instance
  43 | 	InsertService:new().Parent = instance
  44 | 	LocalizationService:new().Parent = instance
  45 | 	MarketplaceService:new().Parent = instance
  46 | 	NotificationService:new().Parent = instance
  47 | 	Players:new().Parent = instance
  48 | 	ReplicatedFirst:new().Parent = instance
  49 | 	ReplicatedStorage:new().Parent = instance
  50 | 	RunService:new().Parent = instance
  51 | 	ServerScriptService:new().Parent = instance
  52 | 	ServerStorage:new().Parent = instance
  53 | 	StarterPlayer:new().Parent = instance
  54 | 	Stats:new().Parent = instance
  55 | 	TestService:new().Parent = instance
  56 | 	TextService:new().Parent = instance
  57 | 	TweenService:new().Parent = instance
  58 | 	UserInputService:new().Parent = instance
  59 | 	VirtualInputManager:new().Parent = instance
  60 | 	Workspace:new().Parent = instance
  61 | end
  62 | 
  63 | function Game.prototype:GetService(serviceName)
  64 | 	local service = self:FindFirstChildOfClass(serviceName)
  65 | 
  66 | 	if service then
  67 | 		return service
  68 | 	end
  69 | 
  70 | 	-- TODO: Load the service if possible?
  71 | 
  72 | 	error(string.format("Cannot get service %q", tostring(serviceName)), 2)
  73 | end
  74 | 
  75 | Game.properties.CreatorId = InstanceProperty.readOnly({
  76 | 	getDefault = function()
  77 | 		return 0
  78 | 	end,
  79 | })
  80 | 
  81 | Game.properties.CreatorType = InstanceProperty.readOnly({
  82 | 	getDefault = function()
  83 | 		return CreatorType.User
  84 | 	end,
  85 | })
  86 | 
  87 | Game.properties.GameId = InstanceProperty.readOnly({
  88 | 	getDefault = function()
  89 | 		return 0
  90 | 	end,
  91 | })
  92 | 
  93 | Game.properties.JobId = InstanceProperty.readOnly({
  94 | 	getDefault = function()
  95 | 		return ""
  96 | 	end,
  97 | })
  98 | 
  99 | Game.properties.PlaceId = InstanceProperty.readOnly({
 100 | 	getDefault = function()
 101 | 		return 0
 102 | 	end,
 103 | })
 104 | 
 105 | Game.properties.PlaceVersion = InstanceProperty.readOnly({
 106 | 	getDefault = function()
 107 | 		return 0
 108 | 	end,
 109 | })
 110 | 
 111 | Game.properties.VIPServerId = InstanceProperty.readOnly({
 112 | 	getDefault = function()
 113 | 		return ""
 114 | 	end,
 115 | })
 116 | 
 117 | Game.properties.VIPServerOwnerId = InstanceProperty.readOnly({
 118 | 	getDefault = function()
 119 | 		return 0
 120 | 	end,
 121 | })
 122 | 
 123 | return Game
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/Game_spec.lua`
<details>
<summary>View Source (41 lines)</summary>

```lua
   1 | local Game = import("./Game")
   2 | local typeof = import("../functions/typeof")
   3 | 
   4 | describe("instances.Game", function()
   5 | 	it("should instantiate", function()
   6 | 		local instance = Game:new()
   7 | 
   8 | 		assert.not_nil(instance)
   9 | 	end)
  10 | 
  11 | 	describe("GetService", function()
  12 | 		it("should have GetService", function()
  13 | 			local instance = Game:new()
  14 | 
  15 | 			local ReplicatedStorage = instance:GetService("ReplicatedStorage")
  16 | 
  17 | 			assert.not_nil(ReplicatedStorage)
  18 | 			assert.equal(instance.ReplicatedStorage, ReplicatedStorage)
  19 | 		end)
  20 | 
  21 | 		it("should throw when given invalid service names", function()
  22 | 			local instance = Game:new()
  23 | 
  24 | 			assert.has.errors(function()
  25 | 				instance:GetService("SOMETHING THAT WILL NEVER EXIST")
  26 | 			end)
  27 | 		end)
  28 | 	end)
  29 | 
  30 | 	it("should have properties defined", function()
  31 | 		local instance = Game:new()
  32 | 
  33 | 		assert.equal(typeof(instance.CreatorId), "number")
  34 | 		assert.equal(typeof(instance.CreatorType), "EnumItem")
  35 | 		assert.equal(typeof(instance.GameId), "number")
  36 | 		assert.equal(typeof(instance.JobId), "string")
  37 | 		assert.equal(typeof(instance.PlaceId), "number")
  38 | 		assert.equal(typeof(instance.PlaceVersion), "number")
  39 | 		assert.equal(typeof(instance.VIPServerId), "string")
  40 | 		assert.equal(typeof(instance.VIPServerOwnerId), "number")
  41 | 	end)
  42 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/GuiButton.lua`
<details>
<summary>View Source (29 lines)</summary>

```lua
   1 | local GuiObject = import("./GuiObject")
   2 | local InstanceProperty = import("../InstanceProperty")
   3 | local Signal = import("../Signal")
   4 | local GuiButton = GuiObject:extend("GuiButton")
   5 | 
   6 | GuiButton.properties.Activated = InstanceProperty.readOnly({
   7 | 	getDefault = function()
   8 | 		return Signal.new()
   9 | 	end,
  10 | })
  11 | 
  12 | GuiButton.properties.AutoButtonColor = InstanceProperty.typed("boolean", {
  13 | 	getDefault = function()
  14 | 		return false
  15 | 	end,
  16 | })
  17 | 
  18 | GuiButton.properties.Modal = InstanceProperty.typed("boolean", {
  19 | 	getDefault = function()
  20 | 		return false
  21 | 	end,
  22 | })
  23 | 
  24 | GuiButton.properties.MouseButton1Click = InstanceProperty.readOnly({
  25 | 	getDefault = function()
  26 | 		return Signal.new()
  27 | 	end,
  28 | })
  29 | 
  30 | return GuiButton
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/GuiButton_spec.lua`
<details>
<summary>View Source (19 lines)</summary>

```lua
   1 | local typeof = import("../functions/typeof")
   2 | 
   3 | local GuiButton = import("./GuiButton")
   4 | 
   5 | describe("instances.GuiButton", function()
   6 | 	it("should instantiate", function()
   7 | 		local instance = GuiButton:new()
   8 | 
   9 | 		assert.not_nil(instance)
  10 | 	end)
  11 | 
  12 | 	it("should have properties defined", function()
  13 | 		local instance = GuiButton:new()
  14 | 		assert.equal(typeof(instance.Activated), "RBXScriptSignal")
  15 | 		assert.equal(typeof(instance.AutoButtonColor), "boolean")
  16 | 		assert.equal(typeof(instance.Modal), "boolean")
  17 | 		assert.equal(typeof(instance.MouseButton1Click), "RBXScriptSignal")
  18 | 	end)
  19 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/GuiObject.lua`
<details>
<summary>View Source (157 lines)</summary>

```lua
   1 | local BaseInstance = import("./BaseInstance")
   2 | local Color3 = import("../types/Color3")
   3 | local InstanceProperty = import("../InstanceProperty")
   4 | local Signal = import("../Signal")
   5 | local SizeConstraint = import("../Enum/SizeConstraint")
   6 | local UDim2 = import("../types/UDim2")
   7 | local Vector2 = import("../types/Vector2")
   8 | 
   9 | local GuiObject = BaseInstance:extend("GuiObject")
  10 | 
  11 | GuiObject.properties.AbsolutePosition = InstanceProperty.readOnly({
  12 | 	get = function(self)
  13 | 		if self:FindFirstAncestorOfClass("ScreenGui") == nil then
  14 | 			return Vector2.new()
  15 | 		end
  16 | 
  17 | 		local parentAbsolutePosition = self.Parent.AbsolutePosition
  18 | 		local parentAbsoluteSize = self.Parent.AbsoluteSize
  19 | 		local position = self.Position
  20 | 
  21 | 		return Vector2.new(
  22 | 			parentAbsolutePosition.X + position.X.Scale * parentAbsoluteSize.X + position.X.Offset,
  23 | 			parentAbsolutePosition.Y + position.Y.Scale * parentAbsoluteSize.Y + position.Y.Offset
  24 | 		)
  25 | 	end,
  26 | })
  27 | 
  28 | GuiObject.properties.AbsoluteSize = InstanceProperty.readOnly({
  29 | 	get = function(self)
  30 | 		if self:FindFirstAncestorOfClass("ScreenGui") == nil then
  31 | 			return Vector2.new()
  32 | 		end
  33 | 
  34 | 		local size = self.Size
  35 | 		local scaleX, scaleY = 0, 0
  36 | 
  37 | 		if self.Parent ~= nil and (self.Parent:IsA("GuiObject") or self.Parent:IsA("ScreenGui")) then
  38 | 			local parentSize = self.Parent.AbsoluteSize
  39 | 			scaleX = parentSize.X
  40 | 			scaleY = parentSize.Y
  41 | 		end
  42 | 
  43 | 		return Vector2.new(
  44 | 			scaleX * size.X.Scale + size.X.Offset,
  45 | 			scaleY * size.Y.Scale + size.Y.Offset
  46 | 		)
  47 | 	end,
  48 | })
  49 | 
  50 | GuiObject.properties.Active = InstanceProperty.typed("boolean", {
  51 | 	getDefault = function()
  52 | 		return true
  53 | 	end,
  54 | })
  55 | 
  56 | GuiObject.properties.AnchorPoint = InstanceProperty.typed("Vector2", {
  57 | 	getDefault = function()
  58 | 		return Vector2.new()
  59 | 	end,
  60 | })
  61 | 
  62 | GuiObject.properties.BackgroundColor3 = InstanceProperty.typed("Color3", {
  63 | 	getDefault = function()
  64 | 		return Color3.new()
  65 | 	end,
  66 | })
  67 | 
  68 | GuiObject.properties.BackgroundTransparency = InstanceProperty.typed("number", {
  69 | 	getDefault = function()
  70 | 		return 0
  71 | 	end,
  72 | })
  73 | 
  74 | GuiObject.properties.BorderSizePixel = InstanceProperty.typed("number", {
  75 | 	getDefault = function()
  76 | 		return 0
  77 | 	end,
  78 | })
  79 | 
  80 | GuiObject.properties.BorderColor3 = InstanceProperty.typed("Color3", {
  81 | 	getDefault = function()
  82 | 		return Color3.fromRGB(27, 42, 53)
  83 | 	end,
  84 | })
  85 | 
  86 | GuiObject.properties.ClipsDescendants = InstanceProperty.typed("boolean", {
  87 | 	getDefault = function()
  88 | 		return false
  89 | 	end,
  90 | })
  91 | 
  92 | GuiObject.properties.InputBegan = InstanceProperty.readOnly({
  93 | 	getDefault = function()
  94 | 		return Signal.new()
  95 | 	end,
  96 | })
  97 | 
  98 | GuiObject.properties.InputEnded = InstanceProperty.readOnly({
  99 | 	getDefault = function()
 100 | 		return Signal.new()
 101 | 	end,
 102 | })
 103 | 
 104 | GuiObject.properties.LayoutOrder = InstanceProperty.typed("number", {
 105 | 	getDefault = function()
 106 | 		return 0
 107 | 	end,
 108 | })
 109 | 
 110 | GuiObject.properties.MouseEnter = InstanceProperty.readOnly({
 111 | 	getDefault = function()
 112 | 		return Signal.new()
 113 | 	end,
 114 | })
 115 | 
 116 | GuiObject.properties.MouseLeave = InstanceProperty.readOnly({
 117 | 	getDefault = function()
 118 | 		return Signal.new()
 119 | 	end,
 120 | })
 121 | 
 122 | GuiObject.properties.Position = InstanceProperty.typed("UDim2", {
 123 | 	getDefault = function()
 124 | 		return UDim2.new()
 125 | 	end,
 126 | })
 127 | 
 128 | GuiObject.properties.Selectable = InstanceProperty.typed("boolean", {
 129 | 	getDefault = function()
 130 | 		return true
 131 | 	end,
 132 | })
 133 | 
 134 | GuiObject.properties.Size = InstanceProperty.typed("UDim2", {
 135 | 	getDefault = function()
 136 | 		return UDim2.new()
 137 | 	end,
 138 | })
 139 | 
 140 | GuiObject.properties.SizeConstraint = InstanceProperty.enum(SizeConstraint, {
 141 | 	getDefault = function()
 142 | 		return SizeConstraint.RelativeXY
 143 | 	end,
 144 | })
 145 | 
 146 | GuiObject.properties.Visible = InstanceProperty.typed("boolean", {
 147 | 	getDefault = function()
 148 | 		return true
 149 | 	end,
 150 | })
 151 | 
 152 | GuiObject.properties.ZIndex = InstanceProperty.typed("number", {
 153 | 	getDefault = function()
 154 | 		return 1
 155 | 	end,
 156 | })
 157 | 
 158 | return GuiObject
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/GuiObject_spec.lua`
<details>
<summary>View Source (135 lines)</summary>

```lua
   1 | local ScreenGui = import("./ScreenGui")
   2 | local UDim2 = import("../types/UDim2")
   3 | local typeof = import("../functions/typeof")
   4 | local SizeConstraint = import("../Enum/SizeConstraint")
   5 | 
   6 | local GuiObject = import("./GuiObject")
   7 | 
   8 | local function extractVector2(v)
   9 | 	return { v.X, v.Y }
  10 | end
  11 | 
  12 | describe("instances.GuiObject", function()
  13 | 	it("should instantiate", function()
  14 | 		local instance = GuiObject:new()
  15 | 
  16 | 		assert.not_nil(instance)
  17 | 	end)
  18 | 
  19 | 	it("should have properties defined", function()
  20 | 		local instance = GuiObject:new()
  21 | 
  22 | 		assert.equal(typeof(instance.Active), "boolean")
  23 | 		assert.equal(typeof(instance.AnchorPoint), "Vector2")
  24 | 		assert.equal(typeof(instance.BackgroundColor3), "Color3")
  25 | 		assert.equal(typeof(instance.BackgroundTransparency), "number")
  26 | 		assert.equal(typeof(instance.BorderColor3), "Color3")
  27 | 		assert.equal(typeof(instance.BorderSizePixel), "number")
  28 | 		assert.equal(typeof(instance.ClipsDescendants), "boolean")
  29 | 		assert.equal(typeof(instance.InputBegan), "RBXScriptSignal")
  30 | 		assert.equal(typeof(instance.InputEnded), "RBXScriptSignal")
  31 | 		assert.equal(typeof(instance.LayoutOrder), "number")
  32 | 		assert.equal(typeof(instance.MouseEnter), "RBXScriptSignal")
  33 | 		assert.equal(typeof(instance.MouseLeave), "RBXScriptSignal")
  34 | 		assert.equal(typeof(instance.Position), "UDim2")
  35 | 		assert.equal(typeof(instance.Selectable), "boolean")
  36 | 		assert.equal(typeof(instance.Size), "UDim2")
  37 | 		assert.equal(typeof(instance.SizeConstraint), "EnumItem")
  38 | 		assert.equal(instance.SizeConstraint.EnumType, SizeConstraint)
  39 | 		assert.equal(typeof(instance.Visible), "boolean")
  40 | 		assert.equal(typeof(instance.ZIndex), "number")
  41 | 	end)
  42 | 
  43 | 	describe("AbsolutePosition", function()
  44 | 		it("should return (0, 0) when it is not a child of ScreenGui", function()
  45 | 			local parent = GuiObject:new()
  46 | 			parent.Size = UDim2.new(0, 320, 0, 240)
  47 | 
  48 | 			local child = GuiObject:new()
  49 | 			child.Size = UDim2.new(0.5, 20, 0.5, 20)
  50 | 			child.Parent = parent
  51 | 
  52 | 			assert.are.same(extractVector2(parent.AbsolutePosition), {0, 0})
  53 | 			assert.are.same(extractVector2(child.AbsolutePosition), {0, 0})
  54 | 		end)
  55 | 
  56 | 		it("should propagate position from a ScreenGui", function()
  57 | 			local screenGui = ScreenGui:new()
  58 | 			local screenGuiSize = screenGui.AbsoluteSize
  59 | 
  60 | 			local parent = GuiObject:new()
  61 | 			parent.Parent = screenGui
  62 | 			parent.Position = UDim2.new(0.1, 50, 0.2, 100)
  63 | 			parent.Size = UDim2.new(0.5, 100, 0.1, 200)
  64 | 
  65 | 			local parentAbsolutePosition = parent.AbsolutePosition
  66 | 			local parentAbsoluteSize = parent.AbsoluteSize
  67 | 			assert.are.same(
  68 | 				extractVector2(parentAbsolutePosition),
  69 | 				{
  70 | 					0.1 * screenGuiSize.X + 50,
  71 | 					0.2 * screenGuiSize.Y + 100,
  72 | 				}
  73 | 			)
  74 | 
  75 | 			local child = GuiObject:new()
  76 | 			child.Parent = parent
  77 | 			child.Position = UDim2.new(0.5, 0, 0.2, 10)
  78 | 			child.Size = UDim2.new(2, 50, 4, 10)
  79 | 
  80 | 			local childAbsolutePosition = child.AbsolutePosition
  81 | 			assert.are.same(
  82 | 				extractVector2(childAbsolutePosition),
  83 | 				{
  84 | 					parentAbsolutePosition.X + 0.5 * parentAbsoluteSize.X,
  85 | 					parentAbsolutePosition.Y + 0.2 * parentAbsoluteSize.Y + 10,
  86 | 				}
  87 | 			)
  88 | 		end)
  89 | 	end)
  90 | 
  91 | 	describe("AbsoluteSize", function()
  92 | 		it("should return (0, 0) when it is not a child of ScreenGui", function()
  93 | 			local parent = GuiObject:new()
  94 | 			parent.Size = UDim2.new(0, 320, 0, 240)
  95 | 
  96 | 			local child = GuiObject:new()
  97 | 			child.Size = UDim2.new(0.5, 20, 0.5, 20)
  98 | 			child.Parent = parent
  99 | 
 100 | 			assert.are.same(extractVector2(parent.AbsoluteSize), {0, 0})
 101 | 			assert.are.same(extractVector2(child.AbsoluteSize), {0, 0})
 102 | 		end)
 103 | 
 104 | 		it("should propagate size from a ScreenGui", function()
 105 | 			local screenGui = ScreenGui:new()
 106 | 			local screenGuiSize = screenGui.AbsoluteSize
 107 | 
 108 | 			local parent = GuiObject:new()
 109 | 			parent.Parent = screenGui
 110 | 			parent.Size = UDim2.new(0.5, 100, 0.1, 200)
 111 | 
 112 | 			local parentAbsoluteSize = parent.AbsoluteSize
 113 | 			assert.are.same(
 114 | 				extractVector2(parentAbsoluteSize),
 115 | 				{
 116 | 					0.5 * screenGuiSize.X + 100,
 117 | 					0.1 * screenGuiSize.Y + 200,
 118 | 				}
 119 | 			)
 120 | 
 121 | 			local child = GuiObject:new()
 122 | 			child.Parent = parent
 123 | 			child.Size = UDim2.new(2, 50, 4, 10)
 124 | 
 125 | 			local childAbsoluteSize = child.AbsoluteSize
 126 | 			assert.are.same(
 127 | 				extractVector2(childAbsoluteSize),
 128 | 				{
 129 | 					2 * parentAbsoluteSize.X + 50,
 130 | 					4 * parentAbsoluteSize.Y + 10,
 131 | 				}
 132 | 			)
 133 | 		end)
 134 | 	end)
 135 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/GuiService.lua`
<details>
<summary>View Source (39 lines)</summary>

```lua
   1 | local BaseInstance = import("./BaseInstance")
   2 | local InstanceProperty = import("../InstanceProperty")
   3 | local Signal = import("../Signal")
   4 | local validateType = import("../validateType")
   5 | 
   6 | local GuiService = BaseInstance:extend("GuiService")
   7 | 
   8 | function GuiService.prototype:BroadcastNotification(data, notification)
   9 | 	validateType("data", data, "string")
  10 | 	validateType("noficiation", notification, "number")
  11 | end
  12 | 
  13 | function GuiService.prototype:GetNotificationTypeList()
  14 | 	return {
  15 | 		ACTION_LOG_OUT = "ACTION_LOG_OUT",
  16 | 	}
  17 | end
  18 | 
  19 | function GuiService.prototype:SetGlobalGuiInset(x1, y1, x2, y2)
  20 | 	validateType("x1", x1, "number")
  21 | 	validateType("y1", y1, "number")
  22 | 	validateType("x2", x2, "number")
  23 | 	validateType("y2", y2, "number")
  24 | end
  25 | 
  26 | function GuiService.prototype:SafeZoneOffsetsChanged()
  27 | end
  28 | 
  29 | function GuiService.prototype:IsTenFootInterface()
  30 | 	return false
  31 | end
  32 | 
  33 | GuiService.properties.BrowserWindowClosed = InstanceProperty.readOnly({
  34 | 	getDefault = function()
  35 | 		return Signal.new()
  36 | 	end,
  37 | })
  38 | 
  39 | return GuiService
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/GuiService_spec.lua`
<details>
<summary>View Source (47 lines)</summary>

```lua
   1 | local GuiService = import("./GuiService")
   2 | local typeof = import("../functions/typeof")
   3 | 
   4 | describe("instances.GuiService", function()
   5 | 	it("should instantiate", function()
   6 | 		local instance = GuiService:new()
   7 | 
   8 | 		assert.not_nil(instance)
   9 | 	end)
  10 | 
  11 | 	describe("BroadcastNotification", function()
  12 | 		it("should exist", function()
  13 | 			GuiService:new():BroadcastNotification("test", 123)
  14 | 		end)
  15 | 	end)
  16 | 
  17 | 	describe("GetNotificationTypeList", function()
  18 | 		it("should return a table", function()
  19 | 			assert.equal(type(GuiService:new():GetNotificationTypeList()), "table")
  20 | 		end)
  21 | 	end)
  22 | 
  23 | 	describe("SetGlobalGuiInset", function()
  24 | 		it("should exist", function()
  25 | 			GuiService:new():SetGlobalGuiInset(1, 2, 3, 4)
  26 | 		end)
  27 | 	end)
  28 | 
  29 | 	describe("SafeZoneOffsetsChanged", function()
  30 | 		it("should exist", function()
  31 | 			GuiService:new():SafeZoneOffsetsChanged()
  32 | 		end)
  33 | 	end)
  34 | 
  35 | 	describe("IsTenFootInterface", function()
  36 | 		it("should return a boolean", function()
  37 | 			assert.equal(type(GuiService:new():IsTenFootInterface()), "boolean")
  38 | 		end)
  39 | 	end)
  40 | 
  41 | 	describe("BrowserWindowClosed", function()
  42 | 		it("should return a signal", function()
  43 | 			local instance = GuiService:new()
  44 | 
  45 | 			assert.equal(typeof(instance.BrowserWindowClosed), "RBXScriptSignal")
  46 | 		end)
  47 | 	end)
  48 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/HttpRbxApiService.lua`
<details>
<summary>View Source (3 lines)</summary>

```lua
   1 | local BaseInstance = import("./BaseInstance")
   2 | local HttpRbxApiService = BaseInstance:extend("HttpRbxApiService")
   3 | 
   4 | return HttpRbxApiService
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/HttpRbxApiService_spec.lua`
<details>
<summary>View Source (8 lines)</summary>

```lua
   1 | local HttpRbxApiService = import("./HttpRbxApiService")
   2 | 
   3 | describe("instances.HttpRbxApiService", function()
   4 | 	it("should instantiate", function()
   5 | 		local instance = HttpRbxApiService:new()
   6 | 
   7 | 		assert.not_nil(instance)
   8 | 	end)
   9 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/HttpService.lua`
<details>
<summary>View Source (39 lines)</summary>

```lua
   1 | local BaseInstance = import("./BaseInstance")
   2 | local typeof = import("../functions/typeof")
   3 | local json = import("../json")
   4 | 
   5 | local HttpService = BaseInstance:extend("HttpService")
   6 | 
   7 | function HttpService.prototype:JSONEncode(input)
   8 | 	return json.encode(input)
   9 | end
  10 | 
  11 | function HttpService.prototype:JSONDecode(input)
  12 | 	return json.decode(input)
  13 | end
  14 | 
  15 | function HttpService.prototype:UrlEncode(input)
  16 | 	local url = input:gsub("\n", "\r\n")
  17 | 
  18 | 	return url:gsub("([^%w])", function(c)
  19 | 		return string.format("%%%02X", string.byte(c))
  20 | 	end)
  21 | end
  22 | 
  23 | function HttpService.prototype:GenerateGUID(wrapInCurlyBraces)
  24 | 	local argType = typeof(wrapInCurlyBraces)
  25 | 	if wrapInCurlyBraces ~= nil and argType ~= "boolean" then
  26 | 		error(("Unable to cast %s to bool"):format(argType), 2)
  27 | 	end
  28 | 
  29 | 	--[[
  30 | 		`GenerateGUID` allows any value type for `wrapInCurlyBraces`, but it
  31 | 		only omits the curly braces when `wrapInCurlyBraces` is set to `false`
  32 | 	]]
  33 | 	if wrapInCurlyBraces == false then
  34 | 		return "04AEBFEA-87FC-480F-A98B-E5E221007A90"
  35 | 	else
  36 | 		return "{04AEBFEA-87FC-480F-A98B-E5E221007A90}"
  37 | 	end
  38 | end
  39 | 
  40 | return HttpService
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/HttpService_spec.lua`
<details>
<summary>View Source (58 lines)</summary>

```lua
   1 | local HttpService = import("./HttpService")
   2 | 
   3 | describe("instances.HttpService", function()
   4 | 	it("should instantiate", function()
   5 | 		local instance = HttpService:new()
   6 | 
   7 | 		assert.not_nil(instance)
   8 | 	end)
   9 | 
  10 | 	it("should json encode properly", function()
  11 | 		local instance = HttpService:new()
  12 | 
  13 | 		assert.equal(instance:JSONEncode({ 1, true }), "[1,true]")
  14 | 	end)
  15 | 
  16 | 	it("should json decode properly", function()
  17 | 		local instance = HttpService:new()
  18 | 
  19 | 		assert.are.same(instance:JSONDecode("[1,true]"), { 1, true })
  20 | 	end)
  21 | 
  22 | 	it("should URL encode properly", function()
  23 | 		local instance = HttpService:new()
  24 | 
  25 | 		assert.equal(instance:UrlEncode("testing test&test !@#$%^&*()+" ..
  26 | 			"_-=~`<>,./?| FranÃ§ois"),
  27 | 			"testing%20test%26test%20%21%40%23%24%25%5E%26%2A%28%29" ..
  28 | 			"%2B%5F%2D%3D%7E%60%3C%3E%2C%2E%2F%3F%7C%20Fran%C3%A7ois")
  29 | 	end)
  30 | 
  31 | 	describe("GenerateGUID", function()
  32 | 		it("should omit curly braces when wrapInCurlyBraces is false", function()
  33 | 			local instance = HttpService:new()
  34 | 			local guid = instance:GenerateGUID(false)
  35 | 
  36 | 			assert.equal(guid:find("{"), nil)
  37 | 			assert.equal(guid:find("}"), nil)
  38 | 		end)
  39 | 
  40 | 		it("should include curly braces when wrapInCurlyBraces is nil or true", function()
  41 | 			local instance = HttpService:new()
  42 | 			local guid = instance:GenerateGUID(true)
  43 | 
  44 | 			assert.equal(guid:find("{.+}"), 1)
  45 | 
  46 | 			guid = instance:GenerateGUID()
  47 | 
  48 | 			assert.equal(guid:find("{.+}"), 1)
  49 | 		end)
  50 | 
  51 | 		it("should throw when given invalid arg types", function()
  52 | 			local instance = HttpService:new()
  53 | 
  54 | 			assert.has_error(function() instance:GenerateGUID(newproxy()) end)
  55 | 			assert.has_error(function() instance:GenerateGUID({}) end)
  56 | 			assert.has_error(function() instance:GenerateGUID(function() end) end)
  57 | 		end)
  58 | 	end)
  59 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/Humanoid.lua`
<details>
<summary>View Source (55 lines)</summary>

```lua
   1 | local BaseInstance = import("./BaseInstance")
   2 | local InstanceProperty = import("../InstanceProperty")
   3 | local Signal = import("../Signal")
   4 | local validateType = import("../validateType")
   5 | 
   6 | local Humanoid = BaseInstance:extend("Humanoid", {
   7 | 	creatable = true,
   8 | })
   9 | 
  10 | function Humanoid:init(instance)
  11 | 	getmetatable(instance).instance.died = false
  12 | end
  13 | 
  14 | Humanoid.properties.Died = InstanceProperty.readOnly({
  15 | 	getDefault = Signal.new
  16 | })
  17 | 
  18 | Humanoid.properties.Health = InstanceProperty.normal({
  19 | 	getDefault = function()
  20 | 		return 100
  21 | 	end,
  22 | 
  23 | 	set = function(self, key, value)
  24 | 		validateType("Health", value, "number")
  25 | 		local instance = getmetatable(self).instance
  26 | 		local health = math.min(
  27 | 			math.max(0, value),
  28 | 			self.MaxHealth
  29 | 		)
  30 | 
  31 | 		instance.properties.Health = health
  32 | 
  33 | 		if not instance.died and health == 0 and self:FindFirstAncestorWhichIsA("Workspace") ~= nil then
  34 | 			instance.died = true
  35 | 			self.Died:Fire()
  36 | 		end
  37 | 	end,
  38 | })
  39 | 
  40 | Humanoid.properties.MaxHealth = InstanceProperty.normal({
  41 | 	getDefault = function()
  42 | 		return 100
  43 | 	end,
  44 | 
  45 | 	set = function(self, key, value)
  46 | 		validateType("MaxHealth", value, "number")
  47 | 		local instance = getmetatable(self).instance
  48 | 		local maxHealth = math.max(0, value)
  49 | 
  50 | 		instance.properties.MaxHealth = maxHealth
  51 | 		self.Health = math.min(self.Health, maxHealth)
  52 | 	end,
  53 | })
  54 | 
  55 | return Humanoid
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/Humanoid_spec.lua`
<details>
<summary>View Source (52 lines)</summary>

```lua
   1 | local Humanoid = import("./Humanoid")
   2 | local Instance = import("../Instance")
   3 | local Workspace = import("./Workspace")
   4 | 
   5 | describe("instances.Humanoid", function()
   6 | 	it("should instantiate", function()
   7 | 		local instance = Instance.new("Humanoid")
   8 | 
   9 | 		assert.not_nil(instance)
  10 | 		assert.equal(instance.Health, 100)
  11 | 		assert.equal(instance.MaxHealth, 100)
  12 | 	end)
  13 | 
  14 | 	it("should clamp health and max health", function()
  15 | 		local instance = Humanoid:new()
  16 | 
  17 | 		instance.MaxHealth = 50
  18 | 		assert.equal(instance.MaxHealth, 50)
  19 | 		assert.equal(instance.Health, 50)
  20 | 
  21 | 		instance.MaxHealth = 100
  22 | 		assert.equal(instance.MaxHealth, 100)
  23 | 		assert.equal(instance.Health, 50)
  24 | 
  25 | 		instance.Health = 300
  26 | 		assert.equal(instance.MaxHealth, 100)
  27 | 		assert.equal(instance.Health, 100)
  28 | 
  29 | 		instance.Health = -10
  30 | 		assert.equal(instance.Health, 0)
  31 | 
  32 | 		instance.MaxHealth = -10
  33 | 		assert.equal(instance.MaxHealth, 0)
  34 | 		assert.equal(instance.Health, 0)
  35 | 	end)
  36 | 
  37 | 	it("should call Died when Health is set to 0 and the Humanoid is in Workspace", function()
  38 | 		local instance = Humanoid:new()
  39 | 
  40 | 		local spy = spy.new(function() end)
  41 | 		instance.Died:Connect(spy)
  42 | 		instance.Health = 0
  43 | 		assert.spy(spy).was_called(0)
  44 | 		instance.Health = 100
  45 | 		assert.spy(spy).was_called(0)
  46 | 
  47 | 		instance.Parent = Workspace:new()
  48 | 		assert.spy(spy).was_called(0)
  49 | 		instance.Health = 0
  50 | 		assert.spy(spy).was_called(1)
  51 | 	end)
  52 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/ImageButton.lua`
<details>
<summary>View Source (47 lines)</summary>

```lua
   1 | local Color3 = import("../types/Color3")
   2 | local GuiButton = import("./GuiButton")
   3 | local InstanceProperty = import("../InstanceProperty")
   4 | local Rect = import("../types/Rect")
   5 | local ScaleType = import("../Enum/ScaleType")
   6 | local Vector2 = import("../types/Vector2")
   7 | 
   8 | local ImageButton = GuiButton:extend("ImageButton", {
   9 | 	creatable = true,
  10 | })
  11 | 
  12 | ImageButton.properties.Image = InstanceProperty.typed("string", {
  13 | 	getDefault = function()
  14 | 		return ""
  15 | 	end,
  16 | })
  17 | 
  18 | ImageButton.properties.ImageColor3 = InstanceProperty.typed("Color3", {
  19 | 	getDefault = function()
  20 | 		return Color3.new()
  21 | 	end,
  22 | })
  23 | 
  24 | ImageButton.properties.ImageRectOffset = InstanceProperty.typed("Vector2", {
  25 | 	getDefault = function()
  26 | 		return Vector2.new(0, 0)
  27 | 	end,
  28 | })
  29 | 
  30 | ImageButton.properties.ImageRectSize = InstanceProperty.typed("Vector2", {
  31 | 	getDefault = function()
  32 | 		return Vector2.new(0, 0)
  33 | 	end,
  34 | })
  35 | 
  36 | ImageButton.properties.ScaleType = InstanceProperty.enum(ScaleType, {
  37 | 	getDefault = function()
  38 | 		return ScaleType.Stretch
  39 | 	end,
  40 | })
  41 | 
  42 | ImageButton.properties.SliceCenter = InstanceProperty.typed("Rect", {
  43 | 	getDefault = function()
  44 | 		return Rect.new(0, 0, 1, 1)
  45 | 	end,
  46 | })
  47 | 
  48 | return ImageButton
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/ImageButton_spec.lua`
<details>
<summary>View Source (22 lines)</summary>

```lua
   1 | local Instance = import("../Instance")
   2 | local typeof = import("../functions/typeof")
   3 | local ScaleType = import("../Enum/ScaleType")
   4 | 
   5 | describe("instances.ImageButton", function()
   6 | 	it("should instantiate", function()
   7 | 		local instance = Instance.new("ImageButton")
   8 | 
   9 | 		assert.not_nil(instance)
  10 | 	end)
  11 | 
  12 | 	it("should have properties defined", function()
  13 | 		local instance = Instance.new("ImageButton")
  14 | 		assert.equals(typeof(instance.Image), "string")
  15 | 		assert.equals(typeof(instance.ImageColor3), "Color3")
  16 | 		assert.equals(typeof(instance.ImageRectOffset), "Vector2")
  17 | 		assert.equals(typeof(instance.ImageRectSize), "Vector2")
  18 | 		assert.equals(typeof(instance.ScaleType), "EnumItem")
  19 | 		assert.equal(instance.ScaleType.EnumType, ScaleType)
  20 | 		assert.equals(typeof(instance.SliceCenter), "Rect")
  21 | 	end)
  22 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/ImageLabel.lua`
<details>
<summary>View Source (47 lines)</summary>

```lua
   1 | local Color3 = import("../types/Color3")
   2 | local GuiObject = import("./GuiObject")
   3 | local InstanceProperty = import("../InstanceProperty")
   4 | local Rect = import("../types/Rect")
   5 | local ScaleType = import("../Enum/ScaleType")
   6 | local Vector2 = import("../types/Vector2")
   7 | 
   8 | local ImageLabel = GuiObject:extend("ImageLabel", {
   9 | 	creatable = true,
  10 | })
  11 | 
  12 | ImageLabel.properties.Image = InstanceProperty.typed("string", {
  13 | 	getDefault = function()
  14 | 		return ""
  15 | 	end,
  16 | })
  17 | 
  18 | ImageLabel.properties.ImageColor3 = InstanceProperty.typed("Color3", {
  19 | 	getDefault = function()
  20 | 		return Color3.new()
  21 | 	end,
  22 | })
  23 | 
  24 | ImageLabel.properties.ImageRectOffset = InstanceProperty.typed("Vector2", {
  25 | 	getDefault = function()
  26 | 		return Vector2.new(0, 0)
  27 | 	end,
  28 | })
  29 | 
  30 | ImageLabel.properties.ImageRectSize = InstanceProperty.typed("Vector2", {
  31 | 	getDefault = function()
  32 | 		return Vector2.new(0, 0)
  33 | 	end,
  34 | })
  35 | 
  36 | ImageLabel.properties.ScaleType = InstanceProperty.enum(ScaleType, {
  37 | 	getDefault = function()
  38 | 		return ScaleType.Stretch
  39 | 	end,
  40 | })
  41 | 
  42 | ImageLabel.properties.SliceCenter = InstanceProperty.typed("Rect", {
  43 | 	getDefault = function()
  44 | 		return Rect.new(0, 0, 1, 1)
  45 | 	end,
  46 | })
  47 | 
  48 | return ImageLabel
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/ImageLabel_spec.lua`
<details>
<summary>View Source (22 lines)</summary>

```lua
   1 | local Instance = import("../Instance")
   2 | local typeof = import("../functions/typeof")
   3 | local ScaleType = import("../Enum/ScaleType")
   4 | 
   5 | describe("instances.ImageLabel", function()
   6 | 	it("should instantiate", function()
   7 | 		local instance = Instance.new("ImageLabel")
   8 | 
   9 | 		assert.not_nil(instance)
  10 | 	end)
  11 | 
  12 | 	it("should have properties defined", function()
  13 | 		local instance = Instance.new("ImageLabel")
  14 | 		assert.equals(typeof(instance.Image), "string")
  15 | 		assert.equals(typeof(instance.ImageColor3), "Color3")
  16 | 		assert.equals(typeof(instance.ImageRectOffset), "Vector2")
  17 | 		assert.equals(typeof(instance.ImageRectSize), "Vector2")
  18 | 		assert.equals(typeof(instance.ScaleType), "EnumItem")
  19 | 		assert.equals(instance.ScaleType.EnumType, ScaleType)
  20 | 		assert.equals(typeof(instance.SliceCenter), "Rect")
  21 | 	end)
  22 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/init.lua`
<details>
<summary>View Source (61 lines)</summary>

```lua
   1 | local names = {
   2 | 	"AnalyticsService",
   3 | 	"BindableEvent",
   4 | 	"BoolValue",
   5 | 	"Camera",
   6 | 	"Configuration",
   7 | 	"ContentProvider",
   8 | 	"CoreGui",
   9 | 	"CorePackages",
  10 | 	"Folder",
  11 | 	"Frame",
  12 | 	"Game",
  13 | 	"GuiButton",
  14 | 	"GuiObject",
  15 | 	"GuiService",
  16 | 	"HttpService",
  17 | 	"Humanoid",
  18 | 	"ImageButton",
  19 | 	"ImageLabel",
  20 | 	"IntValue",
  21 | 	"LocalizationService",
  22 | 	"LocalizationTable",
  23 | 	"LocalScript",
  24 | 	"Model",
  25 | 	"ModuleScript",
  26 | 	"NotificationService",
  27 | 	"NumberValue",
  28 | 	"ObjectValue",
  29 | 	"ParticleEffect",
  30 | 	"Player",
  31 | 	"Players",
  32 | 	"ReplicatedFirst",
  33 | 	"ReplicatedStorage",
  34 | 	"RunService",
  35 | 	"ScreenGui",
  36 | 	"Script",
  37 | 	"ScrollingFrame",
  38 | 	"ServerScriptService",
  39 | 	"ServerStorage",
  40 | 	"Stats",
  41 | 	"StringValue",
  42 | 	"TestService",
  43 | 	"TextButton",
  44 | 	"TextLabel",
  45 | 	"TextService",
  46 | 	"TweenService",
  47 | 	"UIGridStyleLayout",
  48 | 	"UIListLayout",
  49 | 	"UIPadding",
  50 | 	"UITextSizeConstraint",
  51 | 	"UserInputService",
  52 | 	"VirtualInputManager",
  53 | 	"Workspace",
  54 | }
  55 | 
  56 | local instances = {}
  57 | 
  58 | for _, name in ipairs(names) do
  59 | 	instances[name] = import("./" .. name)
  60 | end
  61 | 
  62 | return instances
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/InsertService.lua`
<details>
<summary>View Source (3 lines)</summary>

```lua
   1 | local BaseInstance = import("./BaseInstance")
   2 | local InsertService = BaseInstance:extend("InsertService")
   3 | 
   4 | return InsertService
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/InsertService_spec.lua`
<details>
<summary>View Source (8 lines)</summary>

```lua
   1 | local InsertService = import("./InsertService")
   2 | 
   3 | describe("instances.InsertService", function()
   4 | 	it("should instantiate", function()
   5 | 		local instance = InsertService:new()
   6 | 
   7 | 		assert.not_nil(instance)
   8 | 	end)
   9 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/IntValue.lua`
<details>
<summary>View Source (17 lines)</summary>

```lua
   1 | local BaseInstance = import("./BaseInstance")
   2 | local InstanceProperty = import("../InstanceProperty")
   3 | 
   4 | local IntValue = BaseInstance:extend("IntValue", {
   5 | 	creatable = true,
   6 | })
   7 | 
   8 | IntValue.properties.Value = InstanceProperty.normal({
   9 | 	getDefault = function()
  10 | 		return 0
  11 | 	end,
  12 | })
  13 | 
  14 | function IntValue:init(instance)
  15 | 	instance.Name = "Value"
  16 | end
  17 | 
  18 | return IntValue
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/IntValue_spec.lua`
<details>
<summary>View Source (10 lines)</summary>

```lua
   1 | local Instance = import("../Instance")
   2 | 
   3 | describe("instances.IntValue", function()
   4 | 	it("should instantiate", function()
   5 | 		local instance = Instance.new("IntValue")
   6 | 
   7 | 		assert.not_nil(instance)
   8 | 		assert.equal("Value", instance.Name)
   9 | 		assert.equal(0, instance.Value)
  10 | 	end)
  11 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/LocalizationService.lua`
<details>
<summary>View Source (16 lines)</summary>

```lua
   1 | local BaseInstance = import("./BaseInstance")
   2 | local InstanceProperty = import("../InstanceProperty")
   3 | local LocalizationService = BaseInstance:extend("LocalizationService")
   4 | 
   5 | LocalizationService.properties.SystemLocaleId = InstanceProperty.readOnly({
   6 | 	getDefault = function()
   7 | 		return "en-us"
   8 | 	end,
   9 | })
  10 | 
  11 | LocalizationService.properties.RobloxLocaleId = InstanceProperty.readOnly({
  12 | 	getDefault = function()
  13 | 		return "en-us"
  14 | 	end,
  15 | })
  16 | 
  17 | return LocalizationService
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/LocalizationService_spec.lua`
<details>
<summary>View Source (38 lines)</summary>

```lua
   1 | local LocalizationService = import("./LocalizationService")
   2 | 
   3 | describe("instances.LocalizationService", function()
   4 | 	it("should instantiate", function()
   5 | 		local instance = LocalizationService:new()
   6 | 
   7 | 		assert.not_nil(instance)
   8 | 	end)
   9 | 
  10 | 	describe("SystemLocaleId", function()
  11 | 		it("should have a string value", function()
  12 | 			local instance = LocalizationService:new()
  13 | 			assert.not_nil(instance.SystemLocaleId)
  14 | 			assert.equals(type(instance.SystemLocaleId), "string")
  15 | 		end)
  16 | 
  17 | 		it("should be read-only", function()
  18 | 			local instance = LocalizationService:new()
  19 | 			assert.has.errors(function()
  20 | 				instance.SystemLocaleId = "es-mx"
  21 | 			end)
  22 | 		end)
  23 | 	end)
  24 | 
  25 | 	describe("RobloxLocaleId", function()
  26 | 		it("should have a string value", function()
  27 | 			local instance = LocalizationService:new()
  28 | 			assert.not_nil(instance.RobloxLocaleId)
  29 | 			assert.equals(type(instance.RobloxLocaleId), "string")
  30 | 		end)
  31 | 
  32 | 		it("should be read-only", function()
  33 | 			local instance = LocalizationService:new()
  34 | 			assert.has.errors(function()
  35 | 				instance.RobloxLocaleId = "es-mx"
  36 | 			end)
  37 | 		end)
  38 | 	end)
  39 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/LocalizationTable.lua`
<details>
<summary>View Source (34 lines)</summary>

```lua
   1 | local BaseInstance = import("./BaseInstance")
   2 | local InstanceProperty = import("../InstanceProperty")
   3 | local json = import("../json")
   4 | 
   5 | local LocalizationTable = BaseInstance:extend("LocalizationTable", {
   6 | 	creatable = true,
   7 | })
   8 | 
   9 | LocalizationTable.properties.SourceLocaleId = InstanceProperty.normal({
  10 | 	getDefault = function()
  11 | 		return "en-us"
  12 | 	end,
  13 | })
  14 | 
  15 | function LocalizationTable:init(instance)
  16 | 	getmetatable(instance).instance.contents = {}
  17 | end
  18 | 
  19 | function LocalizationTable.prototype:SetContents(contents)
  20 | 	getmetatable(self).instance.contents = json.decode(contents)
  21 | end
  22 | 
  23 | function LocalizationTable.prototype:GetString(targetLocaleId, key)
  24 | 	local contents = getmetatable(self).instance.contents
  25 | 
  26 | 	for _, entry in ipairs(contents) do
  27 | 		if entry.key == key then
  28 | 			return entry.values[targetLocaleId]
  29 | 		end
  30 | 	end
  31 | 
  32 | 	return nil
  33 | end
  34 | 
  35 | return LocalizationTable
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/LocalizationTable_spec.lua`
<details>
<summary>View Source (46 lines)</summary>

```lua
   1 | local Instance = import("../Instance")
   2 | local typeof = import("../functions/typeof")
   3 | 
   4 | describe("instances.LocalizationTable", function()
   5 | 	it("should instantiate", function()
   6 | 		local instance = Instance.new("LocalizationTable")
   7 | 
   8 | 		assert.not_nil(instance)
   9 | 	end)
  10 | 
  11 | 	describe("SourceLocaleId", function()
  12 | 		it("should be a string", function()
  13 | 			local instance = Instance.new("LocalizationTable")
  14 | 			assert.equals(typeof(instance.SourceLocaleId), "string")
  15 | 		end)
  16 | 
  17 | 		it("should be writeable", function()
  18 | 			local instance = Instance.new("LocalizationTable")
  19 | 			local value = "TestValue"
  20 | 			instance.SourceLocaleId = value
  21 | 			assert.equals(instance.SourceLocaleId, value)
  22 | 		end)
  23 | 	end)
  24 | 
  25 | 	it("should translate text", function()
  26 | 		local instance = Instance.new("LocalizationTable")
  27 | 
  28 | 		local translationDictionary = [[
  29 | 			[
  30 | 				{
  31 | 					"key": "TEST_STRING",
  32 | 					"values": {
  33 | 						"es-mx": "SPANISH",
  34 | 						"en-us": "VALUE"
  35 | 					}
  36 | 				}
  37 | 			]
  38 | 		]]
  39 | 
  40 | 		instance:SetContents(translationDictionary)
  41 | 
  42 | 		assert.equals(instance:GetString("en-us", "TEST_STRING"), "VALUE")
  43 | 		assert.equals(instance:GetString("es-mx", "TEST_STRING"), "SPANISH")
  44 | 		assert.equals(instance:GetString("language-not-defined", "TEST_STRING"), nil)
  45 | 		assert.equals(instance:GetString("en-us", "STRING_KEY_NOT_DEFINED"), nil)
  46 | 	end)
  47 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/LocalScript.lua`
<details>
<summary>View Source (17 lines)</summary>

```lua
   1 | --[[
   2 | 	Serves as just a source container right now.
   3 | ]]
   4 | 
   5 | local BaseInstance = import("./BaseInstance")
   6 | local InstanceProperty = import("../InstanceProperty")
   7 | 
   8 | local LocalScript = BaseInstance:extend("LocalScript", {
   9 | 	creatable = true,
  10 | })
  11 | 
  12 | LocalScript.properties.Source = InstanceProperty.normal({
  13 | 	getDefault = function()
  14 | 		return ""
  15 | 	end,
  16 | })
  17 | 
  18 | return LocalScript
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/LocalScript_spec.lua`
<details>
<summary>View Source (9 lines)</summary>

```lua
   1 | local Instance = import("../Instance")
   2 | 
   3 | describe("instances.LocalScript", function()
   4 | 	it("should instantiate", function()
   5 | 		local instance = Instance.new("LocalScript")
   6 | 
   7 | 		assert.not_nil(instance)
   8 | 		assert.is.string(instance.Source)
   9 | 	end)
  10 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/MarketplaceService.lua`
<details>
<summary>View Source (29 lines)</summary>

```lua
   1 | local BaseInstance = import("./BaseInstance")
   2 | local InstanceProperty = import("../InstanceProperty")
   3 | local Signal = import("../Signal")
   4 | local MarketplaceService = BaseInstance:extend("MarketplaceService")
   5 | 
   6 | MarketplaceService.properties.PromptPurchaseRequested = InstanceProperty.readOnly({
   7 | 	getDefault = function()
   8 | 		return Signal.new()
   9 | 	end,
  10 | })
  11 | 
  12 | MarketplaceService.properties.PromptProductPurchaseRequested = InstanceProperty.readOnly({
  13 | 	getDefault = function()
  14 | 		return Signal.new()
  15 | 	end,
  16 | })
  17 | 
  18 | MarketplaceService.properties.PromptGamePassPurchaseRequested = InstanceProperty.readOnly({
  19 | 	getDefault = function()
  20 | 		return Signal.new()
  21 | 	end,
  22 | })
  23 | 
  24 | MarketplaceService.properties.ServerPurchaseVerification = InstanceProperty.readOnly({
  25 | 	getDefault = function()
  26 | 		return Signal.new()
  27 | 	end,
  28 | })
  29 | 
  30 | return MarketplaceService
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/MarketplaceService_spec.lua`
<details>
<summary>View Source (8 lines)</summary>

```lua
   1 | local MarketplaceService = import("./MarketplaceService")
   2 | 
   3 | describe("instances.MarketplaceService", function()
   4 | 	it("should instantiate", function()
   5 | 		local instance = MarketplaceService:new()
   6 | 
   7 | 		assert.not_nil(instance)
   8 | 	end)
   9 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/Model.lua`
<details>
<summary>View Source (4 lines)</summary>

```lua
   1 | local BaseInstance = import("./BaseInstance")
   2 | 
   3 | return BaseInstance:extend("Model", {
   4 | 	creatable = true,
   5 | })
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/Model_spec.lua`
<details>
<summary>View Source (8 lines)</summary>

```lua
   1 | local Instance = import("../Instance")
   2 | 
   3 | describe("instances.Model", function()
   4 | 	it("should instantiate", function()
   5 | 		local instance = Instance.new("Model")
   6 | 
   7 | 		assert.not_nil(instance)
   8 | 	end)
   9 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/ModuleScript.lua`
<details>
<summary>View Source (13 lines)</summary>

```lua
   1 | local BaseInstance = import("./BaseInstance")
   2 | local InstanceProperty = import("../InstanceProperty")
   3 | 
   4 | local ModuleScript = BaseInstance:extend("ModuleScript", {
   5 | 	creatable = true,
   6 | })
   7 | 
   8 | ModuleScript.properties.Source = InstanceProperty.normal({
   9 | 	getDefault = function()
  10 | 		return ""
  11 | 	end,
  12 | })
  13 | 
  14 | return ModuleScript
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/ModuleScript_spec.lua`
<details>
<summary>View Source (9 lines)</summary>

```lua
   1 | local Instance = import("../Instance")
   2 | 
   3 | describe("instances.ModuleScript", function()
   4 | 	it("should instantiate", function()
   5 | 		local instance = Instance.new("ModuleScript")
   6 | 
   7 | 		assert.not_nil(instance)
   8 | 		assert.is.string(instance.Source)
   9 | 	end)
  10 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/NotificationService.lua`
<details>
<summary>View Source (4 lines)</summary>

```lua
   1 | local BaseInstance = import("./BaseInstance")
   2 | 
   3 | return BaseInstance:extend("NotificationService", {
   4 | 	creatable = true,
   5 | })
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/NotificationService_spec.lua`
<details>
<summary>View Source (8 lines)</summary>

```lua
   1 | local Instance = import("../Instance")
   2 | 
   3 | describe("instances.NotificationService", function()
   4 | 	it("should instantiate", function()
   5 | 		local instance = Instance.new("NotificationService")
   6 | 
   7 | 		assert.not_nil(instance)
   8 | 	end)
   9 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/NumberValue.lua`
<details>
<summary>View Source (17 lines)</summary>

```lua
   1 | local BaseInstance = import("./BaseInstance")
   2 | local InstanceProperty = import("../InstanceProperty")
   3 | 
   4 | local NumberValue = BaseInstance:extend("NumberValue", {
   5 | 	creatable = true,
   6 | })
   7 | 
   8 | NumberValue.properties.Value = InstanceProperty.normal({
   9 | 	getDefault = function()
  10 | 		return 0
  11 | 	end,
  12 | })
  13 | 
  14 | function NumberValue:init(instance)
  15 | 	instance.Name = "Value"
  16 | end
  17 | 
  18 | return NumberValue
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/NumberValue_spec.lua`
<details>
<summary>View Source (16 lines)</summary>

```lua
   1 | local Instance = import("../Instance")
   2 | 
   3 | describe("instances.NumberValue", function()
   4 | 	it("should instantiate", function()
   5 | 		local instance = Instance.new("NumberValue")
   6 | 
   7 | 		assert.not_nil(instance)
   8 | 		assert.equal("Value", instance.Name)
   9 | 		assert.equal(0, instance.Value)
  10 | 	end)
  11 | 
  12 | 	it("should work with decimals", function()
  13 | 		local instance = Instance.new("NumberValue")
  14 | 		instance.Value = 0.5
  15 | 		assert.equal(instance.Value, 0.5)
  16 | 	end)
  17 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/ObjectValue.lua`
<details>
<summary>View Source (13 lines)</summary>

```lua
   1 | local BaseInstance = import("./BaseInstance")
   2 | local InstanceProperty = import("../InstanceProperty")
   3 | 
   4 | local ObjectValue = BaseInstance:extend("ObjectValue", {
   5 | 	creatable = true,
   6 | })
   7 | 
   8 | ObjectValue.properties.Value = InstanceProperty.normal({})
   9 | 
  10 | function ObjectValue:init(instance)
  11 | 	instance.Name = "Value"
  12 | end
  13 | 
  14 | return ObjectValue
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/ObjectValue_spec.lua`
<details>
<summary>View Source (18 lines)</summary>

```lua
   1 | local Instance = import("../Instance")
   2 | 
   3 | describe("instances.ObjectValue", function()
   4 | 	it("should instantiate", function()
   5 | 		local instance = Instance.new("ObjectValue")
   6 | 
   7 | 		assert.not_nil(instance)
   8 | 		assert.equal("Value", instance.Name)
   9 | 		assert.equal(nil, instance.Value)
  10 | 	end)
  11 | 
  12 | 	it("should set values", function()
  13 | 		local instance = Instance.new("ObjectValue")
  14 | 
  15 | 		instance.Value = instance
  16 | 
  17 | 		assert.equal(instance.Value, instance)
  18 | 	end)
  19 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/ParticleEffect.lua`
<details>
<summary>View Source (13 lines)</summary>

```lua
   1 | local BaseInstance = import("./BaseInstance")
   2 | local InstanceProperty = import("../InstanceProperty")
   3 | 
   4 | local ParticleEffect = BaseInstance:extend("ParticleEffect", {
   5 | 	creatable = true,
   6 | })
   7 | 
   8 | ParticleEffect.properties.Enabled = InstanceProperty.normal({
   9 | 	getDefault = function()
  10 | 		return true
  11 | 	end,
  12 | })
  13 | 
  14 | return ParticleEffect
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/ParticleEffect_spec.lua`
<details>
<summary>View Source (9 lines)</summary>

```lua
   1 | local Instance = import("../Instance")
   2 | 
   3 | describe("instances.ParticleEffect", function()
   4 | 	it("should instantiate", function()
   5 | 		local instance = Instance.new("ParticleEffect")
   6 | 
   7 | 		assert.not_nil(instance)
   8 | 		assert.equal(true, instance.Enabled)
   9 | 	end)
  10 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/Player.lua`
<details>
<summary>View Source (20 lines)</summary>

```lua
   1 | local BaseInstance = import("./BaseInstance")
   2 | local InstanceProperty = import("../InstanceProperty")
   3 | local Player = BaseInstance:extend("Player")
   4 | 
   5 | function Player:init(instance, userId)
   6 | 	if userId ~= nil then
   7 | 		if type(userId) ~= "number" then
   8 | 			error("userId must be an int64", 2)
   9 | 		end
  10 | 
  11 | 		getmetatable(instance).instance.properties.UserId = userId
  12 | 	end
  13 | end
  14 | 
  15 | Player.properties.UserId = InstanceProperty.readOnly({
  16 | 	getDefault = function()
  17 | 		return 0
  18 | 	end,
  19 | })
  20 | 
  21 | return Player
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/Player_spec.lua`
<details>
<summary>View Source (21 lines)</summary>

```lua
   1 | local Player = import("./Player")
   2 | 
   3 | describe("instances.Player", function()
   4 | 	it("should instantiate", function()
   5 | 		local instance = Player:new()
   6 | 
   7 | 		assert.not_nil(instance)
   8 | 		assert.equals(instance.UserId, 0)
   9 | 	end)
  10 | 
  11 | 	it("should take a userId", function()
  12 | 		local instance = Player:new(1234)
  13 | 
  14 | 		assert.equals(instance.UserId, 1234)
  15 | 	end)
  16 | 
  17 | 	it("should throw when userId is not a number", function()
  18 | 		assert.has.errors(function()
  19 | 			Player:new("1234")
  20 | 		end)
  21 | 	end)
  22 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/Players.lua`
<details>
<summary>View Source (16 lines)</summary>

```lua
   1 | local BaseInstance = import("./BaseInstance")
   2 | local InstanceProperty = import("../InstanceProperty")
   3 | local Player = import("./Player")
   4 | 
   5 | local Players = BaseInstance:extend("Players")
   6 | 
   7 | Players.properties.LocalPlayer = InstanceProperty.normal({
   8 | 	getDefault = function()
   9 | 		return Player:new()
  10 | 	end,
  11 | })
  12 | 
  13 | function Players.prototype:GetPlayerFromCharacter()
  14 | 	return nil
  15 | end
  16 | 
  17 | return Players
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/Players_spec.lua`
<details>
<summary>View Source (24 lines)</summary>

```lua
   1 | local typeof = import("../functions/typeof")
   2 | 
   3 | local Model = import("./Model")
   4 | local Players = import("./Players")
   5 | 
   6 | describe("instances.Players", function()
   7 | 	it("should instantiate", function()
   8 | 		local instance = Players:new()
   9 | 
  10 | 		assert.not_nil(instance)
  11 | 	end)
  12 | 
  13 | 	it("should have properties defined", function()
  14 | 		local instance = Players:new()
  15 | 
  16 | 		assert.equal(typeof(instance.LocalPlayer), "Instance")
  17 | 	end)
  18 | 
  19 | 	it("should return nil when using GetPlayerFromCharacter", function()
  20 | 		local instance = Players:new()
  21 | 
  22 | 		assert.equal(instance:GetPlayerFromCharacter(Model:new()), nil)
  23 | 	end)
  24 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/ReplicatedFirst.lua`
<details>
<summary>View Source (3 lines)</summary>

```lua
   1 | local BaseInstance = import("./BaseInstance")
   2 | local ReplicatedFirst = BaseInstance:extend("ReplicatedFirst")
   3 | 
   4 | return ReplicatedFirst
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/ReplicatedFirst_spec.lua`
<details>
<summary>View Source (8 lines)</summary>

```lua
   1 | local ReplicatedFirst = import("./ReplicatedFirst")
   2 | 
   3 | describe("instances.ReplicatedFirst", function()
   4 | 	it("should instantiate", function()
   5 | 		local instance = ReplicatedFirst:new()
   6 | 
   7 | 		assert.not_nil(instance)
   8 | 	end)
   9 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/ReplicatedStorage.lua`
<details>
<summary>View Source (2 lines)</summary>

```lua
   1 | local BaseInstance = import("./BaseInstance")
   2 | 
   3 | return BaseInstance:extend("ReplicatedStorage")
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/ReplicatedStorage_spec.lua`
<details>
<summary>View Source (8 lines)</summary>

```lua
   1 | local ReplicatedStorage = import("./ReplicatedStorage")
   2 | 
   3 | describe("instances.ReplicatedStorage", function()
   4 | 	it("should instantiate", function()
   5 | 		local instance = ReplicatedStorage:new()
   6 | 
   7 | 		assert.not_nil(instance)
   8 | 	end)
   9 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/RunService.lua`
<details>
<summary>View Source (27 lines)</summary>

```lua
   1 | local Signal = import("../Signal")
   2 | local BaseInstance = import("./BaseInstance")
   3 | local InstanceProperty = import("../InstanceProperty")
   4 | 
   5 | local RunService = BaseInstance:extend("RunService")
   6 | 
   7 | function RunService:init(instance)
   8 | 	instance.Name = "Run Service"
   9 | end
  10 | 
  11 | RunService.properties.Heartbeat = InstanceProperty.readOnly({
  12 | 	getDefault = Signal.new,
  13 | })
  14 | 
  15 | RunService.properties.RenderStepped = InstanceProperty.readOnly({
  16 | 	getDefault = Signal.new,
  17 | })
  18 | 
  19 | function RunService.prototype:IsServer()
  20 | 	return false -- TODO: You should be able to customize this option (#115)
  21 | end
  22 | 
  23 | function RunService.prototype:IsStudio()
  24 | 	return false
  25 | end
  26 | 
  27 | return RunService
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/RunService_spec.lua`
<details>
<summary>View Source (32 lines)</summary>

```lua
   1 | local RunService = import("./RunService")
   2 | local Signal = import("../Signal")
   3 | 
   4 | describe("instances.RunService", function()
   5 | 	it("should instantiate", function()
   6 | 		local instance = RunService:new()
   7 | 
   8 | 		assert.not_nil(instance)
   9 | 		assert.not_nil(instance.Heartbeat)
  10 | 	end)
  11 | 
  12 | 	it("should have the name 'Run Service'", function()
  13 | 		local instance = RunService:new()
  14 | 		assert.is_equal(instance.Name, "Run Service")
  15 | 	end)
  16 | 
  17 | 	it("should return false when IsStudio() is called", function()
  18 | 		local instance = RunService:new()
  19 | 		assert.is_equal(instance:IsStudio(), false)
  20 | 	end)
  21 | 
  22 | 	it("should return a bool when IsServer() is called", function()
  23 | 		local instance = RunService:new()
  24 | 		assert.is_equal(type(instance:IsServer()), "boolean")
  25 | 	end)
  26 | 
  27 | 	it("should have properties defined", function()
  28 | 		local instance = RunService:new()
  29 | 
  30 | 		assert.equals(instance.Heartbeat.__index, Signal)
  31 | 		assert.equals(instance.RenderStepped.__index, Signal)
  32 | 	end)
  33 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/ScreenGui.lua`
<details>
<summary>View Source (58 lines)</summary>

```lua
   1 | local BaseInstance = import("./BaseInstance")
   2 | local InstanceProperty = import("../InstanceProperty")
   3 | local Vector2 = import("../types/Vector2")
   4 | local ZIndexBehavior = import("../Enum/ZIndexBehavior")
   5 | 
   6 | local ScreenGui = BaseInstance:extend("ScreenGui", {
   7 | 	creatable = true,
   8 | })
   9 | 
  10 | ScreenGui.properties.AbsolutePosition = InstanceProperty.readOnly({
  11 | 	get = function(self)
  12 | 		return Vector2.new(0, 0)
  13 | 	end,
  14 | })
  15 | 
  16 | ScreenGui.properties.AbsoluteSize = InstanceProperty.readOnly({
  17 | 	get = function(self)
  18 | 		return Vector2.new(800, 600)
  19 | 	end,
  20 | })
  21 | 
  22 | ScreenGui.properties.DisplayOrder = InstanceProperty.typed("number", {
  23 | 	getDefault = function()
  24 | 		return 0
  25 | 	end,
  26 | })
  27 | 
  28 | ScreenGui.properties.AutoLocalize = InstanceProperty.typed("boolean", {
  29 | 	getDefault = function()
  30 | 		return true
  31 | 	end,
  32 | })
  33 | 
  34 | ScreenGui.properties.IgnoreGuiInset = InstanceProperty.typed("boolean", {
  35 | 	getDefault = function()
  36 | 		return false
  37 | 	end,
  38 | })
  39 | 
  40 | ScreenGui.properties.ZIndexBehavior = InstanceProperty.enum(ZIndexBehavior, {
  41 | 	getDefault = function()
  42 | 		return ZIndexBehavior.Global
  43 | 	end,
  44 | })
  45 | 
  46 | ScreenGui.properties.Enabled = InstanceProperty.typed("boolean", {
  47 | 	getDefault = function()
  48 | 		return true
  49 | 	end,
  50 | })
  51 | 
  52 | ScreenGui.properties.OnTopOfCoreBlur = InstanceProperty.typed("boolean", {
  53 | 	getDefault = function()
  54 | 		return false
  55 | 	end,
  56 | })
  57 | 
  58 | return ScreenGui
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/ScreenGui_spec.lua`
<details>
<summary>View Source (25 lines)</summary>

```lua
   1 | local Instance = import("../Instance")
   2 | local typeof = import("../functions/typeof")
   3 | local ZIndexBehavior = import("../Enum/ZIndexBehavior")
   4 | 
   5 | describe("instances.ScreenGui", function()
   6 | 	it("should instantiate", function()
   7 | 		local instance = Instance.new("ScreenGui")
   8 | 
   9 | 		assert.not_nil(instance)
  10 | 	end)
  11 | 
  12 | 	it("should have properties defined", function()
  13 | 		local instance = Instance.new("ScreenGui")
  14 | 
  15 | 		assert.equals(typeof(instance.AbsolutePosition), "Vector2")
  16 | 		assert.equals(typeof(instance.AbsoluteSize), "Vector2")
  17 | 		assert.equals(typeof(instance.DisplayOrder), "number")
  18 | 		assert.equals(typeof(instance.AutoLocalize), "boolean")
  19 | 		assert.equals(typeof(instance.IgnoreGuiInset), "boolean")
  20 | 		assert.equals(typeof(instance.ZIndexBehavior), "EnumItem")
  21 | 		assert.equals(typeof(instance.OnTopOfCoreBlur), "boolean")
  22 | 		assert.equals(typeof(instance.Enabled), "boolean")
  23 | 		assert.equals(instance.ZIndexBehavior.EnumType, ZIndexBehavior)
  24 | 	end)
  25 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/Script.lua`
<details>
<summary>View Source (17 lines)</summary>

```lua
   1 | --[[
   2 | 	Serves as just a source container right now.
   3 | ]]
   4 | 
   5 | local BaseInstance = import("./BaseInstance")
   6 | local InstanceProperty = import("../InstanceProperty")
   7 | 
   8 | local Script = BaseInstance:extend("Script", {
   9 | 	creatable = true,
  10 | })
  11 | 
  12 | Script.properties.Source = InstanceProperty.normal({
  13 | 	getDefault = function()
  14 | 		return ""
  15 | 	end,
  16 | })
  17 | 
  18 | return Script
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/Script_spec.lua`
<details>
<summary>View Source (9 lines)</summary>

```lua
   1 | local Instance = import("../Instance")
   2 | 
   3 | describe("instances.Script", function()
   4 | 	it("should instantiate", function()
   5 | 		local instance = Instance.new("Script")
   6 | 
   7 | 		assert.not_nil(instance)
   8 | 		assert.is.string(instance.Source)
   9 | 	end)
  10 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/ScrollingFrame.lua`
<details>
<summary>View Source (91 lines)</summary>

```lua
   1 | local ScrollingDirection = import("../Enum/ScrollingDirection")
   2 | local ScrollBarInset = import("../Enum/ScrollBarInset")
   3 | local VerticalScrollBarPosition = import("../Enum/VerticalScrollBarPosition")
   4 | local GuiObject = import("./GuiObject")
   5 | local InstanceProperty = import("../InstanceProperty")
   6 | local UDim2 = import("../types/UDim2")
   7 | local Vector2 = import("../types/Vector2")
   8 | 
   9 | local ScrollingFrame = GuiObject:extend("ScrollingFrame", {
  10 | 	creatable = true,
  11 | })
  12 | 
  13 | ScrollingFrame.properties.AbsoluteWindowSize = InstanceProperty.readOnly({
  14 | 	get = function(self)
  15 | 		local size = self.AbsoluteSize
  16 | 
  17 | 		local thickness = self.ScrollBarThickness
  18 | 		local marginX = 0
  19 | 		local marginY = 0
  20 | 
  21 | 		if self:_canScrollHorizontal() then
  22 | 			marginX = thickness
  23 | 		end
  24 | 
  25 | 		if self:_canScrollVertical() then
  26 | 			marginY = thickness
  27 | 		end
  28 | 
  29 | 		return Vector2.new(
  30 | 			math.max(0, size.X - marginX),
  31 | 			math.max(0, size.Y - marginY)
  32 | 		)
  33 | 	end,
  34 | })
  35 | 
  36 | ScrollingFrame.properties.CanvasPosition = InstanceProperty.typed("Vector2", {
  37 | 	getDefault = function()
  38 | 		return Vector2.new()
  39 | 	end,
  40 | })
  41 | 
  42 | ScrollingFrame.properties.CanvasSize = InstanceProperty.typed("UDim2", {
  43 | 	getDefault = function()
  44 | 		return UDim2.new()
  45 | 	end,
  46 | })
  47 | 
  48 | ScrollingFrame.properties.ScrollBarThickness = InstanceProperty.typed("number", {
  49 | 	getDefault = function()
  50 | 		return 12
  51 | 	end,
  52 | })
  53 | 
  54 | ScrollingFrame.properties.ScrollingDirection = InstanceProperty.enum(ScrollingDirection, {
  55 | 	getDefault = function()
  56 | 		return ScrollingDirection.XY
  57 | 	end,
  58 | })
  59 | 
  60 | ScrollingFrame.properties.ScrollingEnabled = InstanceProperty.typed("boolean", {
  61 | 	getDefault = function()
  62 | 		return true
  63 | 	end,
  64 | })
  65 | 
  66 | ScrollingFrame.properties.VerticalScrollBarInset = InstanceProperty.enum(ScrollBarInset, {
  67 | 	getDefault = function()
  68 | 		return ScrollBarInset.None
  69 | 	end,
  70 | })
  71 | 
  72 | ScrollingFrame.properties.VerticalScrollBarPosition = InstanceProperty.enum(VerticalScrollBarPosition, {
  73 | 	getDefault = function()
  74 | 		return VerticalScrollBarPosition.Right
  75 | 	end,
  76 | })
  77 | 
  78 | function ScrollingFrame.prototype:_canScrollHorizontal()
  79 | 	local scrollDir = self.ScrollingDirection
  80 | 	return self.ScrollingEnabled and
  81 | 		(scrollDir == ScrollingDirection.X or
  82 | 		scrollDir == ScrollingDirection.XY)
  83 | end
  84 | 
  85 | function ScrollingFrame.prototype:_canScrollVertical()
  86 | 	local scrollDir = self.ScrollingDirection
  87 | 	return self.ScrollingEnabled and
  88 | 		(scrollDir == ScrollingDirection.Y or
  89 | 		scrollDir == ScrollingDirection.XY)
  90 | end
  91 | 
  92 | return ScrollingFrame
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/ScrollingFrame_spec.lua`
<details>
<summary>View Source (75 lines)</summary>

```lua
   1 | local Instance = import("../Instance")
   2 | local ScrollingDirection = import("../Enum/ScrollingDirection")
   3 | local ScrollBarInset = import("../Enum/ScrollBarInset")
   4 | local typeof = import("../functions/typeof")
   5 | local UDim2 = import("../types/UDim2")
   6 | local VerticalScrollBarPosition = import("../Enum/VerticalScrollBarPosition")
   7 | 
   8 | local function extractVector2(vector2)
   9 | 	return { vector2.X, vector2.Y }
  10 | end
  11 | 
  12 | describe("instances.ScrollingFrame", function()
  13 | 	it("should instantiate", function()
  14 | 		local instance = Instance.new("ScrollingFrame")
  15 | 		assert.not_nil(instance)
  16 | 	end)
  17 | 
  18 | 	it("should have properties defined", function()
  19 | 		local instance = Instance.new("ScrollingFrame")
  20 | 
  21 | 		assert.equal(typeof(instance.CanvasPosition), "Vector2")
  22 | 		assert.equal(typeof(instance.CanvasSize), "UDim2")
  23 | 		assert.equal(typeof(instance.ScrollBarThickness), "number")
  24 | 		assert.equal(typeof(instance.ScrollingDirection), "EnumItem")
  25 | 		assert.equal(instance.ScrollingDirection.EnumType, ScrollingDirection)
  26 | 		assert.equal(typeof(instance.ScrollingEnabled), "boolean")
  27 | 		assert.equal(typeof(instance.VerticalScrollBarInset), "EnumItem")
  28 | 		assert.equal(instance.VerticalScrollBarInset.EnumType, ScrollBarInset)
  29 | 		assert.equal(typeof(instance.VerticalScrollBarPosition), "EnumItem")
  30 | 		assert.equal(instance.VerticalScrollBarPosition.EnumType, VerticalScrollBarPosition)
  31 | 	end)
  32 | 
  33 | 	describe("AbsoluteWindowSize", function()
  34 | 		it("it should be affected by scrolling", function()
  35 | 			local screenGui = Instance.new("ScreenGui")
  36 | 			local screenGuiSize = screenGui.AbsoluteSize
  37 | 
  38 | 			local instance = Instance.new("ScrollingFrame", screenGui)
  39 | 			instance.Size = UDim2.new(1, 0, 1, 0)
  40 | 
  41 | 			instance.ScrollingEnabled = false
  42 | 			assert.same(extractVector2(screenGuiSize), extractVector2(instance.AbsoluteWindowSize))
  43 | 
  44 | 			instance.ScrollingEnabled = true
  45 | 			instance.ScrollingDirection = ScrollingDirection.XY
  46 | 			assert.same(
  47 | 				{
  48 | 					screenGuiSize.X - instance.ScrollBarThickness,
  49 | 					screenGuiSize.Y - instance.ScrollBarThickness,
  50 | 				},
  51 | 				extractVector2(instance.AbsoluteWindowSize)
  52 | 			)
  53 | 
  54 | 			instance.ScrollingDirection = ScrollingDirection.X
  55 | 			instance.ScrollingEnabled = true
  56 | 			assert.same(
  57 | 				{
  58 | 					screenGuiSize.X - instance.ScrollBarThickness,
  59 | 					screenGuiSize.Y,
  60 | 				},
  61 | 				extractVector2(instance.AbsoluteWindowSize)
  62 | 			)
  63 | 
  64 | 			instance.ScrollingDirection = ScrollingDirection.Y
  65 | 			instance.ScrollingEnabled = true
  66 | 			assert.same(
  67 | 				{
  68 | 					screenGuiSize.X,
  69 | 					screenGuiSize.Y - instance.ScrollBarThickness,
  70 | 				},
  71 | 				extractVector2(instance.AbsoluteWindowSize)
  72 | 			)
  73 | 		end)
  74 | 	end)
  75 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/ServerScriptService.lua`
<details>
<summary>View Source (3 lines)</summary>

```lua
   1 | local BaseInstance = import("./BaseInstance")
   2 | local ServerScriptService = BaseInstance:extend("ServerScriptService")
   3 | 
   4 | return ServerScriptService
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/ServerScriptService_spec.lua`
<details>
<summary>View Source (9 lines)</summary>

```lua
   1 | local ServerScriptService = import("./ServerScriptService")
   2 | 
   3 | describe("instances.ServerScriptService", function()
   4 | 	it("should instantiate", function()
   5 | 		local instance = ServerScriptService:new()
   6 | 
   7 | 		assert.not_nil(instance)
   8 | 	end)
   9 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/ServerStorage.lua`
<details>
<summary>View Source (3 lines)</summary>

```lua
   1 | local BaseInstance = import("./BaseInstance")
   2 | local ServerStorage = BaseInstance:extend("ServerStorage")
   3 | 
   4 | return ServerStorage
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/ServerStorage_spec.lua`
<details>
<summary>View Source (9 lines)</summary>

```lua
   1 | local ServerStorage = import("./ServerStorage")
   2 | 
   3 | describe("instances.ServerStorage", function()
   4 | 	it("should instantiate", function()
   5 | 		local instance = ServerStorage:new()
   6 | 
   7 | 		assert.not_nil(instance)
   8 | 	end)
   9 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/StarterCharacterScripts.lua`
<details>
<summary>View Source (3 lines)</summary>

```lua
   1 | local StarterPlayerScripts = import("./StarterPlayerScripts")
   2 | local StarterCharacterScripts = StarterPlayerScripts:extend("StarterCharacterScripts")
   3 | 
   4 | return StarterCharacterScripts
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/StarterCharacterScripts_spec.lua`
<details>
<summary>View Source (13 lines)</summary>

```lua
   1 | local StarterCharacterScripts = import("./StarterCharacterScripts")
   2 | 
   3 | describe("instances.StarterCharacterScripts", function()
   4 | 	it("should instantiate", function()
   5 | 		local instance = StarterCharacterScripts:new()
   6 | 
   7 | 		assert.not_nil(instance)
   8 | 	end)
   9 | 
  10 | 	it("should inherit StarterPlayerScripts", function()
  11 | 		assert.True(StarterCharacterScripts:new():IsA("StarterPlayerScripts"))
  12 | 	end)
  13 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/StarterPlayer.lua`
<details>
<summary>View Source (12 lines)</summary>

```lua
   1 | local BaseInstance = import("./BaseInstance")
   2 | local StarterCharacterScripts = import("./StarterCharacterScripts")
   3 | local StarterPlayerScripts = import("./StarterPlayerScripts")
   4 | 
   5 | local StarterPlayer = BaseInstance:extend("StarterPlayer")
   6 | 
   7 | function StarterPlayer:init(instance)
   8 | 	StarterCharacterScripts:new().Parent = instance
   9 | 	StarterPlayerScripts:new().Parent = instance
  10 | end
  11 | 
  12 | return StarterPlayer
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/StarterPlayer_spec.lua`
<details>
<summary>View Source (16 lines)</summary>

```lua
   1 | local StarterPlayer = import("./StarterPlayer")
   2 | 
   3 | describe("instances.StarterPlayer", function()
   4 | 	it("should instantiate", function()
   5 | 		local instance = StarterPlayer:new()
   6 | 
   7 | 		assert.not_nil(instance)
   8 | 	end)
   9 | 
  10 | 	it("should contain StarterPlayerScripts and StarterCharacterScripts", function()
  11 | 		local instance = StarterPlayer:new()
  12 | 
  13 | 		assert.not_nil(instance:FindFirstChild("StarterPlayerScripts"))
  14 | 		assert.not_nil(instance:FindFirstChild("StarterCharacterScripts"))
  15 | 	end)
  16 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/StarterPlayerScripts.lua`
<details>
<summary>View Source (3 lines)</summary>

```lua
   1 | local BaseInstance = import("./BaseInstance")
   2 | local StarterPlayerScripts = BaseInstance:extend("StarterPlayerScripts")
   3 | 
   4 | return StarterPlayerScripts
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/StarterPlayerScripts_spec.lua`
<details>
<summary>View Source (9 lines)</summary>

```lua
   1 | local StarterPlayerScripts = import("./StarterPlayerScripts")
   2 | 
   3 | describe("instances.StarterPlayerScripts", function()
   4 | 	it("should instantiate", function()
   5 | 		local instance = StarterPlayerScripts:new()
   6 | 
   7 | 		assert.not_nil(instance)
   8 | 	end)
   9 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/Stats.lua`
<details>
<summary>View Source (3 lines)</summary>

```lua
   1 | local BaseInstance = import("./BaseInstance")
   2 | local Stats = BaseInstance:extend("Stats")
   3 | 
   4 | return Stats
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/Stats_spec.lua`
<details>
<summary>View Source (8 lines)</summary>

```lua
   1 | local Stats = import("./Stats")
   2 | 
   3 | describe("instances.Stats", function()
   4 | 	it("should instantiate", function()
   5 | 		local instance = Stats:new()
   6 | 
   7 | 		assert.not_nil(instance)
   8 | 	end)
   9 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/StringValue.lua`
<details>
<summary>View Source (17 lines)</summary>

```lua
   1 | local BaseInstance = import("./BaseInstance")
   2 | local InstanceProperty = import("../InstanceProperty")
   3 | 
   4 | local StringValue = BaseInstance:extend("StringValue", {
   5 | 	creatable = true,
   6 | })
   7 | 
   8 | StringValue.properties.Value = InstanceProperty.normal({
   9 | 	getDefault = function()
  10 | 		return ""
  11 | 	end,
  12 | })
  13 | 
  14 | function StringValue:init(instance)
  15 | 	instance.Name = "Value"
  16 | end
  17 | 
  18 | return StringValue
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/StringValue_spec.lua`
<details>
<summary>View Source (10 lines)</summary>

```lua
   1 | local Instance = import("../Instance")
   2 | 
   3 | describe("instances.StringValue", function()
   4 | 	it("should instantiate", function()
   5 | 		local instance = Instance.new("StringValue")
   6 | 
   7 | 		assert.not_nil(instance)
   8 | 		assert.equal("Value", instance.Name)
   9 | 		assert.equal("", instance.Value)
  10 | 	end)
  11 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/TestService.lua`
<details>
<summary>View Source (9 lines)</summary>

```lua
   1 | local BaseInstance = import("./BaseInstance")
   2 | 
   3 | local TestService = BaseInstance:extend("TestService")
   4 | 
   5 | function TestService.prototype:Error(message)
   6 | 	io.stderr:write(message)
   7 | 	io.stderr:write("\n")
   8 | end
   9 | 
  10 | return TestService
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/TestService_spec.lua`
<details>
<summary>View Source (27 lines)</summary>

```lua
   1 | local TestService = import("./TestService")
   2 | 
   3 | describe("instances.TestService", function()
   4 | 	it("should instantiate", function()
   5 | 		local instance = TestService:new()
   6 | 
   7 | 		assert.not_nil(instance)
   8 | 		assert.not_nil(instance.Error)
   9 | 	end)
  10 | 
  11 | 	it("should write to stderr", function()
  12 | 		local instance = TestService:new()
  13 | 		local oldErr = io.stderr
  14 | 
  15 | 		local writeSpy = spy.new(function(_, msg) end)
  16 | 
  17 | 		io.stderr = { -- luacheck: ignore
  18 | 			write = writeSpy
  19 | 		}
  20 | 
  21 | 		instance:Error("Testing tests in a library for testing?")
  22 | 
  23 | 		assert.spy(writeSpy).was_called_with(io.stderr, "Testing tests in a library for testing?")
  24 | 
  25 | 		io.stderr = oldErr -- luacheck: ignore
  26 | 	end)
  27 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/TextButton.lua`
<details>
<summary>View Source (54 lines)</summary>

```lua
   1 | local Color3 = import("../types/Color3")
   2 | local Font = import("../Enum/Font")
   3 | local GuiButton = import("./GuiButton")
   4 | local InstanceProperty = import("../InstanceProperty")
   5 | local TextXAlignment = import("../Enum/TextXAlignment")
   6 | local TextYAlignment = import("../Enum/TextYAlignment")
   7 | 
   8 | local TextButton = GuiButton:extend("TextButton", {
   9 | 	creatable = true,
  10 | })
  11 | 
  12 | TextButton.properties.Font = InstanceProperty.enum(Font, {
  13 | 	getDefault = function()
  14 | 		return Font.Legacy
  15 | 	end,
  16 | })
  17 | 
  18 | TextButton.properties.Text = InstanceProperty.typed("string", {
  19 | 	getDefault = function()
  20 | 		return "Button"
  21 | 	end,
  22 | })
  23 | 
  24 | TextButton.properties.TextColor3 = InstanceProperty.typed("Color3", {
  25 | 	getDefault = function()
  26 | 		return Color3.fromRGB(27, 42, 53)
  27 | 	end,
  28 | })
  29 | 
  30 | TextButton.properties.TextSize = InstanceProperty.typed("number", {
  31 | 	getDefault = function()
  32 | 		return 14
  33 | 	end,
  34 | })
  35 | 
  36 | TextButton.properties.TextWrapped = InstanceProperty.typed("boolean", {
  37 | 	getDefault = function()
  38 | 		return false
  39 | 	end,
  40 | })
  41 | 
  42 | TextButton.properties.TextXAlignment = InstanceProperty.enum(TextXAlignment, {
  43 | 	getDefault = function()
  44 | 		return TextXAlignment.Left
  45 | 	end,
  46 | })
  47 | 
  48 | TextButton.properties.TextYAlignment = InstanceProperty.enum(TextYAlignment, {
  49 | 	getDefault = function()
  50 | 		return TextYAlignment.Top
  51 | 	end,
  52 | })
  53 | 
  54 | return TextButton
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/TextButton_spec.lua`
<details>
<summary>View Source (27 lines)</summary>

```lua
   1 | local Font = import("../Enum/Font")
   2 | local Instance = import("../Instance")
   3 | local TextXAlignment = import("../Enum/TextXAlignment")
   4 | local TextYAlignment = import("../Enum/TextYAlignment")
   5 | local typeof = import("../functions/typeof")
   6 | 
   7 | describe("instances.TextButton", function()
   8 | 	it("should instantiate", function()
   9 | 		local instance = Instance.new("TextButton")
  10 | 
  11 | 		assert.not_nil(instance)
  12 | 	end)
  13 | 
  14 | 	it("should have properties defined", function()
  15 | 		local instance = Instance.new("TextButton")
  16 | 		assert.equal(typeof(instance.Font), "EnumItem")
  17 | 		assert.equal(instance.Font.EnumType, Font)
  18 | 		assert.equal(typeof(instance.Text), "string")
  19 | 		assert.equal(typeof(instance.TextColor3), "Color3")
  20 | 		assert.equal(typeof(instance.TextSize), "number")
  21 | 		assert.equal(typeof(instance.TextWrapped), "boolean")
  22 | 		assert.equal(typeof(instance.TextXAlignment), "EnumItem")
  23 | 		assert.equal(instance.TextXAlignment.EnumType, TextXAlignment)
  24 | 		assert.equal(typeof(instance.TextYAlignment), "EnumItem")
  25 | 		assert.equal(instance.TextYAlignment.EnumType, TextYAlignment)
  26 | 	end)
  27 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/TextLabel.lua`
<details>
<summary>View Source (73 lines)</summary>

```lua
   1 | local Color3 = import("../types/Color3")
   2 | local Font = import("../Enum/Font")
   3 | local GuiObject = import("./GuiObject")
   4 | local InstanceProperty = import("../InstanceProperty")
   5 | local TextTruncate = import("../Enum/TextTruncate")
   6 | local TextXAlignment = import("../Enum/TextXAlignment")
   7 | local TextYAlignment = import("../Enum/TextYAlignment")
   8 | 
   9 | local TextLabel = GuiObject:extend("TextLabel", {
  10 | 	creatable = true,
  11 | })
  12 | 
  13 | TextLabel.properties.Font = InstanceProperty.enum(Font, {
  14 | 	getDefault = function()
  15 | 		return Font.Legacy
  16 | 	end,
  17 | })
  18 | 
  19 | TextLabel.properties.Text = InstanceProperty.typed("string", {
  20 | 	getDefault = function()
  21 | 		return "Label"
  22 | 	end,
  23 | })
  24 | 
  25 | TextLabel.properties.TextColor3 = InstanceProperty.typed("Color3", {
  26 | 	getDefault = function()
  27 | 		return Color3.fromRGB(27, 42, 53)
  28 | 	end,
  29 | })
  30 | 
  31 | TextLabel.properties.TextSize = InstanceProperty.typed("number", {
  32 | 	getDefault = function()
  33 | 		return 14
  34 | 	end,
  35 | })
  36 | 
  37 | TextLabel.properties.TextTransparency = InstanceProperty.typed("number", {
  38 | 	getDefault = function()
  39 | 		return 0
  40 | 	end,
  41 | })
  42 | 
  43 | TextLabel.properties.TextTruncate = InstanceProperty.enum(TextTruncate, {
  44 | 	getDefault = function()
  45 | 		return TextTruncate.None
  46 | 	end,
  47 | })
  48 | 
  49 | TextLabel.properties.TextWrapped = InstanceProperty.typed("boolean", {
  50 | 	getDefault = function()
  51 | 		return false
  52 | 	end,
  53 | })
  54 | 
  55 | TextLabel.properties.TextScaled = InstanceProperty.typed("boolean", {
  56 | 	getDefault = function()
  57 | 		return false
  58 | 	end,
  59 | })
  60 | 
  61 | TextLabel.properties.TextXAlignment = InstanceProperty.enum(TextXAlignment, {
  62 | 	getDefault = function()
  63 | 		return TextXAlignment.Left
  64 | 	end,
  65 | })
  66 | 
  67 | TextLabel.properties.TextYAlignment = InstanceProperty.enum(TextYAlignment, {
  68 | 	getDefault = function()
  69 | 		return TextYAlignment.Top
  70 | 	end,
  71 | })
  72 | 
  73 | return TextLabel
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/TextLabel_spec.lua`
<details>
<summary>View Source (30 lines)</summary>

```lua
   1 | local Font = import("../Enum/Font")
   2 | local Instance = import("../Instance")
   3 | local TextTruncate = import("../Enum/TextTruncate")
   4 | local TextXAlignment = import("../Enum/TextXAlignment")
   5 | local TextYAlignment = import("../Enum/TextYAlignment")
   6 | local typeof = import("../functions/typeof")
   7 | 
   8 | describe("instances.TextLabel", function()
   9 | 	it("should instantiate", function()
  10 | 		local instance = Instance.new("TextLabel")
  11 | 
  12 | 		assert.not_nil(instance)
  13 | 	end)
  14 | 
  15 | 	it("should have properties defined", function()
  16 | 		local instance = Instance.new("TextLabel")
  17 | 		assert.equal(typeof(instance.Font), "EnumItem")
  18 | 		assert.equal(instance.Font.EnumType, Font)
  19 | 		assert.equal(typeof(instance.Text), "string")
  20 | 		assert.equal(typeof(instance.TextColor3), "Color3")
  21 | 		assert.equal(typeof(instance.TextSize), "number")
  22 | 		assert.equal(typeof(instance.TextWrapped), "boolean")
  23 | 		assert.equal(typeof(instance.TextTruncate), "EnumItem")
  24 | 		assert.equal(instance.TextTruncate.EnumType, TextTruncate)
  25 | 		assert.equal(typeof(instance.TextXAlignment), "EnumItem")
  26 | 		assert.equal(instance.TextXAlignment.EnumType, TextXAlignment)
  27 | 		assert.equal(typeof(instance.TextYAlignment), "EnumItem")
  28 | 		assert.equal(instance.TextYAlignment.EnumType, TextYAlignment)
  29 | 		assert.equal(typeof(instance.TextScaled), "boolean")
  30 | 	end)
  31 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/TextService.lua`
<details>
<summary>View Source (24 lines)</summary>

```lua
   1 | local BaseInstance = import("./BaseInstance")
   2 | local Font = import("../Enum/Font")
   3 | local typeof = import("../functions/typeof")
   4 | local Vector2 = import("../types/Vector2")
   5 | 
   6 | local TextService = BaseInstance:extend("TextService")
   7 | 
   8 | -- right now this is just a lazy [fontSize * len(text), fontSize] clipped by frameSize
   9 | function TextService.prototype:GetTextSize(text, fontSize, font, frameSize)
  10 | 	if typeof(text) ~= "string" then
  11 | 		error("text must be a string", 2)
  12 | 	elseif typeof(fontSize) ~= "number" then
  13 | 		error("fontSize must be a number", 2)
  14 | 	elseif typeof(font) ~= "EnumItem" and font.EnumType ~= Font then
  15 | 		error("font must be an Enum.Font", 2)
  16 | 	elseif typeof(frameSize) ~= "Vector2" then
  17 | 		error("frameSize must be a Vector2", 2)
  18 | 	end
  19 | 
  20 | 	local width = text:len() * fontSize
  21 | 
  22 | 	return Vector2.new(math.min(width, frameSize.X), math.min(fontSize, frameSize.Y))
  23 | end
  24 | 
  25 | return TextService
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/TextService_spec.lua`
<details>
<summary>View Source (45 lines)</summary>

```lua
   1 | local Font = import("../Enum/Font")
   2 | local Vector2 = import("../types/Vector2")
   3 | local typeof = import("../functions/typeof")
   4 | 
   5 | local TextService = import("./TextService")
   6 | 
   7 | describe("instances.TextService", function()
   8 | 	it("should instantiate", function()
   9 | 		local instance = TextService:new()
  10 | 
  11 | 		assert.not_nil(instance)
  12 | 	end)
  13 | 
  14 | 	describe("GetTextSize", function()
  15 | 		it("should verify parameters", function()
  16 | 			local instance = TextService:new()
  17 | 
  18 | 			assert.has.errors(function()
  19 | 				instance:GetTextSize(100, 36, Font.Legacy, Vector2.new(1, 1))
  20 | 			end)
  21 | 			assert.has.errors(function()
  22 | 				instance:GetTextSize("text", "str", Font.Legacy, Vector2.new(1, 1))
  23 | 			end)
  24 | 			assert.has.errors(function()
  25 | 				instance:GetTextSize("text", 36, "hey", Vector2.new(1, 1))
  26 | 			end)
  27 | 			assert.has.errors(function()
  28 | 				instance:GetTextSize("text", 36, Font.Legacy, 100)
  29 | 			end)
  30 | 		end)
  31 | 
  32 | 		it("should return a Vector2", function()
  33 | 			local instance = TextService:new()
  34 | 			local result = instance:GetTextSize("text", 36, Font.Legacy, Vector2.new(1000, 1000))
  35 | 
  36 | 			assert.equals(typeof(result), "Vector2")
  37 | 		end)
  38 | 
  39 | 		it("should clip the rect down", function()
  40 | 			local instance = TextService:new()
  41 | 			local result = instance:GetTextSize("VERY LARGE TEXT", 36, Font.Legacy, Vector2.new(1, 1))
  42 | 
  43 | 			assert.same({result.X, result.Y}, {1, 1})
  44 | 		end)
  45 | 	end)
  46 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/TweenService.lua`
<details>
<summary>View Source (2 lines)</summary>

```lua
   1 | local BaseInstance = import("./BaseInstance")
   2 | 
   3 | return BaseInstance:extend("TweenService")
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/TweenService_spec.lua`
<details>
<summary>View Source (8 lines)</summary>

```lua
   1 | local TweenService = import("./TweenService")
   2 | 
   3 | describe("instances.TweenService", function()
   4 | 	it("should instantiate", function()
   5 | 		local instance = TweenService:new()
   6 | 
   7 | 		assert.not_nil(instance)
   8 | 	end)
   9 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/UIGridStyleLayout.lua`
<details>
<summary>View Source (40 lines)</summary>

```lua
   1 | local BaseInstance = import("./BaseInstance")
   2 | local FillDirection = import("../Enum/FillDirection")
   3 | local HorizontalAlignment = import("../Enum/HorizontalAlignment")
   4 | local InstanceProperty = import("../InstanceProperty")
   5 | local SortOrder = import("../Enum/SortOrder")
   6 | local VerticalAlignment = import("../Enum/VerticalAlignment")
   7 | local Vector2 = import("../types/Vector2")
   8 | 
   9 | local UIGridStyleLayout = BaseInstance:extend("UIGridStyleLayout")
  10 | 
  11 | UIGridStyleLayout.properties.FillDirection = InstanceProperty.enum(FillDirection, {
  12 | 	getDefault = function()
  13 | 		return FillDirection.Horizontal
  14 | 	end,
  15 | })
  16 | 
  17 | UIGridStyleLayout.properties.HorizontalAlignment = InstanceProperty.enum(HorizontalAlignment, {
  18 | 	getDefault = function()
  19 | 		return HorizontalAlignment.Center
  20 | 	end,
  21 | })
  22 | 
  23 | UIGridStyleLayout.properties.SortOrder = InstanceProperty.enum(SortOrder, {
  24 | 	getDefault = function()
  25 | 		return SortOrder.Name
  26 | 	end,
  27 | })
  28 | 
  29 | UIGridStyleLayout.properties.VerticalAlignment = InstanceProperty.enum(VerticalAlignment, {
  30 | 	getDefault = function()
  31 | 		return VerticalAlignment.Center
  32 | 	end,
  33 | })
  34 | 
  35 | UIGridStyleLayout.properties.AbsoluteContentSize = InstanceProperty.readOnly({
  36 | 	get = function(self)
  37 | 		return Vector2.new(0, 0)
  38 | 	end,
  39 | })
  40 | 
  41 | return UIGridStyleLayout
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/UIGridStyleLayout_spec.lua`
<details>
<summary>View Source (28 lines)</summary>

```lua
   1 | local FillDirection = import("../Enum/FillDirection")
   2 | local HorizontalAlignment = import("../Enum/HorizontalAlignment")
   3 | local SortOrder = import("../Enum/SortOrder")
   4 | local typeof = import("../functions/typeof")
   5 | local VerticalAlignment = import("../Enum/VerticalAlignment")
   6 | 
   7 | local UIGridStyleLayout = import("./UIGridStyleLayout")
   8 | 
   9 | describe("instances.UIGridStyleLayout", function()
  10 | 	it("should instantiate", function()
  11 | 		local instance = UIGridStyleLayout:new()
  12 | 
  13 | 		assert.not_nil(instance)
  14 | 	end)
  15 | 
  16 | 	it("should have properties defined", function()
  17 | 		local instance = UIGridStyleLayout:new()
  18 | 
  19 | 		assert.equals(typeof(instance.FillDirection), "EnumItem")
  20 | 		assert.equals(instance.FillDirection.EnumType, FillDirection)
  21 | 		assert.equals(typeof(instance.HorizontalAlignment), "EnumItem")
  22 | 		assert.equals(instance.HorizontalAlignment.EnumType, HorizontalAlignment)
  23 | 		assert.equals(typeof(instance.SortOrder), "EnumItem")
  24 | 		assert.equals(instance.SortOrder.EnumType, SortOrder)
  25 | 		assert.equals(typeof(instance.VerticalAlignment), "EnumItem")
  26 | 		assert.equal(instance.VerticalAlignment.EnumType, VerticalAlignment)
  27 | 		assert.equals(typeof(instance.AbsoluteContentSize), "Vector2")
  28 | 	end)
  29 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/UIListLayout.lua`
<details>
<summary>View Source (14 lines)</summary>

```lua
   1 | local UIGridStyleLayout = import("./UIGridStyleLayout")
   2 | local InstanceProperty = import("../InstanceProperty")
   3 | local UDim = import("../types/UDim")
   4 | 
   5 | local UIListLayout = UIGridStyleLayout:extend("UIListLayout", {
   6 | 	creatable = true,
   7 | })
   8 | 
   9 | UIListLayout.properties.Padding = InstanceProperty.typed("UDim", {
  10 | 	getDefault = function()
  11 | 		return UDim.new()
  12 | 	end,
  13 | })
  14 | 
  15 | return UIListLayout
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/UIListLayout_spec.lua`
<details>
<summary>View Source (21 lines)</summary>

```lua
   1 | local Instance = import("../Instance")
   2 | local typeof = import("../functions/typeof")
   3 | 
   4 | describe("instances.UIListLayout", function()
   5 | 	it("should instantiate", function()
   6 | 		local instance = Instance.new("UIListLayout")
   7 | 
   8 | 		assert.not_nil(instance)
   9 | 	end)
  10 | 
  11 | 	it("should inherit from UIGridStyleLayout", function()
  12 | 		local instance = Instance.new("UIListLayout")
  13 | 
  14 | 		assert.True(instance:IsA("UIGridStyleLayout"))
  15 | 	end)
  16 | 
  17 | 	it("should have properties defined", function()
  18 | 		local instance = Instance.new("UIListLayout")
  19 | 
  20 | 		assert.equals(typeof(instance.Padding), "UDim")
  21 | 	end)
  22 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/UIPadding.lua`
<details>
<summary>View Source (32 lines)</summary>

```lua
   1 | local BaseInstance = import("./BaseInstance")
   2 | local InstanceProperty = import("../InstanceProperty")
   3 | local UDim = import("../types/UDim")
   4 | 
   5 | local UIPadding = BaseInstance:extend("UIPadding", {
   6 | 	creatable = true,
   7 | })
   8 | 
   9 | UIPadding.properties.PaddingBottom = InstanceProperty.typed("UDim", {
  10 | 	getDefault = function()
  11 | 		return UDim.new()
  12 | 	end,
  13 | })
  14 | 
  15 | UIPadding.properties.PaddingLeft = InstanceProperty.typed("UDim", {
  16 | 	getDefault = function()
  17 | 		return UDim.new()
  18 | 	end,
  19 | })
  20 | 
  21 | UIPadding.properties.PaddingRight = InstanceProperty.typed("UDim", {
  22 | 	getDefault = function()
  23 | 		return UDim.new()
  24 | 	end,
  25 | })
  26 | 
  27 | UIPadding.properties.PaddingTop = InstanceProperty.typed("UDim", {
  28 | 	getDefault = function()
  29 | 		return UDim.new()
  30 | 	end,
  31 | })
  32 | 
  33 | return UIPadding
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/UIPadding_spec.lua`
<details>
<summary>View Source (17 lines)</summary>

```lua
   1 | local Instance = import("../Instance")
   2 | local typeof = import("../functions/typeof")
   3 | 
   4 | describe("instances.UIPadding", function()
   5 | 	it("should instantiate", function()
   6 | 		local instance = Instance.new("UIPadding")
   7 | 
   8 | 		assert.not_nil(instance)
   9 | 	end)
  10 | 
  11 | 	it("should have properties defined", function()
  12 | 		local instance = Instance.new("UIPadding")
  13 | 		assert.equal(typeof(instance.PaddingBottom), "UDim")
  14 | 		assert.equal(typeof(instance.PaddingLeft), "UDim")
  15 | 		assert.equal(typeof(instance.PaddingRight), "UDim")
  16 | 		assert.equal(typeof(instance.PaddingTop), "UDim")
  17 | 	end)
  18 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/UITextSizeConstraint.lua`
<details>
<summary>View Source (13 lines)</summary>

```lua
   1 | local BaseInstance = import("./BaseInstance")
   2 | local InstanceProperty = import("../InstanceProperty")
   3 | 
   4 | local UITextSizeConstraint = BaseInstance:extend("UITextSizeConstraint", {
   5 | 	creatable = true,
   6 | })
   7 | 
   8 | UITextSizeConstraint.properties.MaxTextSize = InstanceProperty.typed("number", {
   9 | 	getDefault = function()
  10 | 		return 100
  11 | 	end,
  12 | })
  13 | 
  14 | return UITextSizeConstraint
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/UITextSizeContstraint_spec.lua`
<details>
<summary>View Source (14 lines)</summary>

```lua
   1 | local Instance = import("../Instance")
   2 | local typeof = import("../functions/typeof")
   3 | 
   4 | describe("instances.UITextSizeConstraint", function()
   5 | 	it("should instantiate", function()
   6 | 		local instance = Instance.new("UITextSizeConstraint")
   7 | 
   8 | 		assert.not_nil(instance)
   9 | 	end)
  10 | 
  11 | 	it("should have properties defined", function()
  12 | 		local instance = Instance.new("UITextSizeConstraint")
  13 | 		assert.equal(typeof(instance.MaxTextSize), "number")
  14 | 	end)
  15 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/UserInputService.lua`
<details>
<summary>View Source (30 lines)</summary>

```lua
   1 | local BaseInstance = import("./BaseInstance")
   2 | local InstanceProperty = import("../InstanceProperty")
   3 | local Signal = import("../Signal")
   4 | local MouseBehavior = import("../Enum/MouseBehavior")
   5 | local Platform = import("../Enum/Platform")
   6 | 
   7 | local UserInputService = BaseInstance:extend("UserInputService")
   8 | 
   9 | function UserInputService.prototype:GetPlatform()
  10 | 	return Platform.Windows
  11 | end
  12 | 
  13 | UserInputService.properties.InputBegan = InstanceProperty.readOnly({
  14 | 	getDefault = function()
  15 | 		return Signal.new()
  16 | 	end,
  17 | })
  18 | 
  19 | UserInputService.properties.InputChanged = InstanceProperty.readOnly({
  20 | 	getDefault = function()
  21 | 		return Signal.new()
  22 | 	end,
  23 | })
  24 | 
  25 | UserInputService.properties.MouseBehavior = InstanceProperty.normal({
  26 | 	getDefault = function()
  27 | 		return MouseBehavior.Default
  28 | 	end
  29 | })
  30 | 
  31 | return UserInputService
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/UserInputService_spec.lua`
<details>
<summary>View Source (8 lines)</summary>

```lua
   1 | local UserInputService = import("./UserInputService")
   2 | 
   3 | describe("instances.UserInputService", function()
   4 | 	it("should instantiate", function()
   5 | 		local instance = UserInputService:new()
   6 | 
   7 | 		assert.not_nil(instance)
   8 | 	end)
   9 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/VirtualInputManager.lua`
<details>
<summary>View Source (2 lines)</summary>

```lua
   1 | local BaseInstance = import("./BaseInstance")
   2 | 
   3 | return BaseInstance:extend("VirtualInputManager")
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/VirtualInputManager_spec.lua`
<details>
<summary>View Source (8 lines)</summary>

```lua
   1 | local VirtualInputManager = import("./VirtualInputManager")
   2 | 
   3 | describe("instances.VirtualInputManager", function()
   4 | 	it("should instantiate", function()
   5 | 		local instance = VirtualInputManager:new()
   6 | 
   7 | 		assert.not_nil(instance)
   8 | 	end)
   9 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/Workspace.lua`
<details>
<summary>View Source (33 lines)</summary>

```lua
   1 | local BaseInstance = import("./BaseInstance")
   2 | local Camera = import("./Camera")
   3 | local InstanceProperty = import("../InstanceProperty")
   4 | 
   5 | local Workspace = BaseInstance:extend("Workspace")
   6 | 
   7 | function Workspace:init(instance)
   8 | 	local camera = Camera:new()
   9 | 	camera.Name = "Camera"
  10 | 	camera.Parent = instance
  11 | 	instance.CurrentCamera = camera
  12 | end
  13 | 
  14 | Workspace.properties.CurrentCamera = InstanceProperty.normal({})
  15 | 
  16 | Workspace.properties.DistributedGameTime = InstanceProperty.readOnly({
  17 | 	getDefault = function ()
  18 | 		return 0
  19 | 	end
  20 | })
  21 | 
  22 | Workspace.properties.AllowThirdPartySales = InstanceProperty.typed("boolean", {
  23 | 	getDefault = function ()
  24 | 		return false
  25 | 	end
  26 | })
  27 | 
  28 | Workspace.properties.Gravity = InstanceProperty.typed("number", {
  29 | 	getDefault = function()
  30 | 		return 196.2
  31 | 	end
  32 | })
  33 | 
  34 | return Workspace
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/instances/Workspace_spec.lua`
<details>
<summary>View Source (28 lines)</summary>

```lua
   1 | local Workspace = import("./Workspace")
   2 | local typeof = import("../functions/typeof")
   3 | 
   4 | describe("instances.Workspace", function()
   5 | 	it("should instantiate", function()
   6 | 		local instance = Workspace:new()
   7 | 
   8 | 		assert.not_nil(instance)
   9 | 		assert.equal(typeof(instance.Gravity), "number")
  10 | 	end)
  11 | 
  12 | 	describe("CurrentCamera", function()
  13 | 		it("should be an object of type Camera", function()
  14 | 			local instance = Workspace:new()
  15 | 			local camera = instance.CurrentCamera
  16 | 
  17 | 			assert.not_nil(camera)
  18 | 			assert.equal(typeof(camera), "Instance")
  19 | 		end)
  20 | 
  21 | 		it("should be accessible as a child named Camera", function()
  22 | 			local instance = Workspace:new()
  23 | 			local camera = instance:WaitForChild("Camera")
  24 | 
  25 | 			assert.not_nil(camera)
  26 | 			assert.equals(instance.CurrentCamera, camera)
  27 | 		end)
  28 | 	end)
  29 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/json.lua`
<details>
<summary>View Source (17 lines)</summary>

```lua
   1 | local exists, dkjson = pcall(require, "dkjson")
   2 | 
   3 | local json = {}
   4 | 
   5 | function json.encode(input)
   6 | 	error("Please install `dkjson` to use JSON features.", 2)
   7 | end
   8 | 
   9 | function json.decode(input)
  10 | 	error("Please install `dkjson` to use JSON features.", 2)
  11 | end
  12 | 
  13 | if exists then
  14 | 	json.encode = dkjson.encode
  15 | 	json.decode = dkjson.decode
  16 | end
  17 | 
  18 | return json
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/libs/bit32.lua`
<details>
<summary>View Source (16 lines)</summary>

```lua
   1 | local exists, bit32 = pcall(require, "bit32")
   2 | 
   3 | if exists then
   4 | 	local rbxBit32 = {}
   5 | 	for key, value in pairs(bit32) do
   6 | 		rbxBit32[key] = value
   7 | 	end
   8 | 	return rbxBit32
   9 | else
  10 | 	return setmetatable({}, {
  11 | 		__index = function(self, index)
  12 | 			return function()
  13 | 				error("Please install `bit32` to use bit32 features.", 2)
  14 | 			end
  15 | 		end
  16 | 	})
  17 | end
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/libs/bit32_spec.lua`
<details>
<summary>View Source (28 lines)</summary>

```lua
   1 | local bit32 = import("./bit32")
   2 | 
   3 | describe("libs.bit32", function()
   4 | 	describe("bor", function()
   5 | 		it("should be a function", function()
   6 | 			assert.is_function(bit32.bor)
   7 | 		end)
   8 | 
   9 | 		-- 101 -> 5
  10 | 		-- 010 -> 2
  11 | 		-- 101 | 010 = 111 -> 7
  12 | 		it("should bitwise OR two values", function()
  13 | 			assert.are.equals(7, bit32.bor(5, 2))
  14 | 		end)
  15 | 	end)
  16 | 
  17 | 	describe("band", function()
  18 | 		it("should be a function", function()
  19 | 			assert.is_function(bit32.band)
  20 | 		end)
  21 | 
  22 | 		-- 101 -> 5
  23 | 		-- 110 -> 6
  24 | 		-- 101 & 110 = 100 -> 4
  25 | 		it("should bitwise AND two values", function()
  26 | 			assert.are.equals(4, bit32.band(5, 6))
  27 | 		end)
  28 | 	end)
  29 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/libs/init.lua`
<details>
<summary>View Source (13 lines)</summary>

```lua
   1 | local names = {
   2 | 	"bit32",
   3 | 	"math",
   4 | 	"string",
   5 | }
   6 | 
   7 | local libs = {}
   8 | 
   9 | for _, name in ipairs(names) do
  10 | 	libs[name] = import("./" .. name)
  11 | end
  12 | 
  13 | return libs
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/libs/math.lua`
<details>
<summary>View Source (10 lines)</summary>

```lua
   1 | local rbxMath = {}
   2 | 
   3 | for key, value in pairs(math) do
   4 | 	rbxMath[key] = value
   5 | end
   6 | 
   7 | rbxMath.clamp = function(n, min, max)
   8 | 	return math.min(max, math.max(min, n))
   9 | end
  10 | 
  11 | return rbxMath
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/libs/math_spec.lua`
<details>
<summary>View Source (20 lines)</summary>

```lua
   1 | local math = import("./math")
   2 | 
   3 | describe("libs.math", function()
   4 | 	describe("clamp", function()
   5 | 		it("should be a function", function()
   6 | 			assert.is_function(math.clamp)
   7 | 		end)
   8 | 
   9 | 		it("should clamp if > max", function()
  10 | 			assert.are.equals(1, math.clamp(2, 0, 1))
  11 | 		end)
  12 | 
  13 | 		it("should clamp if < min", function()
  14 | 			assert.are.equals(0, math.clamp(-1, 0, 1))
  15 | 		end)
  16 | 
  17 | 		it("should not clamp if value is between min and max", function()
  18 | 			assert.are.equals(0.5, math.clamp(0.5, 0, 1))
  19 | 		end)
  20 | 	end)
  21 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/libs/string.lua`
<details>
<summary>View Source (36 lines)</summary>

```lua
   1 | local rbxString = {}
   2 | 
   3 | for key, value in pairs(string) do
   4 | 	rbxString[key] = value
   5 | end
   6 | 
   7 | rbxString.split = function(str, sep)
   8 | 	local result = {}
   9 | 
  10 | 	if sep == "" then
  11 | 		for i = 1, #str do
  12 | 			result[i] = str:sub(i, i)
  13 | 		end
  14 | 	else
  15 | 		if sep == nil then
  16 | 			sep = ","
  17 | 		end
  18 | 
  19 | 		local count = 1
  20 | 		local pos = 1
  21 | 		local a, b = str:find(sep, pos, true)
  22 | 
  23 | 		while a do
  24 | 			result[count] = str:sub(pos, a - 1)
  25 | 			count = count + 1
  26 | 			pos = b + 1
  27 | 			a, b = str:find(sep, pos, true)
  28 | 		end
  29 | 
  30 | 		result[count] = str:sub(pos)
  31 | 	end
  32 | 
  33 | 	return result
  34 | end
  35 | 
  36 | return rbxString
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/libs/string_spec.lua`
<details>
<summary>View Source (98 lines)</summary>

```lua
   1 | local string = import("./string")
   2 | 
   3 | describe("libs.string", function()
   4 | 	describe("split", function()
   5 | 		it("should be a function", function()
   6 | 			assert.is_function(string.split)
   7 | 		end)
   8 | 
   9 | 		it("should return an array of comma separated strings if sep is nil", function()
  10 | 			assert.are.same({"Hello", "world", "and", "lemur"}, string.split("Hello,world,and,lemur"))
  11 | 		end)
  12 | 
  13 | 		it("should return an array of all characters in a string if sep is the empty string", function()
  14 | 			assert.are.same({
  15 | 				"H",
  16 | 				"e",
  17 | 				"l",
  18 | 				"l",
  19 | 				"o",
  20 | 				",",
  21 | 				"w",
  22 | 				"o",
  23 | 				"r",
  24 | 				"l",
  25 | 				"d",
  26 | 				",",
  27 | 				"a",
  28 | 				"n",
  29 | 				"d",
  30 | 				",",
  31 | 				"l",
  32 | 				"e",
  33 | 				"m",
  34 | 				"u",
  35 | 				"r",
  36 | 			}, string.split("Hello,world,and,lemur", ""))
  37 | 		end)
  38 | 
  39 | 		it("should return an empty table if the string and sep is the empty string", function()
  40 | 			assert.are.same({}, string.split("", ""))
  41 | 		end)
  42 | 
  43 | 		it("should return the original string in a table if no sep is matched", function()
  44 | 			assert.are.same({"Hello, world"}, string.split("Hello, world", "K"))
  45 | 			assert.are.same({""}, string.split("", " "))
  46 | 		end)
  47 | 
  48 | 		it("should return empty strings at the front and back when seps are present there", function()
  49 | 			assert.are.same({"", "Validark", "Osyris", "Vorlias", ""}, string.split("/Validark/Osyris/Vorlias/", "/"))
  50 | 			assert.are.same({"", "Validark", "Osyris", "Vorlias"}, string.split("/Validark/Osyris/Vorlias", "/"))
  51 | 			assert.are.same({"Validark", "Osyris", "Vorlias", ""}, string.split("Validark/Osyris/Vorlias/", "/"))
  52 | 			assert.are.same({"Validark", "Osyris", "Vorlias"}, string.split("Validark/Osyris/Vorlias", "/"))
  53 | 		end)
  54 | 
  55 | 		it("should allow multi-character separators", function()
  56 | 			assert.are.same({"Hello", "world"}, string.split("Hello, world", ", "))
  57 | 		end)
  58 | 
  59 | 		it("should literally interpret Lua character classes", function()
  60 | 			assert.are.same({"Hello, world"}, string.split("Hello, world", "%l"))
  61 | 			assert.are.same({"Hel", "o, world"}, string.split("Hel%lo, world", "%l"))
  62 | 		end)
  63 | 
  64 | 		it("should match Roblox's internal tests", function()
  65 | 			-- Provided by tiffany352 at https://github.com/LPGhatguy/lemur/pull/190
  66 | 			local char = string.char
  67 | 			local ZWJ = char(0xe2, 0x80, 0x8d)
  68 | 			assert.are.same({ "" }, string.split("", ","))
  69 | 			assert.are.same({ "foo", "", "bar" }, string.split("foo,,bar", ","))
  70 | 			assert.are.same({ "", "foo" }, string.split(",foo", ","))
  71 | 			assert.are.same({ "foo", "" }, string.split("foo,", ","))
  72 | 			assert.are.same({ "", "" }, string.split(",", ","))
  73 | 			assert.are.same({ "", "", "" }, string.split(",,", ","))
  74 | 			assert.are.same({ "" }, string.split("", "~~~"))
  75 | 			assert.are.same({ "~~" }, string.split("~~", "~~~"))
  76 | 			assert.are.same({ "~~ ~~" }, string.split("~~ ~~", "~~~"))
  77 | 			assert.are.same({ "foo", "bar" }, string.split("foo~~~bar", "~~~"))
  78 | 			assert.are.same({ "foo", "", "bar" }, string.split("foo~~~~~~bar", "~~~"))
  79 | 			assert.are.same({ "", "foo" }, string.split("~~~foo", "~~~"))
  80 | 			assert.are.same({ "foo", "" }, string.split("foo~~~", "~~~"))
  81 | 			assert.are.same({ "", "" }, string.split("~~~", "~~~"))
  82 | 			assert.are.same({ "", "", "" }, string.split("~~~~~~", "~~~"))
  83 | 			assert.are.same({ "", "", "O" }, string.split("OOOOO", "OO"))
  84 | 			assert.are.same({ "   ws   " }, string.split("   ws   ", ","))
  85 | 			assert.are.same({ "foo ", " bar" }, string.split("foo , bar", ","))
  86 | 			assert.are.same({ "æˆ‘å¾ˆé«˜å…´", "ä½ å‘¢ï¼Ÿ" }, string.split("æˆ‘å¾ˆé«˜å…´ï¼Œä½ å‘¢ï¼Ÿ", "ï¼Œ"))
  87 | 			assert.are.same({ "ğŸ‘©", "ğŸ‘©", "ğŸ‘§", "ğŸ‘§" }, string.split("ğŸ‘©â€ğŸ‘©â€ğŸ‘§â€ğŸ‘§", ZWJ))
  88 | 			assert.are.same({ "foo", "bar" }, string.split("foo\0bar", "\0"))
  89 | 			assert.are.same({ "foo", "bar", "" }, string.split("foo\0bar\0", "\0"))
  90 | 			assert.are.same({ "foo", "bar" }, string.split("foo\0\0bar", "\0\0"))
  91 | 			assert.are.same({ "foo\0" }, string.split("foo\0", "\0\0"))
  92 | 			assert.are.same({ "foo", "\0" }, string.split("foo\0\0\0", "\0\0"))
  93 | 			assert.are.same({ }, string.split("", ""))
  94 | 			assert.are.same({ "a", "b", "c" }, string.split("abc", ""))
  95 | 			assert.are.same({ char(0xef), char(0xbc), char(0x9f) }, string.split("ï¼Ÿ", ""))
  96 | 		end)
  97 | 	end)
  98 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/Signal.lua`
<details>
<summary>View Source (98 lines)</summary>

```lua
   1 | --[[
   2 | 	A limited, simple implementation of a Signal.
   3 | 
   4 | 	Handlers are fired in order, and (dis)connections are properly handled when
   5 | 	executing an event.
   6 | ]]
   7 | 
   8 | local typeKey = import("./typeKey")
   9 | 
  10 | local function immutableAppend(list, ...)
  11 | 	local new = {}
  12 | 	local len = #list
  13 | 
  14 | 	for key = 1, len do
  15 | 		new[key] = list[key]
  16 | 	end
  17 | 
  18 | 	for i = 1, select("#", ...) do
  19 | 		new[len + i] = select(i, ...)
  20 | 	end
  21 | 
  22 | 	return new
  23 | end
  24 | 
  25 | local function immutableRemoveValue(list, removeValue)
  26 | 	local new = {}
  27 | 
  28 | 	for i = 1, #list do
  29 | 		if list[i] ~= removeValue then
  30 | 			table.insert(new, list[i])
  31 | 		end
  32 | 	end
  33 | 
  34 | 	return new
  35 | end
  36 | 
  37 | local Signal = {}
  38 | 
  39 | Signal.__index = Signal
  40 | 
  41 | function Signal.new()
  42 | 	local internal = {
  43 | 		listeners = {},
  44 | 	}
  45 | 
  46 | 	local self = newproxy(true)
  47 | 	getmetatable(self).__index = Signal
  48 | 	getmetatable(self).internal = internal
  49 | 	getmetatable(self)[typeKey] = "RBXScriptSignal"
  50 | 
  51 | 	return self
  52 | end
  53 | 
  54 | function Signal:Connect(callback)
  55 | 	local internal = getmetatable(self).internal
  56 | 
  57 | 	internal.listeners = immutableAppend(internal.listeners, callback)
  58 | 
  59 | 	local connection = {}
  60 | 	connection.Connected = true
  61 | 
  62 | 	function connection.Disconnect()
  63 | 		connection.Connected = false
  64 | 		internal.listeners = immutableRemoveValue(internal.listeners, callback)
  65 | 	end
  66 | 
  67 | 	return connection
  68 | end
  69 | 
  70 | function Signal:Fire(...)
  71 | 	-- TODO: Move this function somewhere else, since it isn't part of the
  72 | 	-- public API that Roblox exposes.
  73 | 
  74 | 	local internal = getmetatable(self).internal
  75 | 
  76 | 	for _, listener in ipairs(internal.listeners) do
  77 | 		-- Busted uses tables for spies, which angers coroutine.create if we use
  78 | 		-- them directly.
  79 | 		local co = coroutine.create(function(...)
  80 | 			return listener(...)
  81 | 		end)
  82 | 
  83 | 		-- TODO: Report errors in a nice way that won't spam tests
  84 | 		coroutine.resume(co, ...)
  85 | 	end
  86 | end
  87 | 
  88 | function Signal:Wait()
  89 | 	-- Once Lemur has an event loop, this can be revisited.
  90 | 	error("Signal:Wait is not implemented in Lemur", 2)
  91 | end
  92 | 
  93 | function Signal:_DisconnectAllListeners()
  94 | 	local internal = getmetatable(self).internal
  95 | 
  96 | 	internal.listeners = {}
  97 | end
  98 | 
  99 | return Signal
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/Signal_spec.lua`
<details>
<summary>View Source (96 lines)</summary>

```lua
   1 | local Signal = import("./Signal")
   2 | 
   3 | describe("Signal", function()
   4 | 	it("should be instantiable", function()
   5 | 		local signal = Signal.new()
   6 | 
   7 | 		assert.is_userdata(signal)
   8 | 		assert.is_function(signal.Connect)
   9 | 		assert.is_function(signal.Wait)
  10 | 
  11 | 		-- This isn't a standard function, but it's how users of Signal fire it!
  12 | 		assert.is_function(signal.Fire)
  13 | 	end)
  14 | 
  15 | 	it("should handle connections", function()
  16 | 		local signal = Signal.new()
  17 | 		local spy = spy.new(function() end)
  18 | 
  19 | 		local connection = signal:Connect(spy)
  20 | 
  21 | 		assert.not_nil(connection)
  22 | 
  23 | 		signal:Fire()
  24 | 		assert.spy(spy).was_called(1)
  25 | 
  26 | 		signal:Fire()
  27 | 		assert.spy(spy).was_called(2)
  28 | 
  29 | 		connection:Disconnect()
  30 | 		signal:Fire()
  31 | 		assert.spy(spy).was_called(2)
  32 | 	end)
  33 | 
  34 | 	it("should preserve other connections on disconnect", function()
  35 | 		local signal = Signal.new()
  36 | 		local spyA = spy.new(function() end)
  37 | 		local spyB = spy.new(function() end)
  38 | 
  39 | 		local connectionA = signal:Connect(spyA)
  40 | 		signal:Connect(spyB)
  41 | 
  42 | 		signal:Fire()
  43 | 
  44 | 		assert.spy(spyA).was_called(1)
  45 | 		assert.spy(spyB).was_called(1)
  46 | 
  47 | 		connectionA:Disconnect()
  48 | 		signal:Fire()
  49 | 
  50 | 		assert.spy(spyA).was_called(1)
  51 | 		assert.spy(spyB).was_called(2)
  52 | 	end)
  53 | 
  54 | 	it("should set Connected", function()
  55 | 		local signal = Signal.new()
  56 | 
  57 | 		local connection = signal:Connect(function() end)
  58 | 		assert.is_true(connection.Connected)
  59 | 
  60 | 		connection:Disconnect()
  61 | 		assert.is_false(connection.Connected)
  62 | 	end)
  63 | 
  64 | 	it("should catch yields", function()
  65 | 		local signal = Signal.new()
  66 | 
  67 | 		signal:Connect(function()
  68 | 			coroutine.yield()
  69 | 		end)
  70 | 
  71 | 		local co = coroutine.create(function()
  72 | 			signal:Fire()
  73 | 		end)
  74 | 
  75 | 		assert(coroutine.resume(co))
  76 | 		assert.equal(coroutine.status(co), "dead")
  77 | 	end)
  78 | 
  79 | 	it("should catch errors", function()
  80 | 		local signal = Signal.new()
  81 | 
  82 | 		signal:Connect(function()
  83 | 			error("The test failed.")
  84 | 		end)
  85 | 
  86 | 		signal:Fire()
  87 | 	end)
  88 | 
  89 | 	-- Remove this when the event loop is made
  90 | 	it("should error on Wait", function()
  91 | 		local signal = Signal.new()
  92 | 
  93 | 		assert.has.errors(function()
  94 | 			signal:Wait()
  95 | 		end)
  96 | 	end)
  97 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/taskFunctions/delay.lua`
<details>
<summary>View Source (8 lines)</summary>

```lua
   1 | return function(taskScheduler)
   2 | 	return function(delay, fn)
   3 | 		if type(delay) ~= "number" then
   4 | 			error("Bad argument provided to delay, number expected, received " .. type(delay))
   5 | 		end
   6 | 
   7 | 		taskScheduler:schedule(math.max(0.03, delay), coroutine.create(fn))
   8 | 	end
   9 | end
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/taskFunctions/delay_spec.lua`
<details>
<summary>View Source (31 lines)</summary>

```lua
   1 | local createDelay = import("./delay")
   2 | local TaskScheduler = import("../TaskScheduler")
   3 | 
   4 | describe("taskFunctions.delay", function()
   5 | 	it("should schedule after a small amount of time", function()
   6 | 		local scheduler = TaskScheduler.new()
   7 | 		local delay = createDelay(scheduler)
   8 | 
   9 | 		local spy = spy.new(function() end)
  10 | 		delay(0, function() spy() end)
  11 | 		scheduler:step(0.2)
  12 | 		assert.spy(spy).was_called()
  13 | 	end)
  14 | 
  15 | 	it("should not call the function until after the delay", function()
  16 | 		local scheduler = TaskScheduler.new()
  17 | 		local delay = createDelay(scheduler)
  18 | 
  19 | 		local spy = spy.new(function() end)
  20 | 		delay(1, function() spy() end)
  21 | 		scheduler:step(0.2)
  22 | 		assert.spy(spy).was_not_called()
  23 | 	end)
  24 | 
  25 | 	it("should error when given a non-number delay", function()
  26 | 		local scheduler = TaskScheduler.new()
  27 | 		local delay = createDelay(scheduler)
  28 | 		assert.has.errors(function()
  29 | 			delay("a long time", function() end)
  30 | 		end)
  31 | 	end)
  32 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/taskFunctions/init.lua`
<details>
<summary>View Source (12 lines)</summary>

```lua
   1 | local names = {
   2 | 	"delay",
   3 | 	"spawn",
   4 | 	"wait",
   5 | }
   6 | 
   7 | local taskFunctions = {}
   8 | 
   9 | for _, name in ipairs(names) do
  10 | 	taskFunctions[name] = import("./" .. name)
  11 | end
  12 | 
  13 | return taskFunctions
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/taskFunctions/spawn.lua`
<details>
<summary>View Source (4 lines)</summary>

```lua
   1 | return function(taskScheduler)
   2 | 	return function(fn)
   3 | 		taskScheduler:schedule(0.03, coroutine.create(fn))
   4 | 	end
   5 | end
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/taskFunctions/spawn_spec.lua`
<details>
<summary>View Source (13 lines)</summary>

```lua
   1 | local createSpawn = import("./spawn")
   2 | local TaskScheduler = import("../TaskScheduler")
   3 | 
   4 | describe("taskFunctions.spawn", function()
   5 | 	it("should schedule after a small amount of time", function()
   6 | 		local scheduler = TaskScheduler.new()
   7 | 		local spawn = createSpawn(scheduler)
   8 | 
   9 | 		local spy = spy.new(function() end)
  10 | 		spawn(function() spy() end)
  11 | 		scheduler:step(0.2)
  12 | 		assert.spy(spy).was_called()
  13 | 	end)
  14 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/taskFunctions/wait.lua`
<details>
<summary>View Source (9 lines)</summary>

```lua
   1 | return function(taskScheduler)
   2 | 	return function(delay)
   3 | 		if delay == nil then
   4 | 			delay = 0.03
   5 | 		end
   6 | 
   7 | 		taskScheduler:schedule(delay, coroutine.running())
   8 | 		coroutine.yield()
   9 | 	end
  10 | end
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/taskFunctions/wait_spec.lua`
<details>
<summary>View Source (94 lines)</summary>

```lua
   1 | local createWait = import("./wait")
   2 | local TaskScheduler = import("../TaskScheduler")
   3 | 
   4 | describe("taskFunctions.wait", function()
   5 | 	it("should reschedule self after the specified time", function()
   6 | 		local scheduler = TaskScheduler.new()
   7 | 		local wait = createWait(scheduler)
   8 | 
   9 | 		local aCount = 0
  10 | 		local bCount = 0
  11 | 		local cCount = 0
  12 | 
  13 | 		local co = coroutine.create(function()
  14 | 			aCount = aCount + 1
  15 | 			wait(1)
  16 | 
  17 | 			bCount = bCount + 1
  18 | 			wait(1)
  19 | 
  20 | 			cCount = cCount + 1
  21 | 		end)
  22 | 
  23 | 		assert(coroutine.resume(co))
  24 | 
  25 | 		assert.equal(aCount, 1)
  26 | 		assert.equal(bCount, 0)
  27 | 		assert.equal(coroutine.status(co), "suspended")
  28 | 
  29 | 		scheduler:step(1)
  30 | 
  31 | 		assert.equal(aCount, 1)
  32 | 		assert.equal(bCount, 1)
  33 | 		assert.equal(cCount, 0)
  34 | 		assert.equal(coroutine.status(co), "suspended")
  35 | 
  36 | 		scheduler:step(1)
  37 | 
  38 | 		assert.equal(aCount, 1)
  39 | 		assert.equal(bCount, 1)
  40 | 		assert.equal(cCount, 1)
  41 | 		assert.equal(coroutine.status(co), "dead")
  42 | 	end)
  43 | 
  44 | 	it("should reschedule after a small amount of time with no argument", function()
  45 | 		local scheduler = TaskScheduler.new()
  46 | 		local wait = createWait(scheduler)
  47 | 
  48 | 		local aCount = 0
  49 | 		local bCount = 0
  50 | 
  51 | 		local co = coroutine.create(function()
  52 | 			aCount = aCount + 1
  53 | 			wait()
  54 | 			bCount = bCount + 1
  55 | 		end)
  56 | 
  57 | 		assert(coroutine.resume(co))
  58 | 
  59 | 		assert.equal(aCount, 1)
  60 | 		assert.equal(bCount, 0)
  61 | 		assert.equal(coroutine.status(co), "suspended")
  62 | 
  63 | 		scheduler:step(0.2)
  64 | 
  65 | 		assert.equal(aCount, 1)
  66 | 		assert.equal(bCount, 1)
  67 | 		assert.equal(coroutine.status(co), "dead")
  68 | 	end)
  69 | 
  70 | 	it("should reschedule after a small amount of time with a zero argument", function()
  71 | 		local scheduler = TaskScheduler.new()
  72 | 		local wait = createWait(scheduler)
  73 | 
  74 | 		local aCount = 0
  75 | 		local bCount = 0
  76 | 
  77 | 		local co = coroutine.create(function()
  78 | 			aCount = aCount + 1
  79 | 			wait(0)
  80 | 			bCount = bCount + 1
  81 | 		end)
  82 | 
  83 | 		assert(coroutine.resume(co))
  84 | 
  85 | 		assert.equal(aCount, 1)
  86 | 		assert.equal(bCount, 0)
  87 | 		assert.equal(coroutine.status(co), "suspended")
  88 | 
  89 | 		scheduler:step(0.2)
  90 | 
  91 | 		assert.equal(aCount, 1)
  92 | 		assert.equal(bCount, 1)
  93 | 		assert.equal(coroutine.status(co), "dead")
  94 | 	end)
  95 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/TaskScheduler.lua`
<details>
<summary>View Source (44 lines)</summary>

```lua
   1 | local function taskCompare(a, b)
   2 | 	return a.time > b.time
   3 | end
   4 | 
   5 | local TaskScheduler = {}
   6 | TaskScheduler.prototype = {}
   7 | TaskScheduler.__index = TaskScheduler.prototype
   8 | 
   9 | function TaskScheduler.new()
  10 | 	local self = {}
  11 | 
  12 | 	self.currentTime = 0
  13 | 	self._tasks = {}
  14 | 
  15 | 	setmetatable(self, TaskScheduler)
  16 | 
  17 | 	return self
  18 | end
  19 | 
  20 | function TaskScheduler.prototype:schedule(delay, co)
  21 | 	local task = {
  22 | 		co = co,
  23 | 		time = self.currentTime + delay,
  24 | 	}
  25 | 
  26 | 	table.insert(self._tasks, task)
  27 | 	table.sort(self._tasks, taskCompare)
  28 | end
  29 | 
  30 | function TaskScheduler.prototype:step(deltaTime)
  31 | 	self.currentTime = self.currentTime + deltaTime
  32 | 
  33 | 	while true do
  34 | 		local top = self._tasks[#self._tasks]
  35 | 
  36 | 		if top == nil or top.time > self.currentTime then
  37 | 			break
  38 | 		end
  39 | 
  40 | 		self._tasks[#self._tasks] = nil
  41 | 		assert(coroutine.resume(top.co))
  42 | 	end
  43 | end
  44 | 
  45 | return TaskScheduler
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/typeKey.lua`
<details>
<summary>View Source (14 lines)</summary>

```lua
   1 | --[[
   2 | 	This key is used to mark Roblox objects and make typeof return the correct
   3 | 	value.
   4 | 
   5 | 	Use it as a key into a userdata object's metatable; its value will be what
   6 | 	is returned by typeof.
   7 | ]]
   8 | 
   9 | local typeKey = newproxy(true)
  10 | 
  11 | getmetatable(typeKey).__tostring = function()
  12 | 	return "<Lemur Type Identifier>"
  13 | end
  14 | 
  15 | return typeKey
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/types/Color3.lua`
<details>
<summary>View Source (130 lines)</summary>

```lua
   1 | local assign = import("../assign")
   2 | local typeKey = import("../typeKey")
   3 | 
   4 | local function lerpNumber(a, b, alpha)
   5 | 	return (1 - alpha) * a + b * alpha
   6 | end
   7 | 
   8 | local Color3 = {}
   9 | 
  10 | setmetatable(Color3, {
  11 | 	__tostring = function()
  12 | 		return "Color3"
  13 | 	end,
  14 | })
  15 | 
  16 | local prototype = {}
  17 | 
  18 | function prototype:lerp(goal, alpha)
  19 | 	return Color3.new(
  20 | 		lerpNumber(self.r, goal.r, alpha),
  21 | 		lerpNumber(self.g, goal.g, alpha),
  22 | 		lerpNumber(self.b, goal.b, alpha)
  23 | 	)
  24 | end
  25 | 
  26 | local metatable = {}
  27 | metatable[typeKey] = "Color3"
  28 | 
  29 | function metatable:__index(key)
  30 | 	local internal = getmetatable(self).internal
  31 | 
  32 | 	if internal[key] ~= nil then
  33 | 		return internal[key]
  34 | 	end
  35 | 
  36 | 	if prototype[key] ~= nil then
  37 | 		return prototype[key]
  38 | 	end
  39 | 
  40 | 	error(string.format("%s is not a valid member of Color3", tostring(key)), 2)
  41 | end
  42 | 
  43 | function metatable:__eq(other)
  44 | 	return self.r == other.r and self.g == other.g and self.b == other.b
  45 | end
  46 | 
  47 | function Color3.new(...)
  48 | 	if select("#", ...) == 0 then
  49 | 		return Color3.new(0, 0, 0)
  50 | 	end
  51 | 
  52 | 	local r, g, b = ...
  53 | 
  54 | 	local internalInstance = {
  55 | 		r = r,
  56 | 		g = g,
  57 | 		b = b,
  58 | 	}
  59 | 
  60 | 	local instance = newproxy(true)
  61 | 
  62 | 	assign(getmetatable(instance), metatable)
  63 | 	getmetatable(instance).internal = internalInstance
  64 | 
  65 | 	return instance
  66 | end
  67 | 
  68 | function Color3.fromRGB(r, g, b)
  69 | 	return Color3.new(r / 255, g / 255, b / 255)
  70 | end
  71 | 
  72 | function Color3.fromHSV(h, s, v)
  73 | 	-- Convert h to a 360-degree value (inputs as between 0 and 1)
  74 | 	h = h * 360
  75 | 
  76 | 	-- Sector of the HSV color space (there are 6) that the hue falls in
  77 | 	local sector = h / 60
  78 | 	local chroma = s * v
  79 | 	local x = chroma * (1 - math.abs(sector % 2 - 1))
  80 | 	local m = v - chroma
  81 | 
  82 | 	local r, g, b
  83 | 
  84 | 	if sector >= 0 and sector <= 1 then
  85 | 		r, g, b = chroma, x, 0
  86 | 	elseif sector >= 1 and sector <= 2 then
  87 | 		r, g, b = x, chroma, 0
  88 | 	elseif sector >= 2 and sector <= 3 then
  89 | 		r, g, b = 0, chroma, x
  90 | 	elseif sector >= 3 and sector <= 4 then
  91 | 		r, g, b = 0, x, chroma
  92 | 	elseif sector >= 4 and sector <= 5 then
  93 | 		r, g, b = x, 0, chroma
  94 | 	elseif sector >= 5 and sector < 6 then
  95 | 		r, g, b = chroma, 0, x
  96 | 	else
  97 | 		-- Return a default value of 0, 0, 0. This will happen if h is not between 0 and 1.
  98 | 		return Color3.new(0, 0, 0)
  99 | 	end
 100 | 
 101 | 	return Color3.new(r + m, g + m, b + m)
 102 | end
 103 | 
 104 | function Color3.toHSV(color)
 105 | 	local minComponent = math.min(color.r, color.g, color.b)
 106 | 	local maxComponent = math.max(color.r, color.g, color.b)
 107 | 
 108 | 	-- Grayscale color.
 109 | 	-- Hue and saturation are 0; value is equal to the RGB value.
 110 | 	if minComponent == maxComponent then
 111 | 		return 0, 0, minComponent
 112 | 	end
 113 | 
 114 | 	local delta = maxComponent - minComponent
 115 | 	local hue
 116 | 	local saturation = delta / maxComponent
 117 | 	local value = maxComponent
 118 | 
 119 | 	if color.r == maxComponent then
 120 | 		hue = (color.g - color.b) / delta
 121 | 	elseif color.g == maxComponent then
 122 | 		hue = 2 + (color.b - color.r) / delta
 123 | 	else
 124 | 		hue = 4 + (color.r - color.g) / delta
 125 | 	end
 126 | 
 127 | 	return (hue * 60) / 360, saturation, value
 128 | end
 129 | 
 130 | return Color3
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/types/Color3_spec.lua`
<details>
<summary>View Source (82 lines)</summary>

```lua
   1 | local Color3 = import("./Color3")
   2 | 
   3 | local typeof = import("../functions/typeof")
   4 | 
   5 | local function extractColors(color)
   6 | 	return {
   7 | 		color.r,
   8 | 		color.g,
   9 | 		color.b
  10 | 	}
  11 | end
  12 | 
  13 | describe("types.Color3", function()
  14 | 	it("should have an empty constructor", function()
  15 | 		local color = Color3.new()
  16 | 
  17 | 		assert.not_nil(color)
  18 | 		assert.are.same({ 0, 0, 0 }, extractColors(color))
  19 | 	end)
  20 | 
  21 | 	it("should have a constructor that takes rgb values 0-1", function()
  22 | 		local color = Color3.new(0, 0, 0)
  23 | 
  24 | 		assert.not_nil(color)
  25 | 	end)
  26 | 
  27 | 	it("should have the fromRGB method", function()
  28 | 		local color = Color3.fromRGB(255, 0, 0)
  29 | 
  30 | 		assert.are.same({ 1, 0, 0 }, extractColors(color))
  31 | 	end)
  32 | 
  33 | 	it("should have the fromHSV method", function()
  34 | 		local color = Color3.fromHSV(120 / 360, 0.5, 0.75)
  35 | 
  36 | 		-- Round the colors to the nearest whole number
  37 | 		-- This ensures we don't get errors from rounding, which are
  38 | 		-- ultimately fairly unimportant.
  39 | 		local r = math.floor(color.r * 255 + 0.5)
  40 | 		local g = math.floor(color.g * 255 + 0.5)
  41 | 		local b = math.floor(color.b * 255 + 0.5)
  42 | 
  43 | 		assert.are.same({ 96, 191, 96 }, { r, g, b })
  44 | 	end)
  45 | 
  46 | 	it("should have the toHSV method", function()
  47 | 		local color = Color3.fromHSV(120 / 360, 0.5, 0.75)
  48 | 		local h, s, v = Color3.toHSV(color)
  49 | 
  50 | 		assert.are.same({ 120 / 360, 0.5, 0.75 }, { h, s, v })
  51 | 	end)
  52 | 
  53 | 	describe("lerp", function()
  54 | 		local a = Color3.new(0, 0, 0)
  55 | 		local b = Color3.new(1, 1, 1)
  56 | 
  57 | 		it("should lerp colors", function()
  58 | 			-- Middle used to avoid rounding / float precision issues.
  59 | 			local middle = a:lerp(b, 0.5)
  60 | 			assert.are.same({ 0.5, 0.5, 0.5 }, extractColors(middle))
  61 | 		end)
  62 | 
  63 | 		it("should equal the goal when alpha is 1", function()
  64 | 			assert.are.same({ 1, 1, 1 }, extractColors(a:lerp(b, 1)))
  65 | 		end)
  66 | 
  67 | 		it("should equal the start when alpha is 0", function()
  68 | 			assert.are.same({ 0, 0, 0 }, extractColors(a:lerp(b, 0)))
  69 | 		end)
  70 | 	end)
  71 | 
  72 | 	it("should compare Color3s", function()
  73 | 		local c1, c2 = Color3.new(0, 1, 0), Color3.new(0, 1, 0)
  74 | 		assert.are.equal(c1, c2)
  75 | 		assert.are_not_equal(c1, Color3.new(0, 0, 0))
  76 | 	end)
  77 | 
  78 | 	it("should be detected by typeof", function()
  79 | 		local type = typeof(Color3.new())
  80 | 		assert.are.equal("Color3", type)
  81 | 	end)
  82 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/types/init.lua`
<details>
<summary>View Source (15 lines)</summary>

```lua
   1 | local names = {
   2 | 	"Color3",
   3 | 	"Rect",
   4 | 	"UDim",
   5 | 	"UDim2",
   6 | 	"Vector2",
   7 | 	"Vector3",
   8 | }
   9 | 
  10 | local types = {}
  11 | 
  12 | for _, name in ipairs(names) do
  13 | 	types[name] = import("./" .. name)
  14 | end
  15 | 
  16 | return types
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/types/Rect.lua`
<details>
<summary>View Source (71 lines)</summary>

```lua
   1 | local assign = import("../assign")
   2 | local typeKey = import("../typeKey")
   3 | local typeof = import("../functions/typeof")
   4 | local Vector2 = import("./Vector2")
   5 | 
   6 | local Rect = {}
   7 | 
   8 | setmetatable(Rect, {
   9 | 	__tostring = function()
  10 | 		return "Rect"
  11 | 	end,
  12 | })
  13 | 
  14 | local prototype = {}
  15 | 
  16 | local metatable = {}
  17 | metatable[typeKey] = "Rect"
  18 | 
  19 | function metatable:__index(key)
  20 | 	local internal = getmetatable(self).internal
  21 | 
  22 | 	if internal[key] ~= nil then
  23 | 		return internal[key]
  24 | 	end
  25 | 
  26 | 	if prototype[key] ~= nil then
  27 | 		return prototype[key]
  28 | 	end
  29 | 
  30 | 	error(string.format("%s is not a valid member of Rect", tostring(key)), 2)
  31 | end
  32 | 
  33 | function metatable:__eq(other)
  34 | 	return self.Min == other.Min and self.Max == other.Max
  35 | end
  36 | 
  37 | function Rect.new(...)
  38 | 	if select("#", ...) == 4 then
  39 | 		local minX, minY, maxX, maxY = ...
  40 | 		if type(minX) ~= "number" or type(minY) ~= "number" or
  41 | 			type(maxX) ~= "number" or type(maxY) ~= "number" then
  42 | 			error("Rect.new(minX, minY, maxX, maxY) takes in 4 numbers", 2)
  43 | 		end
  44 | 
  45 | 		return Rect.new(
  46 | 			Vector2.new(minX, minY),
  47 | 			Vector2.new(maxX, maxY)
  48 | 		)
  49 | 	end
  50 | 
  51 | 	local min, max = ...
  52 | 
  53 | 	if typeof(min) ~= "Vector2" or typeof(max) ~= "Vector2" then
  54 | 		error("Rect.new(min, max) takes in 2 Vector2s", 2)
  55 | 	end
  56 | 
  57 | 	local internalInstance = {
  58 | 		Min = min,
  59 | 		Max = max,
  60 | 		Width = max.X - min.X,
  61 | 		Height = max.Y - min.Y,
  62 | 	}
  63 | 	local instance = newproxy(true)
  64 | 
  65 | 	assign(getmetatable(instance), metatable)
  66 | 	getmetatable(instance).internal = internalInstance
  67 | 
  68 | 	return instance
  69 | end
  70 | 
  71 | return Rect
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/types/Rect_spec.lua`
<details>
<summary>View Source (84 lines)</summary>

```lua
   1 | local Rect = import("./Rect")
   2 | local Vector2 = import("./Vector2")
   3 | local typeof = import("../functions/typeof")
   4 | 
   5 | local function extractRect(r)
   6 | 	return { r.Min.X, r.Min.Y, r.Max.X, r.Max.Y, r.Width, r.Height }
   7 | end
   8 | 
   9 | describe("types.Rect", function()
  10 | 	it("should not have an empty constructor", function()
  11 | 		assert.has.errors(function()
  12 | 			Rect.new()
  13 | 		end)
  14 | 	end)
  15 | 
  16 | 	it("should have a constructor with two parameters", function()
  17 | 		local r = Rect.new(Vector2.new(10, 20), Vector2.new(50, 100))
  18 | 
  19 | 		assert.not_nil(r)
  20 | 		assert.are.same({10, 20, 50, 100, 40, 80}, extractRect(r))
  21 | 	end)
  22 | 
  23 | 	it("should have a constructor with four parameters", function()
  24 | 		local r = Rect.new(10, 20, 50, 100)
  25 | 
  26 | 		assert.not_nil(r)
  27 | 		assert.are.same({10, 20, 50, 100, 40, 80}, extractRect(r))
  28 | 	end)
  29 | 
  30 | 	it("should be type Rect", function()
  31 | 		assert.equal(typeof(Rect.new(0, 0, 0, 0)), "Rect")
  32 | 	end)
  33 | 
  34 | 	it("should throw when bad params are passed to the 4-param constructor", function()
  35 | 		assert.has.errors(function()
  36 | 			Rect.new("test", 1, 2, 3)
  37 | 		end)
  38 | 
  39 | 		assert.has.errors(function()
  40 | 			Rect.new(1, "test", 2, 3)
  41 | 		end)
  42 | 
  43 | 		assert.has.errors(function()
  44 | 			Rect.new(1, 2, "test", 3)
  45 | 		end)
  46 | 
  47 | 		assert.has.errors(function()
  48 | 			Rect.new(1, 2, 3, "test")
  49 | 		end)
  50 | 	end)
  51 | 
  52 | 	it("should throw when bad params are passed to the 2-param constructor", function()
  53 | 		assert.has.errors(function()
  54 | 			Rect.new("test", Vector2.new())
  55 | 		end)
  56 | 
  57 | 		assert.has.errors(function()
  58 | 			Rect.new(Vector2.new(), "test")
  59 | 		end)
  60 | 	end)
  61 | 
  62 | 	it("should equal another Rect with the same values", function()
  63 | 		local r1 = Rect.new(10, 30, 50, 200)
  64 | 		local r2 = Rect.new(Vector2.new(10, 30), Vector2.new(50, 200))
  65 | 
  66 | 		assert.equals(r1, r1)
  67 | 		assert.equals(r1, r2)
  68 | 		assert.equals(r2, r2)
  69 | 	end)
  70 | 
  71 | 	it("should not equal another Rect with different min and max values", function()
  72 | 		local rectA = Rect.new(10, 30, 50, 200)
  73 | 
  74 | 		local rectB1 = Rect.new(11, 30, 50, 200)
  75 | 		local rectB2 = Rect.new(10, 16, 50, 200)
  76 | 		local rectB3 = Rect.new(10, 30, 40, 200)
  77 | 		local rectB4 = Rect.new(10, 30, 50, 205)
  78 | 
  79 | 		assert.not_equals(rectA, rectB1)
  80 | 		assert.not_equals(rectA, rectB2)
  81 | 		assert.not_equals(rectA, rectB3)
  82 | 		assert.not_equals(rectA, rectB4)
  83 | 	end)
  84 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/types/UDim.lua`
<details>
<summary>View Source (62 lines)</summary>

```lua
   1 | local assign = import("../assign")
   2 | local typeKey = import("../typeKey")
   3 | 
   4 | local UDim = {}
   5 | 
   6 | setmetatable(UDim, {
   7 | 	__tostring = function()
   8 | 		return "UDim"
   9 | 	end,
  10 | })
  11 | 
  12 | local prototype = {}
  13 | 
  14 | local metatable = {}
  15 | metatable[typeKey] = "UDim"
  16 | 
  17 | function metatable:__index(key)
  18 | 	local internal = getmetatable(self).internal
  19 | 
  20 | 	if internal[key] ~= nil then
  21 | 		return internal[key]
  22 | 	end
  23 | 
  24 | 	if prototype[key] ~= nil then
  25 | 		return prototype[key]
  26 | 	end
  27 | 
  28 | 	error(string.format("%s is not a valid member of UDim", tostring(key)), 2)
  29 | end
  30 | 
  31 | function metatable:__add(other)
  32 | 	return UDim.new(self.Scale + other.Scale, self.Offset + other.Offset)
  33 | end
  34 | 
  35 | function metatable:__eq(other)
  36 | 	return self.Scale == other.Scale and self.Offset == other.Offset
  37 | end
  38 | 
  39 | function UDim.new(...)
  40 | 	if select("#", ...) == 0 then
  41 | 		return UDim.new(0, 0)
  42 | 	end
  43 | 
  44 | 	local Scale, Offset = ...
  45 | 	if type(Scale) ~= "number" or type(Offset) ~= "number" then
  46 | 		error("UDim.new must take in 2 numbers", 2)
  47 | 	end
  48 | 
  49 | 	local internalInstance = {
  50 | 		Scale = Scale,
  51 | 		Offset = Offset,
  52 | 	}
  53 | 
  54 | 	local instance = newproxy(true)
  55 | 
  56 | 	assign(getmetatable(instance), metatable)
  57 | 	getmetatable(instance).internal = internalInstance
  58 | 
  59 | 	return instance
  60 | end
  61 | 
  62 | return UDim
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/types/UDim_spec.lua`
<details>
<summary>View Source (59 lines)</summary>

```lua
   1 | local UDim = import("./UDim")
   2 | 
   3 | local function extractValues(udim)
   4 | 	return { udim.Scale, udim.Offset }
   5 | end
   6 | 
   7 | describe("types.UDim", function()
   8 | 	it("should have an empty constructor", function()
   9 | 		local udim = UDim.new()
  10 | 
  11 | 		assert.not_nil(udim)
  12 | 		assert.are.same({0, 0}, extractValues(udim))
  13 | 	end)
  14 | 
  15 | 	it("should have a constructor with two parameters", function()
  16 | 		local udim = UDim.new(1, 200)
  17 | 
  18 | 		assert.not_nil(udim)
  19 | 		assert.are.same({1, 200}, extractValues(udim))
  20 | 	end)
  21 | 
  22 | 	it("should throw when bad params are passed to the constructor", function()
  23 | 		assert.has.errors(function()
  24 | 			UDim.new(1, "test")
  25 | 		end)
  26 | 
  27 | 		assert.has.errors(function()
  28 | 			UDim.new("test", 10)
  29 | 		end)
  30 | 	end)
  31 | 
  32 | 	it("should add another UDim", function()
  33 | 		local udimA = UDim.new(1, 200)
  34 | 		local udimB = UDim.new(100, 500)
  35 | 		local udim = udimA + udimB
  36 | 
  37 | 		assert.not_nil(udim)
  38 | 		assert.are.same({101, 700}, extractValues(udim))
  39 | 	end)
  40 | 
  41 | 	it("should equal another UDim with the same scale and offset", function()
  42 | 		local udimA = UDim.new(1, 200)
  43 | 		local udimB = UDim.new(1, 200)
  44 | 
  45 | 		assert.equals(udimA, udimB)
  46 | 	end)
  47 | 
  48 | 	it("should not equal another UDim with different scale and offset", function()
  49 | 		local udimA = UDim.new(1, 200)
  50 | 
  51 | 		local udimB1 = UDim.new(1, 201)
  52 | 		local udimB2 = UDim.new(50, 200)
  53 | 		local udimB3 = UDim.new(3, 7)
  54 | 
  55 | 		assert.not_equals(udimA, udimB1)
  56 | 		assert.not_equals(udimA, udimB2)
  57 | 		assert.not_equals(udimA, udimB3)
  58 | 	end)
  59 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/types/UDim2.lua`
<details>
<summary>View Source (95 lines)</summary>

```lua
   1 | local assign = import("../assign")
   2 | local typeKey = import("../typeKey")
   3 | local typeof = import("../functions/typeof")
   4 | local UDim = import("./UDim")
   5 | 
   6 | local function lerpNumber(a, b, alpha)
   7 | 	return (1 - alpha) * a + b * alpha
   8 | end
   9 | 
  10 | local UDim2 = {}
  11 | 
  12 | setmetatable(UDim2, {
  13 | 	__tostring = function()
  14 | 		return "UDim2"
  15 | 	end,
  16 | })
  17 | 
  18 | local prototype = {}
  19 | 
  20 | function prototype:Lerp(goal, alpha)
  21 | 	return UDim2.new(
  22 | 		lerpNumber(self.X.Scale, goal.X.Scale, alpha),
  23 | 		lerpNumber(self.X.Offset, goal.X.Offset, alpha),
  24 | 		lerpNumber(self.Y.Scale, goal.Y.Scale, alpha),
  25 | 		lerpNumber(self.Y.Offset, goal.Y.Offset, alpha)
  26 | 	)
  27 | end
  28 | 
  29 | local metatable = {}
  30 | metatable[typeKey] = "UDim2"
  31 | 
  32 | function metatable:__index(key)
  33 | 	local internal = getmetatable(self).internal
  34 | 
  35 | 	if internal[key] ~= nil then
  36 | 		return internal[key]
  37 | 	end
  38 | 
  39 | 	if prototype[key] ~= nil then
  40 | 		return prototype[key]
  41 | 	end
  42 | 
  43 | 	error(string.format("%s is not a valid member of UDim2", tostring(key)), 2)
  44 | end
  45 | 
  46 | function metatable:__eq(other)
  47 | 	return self.X == other.X and self.Y == other.Y
  48 | end
  49 | 
  50 | function metatable:__add(other)
  51 | 	return UDim2.new(self.X + other.X, self.Y + other.Y)
  52 | end
  53 | 
  54 | function UDim2.new(...)
  55 | 	if select("#", ...) == 0 then
  56 | 		return UDim2.new(
  57 | 			UDim.new(0, 0),
  58 | 			UDim.new(0, 0)
  59 | 		)
  60 | 	end
  61 | 
  62 | 	if select("#", ...) == 4 then
  63 | 		local xScale, xOffset, yScale, yOffset = ...
  64 | 		if type(xScale) ~= "number" or type(xOffset) ~= "number" or
  65 | 			type(yScale) ~= "number" or type(yOffset) ~= "number" then
  66 | 			error("UDim2.new(xScale, xOffset, yScale, yOffset) takes in 4 numbers", 2)
  67 | 		end
  68 | 
  69 | 		return UDim2.new(
  70 | 			UDim.new(xScale, xOffset),
  71 | 			UDim.new(yScale, yOffset)
  72 | 		)
  73 | 	end
  74 | 
  75 | 	local xDim, yDim = ...
  76 | 
  77 | 	if typeof(xDim) ~= "UDim" or typeof(yDim) ~= "UDim" then
  78 | 		error("UDim2.new(xDim, yDim) takes in 2 UDims", 2)
  79 | 	end
  80 | 
  81 | 	local internalInstance = {
  82 | 		X = xDim,
  83 | 		Y = yDim,
  84 | 		Width = xDim,
  85 | 		Height = yDim,
  86 | 	}
  87 | 	local instance = newproxy(true)
  88 | 
  89 | 	assign(getmetatable(instance), metatable)
  90 | 	getmetatable(instance).internal = internalInstance
  91 | 
  92 | 	return instance
  93 | end
  94 | 
  95 | return UDim2
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/types/UDim2_spec.lua`
<details>
<summary>View Source (117 lines)</summary>

```lua
   1 | local UDim = import("./UDim")
   2 | local UDim2 = import("./UDim2")
   3 | 
   4 | local function extractUDim2(udim)
   5 | 	return { udim.X.Scale, udim.X.Offset, udim.Y.Scale, udim.Y.Offset }
   6 | end
   7 | 
   8 | describe("types.UDim2", function()
   9 | 	it("should have an empty constructor", function()
  10 | 		local udim = UDim2.new()
  11 | 
  12 | 		assert.not_nil(udim)
  13 | 		assert.are.same({0, 0, 0, 0}, extractUDim2(udim))
  14 | 	end)
  15 | 
  16 | 	it("should have a constructor with two parameters", function()
  17 | 		local udim = UDim2.new(UDim.new(10, 20), UDim.new(50, 100))
  18 | 
  19 | 		assert.not_nil(udim)
  20 | 		assert.are.same({10, 20, 50, 100}, extractUDim2(udim))
  21 | 	end)
  22 | 
  23 | 	it("should have a constructor with four parameters", function()
  24 | 		local udim = UDim2.new(10, 20, 50, 100)
  25 | 
  26 | 		assert.not_nil(udim)
  27 | 		assert.are.same({10, 20, 50, 100}, extractUDim2(udim))
  28 | 	end)
  29 | 
  30 | 	it("should throw when bad params are passed to the 4-param constructor", function()
  31 | 		assert.has.errors(function()
  32 | 			UDim2.new("test", 1, 2, 3)
  33 | 		end)
  34 | 
  35 | 		assert.has.errors(function()
  36 | 			UDim2.new(1, "test", 2, 3)
  37 | 		end)
  38 | 
  39 | 		assert.has.errors(function()
  40 | 			UDim2.new(1, 2, "test", 3)
  41 | 		end)
  42 | 
  43 | 		assert.has.errors(function()
  44 | 			UDim2.new(1, 2, 3, "test")
  45 | 		end)
  46 | 	end)
  47 | 
  48 | 	it("should throw when bad params are passed to the 2-param constructor", function()
  49 | 		assert.has.errors(function()
  50 | 			-- luacheck: push ignore udim
  51 | 			local udim = UDim2.new("test", UDim.new())
  52 | 			-- luacheck: pop
  53 | 		end)
  54 | 
  55 | 		assert.has.errors(function()
  56 | 			-- luacheck: push ignore udim
  57 | 			local udim = UDim2.new(UDim.new(), "test")
  58 | 			-- luacheck: pop
  59 | 		end)
  60 | 	end)
  61 | 
  62 | 	it("should have property X equal property Width", function()
  63 | 		local udim = UDim2.new(10, 20, 50, 100)
  64 | 
  65 | 		assert.not_nil(udim)
  66 | 		assert.equals(udim.X, udim.Width)
  67 | 	end)
  68 | 
  69 | 
  70 | 	it("should have property Y equal property Height", function()
  71 | 		local udim = UDim2.new(10, 20, 50, 100)
  72 | 
  73 | 		assert.not_nil(udim)
  74 | 		assert.equals(udim.Y, udim.Height)
  75 | 	end)
  76 | 
  77 | 	it("should add another UDim2", function()
  78 | 		local udimA = UDim2.new(10, 30, 50, 200)
  79 | 		local udimB = UDim2.new(UDim.new(20, 40), UDim.new(100, 500))
  80 | 		local udim = udimA + udimB
  81 | 
  82 | 		assert.not_nil(udim)
  83 | 		assert.are.same({30, 70, 150, 700}, extractUDim2(udim))
  84 | 	end)
  85 | 
  86 | 	it("should equal another UDim2 with the same values", function()
  87 | 		local udimA = UDim2.new(10, 30, 50, 200)
  88 | 		local udimB = UDim2.new(10, 30, 50, 200)
  89 | 
  90 | 		assert.equals(udimA, udimB)
  91 | 	end)
  92 | 
  93 | 	it("should not equal another UDim with different scale and offset", function()
  94 | 		local udimA = UDim2.new(10, 30, 50, 200)
  95 | 
  96 | 		local udimB1 = UDim2.new(11, 30, 50, 200)
  97 | 		local udimB2 = UDim2.new(10, 15, 50, 200)
  98 | 		local udimB3 = UDim2.new(10, 30, 60, 200)
  99 | 		local udimB4 = UDim2.new(10, 30, 50, 100)
 100 | 		local udimB5 = UDim2.new(1, 2, 3, 4)
 101 | 
 102 | 		assert.not_equals(udimA, udimB1)
 103 | 		assert.not_equals(udimA, udimB2)
 104 | 		assert.not_equals(udimA, udimB3)
 105 | 		assert.not_equals(udimA, udimB4)
 106 | 		assert.not_equals(udimA, udimB5)
 107 | 	end)
 108 | 
 109 | 	it("should lerp", function()
 110 | 		local udimA = UDim2.new(0, 100, 200, 300)
 111 | 		local udimB = UDim2.new(100, 200, 300, 400)
 112 | 
 113 | 		assert.are.same({0, 100, 200, 300}, extractUDim2(udimA:Lerp(udimB, 0)))
 114 | 		assert.are.same({50, 150, 250, 350}, extractUDim2(udimA:Lerp(udimB, 0.5)))
 115 | 		assert.are.same({100, 200, 300, 400}, extractUDim2(udimA:Lerp(udimB, 1)))
 116 | 	end)
 117 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/types/Vector2.lua`
<details>
<summary>View Source (91 lines)</summary>

```lua
   1 | local assign = import("../assign")
   2 | local typeKey = import("../typeKey")
   3 | local typeof = import("../functions/typeof")
   4 | 
   5 | local Vector2 = {}
   6 | 
   7 | setmetatable(Vector2, {
   8 | 	__tostring = function()
   9 | 		return "Vector2"
  10 | 	end,
  11 | })
  12 | 
  13 | local prototype = {}
  14 | 
  15 | local metatable = {}
  16 | metatable[typeKey] = "Vector2"
  17 | 
  18 | function metatable:__index(key)
  19 | 	local internal = getmetatable(self).internal
  20 | 
  21 | 	if internal[key] ~= nil then
  22 | 		return internal[key]
  23 | 	end
  24 | 
  25 | 	if prototype[key] ~= nil then
  26 | 		return prototype[key]
  27 | 	end
  28 | 
  29 | 	error(string.format("%s is not a valid member of Vector2", tostring(key)), 2)
  30 | end
  31 | 
  32 | function metatable:__add(other)
  33 | 	return Vector2.new(self.X + other.X, self.Y + other.Y)
  34 | end
  35 | 
  36 | function metatable:__sub(other)
  37 | 	return Vector2.new(self.X - other.X, self.Y - other.Y)
  38 | end
  39 | 
  40 | function metatable:__mul(other)
  41 | 	if typeof(self) == "Vector2" and typeof(other) == "Vector2" then
  42 | 		return Vector2.new(self.X * other.X, self.Y * other.Y)
  43 | 	elseif typeof(self) == "Vector2" and typeof(other) == "number" then
  44 | 		return Vector2.new(self.X * other, self.Y * other)
  45 | 	elseif typeof(self) == "number" and typeof(other) == "Vector2" then
  46 | 		return Vector2.new(other.X * self, other.Y * self)
  47 | 	else
  48 | 		error("attempt to multiply a Vector2 with an incompatible value type or nil")
  49 | 	end
  50 | end
  51 | 
  52 | function metatable:__div(other)
  53 | 	if typeof(self) == "Vector2" and typeof(other) == "Vector2" then
  54 | 		return Vector2.new(self.X / other.X, self.Y / other.Y)
  55 | 	elseif typeof(self) == "Vector2" and typeof(other) == "number" then
  56 | 		return Vector2.new(self.X / other, self.Y / other)
  57 | 	elseif typeof(self) == "number" and typeof(other) == "Vector2" then
  58 | 		return Vector2.new(other.X / self, other.Y / self)
  59 | 	else
  60 | 		error("attempt to divide a Vector2 with an incompatible value type or nil")
  61 | 	end
  62 | end
  63 | 
  64 | function metatable:__eq(other)
  65 | 	return self.X == other.X and self.Y == other.Y
  66 | end
  67 | 
  68 | function Vector2.new(...)
  69 | 	if select("#", ...) == 0 then
  70 | 		return Vector2.new(0, 0)
  71 | 	end
  72 | 
  73 | 	local X, Y = ...
  74 | 	if type(X) ~= "number" or type(Y) ~= "number" then
  75 | 		error("Vector2.new takes in 2 numbers", 2)
  76 | 	end
  77 | 
  78 | 	local internalInstance = {
  79 | 		X = X,
  80 | 		Y = Y,
  81 | 	}
  82 | 
  83 | 	local instance = newproxy(true)
  84 | 
  85 | 	assign(getmetatable(instance), metatable)
  86 | 	getmetatable(instance).internal = internalInstance
  87 | 
  88 | 	return instance
  89 | end
  90 | 
  91 | return Vector2
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/types/Vector2_spec.lua`
<details>
<summary>View Source (131 lines)</summary>

```lua
   1 | local Vector2 = import("./Vector2")
   2 | 
   3 | local function extractValues(v)
   4 | 	return { v.X, v.Y }
   5 | end
   6 | 
   7 | 
   8 | describe("types.Vector2", function()
   9 | 	it("should have an empty constructor", function()
  10 | 		local v = Vector2.new()
  11 | 
  12 | 		assert.not_nil(v)
  13 | 		assert.are.same({0, 0}, extractValues(v))
  14 | 	end)
  15 | 
  16 | 	it("should have a constructor with two parameters", function()
  17 | 		local v = Vector2.new(1, 200)
  18 | 
  19 | 		assert.not_nil(v)
  20 | 		assert.are.same({1, 200}, extractValues(v))
  21 | 	end)
  22 | 
  23 | 	it("should throw when bad params are passed to the constructor", function()
  24 | 		assert.has.errors(function()
  25 | 			Vector2.new(1, "test")
  26 | 		end)
  27 | 
  28 | 		assert.has.errors(function()
  29 | 			Vector2.new("test", 10)
  30 | 		end)
  31 | 	end)
  32 | 
  33 | 	it("should add another Vector2", function()
  34 | 		local vectorA = Vector2.new(1, 200)
  35 | 		local vectorB = Vector2.new(100, 500)
  36 | 		local v = vectorA + vectorB
  37 | 
  38 | 		assert.not_nil(v)
  39 | 		assert.are.same({101, 700}, extractValues(v))
  40 | 	end)
  41 | 
  42 | 	it("should subtract another Vector2", function()
  43 | 		local vectorA = Vector2.new(1, 200)
  44 | 		local vectorB = Vector2.new(100, 500)
  45 | 		local v = vectorA - vectorB
  46 | 
  47 | 		assert.not_nil(v)
  48 | 		assert.are.same({-99, -300}, extractValues(v))
  49 | 	end)
  50 | 
  51 | 	it("should multiply by another Vector2", function()
  52 | 		local vectorA = Vector2.new(1, 50)
  53 | 		local vectorB = Vector2.new(2, 0.5)
  54 | 		local v = vectorA * vectorB
  55 | 
  56 | 		assert.not_nil(v)
  57 | 		assert.are.same({2, 25}, extractValues(v))
  58 | 	end)
  59 | 
  60 | 	it("should multiply by a number", function()
  61 | 		local vectorA = Vector2.new(1, 50)
  62 | 		local v = vectorA * 3
  63 | 
  64 | 		assert.not_nil(v)
  65 | 		assert.are.same({3, 150}, extractValues(v))
  66 | 	end)
  67 | 
  68 | 	it("should multiply by a number reversed", function()
  69 | 		local vectorA = Vector2.new(1, 50)
  70 | 		local v = 3 * vectorA
  71 | 
  72 | 		assert.not_nil(v)
  73 | 		assert.are.same({3, 150}, extractValues(v))
  74 | 	end)
  75 | 
  76 | 	it("should throw an error when multiplied by an incompatible type", function()
  77 | 		assert.has.errors(function()
  78 | 			return Vector2.new(1, 2) * nil
  79 | 		end)
  80 | 	end)
  81 | 
  82 | 	it("should divide by another Vector2", function()
  83 | 		local vectorA = Vector2.new(1, 50)
  84 | 		local vectorB = Vector2.new(2, 1)
  85 | 		local v = vectorA / vectorB
  86 | 
  87 | 		assert.not_nil(v)
  88 | 		assert.are.same({0.5, 50}, extractValues(v))
  89 | 	end)
  90 | 
  91 | 	it("should divide by a number", function()
  92 | 		local vectorA = Vector2.new(1, 50)
  93 | 		local v = vectorA / 4
  94 | 
  95 | 		assert.not_nil(v)
  96 | 		assert.are.same({0.25, 12.5}, extractValues(v))
  97 | 	end)
  98 | 
  99 | 	it("should divide by a number reversed", function()
 100 | 		local vectorA = Vector2.new(1, 50)
 101 | 		local v = 4 / vectorA
 102 | 
 103 | 		assert.not_nil(v)
 104 | 		assert.are.same({0.25, 12.5}, extractValues(v))
 105 | 	end)
 106 | 
 107 | 	it("should throw an error when divided by an incompatible type", function()
 108 | 		assert.has.errors(function()
 109 | 			return Vector2.new(1, 2) / "abc"
 110 | 		end)
 111 | 	end)
 112 | 
 113 | 	it("should equal another Vector2 with the same x and y", function()
 114 | 		local vectorA = Vector2.new(1, 200)
 115 | 		local vectorB = Vector2.new(1, 200)
 116 | 
 117 | 		assert.equals(vectorA, vectorB)
 118 | 	end)
 119 | 
 120 | 	it("should not equal another Vector2 with different x and/or y", function()
 121 | 		local vectorA = Vector2.new(1, 200)
 122 | 
 123 | 		local vectorB1 = Vector2.new(10, 200)
 124 | 		local vectorB2 = Vector2.new(1, 300)
 125 | 		local vectorB3 = Vector2.new(5, 10)
 126 | 
 127 | 		assert.not_equals(vectorA, vectorB1)
 128 | 		assert.not_equals(vectorA, vectorB2)
 129 | 		assert.not_equals(vectorA, vectorB3)
 130 | 	end)
 131 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/types/Vector3.lua`
<details>
<summary>View Source (92 lines)</summary>

```lua
   1 | local assign = import("../assign")
   2 | local typeKey = import("../typeKey")
   3 | local typeof = import("../functions/typeof")
   4 | 
   5 | local Vector3 = {}
   6 | 
   7 | setmetatable(Vector3, {
   8 | 	__tostring = function()
   9 | 		return "Vector3"
  10 | 	end,
  11 | })
  12 | 
  13 | local prototype = {}
  14 | 
  15 | local metatable = {}
  16 | metatable[typeKey] = "Vector3"
  17 | 
  18 | function metatable:__index(key)
  19 | 	local internal = getmetatable(self).internal
  20 | 
  21 | 	if internal[key] ~= nil then
  22 | 		return internal[key]
  23 | 	end
  24 | 
  25 | 	if prototype[key] ~= nil then
  26 | 		return prototype[key]
  27 | 	end
  28 | 
  29 | 	error(string.format("%s is not a valid member of Vector3", tostring(key)), 2)
  30 | end
  31 | 
  32 | function metatable:__add(other)
  33 | 	return Vector3.new(self.X + other.X, self.Y + other.Y, self.Z + other.Z)
  34 | end
  35 | 
  36 | function metatable:__sub(other)
  37 | 	return Vector3.new(self.X - other.X, self.Y - other.Y, self.Z - other.Z)
  38 | end
  39 | 
  40 | function metatable:__mul(other)
  41 | 	if typeof(self) == "Vector3" and typeof(other) == "Vector3" then
  42 | 		return Vector3.new(self.X * other.X, self.Y * other.Y, self.Z * other.Z)
  43 | 	elseif typeof(self) == "Vector3" and typeof(other) == "number" then
  44 | 		return Vector3.new(self.X * other, self.Y * other, self.Z * other)
  45 | 	elseif typeof(self) == "number" and typeof(other) == "Vector3" then
  46 | 		return Vector3.new(other.X * self, other.Y * self, other.Z * self)
  47 | 	else
  48 | 		error("attempt to multiply a Vector3 with an incompatible value type or nil")
  49 | 	end
  50 | end
  51 | 
  52 | function metatable:__div(other)
  53 | 	if typeof(self) == "Vector3" and typeof(other) == "Vector3" then
  54 | 		return Vector3.new(self.X / other.X, self.Y / other.Y, self.Z / other.Z)
  55 | 	elseif typeof(self) == "Vector3" and typeof(other) == "number" then
  56 | 		return Vector3.new(self.X / other, self.Y / other, self.Z / other)
  57 | 	elseif typeof(self) == "number" and typeof(other) == "Vector3" then
  58 | 		return Vector3.new(other.X / self, other.Y / self, other.Z / self)
  59 | 	else
  60 | 		error("attempt to divide a Vector3 with an incompatible value type or nil")
  61 | 	end
  62 | end
  63 | 
  64 | function metatable:__eq(other)
  65 | 	return self.X == other.X and self.Y == other.Y and self.Z == other.Z
  66 | end
  67 | 
  68 | function Vector3.new(...)
  69 | 	if select("#", ...) == 0 then
  70 | 		return Vector3.new(0, 0, 0)
  71 | 	end
  72 | 
  73 | 	local X, Y, Z = ...
  74 | 	if type(X) ~= "number" or type(Y) ~= "number" or type(Z) ~= "number" then
  75 | 		error("Vector3.new takes in 3 numbers", 2)
  76 | 	end
  77 | 
  78 | 	local internalInstance = {
  79 | 		X = X,
  80 | 		Y = Y,
  81 | 		Z = Z,
  82 | 	}
  83 | 
  84 | 	local instance = newproxy(true)
  85 | 
  86 | 	assign(getmetatable(instance), metatable)
  87 | 	getmetatable(instance).internal = internalInstance
  88 | 
  89 | 	return instance
  90 | end
  91 | 
  92 | return Vector3
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/types/Vector3_spec.lua`
<details>
<summary>View Source (144 lines)</summary>

```lua
   1 | local Vector3 = import("./Vector3")
   2 | 
   3 | local function extractValues(v)
   4 | 	return { v.X, v.Y, v.Z }
   5 | end
   6 | 
   7 | describe("types.Vector3", function()
   8 | 	it( "should have an empty constructor", function()
   9 | 		local v = Vector3.new()
  10 | 
  11 | 		assert.not_nil(v)
  12 | 		assert.are.same({0, 0, 0}, extractValues(v))
  13 | 	end)
  14 | 
  15 | 	it("should have a constructor with three parameters", function()
  16 | 		local v = Vector3.new(1, 2, 3)
  17 | 
  18 | 		assert.not_nil(v)
  19 | 		assert.are.same({1, 2, 3}, extractValues(v))
  20 | 	end)
  21 | 
  22 | 	it("should throw when bad params are passed to the constructor", function()
  23 | 		assert.has.errors(function()
  24 | 			Vector3.new(1, 2, "test")
  25 | 		end)
  26 | 
  27 | 		assert.has.errors(function()
  28 | 			Vector3.new(1, "test", 3)
  29 | 		end)
  30 | 
  31 | 		assert.has.errors(function()
  32 | 			Vector3.new("test", 2, 3)
  33 | 		end)
  34 | 	end)
  35 | 
  36 | 	it("should add another Vector3", function()
  37 | 		local vectorA = Vector3.new(1, 50, 200)
  38 | 		local vectorB = Vector3.new(100, 300, 500)
  39 | 		local v = vectorA + vectorB
  40 | 
  41 | 		assert.not_nil(v)
  42 | 		assert.are.same({101, 350, 700}, extractValues(v))
  43 | 	end)
  44 | 
  45 | 	it("should subtract another Vector3", function()
  46 | 		local vectorA = Vector3.new(1, 50, 200)
  47 | 		local vectorB = Vector3.new(100, 300, 500)
  48 | 		local v = vectorA - vectorB
  49 | 
  50 | 		assert.not_nil(v)
  51 | 		assert.are.same({-99, -250, -300}, extractValues(v))
  52 | 	end)
  53 | 
  54 | 	it("should multiply by another Vector3", function()
  55 | 		local vectorA = Vector3.new(1, 50, 200)
  56 | 		local vectorB = Vector3.new(2, 0.5, 1)
  57 | 		local v = vectorA * vectorB
  58 | 
  59 | 		assert.not_nil(v)
  60 | 		assert.are.same({2, 25, 200}, extractValues(v))
  61 | 	end)
  62 | 
  63 | 	it("should multiply by a number", function()
  64 | 		local vectorA = Vector3.new(1, 50, 200)
  65 | 		local v = vectorA * 3
  66 | 
  67 | 		assert.not_nil(v)
  68 | 		assert.are.same({3, 150, 600}, extractValues(v))
  69 | 	end)
  70 | 
  71 | 	it("should multiply by a number reversed", function()
  72 | 		local vectorA = Vector3.new(1, 50, 200)
  73 | 		local v = 3 * vectorA
  74 | 
  75 | 		assert.not_nil(v)
  76 | 		assert.are.same({3, 150, 600}, extractValues(v))
  77 | 	end)
  78 | 
  79 | 	it("should throw an error when multiplied by an incompatible type", function()
  80 | 		assert.has.errors(function()
  81 | 			return Vector3.new(1, 2, 3) * nil
  82 | 		end)
  83 | 	end)
  84 | 
  85 | 	it("should divide by another Vector3", function()
  86 | 		local vectorA = Vector3.new(1, 50, 200)
  87 | 		local vectorB = Vector3.new(2, 1, 0.5)
  88 | 		local v = vectorA / vectorB
  89 | 
  90 | 		assert.not_nil(v)
  91 | 		assert.are.same({0.5, 50, 400}, extractValues(v))
  92 | 	end)
  93 | 
  94 | 	it("should divide by a number", function()
  95 | 		local vectorA = Vector3.new(1, 50, 200)
  96 | 		local v = vectorA / 4
  97 | 
  98 | 		assert.not_nil(v)
  99 | 		assert.are.same({0.25, 12.5, 50}, extractValues(v))
 100 | 	end)
 101 | 
 102 | 	it("should divide by a number reversed", function()
 103 | 		local vectorA = Vector3.new(1, 50, 200)
 104 | 		local v = 4 / vectorA
 105 | 
 106 | 		assert.not_nil(v)
 107 | 		assert.are.same({0.25, 12.5, 50}, extractValues(v))
 108 | 	end)
 109 | 
 110 | 	it("should throw an error when divided by an incompatible type", function()
 111 | 		assert.has.errors(function()
 112 | 			return Vector3.new(1, 2, 3) / "abc"
 113 | 		end)
 114 | 	end)
 115 | 
 116 | 	it("should equal another Vector3 with the same x and y", function()
 117 | 		local vectorA = Vector3.new(1, 200, 400)
 118 | 		local vectorB = Vector3.new(1, 200, 400)
 119 | 
 120 | 		assert.equals(vectorA, vectorB)
 121 | 	end)
 122 | 
 123 | 	it("should not equal another Vector3 with different x, y or z values", function()
 124 | 		local vectorA = Vector3.new(1, 200, 500)
 125 | 		local vectorB1 = Vector3.new(1, 200, 3)
 126 | 		local vectorB2 = Vector3.new(1, 3, 500)
 127 | 		local vectorB3 = Vector3.new(100, 200, 500)
 128 | 
 129 | 		assert.not_equals(vectorA, vectorB1)
 130 | 		assert.not_equals(vectorA, vectorB2)
 131 | 		assert.not_equals(vectorA, vectorB3)
 132 | 	end)
 133 | 
 134 | 	it("should throw when accessing an invalid member", function()
 135 | 		assert.has.errors(function()
 136 | 			local v = Vector3.new()
 137 | 			v.frobulations = v.frobulations + 1
 138 | 		end)
 139 | 	end)
 140 | 
 141 | 	it("should have a string representation of \"Vector3\"", function()
 142 | 		assert.equal(tostring(Vector3), "Vector3")
 143 | 	end)
 144 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/validateType.lua`
<details>
<summary>View Source (8 lines)</summary>

```lua
   1 | local typeof = import("./functions/typeof")
   2 | 
   3 | return function(name, value, expectedTypeAsString)
   4 | 	local actualType = typeof(value)
   5 | 	if actualType ~= expectedTypeAsString then
   6 | 		error(string.format("%s must be type `%s`, got type `%s`", name, expectedTypeAsString, actualType), 3)
   7 | 	end
   8 | end
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/lib/validateType_spec.lua`
<details>
<summary>View Source (19 lines)</summary>

```lua
   1 | local validateType = import("./validateType")
   2 | 
   3 | describe("validateType", function()
   4 | 	it("should be a function", function()
   5 | 		assert.not_nil(validateType)
   6 | 		assert.equals(type(validateType), "function")
   7 | 	end)
   8 | 
   9 | 	it("should accept valid types", function()
  10 | 		validateType("", 123, "number")
  11 | 		validateType("", "test", "string")
  12 | 		validateType("", true, "boolean")
  13 | 	end)
  14 | 
  15 | 	it("should throw on mismatched types", function()
  16 | 		assert.has.errors(function()
  17 | 			validateType("text", {}, "string")
  18 | 		end)
  19 | 	end)
  20 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/spec/load_spec.lua`
<details>
<summary>View Source (55 lines)</summary>

```lua
   1 | package.path = "./?/init.lua;" .. package.path
   2 | local lemur = require("lib")
   3 | 
   4 | describe("Lemur", function()
   5 | 	it("should load folders correctly", function()
   6 | 		local habitat = lemur.Habitat:new()
   7 | 
   8 | 		local root = habitat:loadFromFs("spec/test-project")
   9 | 
  10 | 		assert.equal(#root:GetChildren(), 3)
  11 | 
  12 | 		local bar = root:FindFirstChild("bar")
  13 | 		local usurp = root:FindFirstChild("usurp")
  14 | 		local normal = root:FindFirstChild("normal-folder")
  15 | 
  16 | 		assert.equal(bar.ClassName, "ModuleScript")
  17 | 		assert.equal(usurp.ClassName, "ModuleScript")
  18 | 		assert.equal(normal.ClassName, "Folder")
  19 | 
  20 | 		assert.equal(bar.Source, "-- bar.lua")
  21 | 		assert.equal(usurp.Source, "-- init.lua")
  22 | 
  23 | 		assert.equal(#usurp:GetChildren(), 1)
  24 | 
  25 | 		local foo = usurp:FindFirstChild("foo")
  26 | 		assert.equal(foo.ClassName, "ModuleScript")
  27 | 		assert.equal(foo.Source, "-- foo.lua")
  28 | 
  29 | 		assert.equal(#normal:GetChildren(), 1)
  30 | 
  31 | 		local ack = normal:FindFirstChild("ack")
  32 | 		assert.equal(ack.ClassName, "ModuleScript")
  33 | 		assert.equal(ack.Source, "-- ack.lua")
  34 | 	end)
  35 | 
  36 | 	it("should not touch init.lua if loadInitModules is false", function()
  37 | 		local habitat = lemur.Habitat:new()
  38 | 
  39 | 		local root = habitat:loadFromFs("spec/test-project", {
  40 | 			loadInitModules = false,
  41 | 		})
  42 | 
  43 | 		assert.equal(#root:GetChildren(), 3)
  44 | 
  45 | 		local usurp = root:FindFirstChild("usurp")
  46 | 		assert.equal(usurp.ClassName, "Folder")
  47 | 
  48 | 		local init = usurp:FindFirstChild("init")
  49 | 		assert.equal(init.ClassName, "ModuleScript")
  50 | 		assert.equal(init.Source, "-- init.lua")
  51 | 
  52 | 		local foo = usurp:FindFirstChild("foo")
  53 | 		assert.equal(foo.ClassName, "ModuleScript")
  54 | 		assert.equal(foo.Source, "-- foo.lua")
  55 | 	end)
  56 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/spec/require/a.lua`
<details>
<summary>View Source (0 lines)</summary>

```lua
   1 | return require(script.Parent.b)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/spec/require/b.lua`
<details>
<summary>View Source (0 lines)</summary>

```lua
   1 | return "foo"
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/spec/require/bar/baz.lua`
<details>
<summary>View Source (0 lines)</summary>

```lua
   1 | return "qux"
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/spec/require/cacheme.lua`
<details>
<summary>View Source (0 lines)</summary>

```lua
   1 | return {}
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/spec/require/foo.lua`
<details>
<summary>View Source (0 lines)</summary>

```lua
   1 | return require(script.Parent.bar.baz)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/spec/require_spec.lua`
<details>
<summary>View Source (66 lines)</summary>

```lua
   1 | package.path = "./?/init.lua;" .. package.path
   2 | local lemur = require("lib")
   3 | 
   4 | describe("Lemur", function()
   5 | 	it("should load modules directly", function()
   6 | 		local habitat = lemur.Habitat.new()
   7 | 
   8 | 		local root = habitat:loadFromFs("spec/require")
   9 | 
  10 | 		local module = root:FindFirstChild("a")
  11 | 
  12 | 		assert.not_nil(module)
  13 | 
  14 | 		local value = habitat:require(module)
  15 | 
  16 | 		assert.equal(value, "foo")
  17 | 
  18 | 		assert.equal(root:FindFirstChild("a"), module)
  19 | 		assert.not_nil(root:FindFirstChild("b"))
  20 | 	end)
  21 | 
  22 | 	it("should load modules from within folders", function()
  23 | 		local habitat = lemur.Habitat.new()
  24 | 
  25 | 		local root = habitat:loadFromFs("spec/require")
  26 | 
  27 | 		local value = habitat:require(root.foo)
  28 | 
  29 | 		assert.equal(value, "qux")
  30 | 	end)
  31 | 
  32 | 	it("should keep a module cache", function()
  33 | 		local habitat = lemur.Habitat.new()
  34 | 
  35 | 		local root = habitat:loadFromFs("spec/require")
  36 | 
  37 | 		local a = habitat:require(root.cacheme)
  38 | 		local b = habitat:require(root.cacheme)
  39 | 
  40 | 		assert.equal(a, b)
  41 | 	end)
  42 | 
  43 | 	it("should fail to find non-existent modules", function()
  44 | 		local habitat = lemur.Habitat.new()
  45 | 
  46 | 		local root = habitat:loadFromFs("spec/require")
  47 | 
  48 | 		local function nop()
  49 | 		end
  50 | 
  51 | 		assert.has.errors(function()
  52 | 			nop(root.NOPE_NOT_HERE)
  53 | 		end)
  54 | 
  55 | 		local object = root:FindFirstChild("STILL_NOT_HERE")
  56 | 
  57 | 		assert.is_nil(object)
  58 | 	end)
  59 | 
  60 | 	it("should fail to require non-ModuleScripts", function()
  61 | 		local habitat = lemur.Habitat.new()
  62 | 
  63 | 		assert.has.errors(function()
  64 | 			habitat:require(habitat.game)
  65 | 		end)
  66 | 	end)
  67 | end)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/spec/test-project/bar.lua`
<details>
<summary>View Source (0 lines)</summary>

```lua
   1 | -- bar.lua
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/spec/test-project/normal-folder/ack.lua`
<details>
<summary>View Source (0 lines)</summary>

```lua
   1 | -- ack.lua
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/spec/test-project/usurp/foo.lua`
<details>
<summary>View Source (0 lines)</summary>

```lua
   1 | -- foo.lua
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/modules/lemur/spec/test-project/usurp/init.lua`
<details>
<summary>View Source (0 lines)</summary>

```lua
   1 | -- init.lua
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/src/Context.lua`
<details>
<summary>View Source (26 lines)</summary>

```lua
   1 | --[[
   2 | 	The Context object implements a write-once key-value store. It also allows
   3 | 	for a new Context object to inherit the entries from an existing one.
   4 | ]]
   5 | local Context = {}
   6 | 
   7 | function Context.new(parent)
   8 | 	local meta = {}
   9 | 	local index = {}
  10 | 	meta.__index = index
  11 | 
  12 | 	if parent then
  13 | 		for key, value in pairs(getmetatable(parent).__index) do
  14 | 			index[key] = value
  15 | 		end
  16 | 	end
  17 | 
  18 | 	function meta.__newindex(_obj, key, value)
  19 | 		assert(index[key] == nil, string.format("Cannot reassign %s in context", tostring(key)))
  20 | 		index[key] = value
  21 | 	end
  22 | 
  23 | 	return setmetatable({}, meta)
  24 | end
  25 | 
  26 | return Context
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/src/Expectation.lua`
<details>
<summary>View Source (251 lines)</summary>

```lua
   1 | --[[
   2 | 	Allows creation of expectation statements designed for behavior-driven
   3 | 	testing (BDD). See Chai (JS) or RSpec (Ruby) for examples of other BDD
   4 | 	frameworks.
   5 | 
   6 | 	The Expectation class is exposed to tests as a function called `expect`:
   7 | 
   8 | 		expect(5).to.equal(5)
   9 | 		expect(foo()).to.be.ok()
  10 | 
  11 | 	Expectations can be negated using .never:
  12 | 
  13 | 		expect(true).never.to.equal(false)
  14 | 
  15 | 	Expectations throw errors when their conditions are not met.
  16 | ]]
  17 | 
  18 | local Expectation = {}
  19 | 
  20 | --[[
  21 | 	These keys don't do anything except make expectations read more cleanly
  22 | ]]
  23 | local SELF_KEYS = {
  24 | 	to = true,
  25 | 	be = true,
  26 | 	been = true,
  27 | 	have = true,
  28 | 	was = true,
  29 | 	at = true,
  30 | }
  31 | 
  32 | --[[
  33 | 	These keys invert the condition expressed by the Expectation.
  34 | ]]
  35 | local NEGATION_KEYS = {
  36 | 	never = true,
  37 | }
  38 | 
  39 | --[[
  40 | 	Extension of Lua's 'assert' that lets you specify an error level.
  41 | ]]
  42 | local function assertLevel(condition, message, level)
  43 | 	message = message or "Assertion failed!"
  44 | 	level = level or 1
  45 | 
  46 | 	if not condition then
  47 | 		error(message, level + 1)
  48 | 	end
  49 | end
  50 | 
  51 | --[[
  52 | 	Returns a version of the given method that can be called with either . or :
  53 | ]]
  54 | local function bindSelf(self, method)
  55 | 	return function(firstArg, ...)
  56 | 		if firstArg == self then
  57 | 			return method(self, ...)
  58 | 		else
  59 | 			return method(self, firstArg, ...)
  60 | 		end
  61 | 	end
  62 | end
  63 | 
  64 | local function formatMessage(result, trueMessage, falseMessage)
  65 | 	if result then
  66 | 		return trueMessage
  67 | 	else
  68 | 		return falseMessage
  69 | 	end
  70 | end
  71 | 
  72 | --[[
  73 | 	Create a new expectation
  74 | ]]
  75 | function Expectation.new(value)
  76 | 	local self = {
  77 | 		value = value,
  78 | 		successCondition = true,
  79 | 		condition = false
  80 | 	}
  81 | 
  82 | 	setmetatable(self, Expectation)
  83 | 
  84 | 	self.a = bindSelf(self, self.a)
  85 | 	self.an = self.a
  86 | 	self.ok = bindSelf(self, self.ok)
  87 | 	self.equal = bindSelf(self, self.equal)
  88 | 	self.throw = bindSelf(self, self.throw)
  89 | 	self.near = bindSelf(self, self.near)
  90 | 
  91 | 	return self
  92 | end
  93 | 
  94 | function Expectation.__index(self, key)
  95 | 	-- Keys that don't do anything except improve readability
  96 | 	if SELF_KEYS[key] then
  97 | 		return self
  98 | 	end
  99 | 
 100 | 	-- Invert your assertion
 101 | 	if NEGATION_KEYS[key] then
 102 | 		local newExpectation = Expectation.new(self.value)
 103 | 		newExpectation.successCondition = not self.successCondition
 104 | 
 105 | 		return newExpectation
 106 | 	end
 107 | 
 108 | 	-- Fall back to methods provided by Expectation
 109 | 	return Expectation[key]
 110 | end
 111 | 
 112 | --[[
 113 | 	Called by expectation terminators to reset modifiers in a statement.
 114 | 
 115 | 	This makes chains like:
 116 | 
 117 | 		expect(5)
 118 | 			.never.to.equal(6)
 119 | 			.to.equal(5)
 120 | 
 121 | 	Work as expected.
 122 | ]]
 123 | function Expectation:_resetModifiers()
 124 | 	self.successCondition = true
 125 | end
 126 | 
 127 | --[[
 128 | 	Assert that the expectation value is the given type.
 129 | 
 130 | 	expect(5).to.be.a("number")
 131 | ]]
 132 | function Expectation:a(typeName)
 133 | 	local result = (type(self.value) == typeName) == self.successCondition
 134 | 
 135 | 	local message = formatMessage(self.successCondition,
 136 | 		("Expected value of type %q, got value %q of type %s"):format(
 137 | 			typeName,
 138 | 			tostring(self.value),
 139 | 			type(self.value)
 140 | 		),
 141 | 		("Expected value not of type %q, got value %q of type %s"):format(
 142 | 			typeName,
 143 | 			tostring(self.value),
 144 | 			type(self.value)
 145 | 		)
 146 | 	)
 147 | 
 148 | 	assertLevel(result, message, 3)
 149 | 	self:_resetModifiers()
 150 | 
 151 | 	return self
 152 | end
 153 | 
 154 | --[[
 155 | 	Assert that our expectation value is truthy
 156 | ]]
 157 | function Expectation:ok()
 158 | 	local result = (self.value ~= nil) == self.successCondition
 159 | 
 160 | 	local message = formatMessage(self.successCondition,
 161 | 		("Expected value %q to be non-nil"):format(
 162 | 			tostring(self.value)
 163 | 		),
 164 | 		("Expected value %q to be nil"):format(
 165 | 			tostring(self.value)
 166 | 		)
 167 | 	)
 168 | 
 169 | 	assertLevel(result, message, 3)
 170 | 	self:_resetModifiers()
 171 | 
 172 | 	return self
 173 | end
 174 | 
 175 | --[[
 176 | 	Assert that our expectation value is equal to another value
 177 | ]]
 178 | function Expectation:equal(otherValue)
 179 | 	local result = (self.value == otherValue) == self.successCondition
 180 | 
 181 | 	local message = formatMessage(self.successCondition,
 182 | 		("Expected value %q (%s), got %q (%s) instead"):format(
 183 | 			tostring(otherValue),
 184 | 			type(otherValue),
 185 | 			tostring(self.value),
 186 | 			type(self.value)
 187 | 		),
 188 | 		("Expected anything but value %q (%s)"):format(
 189 | 			tostring(otherValue),
 190 | 			type(otherValue)
 191 | 		)
 192 | 	)
 193 | 
 194 | 	assertLevel(result, message, 3)
 195 | 	self:_resetModifiers()
 196 | 
 197 | 	return self
 198 | end
 199 | 
 200 | --[[
 201 | 	Assert that our expectation value is equal to another value within some
 202 | 	inclusive limit.
 203 | ]]
 204 | function Expectation:near(otherValue, limit)
 205 | 	assert(type(self.value) == "number", "Expectation value must be a number to use 'near'")
 206 | 	assert(type(otherValue) == "number", "otherValue must be a number")
 207 | 	assert(type(limit) == "number" or limit == nil, "limit must be a number or nil")
 208 | 
 209 | 	limit = limit or 1e-7
 210 | 
 211 | 	local result = (math.abs(self.value - otherValue) <= limit) == self.successCondition
 212 | 
 213 | 	local message = formatMessage(self.successCondition,
 214 | 		("Expected value to be near %f (within %f) but got %f instead"):format(
 215 | 			otherValue,
 216 | 			limit,
 217 | 			self.value
 218 | 		),
 219 | 		("Expected value to not be near %f (within %f) but got %f instead"):format(
 220 | 			otherValue,
 221 | 			limit,
 222 | 			self.value
 223 | 		)
 224 | 	)
 225 | 
 226 | 	assertLevel(result, message, 3)
 227 | 	self:_resetModifiers()
 228 | 
 229 | 	return self
 230 | end
 231 | 
 232 | --[[
 233 | 	Assert that our functoid expectation value throws an error when called
 234 | ]]
 235 | function Expectation:throw()
 236 | 	local ok, err = pcall(self.value)
 237 | 	local result = ok ~= self.successCondition
 238 | 
 239 | 	local message = formatMessage(self.successCondition,
 240 | 		"Expected function to throw an error, but it did not.",
 241 | 		("Expected function to succeed, but it threw an error: %s"):format(
 242 | 			tostring(err)
 243 | 		)
 244 | 	)
 245 | 
 246 | 	assertLevel(result, message, 3)
 247 | 	self:_resetModifiers()
 248 | 
 249 | 	return self
 250 | end
 251 | 
 252 | return Expectation
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/src/init.lua`
<details>
<summary>View Source (39 lines)</summary>

```lua
   1 | local Expectation = require(script.Expectation)
   2 | local TestBootstrap = require(script.TestBootstrap)
   3 | local TestEnum = require(script.TestEnum)
   4 | local TestPlan = require(script.TestPlan)
   5 | local TestPlanner = require(script.TestPlanner)
   6 | local TestResults = require(script.TestResults)
   7 | local TestRunner = require(script.TestRunner)
   8 | local TestSession = require(script.TestSession)
   9 | local TextReporter = require(script.Reporters.TextReporter)
  10 | local TextReporterQuiet = require(script.Reporters.TextReporterQuiet)
  11 | local TeamCityReporter = require(script.Reporters.TeamCityReporter)
  12 | 
  13 | local function run(testRoot, callback)
  14 | 	local modules = TestBootstrap:getModules(testRoot)
  15 | 	local plan = TestPlanner.createPlan(modules)
  16 | 	local results = TestRunner.runPlan(plan)
  17 | 
  18 | 	callback(results)
  19 | end
  20 | 
  21 | local TestEZ = {
  22 | 	run = run,
  23 | 
  24 | 	Expectation = Expectation,
  25 | 	TestBootstrap = TestBootstrap,
  26 | 	TestEnum = TestEnum,
  27 | 	TestPlan = TestPlan,
  28 | 	TestPlanner = TestPlanner,
  29 | 	TestResults = TestResults,
  30 | 	TestRunner = TestRunner,
  31 | 	TestSession = TestSession,
  32 | 
  33 | 	Reporters = {
  34 | 		TextReporter = TextReporter,
  35 | 		TextReporterQuiet = TextReporterQuiet,
  36 | 		TeamCityReporter = TeamCityReporter,
  37 | 	},
  38 | }
  39 | 
  40 | return TestEZ
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/src/LifecycleHooks.lua`
<details>
<summary>View Source (89 lines)</summary>

```lua
   1 | local TestEnum = require(script.Parent.TestEnum)
   2 | 
   3 | local LifecycleHooks = {}
   4 | LifecycleHooks.__index = LifecycleHooks
   5 | 
   6 | function LifecycleHooks.new()
   7 | 	local self = {
   8 | 		_stack = {},
   9 | 	}
  10 | 	return setmetatable(self, LifecycleHooks)
  11 | end
  12 | 
  13 | --[[
  14 | 	Returns an array of `beforeEach` hooks in FIFO order
  15 | ]]
  16 | function LifecycleHooks:getBeforeEachHooks()
  17 | 	local key = TestEnum.NodeType.BeforeEach
  18 | 	local hooks = {}
  19 | 
  20 | 	for _, level in ipairs(self._stack) do
  21 | 		for _, hook in ipairs(level[key]) do
  22 | 			table.insert(hooks, hook)
  23 | 		end
  24 | 	end
  25 | 
  26 | 	return hooks
  27 | end
  28 | 
  29 | --[[
  30 | 	Returns an array of `afterEach` hooks in FILO order
  31 | ]]
  32 | function LifecycleHooks:getAfterEachHooks()
  33 | 	local key = TestEnum.NodeType.AfterEach
  34 | 	local hooks = {}
  35 | 
  36 | 	for _, level in ipairs(self._stack) do
  37 | 		for _, hook in ipairs(level[key]) do
  38 | 			table.insert(hooks, 1, hook)
  39 | 		end
  40 | 	end
  41 | 
  42 | 	return hooks
  43 | end
  44 | 
  45 | --[[
  46 | 	Pushes uncalled beforeAll and afterAll hooks back up the stack
  47 | ]]
  48 | function LifecycleHooks:popHooks()
  49 | 	table.remove(self._stack, #self._stack)
  50 | end
  51 | 
  52 | function LifecycleHooks:pushHooksFrom(planNode)
  53 | 	assert(planNode ~= nil)
  54 | 
  55 | 	table.insert(self._stack, {
  56 | 		[TestEnum.NodeType.BeforeAll] = self:_getHooksOfType(planNode.children, TestEnum.NodeType.BeforeAll),
  57 | 		[TestEnum.NodeType.AfterAll] = self:_getHooksOfType(planNode.children, TestEnum.NodeType.AfterAll),
  58 | 		[TestEnum.NodeType.BeforeEach] = self:_getHooksOfType(planNode.children, TestEnum.NodeType.BeforeEach),
  59 | 		[TestEnum.NodeType.AfterEach] = self:_getHooksOfType(planNode.children, TestEnum.NodeType.AfterEach),
  60 | 	})
  61 | end
  62 | 
  63 | --[[
  64 | 	Get the beforeAll hooks from the current level.
  65 | ]]
  66 | function LifecycleHooks:getBeforeAllHooks()
  67 | 	return self._stack[#self._stack][TestEnum.NodeType.BeforeAll]
  68 | end
  69 | 
  70 | --[[
  71 | 	Get the afterAll hooks from the current level.
  72 | ]]
  73 | function LifecycleHooks:getAfterAllHooks()
  74 | 	return self._stack[#self._stack][TestEnum.NodeType.AfterAll]
  75 | end
  76 | 
  77 | function LifecycleHooks:_getHooksOfType(nodes, key)
  78 | 	local hooks = {}
  79 | 
  80 | 	for _, node in ipairs(nodes) do
  81 | 		if node.type == key then
  82 | 			table.insert(hooks, node.callback)
  83 | 		end
  84 | 	end
  85 | 
  86 | 	return hooks
  87 | end
  88 | 
  89 | return LifecycleHooks
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/src/Reporters/TeamCityReporter.lua`
<details>
<summary>View Source (101 lines)</summary>

```lua
   1 | local TestService = game:GetService("TestService")
   2 | 
   3 | local TestEnum = require(script.Parent.Parent.TestEnum)
   4 | 
   5 | local TeamCityReporter = {}
   6 | 
   7 | local function teamCityEscape(str)
   8 | 	str = string.gsub(str, "([]|'[])","|%1")
   9 | 	str = string.gsub(str, "\r", "|r")
  10 | 	str = string.gsub(str, "\n", "|n")
  11 | 	return str
  12 | end
  13 | 
  14 | local function teamCityEnterSuite(suiteName)
  15 | 	return string.format("##teamcity[testSuiteStarted name='%s']", teamCityEscape(suiteName))
  16 | end
  17 | 
  18 | local function teamCityLeaveSuite(suiteName)
  19 | 	return string.format("##teamcity[testSuiteFinished name='%s']", teamCityEscape(suiteName))
  20 | end
  21 | 
  22 | local function teamCityEnterCase(caseName)
  23 | 	return string.format("##teamcity[testStarted name='%s']", teamCityEscape(caseName))
  24 | end
  25 | 
  26 | local function teamCityLeaveCase(caseName)
  27 | 	return string.format("##teamcity[testFinished name='%s']", teamCityEscape(caseName))
  28 | end
  29 | 
  30 | local function teamCityFailCase(caseName, errorMessage)
  31 | 	return string.format("##teamcity[testFailed name='%s' message='%s']",
  32 | 		teamCityEscape(caseName), teamCityEscape(errorMessage))
  33 | end
  34 | 
  35 | local function reportNode(node, buffer, level)
  36 | 	buffer = buffer or {}
  37 | 	level = level or 0
  38 | 	if node.status == TestEnum.TestStatus.Skipped then
  39 | 		return buffer
  40 | 	end
  41 | 	if node.planNode.type == TestEnum.NodeType.Describe then
  42 | 		table.insert(buffer, teamCityEnterSuite(node.planNode.phrase))
  43 | 		for _, child in ipairs(node.children) do
  44 | 			reportNode(child, buffer, level + 1)
  45 | 		end
  46 | 		table.insert(buffer, teamCityLeaveSuite(node.planNode.phrase))
  47 | 	else
  48 | 		table.insert(buffer, teamCityEnterCase(node.planNode.phrase))
  49 | 		if node.status == TestEnum.TestStatus.Failure then
  50 | 			table.insert(buffer, teamCityFailCase(node.planNode.phrase, table.concat(node.errors,"\n")))
  51 | 		end
  52 | 		table.insert(buffer, teamCityLeaveCase(node.planNode.phrase))
  53 | 	end
  54 | end
  55 | 
  56 | local function reportRoot(node)
  57 | 	local buffer = {}
  58 | 
  59 | 	for _, child in ipairs(node.children) do
  60 | 		reportNode(child, buffer, 0)
  61 | 	end
  62 | 
  63 | 	return buffer
  64 | end
  65 | 
  66 | local function report(root)
  67 | 	local buffer = reportRoot(root)
  68 | 
  69 | 	return table.concat(buffer, "\n")
  70 | end
  71 | 
  72 | function TeamCityReporter.report(results)
  73 | 	local resultBuffer = {
  74 | 		"Test results:",
  75 | 		report(results),
  76 | 		("%d passed, %d failed, %d skipped"):format(
  77 | 			results.successCount,
  78 | 			results.failureCount,
  79 | 			results.skippedCount
  80 | 		)
  81 | 	}
  82 | 
  83 | 	print(table.concat(resultBuffer, "\n"))
  84 | 
  85 | 	if results.failureCount > 0 then
  86 | 		print(("%d test nodes reported failures."):format(results.failureCount))
  87 | 	end
  88 | 
  89 | 	if #results.errors > 0 then
  90 | 		print("Errors reported by tests:")
  91 | 		print("")
  92 | 
  93 | 		for _, message in ipairs(results.errors) do
  94 | 			TestService:Error(message)
  95 | 
  96 | 			-- Insert a blank line after each error
  97 | 			print("")
  98 | 		end
  99 | 	end
 100 | end
 101 | 
 102 | return TeamCityReporter
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/src/Reporters/TextReporter.lua`
<details>
<summary>View Source (105 lines)</summary>

```lua
   1 | --[[
   2 | 	The TextReporter uses the results from a completed test to output text to
   3 | 	standard output and TestService.
   4 | ]]
   5 | 
   6 | local TestService = game:GetService("TestService")
   7 | 
   8 | local TestEnum = require(script.Parent.Parent.TestEnum)
   9 | 
  10 | local INDENT = (" "):rep(3)
  11 | local STATUS_SYMBOLS = {
  12 | 	[TestEnum.TestStatus.Success] = "+",
  13 | 	[TestEnum.TestStatus.Failure] = "-",
  14 | 	[TestEnum.TestStatus.Skipped] = "~"
  15 | }
  16 | local UNKNOWN_STATUS_SYMBOL = "?"
  17 | 
  18 | local TextReporter = {}
  19 | 
  20 | local function compareNodes(a, b)
  21 | 	return a.planNode.phrase:lower() < b.planNode.phrase:lower()
  22 | end
  23 | 
  24 | local function reportNode(node, buffer, level)
  25 | 	buffer = buffer or {}
  26 | 	level = level or 0
  27 | 
  28 | 	if node.status == TestEnum.TestStatus.Skipped then
  29 | 		return buffer
  30 | 	end
  31 | 
  32 | 	local line
  33 | 
  34 | 	if node.status then
  35 | 		local symbol = STATUS_SYMBOLS[node.status] or UNKNOWN_STATUS_SYMBOL
  36 | 
  37 | 		line = ("%s[%s] %s"):format(
  38 | 			INDENT:rep(level),
  39 | 			symbol,
  40 | 			node.planNode.phrase
  41 | 		)
  42 | 	else
  43 | 		line = ("%s%s"):format(
  44 | 			INDENT:rep(level),
  45 | 			node.planNode.phrase
  46 | 		)
  47 | 	end
  48 | 
  49 | 	table.insert(buffer, line)
  50 | 	table.sort(node.children, compareNodes)
  51 | 
  52 | 	for _, child in ipairs(node.children) do
  53 | 		reportNode(child, buffer, level + 1)
  54 | 	end
  55 | 
  56 | 	return buffer
  57 | end
  58 | 
  59 | local function reportRoot(node)
  60 | 	local buffer = {}
  61 | 	table.sort(node.children, compareNodes)
  62 | 
  63 | 	for _, child in ipairs(node.children) do
  64 | 		reportNode(child, buffer, 0)
  65 | 	end
  66 | 
  67 | 	return buffer
  68 | end
  69 | 
  70 | local function report(root)
  71 | 	local buffer = reportRoot(root)
  72 | 
  73 | 	return table.concat(buffer, "\n")
  74 | end
  75 | 
  76 | function TextReporter.report(results)
  77 | 	local resultBuffer = {
  78 | 		"Test results:",
  79 | 		report(results),
  80 | 		("%d passed, %d failed, %d skipped"):format(
  81 | 			results.successCount,
  82 | 			results.failureCount,
  83 | 			results.skippedCount
  84 | 		)
  85 | 	}
  86 | 
  87 | 	print(table.concat(resultBuffer, "\n"))
  88 | 
  89 | 	if results.failureCount > 0 then
  90 | 		print(("%d test nodes reported failures."):format(results.failureCount))
  91 | 	end
  92 | 
  93 | 	if #results.errors > 0 then
  94 | 		print("Errors reported by tests:")
  95 | 		print("")
  96 | 
  97 | 		for _, message in ipairs(results.errors) do
  98 | 			TestService:Error(message)
  99 | 
 100 | 			-- Insert a blank line after each error
 101 | 			print("")
 102 | 		end
 103 | 	end
 104 | end
 105 | 
 106 | return TextReporter
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/src/Reporters/TextReporterQuiet.lua`
<details>
<summary>View Source (96 lines)</summary>

```lua
   1 | --[[
   2 | 	Copy of TextReporter that doesn't output successful tests.
   3 | 
   4 | 	This should be temporary, it's just a workaround to make CI environments
   5 | 	happy in the short-term.
   6 | ]]
   7 | 
   8 | local TestService = game:GetService("TestService")
   9 | 
  10 | local TestEnum = require(script.Parent.Parent.TestEnum)
  11 | 
  12 | local INDENT = (" "):rep(3)
  13 | local STATUS_SYMBOLS = {
  14 | 	[TestEnum.TestStatus.Success] = "+",
  15 | 	[TestEnum.TestStatus.Failure] = "-",
  16 | 	[TestEnum.TestStatus.Skipped] = "~"
  17 | }
  18 | local UNKNOWN_STATUS_SYMBOL = "?"
  19 | 
  20 | local TextReporterQuiet = {}
  21 | 
  22 | local function reportNode(node, buffer, level)
  23 | 	buffer = buffer or {}
  24 | 	level = level or 0
  25 | 
  26 | 	if node.status == TestEnum.TestStatus.Skipped then
  27 | 		return buffer
  28 | 	end
  29 | 
  30 | 	local line
  31 | 
  32 | 	if node.status ~= TestEnum.TestStatus.Success then
  33 | 		local symbol = STATUS_SYMBOLS[node.status] or UNKNOWN_STATUS_SYMBOL
  34 | 
  35 | 		line = ("%s[%s] %s"):format(
  36 | 			INDENT:rep(level),
  37 | 			symbol,
  38 | 			node.planNode.phrase
  39 | 		)
  40 | 	end
  41 | 
  42 | 	table.insert(buffer, line)
  43 | 
  44 | 	for _, child in ipairs(node.children) do
  45 | 		reportNode(child, buffer, level + 1)
  46 | 	end
  47 | 
  48 | 	return buffer
  49 | end
  50 | 
  51 | local function reportRoot(node)
  52 | 	local buffer = {}
  53 | 
  54 | 	for _, child in ipairs(node.children) do
  55 | 		reportNode(child, buffer, 0)
  56 | 	end
  57 | 
  58 | 	return buffer
  59 | end
  60 | 
  61 | local function report(root)
  62 | 	local buffer = reportRoot(root)
  63 | 
  64 | 	return table.concat(buffer, "\n")
  65 | end
  66 | 
  67 | function TextReporterQuiet.report(results)
  68 | 	local resultBuffer = {
  69 | 		"Test results:",
  70 | 		report(results),
  71 | 		("%d passed, %d failed, %d skipped"):format(
  72 | 			results.successCount,
  73 | 			results.failureCount,
  74 | 			results.skippedCount
  75 | 		)
  76 | 	}
  77 | 
  78 | 	print(table.concat(resultBuffer, "\n"))
  79 | 
  80 | 	if results.failureCount > 0 then
  81 | 		print(("%d test nodes reported failures."):format(results.failureCount))
  82 | 	end
  83 | 
  84 | 	if #results.errors > 0 then
  85 | 		print("Errors reported by tests:")
  86 | 		print("")
  87 | 
  88 | 		for _, message in ipairs(results.errors) do
  89 | 			TestService:Error(message)
  90 | 
  91 | 			-- Insert a blank line after each error
  92 | 			print("")
  93 | 		end
  94 | 	end
  95 | end
  96 | 
  97 | return TextReporterQuiet
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/src/TestBootstrap.lua`
<details>
<summary>View Source (146 lines)</summary>

```lua
   1 | --[[
   2 | 	Provides an interface to quickly run and report tests from a given object.
   3 | ]]
   4 | 
   5 | local TestPlanner = require(script.Parent.TestPlanner)
   6 | local TestRunner = require(script.Parent.TestRunner)
   7 | local TextReporter = require(script.Parent.Reporters.TextReporter)
   8 | 
   9 | local TestBootstrap = {}
  10 | 
  11 | local function stripSpecSuffix(name)
  12 | 	return (name:gsub("%.spec$", ""))
  13 | end
  14 | local function isSpecScript(aScript)
  15 | 	return aScript:IsA("ModuleScript") and aScript.Name:match("%.spec$")
  16 | end
  17 | 
  18 | local function getPath(module, root)
  19 | 	root = root or game
  20 | 
  21 | 	local path = {}
  22 | 	local last = module
  23 | 
  24 | 	if last.Name == "init.spec" then
  25 | 		-- Use the directory's node for init.spec files.
  26 | 		last = last.Parent
  27 | 	end
  28 | 
  29 | 	while last ~= nil and last ~= root do
  30 | 		table.insert(path, stripSpecSuffix(last.Name))
  31 | 		last = last.Parent
  32 | 	end
  33 | 	table.insert(path, stripSpecSuffix(root.Name))
  34 | 
  35 | 	return path
  36 | end
  37 | 
  38 | local function toStringPath(tablePath)
  39 | 	local stringPath = ""
  40 | 	local first = true
  41 | 	for _, element in ipairs(tablePath) do
  42 | 		if first then
  43 | 			stringPath = element
  44 | 			first = false
  45 | 		else
  46 | 			stringPath = element .. " " .. stringPath
  47 | 		end
  48 | 	end
  49 | 	return stringPath
  50 | end
  51 | 
  52 | function TestBootstrap:getModulesImpl(root, modules, current)
  53 | 	modules = modules or {}
  54 | 	current = current or root
  55 | 
  56 | 	if isSpecScript(current) then
  57 | 		local method = require(current)
  58 | 		local path = getPath(current, root)
  59 | 		local pathString = toStringPath(path)
  60 | 
  61 | 		table.insert(modules, {
  62 | 			method = method,
  63 | 			path = path,
  64 | 			pathStringForSorting = pathString:lower()
  65 | 		})
  66 | 	end
  67 | end
  68 | 
  69 | --[[
  70 | 	Find all the ModuleScripts in this tree that are tests.
  71 | ]]
  72 | function TestBootstrap:getModules(root)
  73 | 	local modules = {}
  74 | 
  75 | 	self:getModulesImpl(root, modules)
  76 | 
  77 | 	for _, child in ipairs(root:GetDescendants()) do
  78 | 		self:getModulesImpl(root, modules, child)
  79 | 	end
  80 | 
  81 | 	return modules
  82 | end
  83 | 
  84 | --[[
  85 | 	Runs all test and reports the results using the given test reporter.
  86 | 
  87 | 	If no reporter is specified, a reasonable default is provided.
  88 | 
  89 | 	This function demonstrates the expected workflow with this testing system:
  90 | 	1. Locate test modules
  91 | 	2. Generate test plan
  92 | 	3. Run test plan
  93 | 	4. Report test results
  94 | 
  95 | 	This means we could hypothetically present a GUI to the developer that shows
  96 | 	the test plan before we execute it, allowing them to toggle specific tests
  97 | 	before they're run, but after they've been identified!
  98 | ]]
  99 | function TestBootstrap:run(roots, reporter, otherOptions)
 100 | 	reporter = reporter or TextReporter
 101 | 
 102 | 	otherOptions = otherOptions or {}
 103 | 	local showTimingInfo = otherOptions["showTimingInfo"] or false
 104 | 	local testNamePattern = otherOptions["testNamePattern"]
 105 | 	local extraEnvironment = otherOptions["extraEnvironment"] or {}
 106 | 
 107 | 	if type(roots) ~= "table" then
 108 | 		error(("Bad argument #1 to TestBootstrap:run. Expected table, got %s"):format(typeof(roots)), 2)
 109 | 	end
 110 | 
 111 | 	local startTime = tick()
 112 | 
 113 | 	local modules = {}
 114 | 	for _, subRoot in ipairs(roots) do
 115 | 		local newModules = self:getModules(subRoot)
 116 | 
 117 | 		for _, newModule in ipairs(newModules) do
 118 | 			table.insert(modules, newModule)
 119 | 		end
 120 | 	end
 121 | 
 122 | 	local afterModules = tick()
 123 | 
 124 | 	local plan = TestPlanner.createPlan(modules, testNamePattern, extraEnvironment)
 125 | 	local afterPlan = tick()
 126 | 
 127 | 	local results = TestRunner.runPlan(plan)
 128 | 	local afterRun = tick()
 129 | 
 130 | 	reporter.report(results)
 131 | 	local afterReport = tick()
 132 | 
 133 | 	if showTimingInfo then
 134 | 		local timing = {
 135 | 			("Took %f seconds to locate test modules"):format(afterModules - startTime),
 136 | 			("Took %f seconds to create test plan"):format(afterPlan - afterModules),
 137 | 			("Took %f seconds to run tests"):format(afterRun - afterPlan),
 138 | 			("Took %f seconds to report tests"):format(afterReport - afterRun),
 139 | 		}
 140 | 
 141 | 		print(table.concat(timing, "\n"))
 142 | 	end
 143 | 
 144 | 	return results
 145 | end
 146 | 
 147 | return TestBootstrap
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/src/TestEnum.lua`
<details>
<summary>View Source (27 lines)</summary>

```lua
   1 | --[[
   2 | 	Constants used throughout the testing framework.
   3 | ]]
   4 | 
   5 | local TestEnum = {}
   6 | 
   7 | TestEnum.TestStatus = {
   8 | 	Success = "Success",
   9 | 	Failure = "Failure",
  10 | 	Skipped = "Skipped"
  11 | }
  12 | 
  13 | TestEnum.NodeType = {
  14 | 	Describe = "Describe",
  15 | 	It = "It",
  16 | 	BeforeAll = "BeforeAll",
  17 | 	AfterAll = "AfterAll",
  18 | 	BeforeEach = "BeforeEach",
  19 | 	AfterEach = "AfterEach"
  20 | }
  21 | 
  22 | TestEnum.NodeModifier = {
  23 | 	None = "None",
  24 | 	Skip = "Skip",
  25 | 	Focus = "Focus"
  26 | }
  27 | 
  28 | return TestEnum
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/src/TestPlan.lua`
<details>
<summary>View Source (291 lines)</summary>

```lua
   1 | --[[
   2 | 	Represents a tree of tests that have been loaded but not necessarily
   3 | 	executed yet.
   4 | 
   5 | 	TestPlan objects are produced by TestPlanner.
   6 | ]]
   7 | 
   8 | local TestEnum = require(script.Parent.TestEnum)
   9 | local Expectation = require(script.Parent.Expectation)
  10 | 
  11 | local function newEnvironment(currentNode, extraEnvironment)
  12 | 	local env = {}
  13 | 
  14 | 	if extraEnvironment then
  15 | 		if type(extraEnvironment) ~= "table" then
  16 | 			error(("Bad argument #2 to newEnvironment. Expected table, got %s"):format(
  17 | 				typeof(extraEnvironment)), 2)
  18 | 		end
  19 | 
  20 | 		for key, value in pairs(extraEnvironment) do
  21 | 			env[key] = value
  22 | 		end
  23 | 	end
  24 | 
  25 | 	local function addChild(phrase, callback, nodeType, nodeModifier)
  26 | 		local node = currentNode:addChild(phrase, nodeType, nodeModifier)
  27 | 		node.callback = callback
  28 | 		if nodeType == TestEnum.NodeType.Describe then
  29 | 			node:expand()
  30 | 		end
  31 | 		return node
  32 | 	end
  33 | 
  34 | 	function env.describeFOCUS(phrase, callback)
  35 | 		addChild(phrase, callback, TestEnum.NodeType.Describe, TestEnum.NodeModifier.Focus)
  36 | 	end
  37 | 
  38 | 	function env.describeSKIP(phrase, callback)
  39 | 		addChild(phrase, callback, TestEnum.NodeType.Describe, TestEnum.NodeModifier.Skip)
  40 | 	end
  41 | 
  42 | 	function env.describe(phrase, callback, nodeModifier)
  43 | 		addChild(phrase, callback, TestEnum.NodeType.Describe, TestEnum.NodeModifier.None)
  44 | 	end
  45 | 
  46 | 	function env.itFOCUS(phrase, callback)
  47 | 		addChild(phrase, callback, TestEnum.NodeType.It, TestEnum.NodeModifier.Focus)
  48 | 	end
  49 | 
  50 | 	function env.itSKIP(phrase, callback)
  51 | 		addChild(phrase, callback, TestEnum.NodeType.It, TestEnum.NodeModifier.Skip)
  52 | 	end
  53 | 
  54 | 	function env.itFIXME(phrase, callback)
  55 | 		local node = addChild(phrase, callback, TestEnum.NodeType.It, TestEnum.NodeModifier.Skip)
  56 | 		warn("FIXME: broken test", node:getFullName())
  57 | 	end
  58 | 
  59 | 	function env.it(phrase, callback, nodeModifier)
  60 | 		addChild(phrase, callback, TestEnum.NodeType.It, TestEnum.NodeModifier.None)
  61 | 	end
  62 | 
  63 | 	-- Incrementing counter used to ensure that beforeAll, afterAll, beforeEach, afterEach have unique phrases
  64 | 	local lifecyclePhaseId = 0
  65 | 
  66 | 	local lifecycleHooks = {
  67 | 		[TestEnum.NodeType.BeforeAll] = "beforeAll",
  68 | 		[TestEnum.NodeType.AfterAll] = "afterAll",
  69 | 		[TestEnum.NodeType.BeforeEach] = "beforeEach",
  70 | 		[TestEnum.NodeType.AfterEach] = "afterEach"
  71 | 	}
  72 | 
  73 | 	for nodeType, name in pairs(lifecycleHooks) do
  74 | 		env[name] = function(callback)
  75 | 			addChild(name .. "_" .. tostring(lifecyclePhaseId), callback, nodeType, TestEnum.NodeModifier.None)
  76 | 			lifecyclePhaseId = lifecyclePhaseId + 1
  77 | 		end
  78 | 	end
  79 | 
  80 | 	function env.FIXME(optionalMessage)
  81 | 		warn("FIXME: broken test", currentNode:getFullName(), optionalMessage or "")
  82 | 
  83 | 		currentNode.modifier = TestEnum.NodeModifier.Skip
  84 | 	end
  85 | 
  86 | 	function env.FOCUS()
  87 | 		currentNode.modifier = TestEnum.NodeModifier.Focus
  88 | 	end
  89 | 
  90 | 	function env.SKIP()
  91 | 		currentNode.modifier = TestEnum.NodeModifier.Skip
  92 | 	end
  93 | 
  94 | 	--[[
  95 | 		This function is deprecated. Calling it is a no-op beyond generating a
  96 | 		warning.
  97 | 	]]
  98 | 	function env.HACK_NO_XPCALL()
  99 | 		warn("HACK_NO_XPCALL is deprecated. It is now safe to yield in an " ..
 100 | 			"xpcall, so this is no longer necessary. It can be safely deleted.")
 101 | 	end
 102 | 
 103 | 	env.fit = env.itFOCUS
 104 | 	env.xit = env.itSKIP
 105 | 	env.fdescribe = env.describeFOCUS
 106 | 	env.xdescribe = env.describeSKIP
 107 | 
 108 | 	env.expect = Expectation.new
 109 | 
 110 | 	return env
 111 | end
 112 | 
 113 | local TestNode = {}
 114 | TestNode.__index = TestNode
 115 | 
 116 | --[[
 117 | 	Create a new test node. A pointer to the test plan, a phrase to describe it
 118 | 	and the type of node it is are required. The modifier is optional and will
 119 | 	be None if left blank.
 120 | ]]
 121 | function TestNode.new(plan, phrase, nodeType, nodeModifier)
 122 | 	nodeModifier = nodeModifier or TestEnum.NodeModifier.None
 123 | 
 124 | 	local node = {
 125 | 		plan = plan,
 126 | 		phrase = phrase,
 127 | 		type = nodeType,
 128 | 		modifier = nodeModifier,
 129 | 		children = {},
 130 | 		callback = nil,
 131 | 		parent = nil,
 132 | 	}
 133 | 
 134 | 	node.environment = newEnvironment(node, plan.extraEnvironment)
 135 | 	return setmetatable(node, TestNode)
 136 | end
 137 | 
 138 | local function getModifier(name, pattern, modifier)
 139 | 	if pattern and (modifier == nil or modifier == TestEnum.NodeModifier.None) then
 140 | 		if name:match(pattern) then
 141 | 			return TestEnum.NodeModifier.Focus
 142 | 		else
 143 | 			return TestEnum.NodeModifier.Skip
 144 | 		end
 145 | 	end
 146 | 	return modifier
 147 | end
 148 | 
 149 | function TestNode:addChild(phrase, nodeType, nodeModifier)
 150 | 	if nodeType == TestEnum.NodeType.It then
 151 | 		for _, child in pairs(self.children) do
 152 | 			if child.phrase == phrase then
 153 | 				error("Duplicate it block found: " .. child:getFullName())
 154 | 			end
 155 | 		end
 156 | 	end
 157 | 
 158 | 	local childName = self:getFullName() .. " " .. phrase
 159 | 	nodeModifier = getModifier(childName, self.plan.testNamePattern, nodeModifier)
 160 | 	local child = TestNode.new(self.plan, phrase, nodeType, nodeModifier)
 161 | 	child.parent = self
 162 | 	table.insert(self.children, child)
 163 | 	return child
 164 | end
 165 | 
 166 | --[[
 167 | 	Join the names of all the nodes back to the parent.
 168 | ]]
 169 | function TestNode:getFullName()
 170 | 	if self.parent then
 171 | 		local parentPhrase = self.parent:getFullName()
 172 | 		if parentPhrase then
 173 | 			return parentPhrase .. " " .. self.phrase
 174 | 		end
 175 | 	end
 176 | 	return self.phrase
 177 | end
 178 | 
 179 | --[[
 180 | 	Expand a node by setting its callback environment and then calling it. Any
 181 | 	further it and describe calls within the callback will be added to the tree.
 182 | ]]
 183 | function TestNode:expand()
 184 | 	local originalEnv = getfenv(self.callback)
 185 | 	local callbackEnv = setmetatable({}, { __index = originalEnv })
 186 | 	for key, value in pairs(self.environment) do
 187 | 		callbackEnv[key] = value
 188 | 	end
 189 | 	setfenv(self.callback, callbackEnv)
 190 | 
 191 | 	local success, result = xpcall(self.callback, debug.traceback)
 192 | 
 193 | 	if not success then
 194 | 		self.loadError = result
 195 | 	end
 196 | end
 197 | 
 198 | local TestPlan = {}
 199 | TestPlan.__index = TestPlan
 200 | 
 201 | --[[
 202 | 	Create a new, empty TestPlan.
 203 | ]]
 204 | function TestPlan.new(testNamePattern, extraEnvironment)
 205 | 	local plan = {
 206 | 		children = {},
 207 | 		testNamePattern = testNamePattern,
 208 | 		extraEnvironment = extraEnvironment,
 209 | 	}
 210 | 
 211 | 	return setmetatable(plan, TestPlan)
 212 | end
 213 | 
 214 | --[[
 215 | 	Add a new child under the test plan's root node.
 216 | ]]
 217 | function TestPlan:addChild(phrase, nodeType, nodeModifier)
 218 | 	nodeModifier = getModifier(phrase, self.testNamePattern, nodeModifier)
 219 | 	local child = TestNode.new(self, phrase, nodeType, nodeModifier)
 220 | 	table.insert(self.children, child)
 221 | 	return child
 222 | end
 223 | 
 224 | --[[
 225 | 	Add a new describe node with the given method as a callback. Generates or
 226 | 	reuses all the describe nodes along the path.
 227 | ]]
 228 | function TestPlan:addRoot(path, method)
 229 | 	local curNode = self
 230 | 	for i = #path, 1, -1 do
 231 | 		local nextNode = nil
 232 | 
 233 | 		for _, child in ipairs(curNode.children) do
 234 | 			if child.phrase == path[i] then
 235 | 				nextNode = child
 236 | 				break
 237 | 			end
 238 | 		end
 239 | 
 240 | 		if nextNode == nil then
 241 | 			nextNode = curNode:addChild(path[i], TestEnum.NodeType.Describe)
 242 | 		end
 243 | 
 244 | 		curNode = nextNode
 245 | 	end
 246 | 
 247 | 	curNode.callback = method
 248 | 	curNode:expand()
 249 | end
 250 | 
 251 | --[[
 252 | 	Calls the given callback on all nodes in the tree, traversed depth-first.
 253 | ]]
 254 | function TestPlan:visitAllNodes(callback, root, level)
 255 | 	root = root or self
 256 | 	level = level or 0
 257 | 
 258 | 	for _, child in ipairs(root.children) do
 259 | 		callback(child, level)
 260 | 
 261 | 		self:visitAllNodes(callback, child, level + 1)
 262 | 	end
 263 | end
 264 | 
 265 | --[[
 266 | 	Visualizes the test plan in a simple format, suitable for debugging the test
 267 | 	plan's structure.
 268 | ]]
 269 | function TestPlan:visualize()
 270 | 	local buffer = {}
 271 | 	self:visitAllNodes(function(node, level)
 272 | 		table.insert(buffer, (" "):rep(3 * level) .. node.phrase)
 273 | 	end)
 274 | 	return table.concat(buffer, "\n")
 275 | end
 276 | 
 277 | --[[
 278 | 	Gets a list of all nodes in the tree for which the given callback returns
 279 | 	true.
 280 | ]]
 281 | function TestPlan:findNodes(callback)
 282 | 	local results = {}
 283 | 	self:visitAllNodes(function(node)
 284 | 		if callback(node) then
 285 | 			table.insert(results, node)
 286 | 		end
 287 | 	end)
 288 | 	return results
 289 | end
 290 | 
 291 | return TestPlan
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/src/TestPlanner.lua`
<details>
<summary>View Source (39 lines)</summary>

```lua
   1 | --[[
   2 | 	Turns a series of specification functions into a test plan.
   3 | 
   4 | 	Uses a TestPlanBuilder to keep track of the state of the tree being built.
   5 | ]]
   6 | local TestPlan = require(script.Parent.TestPlan)
   7 | 
   8 | local TestPlanner = {}
   9 | 
  10 | --[[
  11 | 	Create a new TestPlan from a list of specification functions.
  12 | 
  13 | 	These functions should call a combination of `describe` and `it` (and their
  14 | 	variants), which will be turned into a test plan to be executed.
  15 | 
  16 | 	Parameters:
  17 | 		- modulesList - list of tables describing test modules {
  18 | 			method, -- specification function described above
  19 | 			path, -- array of parent entires, first element is the leaf that owns `method`
  20 | 			pathStringForSorting -- a string representation of `path`, used for sorting of the test plan
  21 | 		}
  22 | 		- testNamePattern - Only tests matching this Lua pattern string will run. Pass empty or nil to run all tests
  23 | 		- extraEnvironment - Lua table holding additional functions and variables to be injected into the specification
  24 | 							function during execution
  25 | ]]
  26 | function TestPlanner.createPlan(modulesList, testNamePattern, extraEnvironment)
  27 | 	local plan = TestPlan.new(testNamePattern, extraEnvironment)
  28 | 
  29 | 	table.sort(modulesList, function(a, b)
  30 | 		return a.pathStringForSorting < b.pathStringForSorting
  31 | 	end)
  32 | 
  33 | 	for _, module in ipairs(modulesList) do
  34 | 		plan:addRoot(module.path, module.method)
  35 | 	end
  36 | 
  37 | 	return plan
  38 | end
  39 | 
  40 | return TestPlanner
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/src/TestResults.lua`
<details>
<summary>View Source (111 lines)</summary>

```lua
   1 | --[[
   2 | 	Represents a tree of test results.
   3 | 
   4 | 	Each node in the tree corresponds directly to a node in a corresponding
   5 | 	TestPlan, accessible via the 'planNode' field.
   6 | 
   7 | 	TestResults objects are produced by TestRunner using TestSession as state.
   8 | ]]
   9 | 
  10 | local TestEnum = require(script.Parent.TestEnum)
  11 | 
  12 | local STATUS_SYMBOLS = {
  13 | 	[TestEnum.TestStatus.Success] = "+",
  14 | 	[TestEnum.TestStatus.Failure] = "-",
  15 | 	[TestEnum.TestStatus.Skipped] = "~"
  16 | }
  17 | 
  18 | local TestResults = {}
  19 | 
  20 | TestResults.__index = TestResults
  21 | 
  22 | --[[
  23 | 	Create a new TestResults tree that's linked to the given TestPlan.
  24 | ]]
  25 | function TestResults.new(plan)
  26 | 	local self = {
  27 | 		successCount = 0,
  28 | 		failureCount = 0,
  29 | 		skippedCount = 0,
  30 | 		planNode = plan,
  31 | 		children = {},
  32 | 		errors = {}
  33 | 	}
  34 | 
  35 | 	setmetatable(self, TestResults)
  36 | 
  37 | 	return self
  38 | end
  39 | 
  40 | --[[
  41 | 	Create a new result node that can be inserted into a TestResult tree.
  42 | ]]
  43 | function TestResults.createNode(planNode)
  44 | 	local node = {
  45 | 		planNode = planNode,
  46 | 		children = {},
  47 | 		errors = {},
  48 | 		status = nil
  49 | 	}
  50 | 
  51 | 	return node
  52 | end
  53 | 
  54 | --[[
  55 | 	Visit all test result nodes, depth-first.
  56 | ]]
  57 | function TestResults:visitAllNodes(callback, root)
  58 | 	root = root or self
  59 | 
  60 | 	for _, child in ipairs(root.children) do
  61 | 		callback(child)
  62 | 
  63 | 		self:visitAllNodes(callback, child)
  64 | 	end
  65 | end
  66 | 
  67 | --[[
  68 | 	Creates a debug visualization of the test results.
  69 | ]]
  70 | function TestResults:visualize(root, level)
  71 | 	root = root or self
  72 | 	level = level or 0
  73 | 
  74 | 	local buffer = {}
  75 | 
  76 | 	for _, child in ipairs(root.children) do
  77 | 		if child.planNode.type == TestEnum.NodeType.It then
  78 | 			local symbol = STATUS_SYMBOLS[child.status] or "?"
  79 | 			local str = ("%s[%s] %s"):format(
  80 | 				(" "):rep(3 * level),
  81 | 				symbol,
  82 | 				child.planNode.phrase
  83 | 			)
  84 | 
  85 | 			if child.messages and #child.messages > 0 then
  86 | 				str = str .. "\n " .. (" "):rep(3 * level) .. table.concat(child.messages, "\n " .. (" "):rep(3 * level))
  87 | 			end
  88 | 
  89 | 			table.insert(buffer, str)
  90 | 		else
  91 | 			local str = ("%s%s"):format(
  92 | 				(" "):rep(3 * level),
  93 | 				child.planNode.phrase or ""
  94 | 			)
  95 | 
  96 | 			if child.status then
  97 | 				str = str .. (" (%s)"):format(child.status)
  98 | 			end
  99 | 
 100 | 			table.insert(buffer, str)
 101 | 
 102 | 			if #child.children > 0 then
 103 | 				local text = self:visualize(child, level + 1)
 104 | 				table.insert(buffer, text)
 105 | 			end
 106 | 		end
 107 | 	end
 108 | 
 109 | 	return table.concat(buffer, "\n")
 110 | end
 111 | 
 112 | return TestResults
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/src/TestRunner.lua`
<details>
<summary>View Source (176 lines)</summary>

```lua
   1 | --[[
   2 | 	Contains the logic to run a test plan and gather test results from it.
   3 | 
   4 | 	TestRunner accepts a TestPlan object, executes the planned tests, and
   5 | 	produces a TestResults object. While the tests are running, the system's
   6 | 	state is contained inside a TestSession object.
   7 | ]]
   8 | 
   9 | local Expectation = require(script.Parent.Expectation)
  10 | local TestEnum = require(script.Parent.TestEnum)
  11 | local TestSession = require(script.Parent.TestSession)
  12 | local LifecycleHooks = require(script.Parent.LifecycleHooks)
  13 | 
  14 | local RUNNING_GLOBAL = "__TESTEZ_RUNNING_TEST__"
  15 | 
  16 | local TestRunner = {
  17 | 	environment = {}
  18 | }
  19 | 
  20 | function TestRunner.environment.expect(...)
  21 | 	return Expectation.new(...)
  22 | end
  23 | 
  24 | --[[
  25 | 	Runs the given TestPlan and returns a TestResults object representing the
  26 | 	results of the run.
  27 | ]]
  28 | function TestRunner.runPlan(plan)
  29 | 	local session = TestSession.new(plan)
  30 | 	local lifecycleHooks = LifecycleHooks.new()
  31 | 
  32 | 	local exclusiveNodes = plan:findNodes(function(node)
  33 | 		return node.modifier == TestEnum.NodeModifier.Focus
  34 | 	end)
  35 | 
  36 | 	session.hasFocusNodes = #exclusiveNodes > 0
  37 | 
  38 | 	TestRunner.runPlanNode(session, plan, lifecycleHooks)
  39 | 
  40 | 	return session:finalize()
  41 | end
  42 | 
  43 | --[[
  44 | 	Run the given test plan node and its descendants, using the given test
  45 | 	session to store all of the results.
  46 | ]]
  47 | function TestRunner.runPlanNode(session, planNode, lifecycleHooks)
  48 | 	local function runCallback(callback, messagePrefix)
  49 | 		local success = true
  50 | 		local errorMessage
  51 | 		-- Any code can check RUNNING_GLOBAL to fork behavior based on
  52 | 		-- whether a test is running. We use this to avoid accessing
  53 | 		-- protected APIs; it's a workaround that will go away someday.
  54 | 		_G[RUNNING_GLOBAL] = true
  55 | 
  56 | 		messagePrefix = messagePrefix or ""
  57 | 
  58 | 		local testEnvironment = getfenv(callback)
  59 | 
  60 | 		for key, value in pairs(TestRunner.environment) do
  61 | 			testEnvironment[key] = value
  62 | 		end
  63 | 
  64 | 		testEnvironment.fail = function(message)
  65 | 			if message == nil then
  66 | 				message = "fail() was called."
  67 | 			end
  68 | 
  69 | 			success = false
  70 | 			errorMessage = messagePrefix .. message .. "\n" .. debug.traceback()
  71 | 		end
  72 | 
  73 | 		local context = session:getContext()
  74 | 
  75 | 		local nodeSuccess, nodeResult = xpcall(
  76 | 			function()
  77 | 				callback(context)
  78 | 			end,
  79 | 			function(message)
  80 | 				return messagePrefix .. message .. "\n" .. debug.traceback()
  81 | 			end
  82 | 		)
  83 | 
  84 | 		-- If a node threw an error, we prefer to use that message over
  85 | 		-- one created by fail() if it was set.
  86 | 		if not nodeSuccess then
  87 | 			success = false
  88 | 			errorMessage = nodeResult
  89 | 		end
  90 | 
  91 | 		_G[RUNNING_GLOBAL] = nil
  92 | 
  93 | 		return success, errorMessage
  94 | 	end
  95 | 
  96 | 	local function runNode(childPlanNode)
  97 | 		-- Errors can be set either via `error` propagating upwards or
  98 | 		-- by a test calling fail([message]).
  99 | 
 100 | 		for _, hook in ipairs(lifecycleHooks:getBeforeEachHooks()) do
 101 | 			local success, errorMessage = runCallback(hook, "beforeEach hook: ")
 102 | 			if not success then
 103 | 				return false, errorMessage
 104 | 			end
 105 | 		end
 106 | 
 107 | 		do
 108 | 			local success, errorMessage = runCallback(childPlanNode.callback)
 109 | 			if not success then
 110 | 				return false, errorMessage
 111 | 			end
 112 | 		end
 113 | 
 114 | 		for _, hook in ipairs(lifecycleHooks:getAfterEachHooks()) do
 115 | 			local success, errorMessage = runCallback(hook, "afterEach hook: ")
 116 | 			if not success then
 117 | 				return false, errorMessage
 118 | 			end
 119 | 		end
 120 | 
 121 | 		return true, nil
 122 | 	end
 123 | 
 124 | 	lifecycleHooks:pushHooksFrom(planNode)
 125 | 
 126 | 	local halt = false
 127 | 	for _, hook in ipairs(lifecycleHooks:getBeforeAllHooks()) do
 128 | 		local success, errorMessage = runCallback(hook, "beforeAll hook: ")
 129 | 		if not success then
 130 | 			session:addDummyError("beforeAll", errorMessage)
 131 | 			halt = true
 132 | 		end
 133 | 	end
 134 | 
 135 | 	if not halt then
 136 | 		for _, childPlanNode in ipairs(planNode.children) do
 137 | 			session:pushNode(childPlanNode)
 138 | 
 139 | 			if childPlanNode.type == TestEnum.NodeType.It then
 140 | 				if session:shouldSkip() then
 141 | 					session:setSkipped()
 142 | 				else
 143 | 					local success, errorMessage = runNode(childPlanNode)
 144 | 
 145 | 					if success then
 146 | 						session:setSuccess()
 147 | 					else
 148 | 						session:setError(errorMessage)
 149 | 					end
 150 | 				end
 151 | 			elseif childPlanNode.type == TestEnum.NodeType.Describe then
 152 | 				TestRunner.runPlanNode(session, childPlanNode, lifecycleHooks)
 153 | 
 154 | 				-- Did we have an error trying build a test plan?
 155 | 				if childPlanNode.loadError then
 156 | 					local message = "Error during planning: " .. childPlanNode.loadError
 157 | 					session:setError(message)
 158 | 				else
 159 | 					session:setStatusFromChildren()
 160 | 				end
 161 | 			end
 162 | 
 163 | 			session:popNode()
 164 | 		end
 165 | 	end
 166 | 
 167 | 	for _, hook in ipairs(lifecycleHooks:getAfterAllHooks()) do
 168 | 		local success, errorMessage = runCallback(hook, "afterAll hook: ")
 169 | 		if not success then
 170 | 			session:addDummyError("afterAll", errorMessage)
 171 | 		end
 172 | 	end
 173 | 
 174 | 	lifecycleHooks:popHooks()
 175 | end
 176 | 
 177 | return TestRunner
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/src/TestSession.lua`
<details>
<summary>View Source (230 lines)</summary>

```lua
   1 | --[[
   2 | 	Represents the state relevant while executing a test plan.
   3 | 
   4 | 	Used by TestRunner to produce a TestResults object.
   5 | 
   6 | 	Uses the same tree building structure as TestPlanBuilder; TestSession keeps
   7 | 	track of a stack of nodes that represent the current path through the tree.
   8 | ]]
   9 | 
  10 | local TestEnum = require(script.Parent.TestEnum)
  11 | local TestResults = require(script.Parent.TestResults)
  12 | local Context = require(script.Parent.Context)
  13 | 
  14 | local TestSession = {}
  15 | 
  16 | TestSession.__index = TestSession
  17 | 
  18 | --[[
  19 | 	Create a TestSession related to the given TestPlan.
  20 | 
  21 | 	The resulting TestResults object will be linked to this TestPlan.
  22 | ]]
  23 | function TestSession.new(plan)
  24 | 	local self = {
  25 | 		results = TestResults.new(plan),
  26 | 		nodeStack = {},
  27 | 		contextStack = {},
  28 | 		hasFocusNodes = false
  29 | 	}
  30 | 
  31 | 	setmetatable(self, TestSession)
  32 | 
  33 | 	return self
  34 | end
  35 | 
  36 | --[[
  37 | 	Calculate success, failure, and skipped test counts in the tree at the
  38 | 	current point in the execution.
  39 | ]]
  40 | function TestSession:calculateTotals()
  41 | 	local results = self.results
  42 | 
  43 | 	results.successCount = 0
  44 | 	results.failureCount = 0
  45 | 	results.skippedCount = 0
  46 | 
  47 | 	results:visitAllNodes(function(node)
  48 | 		local status = node.status
  49 | 		local nodeType = node.planNode.type
  50 | 
  51 | 		if nodeType == TestEnum.NodeType.It then
  52 | 			if status == TestEnum.TestStatus.Success then
  53 | 				results.successCount = results.successCount + 1
  54 | 			elseif status == TestEnum.TestStatus.Failure then
  55 | 				results.failureCount = results.failureCount + 1
  56 | 			elseif status == TestEnum.TestStatus.Skipped then
  57 | 				results.skippedCount = results.skippedCount + 1
  58 | 			end
  59 | 		end
  60 | 	end)
  61 | end
  62 | 
  63 | --[[
  64 | 	Gathers all of the errors reported by tests and puts them at the top level
  65 | 	of the TestResults object.
  66 | ]]
  67 | function TestSession:gatherErrors()
  68 | 	local results = self.results
  69 | 
  70 | 	results.errors = {}
  71 | 
  72 | 	results:visitAllNodes(function(node)
  73 | 		if #node.errors > 0 then
  74 | 			for _, message in ipairs(node.errors) do
  75 | 				table.insert(results.errors, message)
  76 | 			end
  77 | 		end
  78 | 	end)
  79 | end
  80 | 
  81 | --[[
  82 | 	Calculates test totals, verifies the tree is valid, and returns results.
  83 | ]]
  84 | function TestSession:finalize()
  85 | 	if #self.nodeStack ~= 0 then
  86 | 		error("Cannot finalize TestResults with nodes still on the stack!", 2)
  87 | 	end
  88 | 
  89 | 	self:calculateTotals()
  90 | 	self:gatherErrors()
  91 | 
  92 | 	return self.results
  93 | end
  94 | 
  95 | --[[
  96 | 	Create a new test result node and push it onto the navigation stack.
  97 | ]]
  98 | function TestSession:pushNode(planNode)
  99 | 	local node = TestResults.createNode(planNode)
 100 | 	local lastNode = self.nodeStack[#self.nodeStack] or self.results
 101 | 	local lastContext = self.contextStack[#self.contextStack]
 102 | 	local context = Context.new(lastContext)
 103 | 
 104 | 	table.insert(lastNode.children, node)
 105 | 	table.insert(self.nodeStack, node)
 106 | 	table.insert(self.contextStack, context)
 107 | end
 108 | 
 109 | --[[
 110 | 	Pops a node off of the navigation stack.
 111 | ]]
 112 | function TestSession:popNode()
 113 | 	assert(#self.nodeStack > 0, "Tried to pop from an empty node stack!")
 114 | 	table.remove(self.nodeStack, #self.nodeStack)
 115 | 	table.remove(self.contextStack, #self.contextStack)
 116 | end
 117 | 
 118 | --[[
 119 | 	Gets the Context object for the current node.
 120 | ]]
 121 | function TestSession:getContext()
 122 | 	assert(#self.contextStack > 0, "Tried to get context from an empty stack!")
 123 | 	return self.contextStack[#self.contextStack]
 124 | end
 125 | 
 126 | --[[
 127 | 	Tells whether the current test we're in should be skipped.
 128 | ]]
 129 | function TestSession:shouldSkip()
 130 | 	-- If our test tree had any exclusive tests, then normal tests are skipped!
 131 | 	if self.hasFocusNodes then
 132 | 		for i = #self.nodeStack, 1, -1 do
 133 | 			local node = self.nodeStack[i]
 134 | 
 135 | 			-- Skipped tests are still skipped
 136 | 			if node.planNode.modifier == TestEnum.NodeModifier.Skip then
 137 | 				return true
 138 | 			end
 139 | 
 140 | 			-- Focused tests are the only ones that aren't skipped
 141 | 			if node.planNode.modifier == TestEnum.NodeModifier.Focus then
 142 | 				return false
 143 | 			end
 144 | 		end
 145 | 
 146 | 		return true
 147 | 	else
 148 | 		for i = #self.nodeStack, 1, -1 do
 149 | 			local node = self.nodeStack[i]
 150 | 
 151 | 			if node.planNode.modifier == TestEnum.NodeModifier.Skip then
 152 | 				return true
 153 | 			end
 154 | 		end
 155 | 	end
 156 | 
 157 | 	return false
 158 | end
 159 | 
 160 | --[[
 161 | 	Set the current node's status to Success.
 162 | ]]
 163 | function TestSession:setSuccess()
 164 | 	assert(#self.nodeStack > 0, "Attempting to set success status on empty stack")
 165 | 	self.nodeStack[#self.nodeStack].status = TestEnum.TestStatus.Success
 166 | end
 167 | 
 168 | --[[
 169 | 	Set the current node's status to Skipped.
 170 | ]]
 171 | function TestSession:setSkipped()
 172 | 	assert(#self.nodeStack > 0, "Attempting to set skipped status on empty stack")
 173 | 	self.nodeStack[#self.nodeStack].status = TestEnum.TestStatus.Skipped
 174 | end
 175 | 
 176 | --[[
 177 | 	Set the current node's status to Failure and adds a message to its list of
 178 | 	errors.
 179 | ]]
 180 | function TestSession:setError(message)
 181 | 	assert(#self.nodeStack > 0, "Attempting to set error status on empty stack")
 182 | 	local last = self.nodeStack[#self.nodeStack]
 183 | 	last.status = TestEnum.TestStatus.Failure
 184 | 	table.insert(last.errors, message)
 185 | end
 186 | 
 187 | --[[
 188 | 	Add a dummy child node to the current node to hold the given error. This
 189 | 	allows an otherwise empty describe node to report an error in a more natural
 190 | 	way.
 191 | ]]
 192 | function TestSession:addDummyError(phrase, message)
 193 | 	self:pushNode({type = TestEnum.NodeType.It, phrase = phrase})
 194 | 	self:setError(message)
 195 | 	self:popNode()
 196 | 	self.nodeStack[#self.nodeStack].status = TestEnum.TestStatus.Failure
 197 | end
 198 | 
 199 | --[[
 200 | 	Set the current node's status based on that of its children. If all children
 201 | 	are skipped, mark it as skipped. If any are fails, mark it as failed.
 202 | 	Otherwise, mark it as success.
 203 | ]]
 204 | function TestSession:setStatusFromChildren()
 205 | 	assert(#self.nodeStack > 0, "Attempting to set status from children on empty stack")
 206 | 
 207 | 	local last = self.nodeStack[#self.nodeStack]
 208 | 	local status = TestEnum.TestStatus.Success
 209 | 	local skipped = true
 210 | 
 211 | 	-- If all children were skipped, then we were skipped
 212 | 	-- If any child failed, then we failed!
 213 | 	for _, child in ipairs(last.children) do
 214 | 		if child.status ~= TestEnum.TestStatus.Skipped then
 215 | 			skipped = false
 216 | 
 217 | 			if child.status == TestEnum.TestStatus.Failure then
 218 | 				status = TestEnum.TestStatus.Failure
 219 | 			end
 220 | 		end
 221 | 	end
 222 | 
 223 | 	if skipped then
 224 | 		status = TestEnum.TestStatus.Skipped
 225 | 	end
 226 | 
 227 | 	last.status = status
 228 | end
 229 | 
 230 | return TestSession
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/test/lemur.lua`
<details>
<summary>View Source (31 lines)</summary>

```lua
   1 | --[[
   2 | 	Loads TestEZ and all of its dependencies, then runs our test entrypoint.
   3 | ]]
   4 | 
   5 | -- If you add any dependencies, add them to this table so they'll be loaded!
   6 | local LOAD_MODULES = {
   7 | 	{"src", "TestEZ"},
   8 | 	{"tests", "TestEZTests"},
   9 | }
  10 | 
  11 | -- This makes sure we can load Lemur and other libraries that depend on init.lua
  12 | package.path = package.path .. ";?/init.lua"
  13 | 
  14 | -- If this fails, make sure you've cloned all Git submodules of this repo!
  15 | local lemur = require("modules.lemur")
  16 | 
  17 | -- Create a virtual Roblox tree
  18 | local habitat = lemur.Habitat.new()
  19 | 
  20 | -- We'll put all of our library code and dependencies here
  21 | local ReplicatedStorage = habitat.game:GetService("ReplicatedStorage")
  22 | 
  23 | -- Load all of the modules specified above
  24 | for _, module in ipairs(LOAD_MODULES) do
  25 | 	local container = habitat:loadFromFs(module[1])
  26 | 	container.Name = module[2]
  27 | 	container.Parent = ReplicatedStorage
  28 | end
  29 | 
  30 | -- When Lemur implements a proper scheduling interface, we'll use that instead.
  31 | local runTests = habitat:loadFromFs("test/runner.server.lua")
  32 | habitat:require(runTests)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/test/runner.server.lua`
<details>
<summary>View Source (95 lines)</summary>

```lua
   1 | --[[
   2 | 	This test runner is invoked in all the environments that we want to test our
   3 | 	library in.
   4 | 
   5 | 	We target Lemur, Roblox Studio, and Roblox-CLI.
   6 | ]]
   7 | 
   8 | -- luacheck: globals __LEMUR__
   9 | 
  10 | local isRobloxCli, ProcessService = pcall(game.GetService, game, "ProcessService")
  11 | 
  12 | local function findUnitTests(container, foundTests)
  13 | 	foundTests = foundTests or {}
  14 | 
  15 | 	for _, child in ipairs(container:GetChildren()) do
  16 | 		if child:IsA("ModuleScript") then
  17 | 			table.insert(foundTests, child)
  18 | 		end
  19 | 	end
  20 | 
  21 | 	return foundTests
  22 | end
  23 | 
  24 | local completed, result = xpcall(function()
  25 | 	local ReplicatedStorage = game:GetService("ReplicatedStorage")
  26 | 
  27 | 	local testModules = findUnitTests(ReplicatedStorage.TestEZTests)
  28 | 
  29 | 	local totalCount = 0
  30 | 	local failureCount = 0
  31 | 	local successCount = 0
  32 | 	local errorMessages = {}
  33 | 
  34 | 	for _, testModule in ipairs(testModules) do
  35 | 		local tests = require(testModule)
  36 | 
  37 | 		print(string.format("%s", testModule.Name))
  38 | 
  39 | 		for testName, testFunction in pairs(tests) do
  40 | 			local success, message = pcall(testFunction)
  41 | 			totalCount = totalCount + 1
  42 | 
  43 | 			if success then
  44 | 				print(string.format("  [PASS] %s", testName))
  45 | 				successCount = successCount + 1
  46 | 			else
  47 | 				print(string.format("  [FAIL] %s", testName))
  48 | 				failureCount = failureCount + 1
  49 | 
  50 | 				local logMessage = string.format("Test: %s\nError: %s", testName, message)
  51 | 				table.insert(errorMessages, logMessage)
  52 | 			end
  53 | 		end
  54 | 	end
  55 | 
  56 | 	print()
  57 | 	print(string.format("%s tests run: %s passed, %s failed", totalCount, successCount, failureCount))
  58 | 
  59 | 	if #errorMessages > 0 then
  60 | 		print()
  61 | 		print(table.concat(errorMessages, "\n\n"))
  62 | 	end
  63 | 
  64 | 	return failureCount == 0 and 0 or 1
  65 | end, debug.traceback)
  66 | 
  67 | local statusCode
  68 | local errorMessage = nil
  69 | if completed then
  70 | 	statusCode = result
  71 | else
  72 | 	statusCode = 1
  73 | 	errorMessage = result
  74 | end
  75 | 
  76 | if __LEMUR__ then
  77 | 	-- Lemur has access to normal Lua OS APIs
  78 | 
  79 | 	if errorMessage ~= nil then
  80 | 		print(errorMessage)
  81 | 	end
  82 | 	os.exit(statusCode)
  83 | elseif isRobloxCli then
  84 | 	-- Roblox CLI has a special service to terminate the process
  85 | 
  86 | 	if errorMessage ~= nil then
  87 | 		print(errorMessage)
  88 | 	end
  89 | 	ProcessService:Exit(statusCode)
  90 | else
  91 | 	-- In Studio, we can just throw an error to get the user's attention
  92 | 
  93 | 	if errorMessage ~= nil then
  94 | 		error(errorMessage, 0)
  95 | 	end
  96 | end
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/testez-cli/src/lemur-entry.lua`
<details>
<summary>View Source (48 lines)</summary>

```lua
   1 | -- This module has variables preprended to it by the TestEZ CLI that inform it
   2 | -- what modules need to be loaded.
   3 | 
   4 | -- luacheck: globals RUNNER_PATH TESTEZ_PATH SRC_PATH DEPS
   5 | 
   6 | assert(type(RUNNER_PATH) == "string")
   7 | assert(type(TESTEZ_PATH) == "string")
   8 | assert(type(SRC_PATH) == "string")
   9 | assert(type(DEPS) == "table" or DEPS == nil)
  10 | 
  11 | local lemur = require("lemur")
  12 | 
  13 | local habitat = lemur.Habitat.new()
  14 | 
  15 | local ReplicatedStorage = habitat.game:GetService("ReplicatedStorage")
  16 | 
  17 | local testRunner = habitat:loadFromFs(RUNNER_PATH)
  18 | testRunner.Name = "TestRunner"
  19 | testRunner.Parent = ReplicatedStorage
  20 | 
  21 | local testez = habitat:loadFromFs(TESTEZ_PATH)
  22 | testez.Name = "TestEZ"
  23 | testez.Parent = testRunner
  24 | 
  25 | local source = habitat:loadFromFs(SRC_PATH)
  26 | -- TODO: Library name?
  27 | source.Parent = ReplicatedStorage
  28 | 
  29 | _G.TESTEZ_TEST_CONTAINERS = { source }
  30 | 
  31 | if DEPS ~= nil then
  32 | 	if DEPS.kind == "rotriever" then
  33 | 		local packages = habitat:loadFromFs(DEPS.packagesPath)
  34 | 
  35 | 		for _, dir in ipairs(packages:GetChildren()) do
  36 | 			dir.Parent = ReplicatedStorage
  37 | 		end
  38 | 	elseif DEPS.kind == "git-submodules" then
  39 | 		for _, dep in ipairs(DEPS.modules) do
  40 | 			local container = habitat:loadFromFs(dep[1])
  41 | 			container.Name = dep[2]
  42 | 			container.Parent = ReplicatedStorage
  43 | 		end
  44 | 	else
  45 | 		error(string.format("Unsupported dependency list kind %q", tostring(DEPS.kind)))
  46 | 	end
  47 | end
  48 | 
  49 | habitat:require(testRunner)
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/testez-cli/src/test-runner.lua`
<details>
<summary>View Source (80 lines)</summary>

```lua
   1 | --[[
   2 | 	This test runner is invoked in all the environments that we want to test our
   3 | 	project in.
   4 | 
   5 | 	TestEZ's CLI targets Lemur, Roblox Studio, and Roblox-CLI.
   6 | 
   7 | 	Assumes TestEZ is put into ReplicatedStorage and that test roots have a
   8 | 	"TestEZTestRoot" CollectionService tag attached to them.
   9 | ]]
  10 | 
  11 | -- luacheck: globals game script __LEMUR__
  12 | 
  13 | local TEST_CONTAINER_TAG = "TestEZTestRoot"
  14 | 
  15 | local hasCollectionService, CollectionService = pcall(game.GetService, game, "CollectionService")
  16 | 
  17 | -- ProcessService only exists when running under Roblox-CLI.
  18 | local isRobloxCli, ProcessService = pcall(game.GetService, game, "ProcessService")
  19 | 
  20 | local platform = {}
  21 | 
  22 | if __LEMUR__ then
  23 | 	platform.exit = os.exit
  24 | 
  25 | 	platform.error = function(message)
  26 | 		print(message)
  27 | 		platform.exit(1)
  28 | 	end
  29 | elseif isRobloxCli then
  30 | 	platform.exit = function(statusCode)
  31 | 		ProcessService:Exit(statusCode)
  32 | 	end
  33 | 
  34 | 	platform.error = function(message)
  35 | 		print(message)
  36 | 		platform.exit(1)
  37 | 	end
  38 | else
  39 | 	platform.exit = function() end
  40 | 
  41 | 	platform.error = function(message)
  42 | 		error(message, 0)
  43 | 	end
  44 | end
  45 | 
  46 | local completed, suitePassed = xpcall(function()
  47 | 	local TestEZ = require(script.TestEZ)
  48 | 
  49 | 	local testContainers
  50 | 	if hasCollectionService then
  51 | 		testContainers = CollectionService:GetTagged(TEST_CONTAINER_TAG)
  52 | 	else
  53 | 		testContainers = _G.TESTEZ_TEST_CONTAINERS
  54 | 	end
  55 | 
  56 | 	if #testContainers == 0 then
  57 | 		print(string.format(
  58 | 			"No tests found. Did you give them the CollectionService tag %q?",
  59 | 			TEST_CONTAINER_TAG
  60 | 		))
  61 | 
  62 | 		return true
  63 | 	end
  64 | 
  65 | 	local testResults = TestEZ.TestBootstrap:run(
  66 | 		testContainers,
  67 | 		TestEZ.Reporters.TextReporter
  68 | 	)
  69 | 
  70 | 	return testResults.failureCount == 0
  71 | end, debug.traceback)
  72 | 
  73 | if completed then
  74 | 	if suitePassed then
  75 | 		platform.exit(0)
  76 | 	else
  77 | 		platform.exit(1)
  78 | 	end
  79 | else
  80 | 	platform.error(suitePassed)
  81 | end
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/tests/api.lua`
<details>
<summary>View Source (7 lines)</summary>

```lua
   1 | local TestEZ = require(script.Parent.Parent.TestEZ)
   2 | 
   3 | return {
   4 | 	function()
   5 | 		assert(typeof(TestEZ) == "table")
   6 | 		assert(typeof(TestEZ.run) == "function")
   7 | 	end,
   8 | }
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/tests/Context.lua`
<details>
<summary>View Source (56 lines)</summary>

```lua
   1 | local TestEZ = script.Parent.Parent.TestEZ
   2 | local Context = require(TestEZ.Context)
   3 | 
   4 | return {
   5 | 	["Context.new returns a new context"] = function()
   6 | 		assert(Context.new(), "Context.new() returned nil")
   7 | 	end,
   8 | 	["context.foo returns nil if it wasn't set"] = function()
   9 | 		local context = Context.new()
  10 | 		assert(context.foo == nil, string.format("Got %s, expected nil", tostring(context.foo)))
  11 | 	end,
  12 | 	["context.foo returns the value from setting context.foo"] = function()
  13 | 		local context = Context.new()
  14 | 		context.foo = "BAR"
  15 | 		assert(context.foo == "BAR", string.format("Got %s, expected BAR", tostring(context.foo)))
  16 | 	end,
  17 | 	["context.foo can't be set twice"] = function()
  18 | 		local context = Context.new()
  19 | 		context.foo = "foo"
  20 | 		local success, _ = pcall(function()
  21 | 			context.foo = "bar"
  22 | 		end)
  23 | 		assert(not success, "Expected second context.foo to error")
  24 | 	end,
  25 | 	["Context.new accepts a parent"] = function()
  26 | 		local parent = Context.new()
  27 | 		assert(Context.new(parent), "Context.new(parent) returned nil")
  28 | 	end,
  29 | 	["A child context can still read its parent values"] = function()
  30 | 		local parent = Context.new()
  31 | 		parent.foo = "BAR"
  32 | 		local child = Context.new(parent)
  33 | 		assert(child.foo == "BAR", string.format("Got %s, expected BAR", tostring(child.foo)))
  34 | 	end,
  35 | 	["A parent context can't read its child values"] = function()
  36 | 		local parent = Context.new()
  37 | 		local child = Context.new(parent)
  38 | 		child.foo = "BAR"
  39 | 		assert(parent.foo == nil, string.format("Got %s, expected nil", tostring(parent.foo)))
  40 | 	end,
  41 | 	["A child can't overwrite parent values"] = function()
  42 | 		local parent = Context.new()
  43 | 		parent.foo = "foo"
  44 | 		local child = Context.new(parent)
  45 | 		local success, _ = pcall(function()
  46 | 			child.foo = "bar"
  47 | 		end)
  48 | 		assert(not success, "Expected setting child.foo to error")
  49 | 	end,
  50 | 	["A child won't see changes to the parent"] = function()
  51 | 		local parent = Context.new()
  52 | 		local child = Context.new(parent)
  53 | 		parent.foo = "foo"
  54 | 		assert(child.foo == nil, string.format("Got %s, expected nil", tostring(parent.foo)))
  55 | 	end,
  56 | }
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/tests/Expectation.lua`
<details>
<summary>View Source (181 lines)</summary>

```lua
   1 | local TestEZ = script.Parent.Parent.TestEZ
   2 | local Expectation = require(TestEZ.Expectation)
   3 | 
   4 | return {
   5 |     ["it should succeed if an empty function is expected to never throw"] = function()
   6 |         local function shouldNotThrow()
   7 |         end
   8 | 
   9 |         local expect = Expectation.new(shouldNotThrow)
  10 | 
  11 |         local success = pcall(function()
  12 |             expect.never:throw()
  13 |         end)
  14 | 
  15 |         assert(success, "should succeed")
  16 |     end,
  17 |     ["it should succeed if a throwing function is expected to throw"] = function()
  18 |         local function shouldThrow()
  19 |             error("oof")
  20 |         end
  21 | 
  22 |         local expect = Expectation.new(shouldThrow)
  23 | 
  24 |         local success = pcall(function()
  25 |             expect:throw()
  26 |         end)
  27 | 
  28 |         assert(success, "should succeed")
  29 |     end,
  30 |     ["it should fail if a throwing function is expected to never throw"] = function()
  31 |         local function shouldThrow()
  32 |             error("oof")
  33 |         end
  34 | 
  35 |         local expect = Expectation.new(shouldThrow)
  36 | 
  37 |         local success, message = pcall(function()
  38 |             expect.never:throw()
  39 |         end)
  40 | 
  41 |         assert(not success, "should fail")
  42 |         assert(
  43 |             message:match("Expected function to succeed, but it threw an error:"),
  44 |             ("Error message does not match:\n%s\n"):format(message)
  45 |         )
  46 |     end,
  47 |     ["it should fail if an empty function is expected to throw"] = function()
  48 |         local function shouldNotThrow()
  49 |         end
  50 | 
  51 |         local expect = Expectation.new(shouldNotThrow)
  52 | 
  53 |         local success, message = pcall(function()
  54 |             expect:throw()
  55 |         end)
  56 | 
  57 |         assert(not success, "should fail")
  58 |         assert(
  59 |             message:match("Expected function to throw an error, but it did not."),
  60 |             ("Error message does not match:\n%s\n"):format(message)
  61 |         )
  62 |     end,
  63 |     ["it should succeed if types match"] = function()
  64 |         local expectNumber = Expectation.new(5)
  65 |         local expectString = Expectation.new("Foo")
  66 |         local expectFunction = Expectation.new(function()
  67 |             return true
  68 |         end)
  69 | 
  70 |         local success = pcall(function()
  71 |             expectNumber:a("number")
  72 |             expectString:a("string")
  73 |             expectFunction:a("function")
  74 |         end)
  75 | 
  76 |         assert(success, "should succeed")
  77 |     end,
  78 |     ["it should fail if types don't match"] = function()
  79 |         local expectNumber = Expectation.new(5)
  80 | 
  81 |         local success, message = pcall(function()
  82 |             expectNumber:a("string")
  83 |         end)
  84 | 
  85 |         assert(not success, "should fail")
  86 |         assert(
  87 |             message:match('Expected value of type "string", got value "5" of type number'),
  88 |             ("Error message does not match:\n%s\n"):format(message)
  89 |         )
  90 |     end,
  91 |     ["nil should be not ok"] = function()
  92 |         local expect = Expectation.new(nil)
  93 | 
  94 |         local successNever = pcall(function()
  95 |             expect.never:ok()
  96 |         end)
  97 | 
  98 |         assert(successNever, "should succeed")
  99 | 
 100 |         local successOk, message = pcall(function()
 101 |             expect:ok()
 102 |         end)
 103 | 
 104 |         assert(not successOk, "should fail")
 105 |         assert(
 106 |             message:match('Expected value "nil" to be non%-nil'),
 107 |             ("Error message does not match:\n%s\n"):format(message)
 108 |         )
 109 |     end,
 110 |     ["false should be ok"] = function()
 111 |         local expect = Expectation.new(false)
 112 | 
 113 |         local successOk = pcall(function()
 114 |             expect:ok()
 115 |         end)
 116 | 
 117 |         assert(successOk, "should succeed")
 118 | 
 119 |         local successNever, message = pcall(function()
 120 |             expect.never:ok()
 121 |         end)
 122 | 
 123 |         assert(not successNever, "should fail")
 124 |         assert(
 125 |             message:match('Expected value "false" to be nil'),
 126 |             ("Error message does not match:\n%s\n"):format(message)
 127 |         )
 128 |     end,
 129 |     ["equal values should be equal"] = function()
 130 |         local expect = Expectation.new("foo")
 131 | 
 132 |         local success = pcall(function()
 133 |             expect:equal("foo")
 134 |         end)
 135 | 
 136 |         assert(success, "should succeed")
 137 |     end,
 138 |     ["different values should not be equal"] = function()
 139 |         local expect = Expectation.new("5")
 140 | 
 141 |         local success, message = pcall(function()
 142 |             expect:equal(5)
 143 |         end)
 144 | 
 145 |         assert(not success, "should fail")
 146 |         assert(
 147 |             message:match('Expected value "5" %(number%), got "5" %(string%) instead'),
 148 |             ("Error message does not match:\n%s\n"):format(message)
 149 |         )
 150 |     end,
 151 |     ["similar numbers should be near"] = function()
 152 |         local expect = Expectation.new(0.1111111)
 153 | 
 154 |         local success = pcall(function()
 155 |             expect:near(1.0 / 9.0)
 156 |         end)
 157 | 
 158 |         assert(success, "should succeed")
 159 |     end,
 160 |     ["numbers outside the default limit should not be near"] = function()
 161 |         local expect = Expectation.new(0.11111)
 162 | 
 163 |         local success, message = pcall(function()
 164 |             expect:near(1.0 / 9.0)
 165 |         end)
 166 | 
 167 |         assert(not success, "should fail")
 168 |         assert(
 169 |             message:match("Expected value to be near %d+.%d+ %(within %d+.%d+%) but got %d+.%d+ instead"),
 170 |             ("Error message does not match:\n%s\n"):format(message)
 171 |         )
 172 |     end,
 173 |     ["near should respect limit argument"] = function()
 174 |         local expect = Expectation.new(0.1)
 175 | 
 176 |         local success = pcall(function()
 177 |             expect:near(1.0 / 9.0, 0.1)
 178 |         end)
 179 | 
 180 |         assert(success, "should succeed")
 181 |     end,
 182 | }
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/tests/lifecycleHooks.lua`
<details>
<summary>View Source (258 lines)</summary>

```lua
   1 | local TestEZ = require(script.Parent.Parent.TestEZ)
   2 | 
   3 | local function expectShallowEquals(array1, array2)
   4 | 	local function shallowEquals()
   5 | 		for index, value in ipairs(array1) do
   6 | 			if array2[index] ~= value then
   7 | 				return false
   8 | 			end
   9 | 		end
  10 | 
  11 | 		for index, value in ipairs(array2) do
  12 | 			if array1[index] ~= value then
  13 | 				return false
  14 | 			end
  15 | 		end
  16 | 
  17 | 		return true
  18 | 	end
  19 | 
  20 | 	if not shallowEquals() then
  21 | 		error(string.format(
  22 | 			"Expected: {\n\t%s\n}.\nGot: {\n\t%s\n}",
  23 | 			table.concat(array2, "\n\t"),
  24 | 			table.concat(array1, "\n\t")
  25 | 		))
  26 | 	end
  27 | end
  28 | 
  29 | local function expectNoFailures(results)
  30 | 	assert(results.failureCount == 0, "Some lifecycleHook test failed!")
  31 | end
  32 | 
  33 | local function runTestPlan(testPlan)
  34 | 	local lifecycleOrder = {}
  35 | 	local function insertLifecycleEvent(lifecycleString)
  36 | 		table.insert(lifecycleOrder, lifecycleString)
  37 | 	end
  38 | 
  39 | 	local plan = TestEZ.TestPlanner.createPlan({
  40 | 		{
  41 | 			method = function()
  42 | 				-- This function environment hack is needed because the testPlan
  43 | 				-- function is not defined or required from within a test. This
  44 | 				-- shouldn't come up in real tests.
  45 | 				setfenv(testPlan, getfenv())
  46 | 				testPlan(insertLifecycleEvent)
  47 | 			end,
  48 | 			path = {'lifecycleHooksTest'}
  49 | 		}
  50 | 	})
  51 | 
  52 | 	local results = TestEZ.TestRunner.runPlan(plan)
  53 | 	return results, lifecycleOrder
  54 | end
  55 | 
  56 | return {
  57 | 	["should run lifecycle methods in single-level"] = function()
  58 | 		local results, lifecycleOrder = runTestPlan(function(insertLifecycleEvent)
  59 | 			beforeAll(function()
  60 | 				insertLifecycleEvent("1 - beforeAll")
  61 | 			end)
  62 | 
  63 | 			afterAll(function()
  64 | 				insertLifecycleEvent("1 - afterAll")
  65 | 			end)
  66 | 
  67 | 			beforeEach(function()
  68 | 				insertLifecycleEvent("1 - beforeEach")
  69 | 			end)
  70 | 
  71 | 			afterEach(function()
  72 | 				insertLifecycleEvent("1 - afterEach")
  73 | 			end)
  74 | 
  75 | 			it("runs root", function()
  76 | 				insertLifecycleEvent("1 - test")
  77 | 			end)
  78 | 
  79 | 			it("runs root again", function()
  80 | 				insertLifecycleEvent("1 - another test")
  81 | 			end)
  82 | 		end)
  83 | 
  84 | 		expectShallowEquals(lifecycleOrder, {
  85 | 			"1 - beforeAll",
  86 | 			"1 - beforeEach",
  87 | 			"1 - test",
  88 | 			"1 - afterEach",
  89 | 			"1 - beforeEach",
  90 | 			"1 - another test",
  91 | 			"1 - afterEach",
  92 | 			"1 - afterAll",
  93 | 		})
  94 | 
  95 | 		expectNoFailures(results)
  96 | 	end,
  97 | 	["should run lifecycle methods in order in nested trees"] = function()
  98 | 		-- follows spec from jest https://jestjs.io/docs/en/setup-teardown#scoping
  99 | 		local results, lifecycleOrder = runTestPlan(function(insertLifecycleEvent)
 100 | 			beforeAll(function()
 101 | 				insertLifecycleEvent("1 - beforeAll")
 102 | 			end)
 103 | 
 104 | 			afterAll(function()
 105 | 				insertLifecycleEvent("1 - afterAll")
 106 | 			end)
 107 | 
 108 | 			beforeEach(function()
 109 | 				insertLifecycleEvent("1 - beforeEach")
 110 | 			end)
 111 | 
 112 | 			afterEach(function()
 113 | 				insertLifecycleEvent("1 - afterEach")
 114 | 			end)
 115 | 
 116 | 			it("runs root", function()
 117 | 				insertLifecycleEvent("1 - test")
 118 | 			end)
 119 | 
 120 | 			describe("nestedDescribe", function()
 121 | 				beforeAll(function()
 122 | 					insertLifecycleEvent("2 - beforeAll")
 123 | 				end)
 124 | 
 125 | 				afterAll(function()
 126 | 					insertLifecycleEvent("2 - afterAll")
 127 | 				end)
 128 | 
 129 | 				beforeEach(function()
 130 | 					insertLifecycleEvent("2 - beforeEach")
 131 | 				end)
 132 | 
 133 | 				afterEach(function()
 134 | 					insertLifecycleEvent("2 - afterEach")
 135 | 				end)
 136 | 
 137 | 				it("runs", function()
 138 | 					insertLifecycleEvent("2 - test")
 139 | 				end)
 140 | 
 141 | 				describe("no tests", function()
 142 | 					beforeAll(function()
 143 | 						insertLifecycleEvent("3 - beforeAll")
 144 | 					end)
 145 | 
 146 | 					afterAll(function()
 147 | 						insertLifecycleEvent("3 - afterAll")
 148 | 					end)
 149 | 				end)
 150 | 			end)
 151 | 
 152 | 			it("runs root again", function()
 153 | 				insertLifecycleEvent("1 - another test")
 154 | 			end)
 155 | 		end)
 156 | 
 157 | 		expectShallowEquals(lifecycleOrder, {
 158 | 			"1 - beforeAll",
 159 | 			"1 - beforeEach",
 160 | 			"1 - test",
 161 | 			"1 - afterEach",
 162 | 			"2 - beforeAll",
 163 | 			"1 - beforeEach",
 164 | 			"2 - beforeEach",
 165 | 			"2 - test",
 166 | 			"2 - afterEach",
 167 | 			"1 - afterEach",
 168 | 			"3 - beforeAll",
 169 | 			"3 - afterAll",
 170 | 			"2 - afterAll",
 171 | 			"1 - beforeEach",
 172 | 			"1 - another test",
 173 | 			"1 - afterEach",
 174 | 			"1 - afterAll",
 175 | 		})
 176 | 		expectNoFailures(results)
 177 | 	end,
 178 | 	["beforeAll should only run once per describe block"] = function()
 179 | 		local results, lifecycleOrder = runTestPlan(function(insertLifecycleEvent)
 180 | 			beforeAll(function()
 181 | 				insertLifecycleEvent("1 - beforeAll")
 182 | 			end)
 183 | 
 184 | 			it("runs 1", function()
 185 | 				insertLifecycleEvent("1 - test")
 186 | 			end)
 187 | 
 188 | 			describe("nestedDescribe", function()
 189 | 				beforeAll(function()
 190 | 					insertLifecycleEvent("2 - beforeAll")
 191 | 				end)
 192 | 
 193 | 				it("runs 2", function()
 194 | 					insertLifecycleEvent("2 - test")
 195 | 				end)
 196 | 
 197 | 				it("runs 2 again", function()
 198 | 					insertLifecycleEvent("2 - test again")
 199 | 				end)
 200 | 			end)
 201 | 		end)
 202 | 
 203 | 		expectShallowEquals(lifecycleOrder, {
 204 | 			"1 - beforeAll",
 205 | 			"1 - test",
 206 | 			"2 - beforeAll",
 207 | 			"2 - test",
 208 | 			"2 - test again",
 209 | 		})
 210 | 		expectNoFailures(results)
 211 | 	end,
 212 | 	["lifecycle failures should fail test node"] = function()
 213 | 		local function failLifecycleCase(hookType)
 214 | 			local itWasRun = false
 215 | 			local results = runTestPlan(function(insertLifecycleEvent)
 216 | 
 217 | 				if hookType == "beforeAll" then
 218 | 					beforeAll(function()
 219 | 						error("this is an error")
 220 | 					end)
 221 | 				end
 222 | 
 223 | 				if hookType == "beforeEach" then
 224 | 					beforeEach(function()
 225 | 						error("this is an error")
 226 | 					end)
 227 | 				end
 228 | 
 229 | 				if hookType == "afterEach" then
 230 | 					afterEach(function()
 231 | 						error("this is an error")
 232 | 					end)
 233 | 				end
 234 | 
 235 | 				if hookType == "afterAll" then
 236 | 					afterAll(function()
 237 | 						error("this is an error")
 238 | 					end)
 239 | 				end
 240 | 
 241 | 				it("runs root", function()
 242 | 					itWasRun = true
 243 | 				end)
 244 | 			end)
 245 | 
 246 | 			assert(results.failureCount == 1, string.format("Expected %s failure to fail test run", hookType))
 247 | 
 248 | 			if hookType:find("before") then
 249 | 				-- if before* hooks fail, our test node should not run
 250 | 				assert(itWasRun == false, "it node was ran despite failure on run: " .. hookType)
 251 | 			end
 252 | 		end
 253 | 
 254 | 		failLifecycleCase("beforeAll")
 255 | 		failLifecycleCase("beforeEach")
 256 | 		failLifecycleCase("afterEach")
 257 | 		failLifecycleCase("afterAll")
 258 | 	end,
 259 | }
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/tests/planner.lua`
<details>
<summary>View Source (95 lines)</summary>

```lua
   1 | local TestEZ = script.Parent.Parent.TestEZ
   2 | local TestPlanner = require(TestEZ.TestPlanner)
   3 | local TestBootstrap = require(TestEZ.TestBootstrap)
   4 | local TestEnum = require(TestEZ.TestEnum)
   5 | 
   6 | local testRoot = script.Parent.planning
   7 | 
   8 | local function verifyPlan(plan, expected, notSkip)
   9 | 	local nodes = plan:findNodes(function(node)
  10 | 		return (not notSkip) or (node.modifier ~= TestEnum.NodeModifier.Skip)
  11 | 	end)
  12 | 
  13 | 	local nodeNames = {}
  14 | 	for _, node in ipairs(nodes) do
  15 | 		local name = node:getFullName()
  16 | 		if nodeNames[name] then
  17 | 			nodeNames[name] = nodeNames[name] + 1
  18 | 		else
  19 | 			nodeNames[name] = 1
  20 | 		end
  21 | 	end
  22 | 
  23 | 	for _, name in ipairs(expected) do
  24 | 		if nodeNames[name] then
  25 | 			nodeNames[name] = nodeNames[name] - 1
  26 | 		else
  27 | 			nodeNames[name] = -1
  28 | 		end
  29 | 	end
  30 | 
  31 | 	local pass = true
  32 | 	local message = ""
  33 | 
  34 | 	for name, count in pairs(nodeNames) do
  35 | 		if count < 0 then
  36 | 			pass = false
  37 | 			message = message .. string.format("expected name [%s] not found, ", name)
  38 | 		elseif count > 0 then
  39 | 			pass = false
  40 | 			message = message .. string.format("additional name [%s] found, ", name)
  41 | 		end
  42 | 	end
  43 | 
  44 | 	return pass, message
  45 | end
  46 | 
  47 | return {
  48 | 	["it should build the full plan with no arguments"] = function()
  49 | 		local modules = TestBootstrap:getModules(testRoot)
  50 | 		local plan = TestPlanner.createPlan(modules)
  51 | 		assert(verifyPlan(plan, {
  52 | 			"planning",
  53 | 			"planning a",
  54 | 			"planning a test1",
  55 | 			"planning a test2",
  56 | 			"planning b",
  57 | 			"planning b test1",
  58 | 			"planning b test2",
  59 | 			"planning b test2 test3",
  60 | 			"planning d",
  61 | 			"planning d test4",
  62 | 			"planning d test4 test5",
  63 | 			"planning d test4 test6",
  64 | 			"planning d test4",  -- Order doesn't actually matter for this test.
  65 | 			"planning d test4 test5",
  66 | 			"planning d test4 test7",
  67 | 		}))
  68 | 	end,
  69 | 	["it should mark skipped tests as skipped"] = function()
  70 | 		local modules = TestBootstrap:getModules(testRoot)
  71 | 		local plan = TestPlanner.createPlan(modules)
  72 | 		assert(verifyPlan(plan, {
  73 | 			"planning",
  74 | 			"planning a",
  75 | 			"planning a test2",
  76 | 			"planning b",
  77 | 			"planning b test1",
  78 | 			"planning b test2 test3", -- This isn't marked skip, its parent is
  79 | 			"planning d",
  80 | 			"planning d test4",
  81 | 			"planning d test4 test5",
  82 | 			"planning d test4 test6",
  83 | 			"planning d test4",  -- Order doesn't actually matter for this test.
  84 | 			"planning d test4 test5",
  85 | 			"planning d test4 test7",
  86 | 		}, true))
  87 | 	end,
  88 | 	["it should skip tests that don't match the filter"] = function()
  89 | 		local modules = TestBootstrap:getModules(testRoot)
  90 | 		local plan = TestPlanner.createPlan(modules, "test2")
  91 | 		assert(verifyPlan(plan, {
  92 | 			"planning a test2",
  93 | 			"planning b test2 test3", -- Gets focus because only its parent is skip
  94 | 		}, true))
  95 | 	end,
  96 | }
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/modules/testez/tests/specTests.lua`
<details>
<summary>View Source (29 lines)</summary>

```lua
   1 | local TestEZ = require(script.Parent.Parent.TestEZ)
   2 | 
   3 | local passing = script.Parent.passing
   4 | local failing = script.Parent.failing
   5 | 
   6 | local function check(test, pass)
   7 | 	TestEZ.run(test, function(results)
   8 | 		if pass then
   9 | 			assert(#results.errors == 0,
  10 | 				"Expected no errors, got " .. tostring(results.errors[1]) ..
  11 | 				" plus " .. tostring(#results.errors - 1) .. " more.")
  12 | 		else
  13 | 			assert(#results.errors > 0, "Expected some errors, got none.")
  14 | 		end
  15 | 	end)
  16 | end
  17 | 
  18 | local tests = {}
  19 | for _, child in ipairs(passing:GetChildren()) do
  20 | 	tests["Passing tests pass: " .. child.Name] = function()
  21 | 		check(child, true)
  22 | 	end
  23 | end
  24 | for _, child in ipairs(failing:GetChildren()) do
  25 | 	tests["Failing tests fail: " .. child.Name] = function()
  26 | 		check(child, false)
  27 | 	end
  28 | end
  29 | return tests
```
</details>

## ğŸŒ™ `Packages/_Index/evaera_promise@4.0.0/promise/runTests.server.lua`
<details>
<summary>View Source (2 lines)</summary>

```lua
   1 | require(script.Parent.TestEZ).TestBootstrap:run({
   2 | 	game.ServerScriptService.Lib
   3 | })
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/ColorUtils.lua`
<details>
<summary>View Source (1 lines)</summary>

```lua
   1 | return require(script.Parent.Parent["csqrl_colour-utils@1.4.1"]["colour-utils"])
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/Fusion.lua`
<details>
<summary>View Source (1 lines)</summary>

```lua
   1 | return require(script.Parent.Parent["elttob_fusion@0.3.0"]["fusion"])
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Components/AutoScaler.luau`
<details>
<summary>View Source (65 lines)</summary>

```lua
   1 | --[=[
   2 | 		@class AutoScaler
   3 | 		
   4 | 		Automatically scales children for the user's screen. ğŸ“±ğŸ’»ğŸ“ºğŸ¥½
   5 | ]=]
   6 | 
   7 | --[=[
   8 | 	@interface AutoScalerProps
   9 | 	@within AutoScaler
  10 | 	
  11 | 	. ... FrameProps -- All Frame properties are accepted.
  12 | 	.BaseResolution Vector2 -- The base resolution to scale from.
  13 | 	.MinScale number -- The minimum scale factor.
  14 | 	.MaxScale number -- The maximum scale factor.
  15 | 	.ScaleMultiplier number -- A multiplier applied to the calculated scale.
  16 | ]=]
  17 | 
  18 | local Workspace = game:GetService("Workspace")
  19 | 
  20 | local OnyxUI = script.Parent.Parent
  21 | local Fusion = require(OnyxUI.Parent.Fusion)
  22 | local Util = require(OnyxUI.Util)
  23 | local ViewportSize = require(OnyxUI.Util.ViewportSize)
  24 | 
  25 | local Out = Fusion.Out
  26 | 
  27 | local Base = require(script.Parent.Base)
  28 | local Frame = require(script.Parent.Frame)
  29 | local Components = {
  30 | 	Base = Base,
  31 | 	Frame = Frame,
  32 | }
  33 | 
  34 | export type Props = Base.Props & {
  35 | 	BaseResolution: Fusion.UsedAs<Vector2>?,
  36 | 	MinScale: Fusion.UsedAs<number>?,
  37 | 	MaxScale: Fusion.UsedAs<number>?,
  38 | 	ScaleMultiplier: Fusion.UsedAs<number>?,
  39 | }
  40 | 
  41 | return function(Scope: Fusion.Scope<any>, Props: Props)
  42 | 	local Scope = Fusion.innerScope(Scope, Fusion, Util, Components)
  43 | 
  44 | 	local BaseResolution = Util.Fallback(Props.BaseResolution, Vector2.new())
  45 | 	local MinScale = Util.Fallback(Props.MinScale, 0.8)
  46 | 	local MaxScale = Util.Fallback(Props.MaxScale, math.huge)
  47 | 	local ScaleMultiplier = Util.Fallback(Props.ScaleMultiplier, 1)
  48 | 
  49 | 	local ScreenSize = Scope:Value(Vector2.new())
  50 | 
  51 | 	ViewportSize:Observe(function(Size)
  52 | 		ScreenSize:set(Size)
  53 | 	end)
  54 | 
  55 | 	return Scope:Frame(Util.CombineProps(Props, {
  56 | 		Name = script.Name,
  57 | 		Scale = {
  58 | 			Scale = Scope:Computed(function(Use)
  59 | 				local Ratio = Use(ScaleMultiplier)
  60 | 					/ math.max((Use(BaseResolution).X / Use(ScreenSize).X), (Use(BaseResolution).Y / Use(ScreenSize).Y))
  61 | 				return math.clamp(Ratio, Use(MinScale), Use(MaxScale))
  62 | 			end),
  63 | 		},
  64 | 	}))
  65 | end
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Components/AutoScaler.story.luau`
<details>
<summary>View Source (37 lines)</summary>

```lua
   1 | local OnyxUI = script.Parent.Parent
   2 | local Fusion = require(OnyxUI.Parent.Fusion)
   3 | local Themer = require(OnyxUI.Themer)
   4 | local Util = require(OnyxUI.Util)
   5 | 
   6 | local Children = Fusion.Children
   7 | 
   8 | local AutoScaler = require(OnyxUI.Components.AutoScaler)
   9 | local Card = require(OnyxUI.Components.Card)
  10 | local Components = {
  11 | 	AutoScaler = AutoScaler,
  12 | 	Card = Card,
  13 | }
  14 | 
  15 | return {
  16 | 	story = function(Props)
  17 | 		local Scope = Fusion.innerScope(Props.scope, Fusion, Util, Components)
  18 | 		local Theme = Themer.Theme:now()
  19 | 
  20 | 		Scope:AutoScaler {
  21 | 			Parent = Props.target,
  22 | 			BaseResolution = Vector2.new(800, 800),
  23 | 			List = {
  24 | 				FillDirection = Enum.FillDirection.Vertical,
  25 | 				Padding = Scope:UDim(0, Theme.Spacing["0.75"]),
  26 | 			},
  27 | 
  28 | 			[Children] = {
  29 | 				Scope:Card {
  30 | 					Size = Scope:UDim2Offset(Theme.Sizing["16"], Theme.Sizing["8"]),
  31 | 					AutomaticSize = Enum.AutomaticSize.None,
  32 | 				},
  33 | 			},
  34 | 		}
  35 | 	end,
  36 | 	fusion = Fusion,
  37 | }
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Components/Avatar.luau`
<details>
<summary>View Source (127 lines)</summary>

```lua
   1 | --[=[
   2 | 		@class Avatar
   3 | 		
   4 | 		Useful for displaying player headshots and profile pictures. And optionally, user status.
   5 | ]=]
   6 | 
   7 | --[=[
   8 | 	@interface AvatarProps
   9 | 	@within Avatar
  10 | 	
  11 | 	. ... ImageProps -- All Image properties are accepted.
  12 | 	.Image string? -- The image to display in the avatar.
  13 | 	.RingEnabled boolean? -- Whether the ring around the avatar is enabled.
  14 | 	.RingColor Color3? -- The color of the ring around the avatar.
  15 | 	.RingThickness number? -- The thickness of the ring around the avatar.
  16 | 	.IndicatorEnabled boolean? -- Whether the indicator is enabled.
  17 | 	.IndicatorColor Color3? -- The color of the indicator.
  18 | 	.IndicatorIcon string? -- The icon to display in the indicator.
  19 | 	.IndicatorIconColor Color3? -- The color of the indicator icon.
  20 | 	.IndicatorCornerRadius UDim? -- The corner radius of the indicator.
  21 | ]=]
  22 | 
  23 | local OnyxUI = script.Parent.Parent
  24 | 
  25 | local Fusion = require(OnyxUI.Parent.Fusion)
  26 | local Util = require(OnyxUI.Util)
  27 | local Themer = require(OnyxUI.Themer)
  28 | 
  29 | local Children = Fusion.Children
  30 | 
  31 | local Image = require(script.Parent.Image)
  32 | local Group = require(script.Parent.Group)
  33 | local Icon = require(script.Parent.Icon)
  34 | local Components = {
  35 | 	Image = Image,
  36 | 	Group = Group,
  37 | 	Icon = Icon,
  38 | }
  39 | 
  40 | export type Props = Image.Props & {
  41 | 	Image: Fusion.UsedAs<string>?,
  42 | 	RingEnabled: Fusion.UsedAs<boolean>?,
  43 | 	RingColor: Fusion.UsedAs<Color3>?,
  44 | 	RingThickness: Fusion.UsedAs<number>?,
  45 | 	IndicatorEnabled: Fusion.UsedAs<boolean>?,
  46 | 	IndicatorColor: Fusion.UsedAs<Color3>?,
  47 | 	IndicatorIcon: Fusion.UsedAs<string>?,
  48 | 	IndicatorIconColor: Fusion.UsedAs<Color3>?,
  49 | 	IndicatorCornerRadius: Fusion.UsedAs<UDim>?,
  50 | }
  51 | 
  52 | return function(Scope: Fusion.Scope<any>, Props: Props)
  53 | 	local Scope = Fusion.innerScope(Scope, Fusion, Util, Components)
  54 | 	local Theme = Themer.Theme:now()
  55 | 
  56 | 	local ImageProp = Util.Fallback(Props.Image, nil)
  57 | 	local RingEnabled = Util.Fallback(Props.RingEnabled, false)
  58 | 	local RingColor = Util.Fallback(Props.RingColor, Theme.Colors.Primary.Main)
  59 | 	local RingThickness = Util.Fallback(Props.RingThickness, Theme.StrokeThickness["2"])
  60 | 	local IndicatorEnabled = Util.Fallback(Props.IndicatorEnabled, false)
  61 | 	local IndicatorColor = Util.Fallback(Props.IndicatorColor, Theme.Colors.Primary.Main)
  62 | 	local IndicatorCornerRadius = Util.Fallback(Props.IndicatorCornerRadius, Scope:UDim(0, Theme.CornerRadius["Full"]))
  63 | 	local IndicatorIcon = Util.Fallback(Props.IndicatorIcon, nil)
  64 | 	local IndicatorIconColor = Util.Fallback(Props.IndicatorIconColor, Util.Colors.White)
  65 | 
  66 | 	return Scope:Image(Util.CombineProps(Props, {
  67 | 		Name = script.Name,
  68 | 		Image = ImageProp,
  69 | 		Size = Scope:UDim2Offset(Theme.TextSize["4.5"], Theme.TextSize["4.5"]),
  70 | 		BackgroundColor3 = Theme.Colors.Neutral.Dark,
  71 | 		Stroke = {
  72 | 			Enabled = RingEnabled,
  73 | 			Color = Scope:Spring(RingColor, Theme.SpringSpeed["0.5"], Theme.SpringDampening["1"]),
  74 | 			Thickness = Scope:Spring(RingThickness, Theme.SpringSpeed["0.5"], Theme.SpringDampening["1"]),
  75 | 		},
  76 | 		Corner = {
  77 | 			Radius = Scope:UDim(0, Theme.CornerRadius["1"]),
  78 | 		},
  79 | 
  80 | 		[Children] = {
  81 | 			Scope:Computed(function(Use)
  82 | 				if Use(IndicatorEnabled) then
  83 | 					return Themer.Theme:is(Theme):during(function()
  84 | 						return Scope:Group {
  85 | 							Name = "Indicator",
  86 | 							BackgroundColor3 = Scope:Spring(
  87 | 								IndicatorColor,
  88 | 								Theme.SpringSpeed["0.5"],
  89 | 								Theme.SpringDampening["1"]
  90 | 							),
  91 | 							BackgroundTransparency = 0,
  92 | 							Size = UDim2.fromScale(0.25, 0.25),
  93 | 							AutomaticSize = Enum.AutomaticSize.None,
  94 | 							AnchorPoint = Vector2.new(1, 1),
  95 | 							Position = UDim2.fromScale(1, 1),
  96 | 							Aspect = {
  97 | 								Ratio = 1,
  98 | 							},
  99 | 							Corner = {
 100 | 								Radius = IndicatorCornerRadius,
 101 | 							},
 102 | 
 103 | 							[Children] = {
 104 | 								Scope:Icon {
 105 | 									Image = IndicatorIcon,
 106 | 									ImageColor3 = IndicatorIconColor,
 107 | 									ImageTransparency = Scope:Computed(function(Use)
 108 | 										if Use(IndicatorIcon) then
 109 | 											return 0
 110 | 										else
 111 | 											return 1
 112 | 										end
 113 | 									end),
 114 | 									Size = UDim2.fromScale(1, 1),
 115 | 									AnchorPoint = Vector2.new(0.5, 0.5),
 116 | 									Position = UDim2.fromScale(0.5, 0.5),
 117 | 								},
 118 | 							},
 119 | 						}
 120 | 					end)
 121 | 				else
 122 | 					return
 123 | 				end
 124 | 			end),
 125 | 		},
 126 | 	}))
 127 | end
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Components/Avatar.story.luau`
<details>
<summary>View Source (103 lines)</summary>

```lua
   1 | local OnyxUI = script.Parent.Parent
   2 | 
   3 | local Fusion = require(OnyxUI.Parent.Fusion)
   4 | local Themer = require(OnyxUI.Themer)
   5 | local Util = require(OnyxUI.Util)
   6 | 
   7 | local Children = Fusion.Children
   8 | 
   9 | local Frame = require(script.Parent.Frame)
  10 | local Avatar = require(script.Parent.Avatar)
  11 | local Components = {
  12 | 	Frame = Frame,
  13 | 	Avatar = Avatar,
  14 | }
  15 | 
  16 | local INDICATOR_COLORS =
  17 | 	{ Util.Colors.Red["500"], Util.Colors.Green["400"], Util.Colors.Orange["500"], Util.Colors.Stone["600"] }
  18 | 
  19 | return {
  20 | 	story = function(Props)
  21 | 		local Scope = Fusion.innerScope(Props.scope, Fusion, Util, Components)
  22 | 		local Theme = Themer.Theme:now()
  23 | 
  24 | 		local IndicatorColor = Scope:Value(INDICATOR_COLORS[2])
  25 | 		local RingThickness = Scope:Value(Fusion.peek(Theme.StrokeThickness["2"]))
  26 | 
  27 | 		local RandomizerThread = task.spawn(function()
  28 | 			while task.wait(1) do
  29 | 				IndicatorColor:set(INDICATOR_COLORS[math.random(1, #INDICATOR_COLORS)])
  30 | 
  31 | 				if Fusion.peek(RingThickness) == Fusion.peek(Theme.StrokeThickness["2"]) then
  32 | 					RingThickness:set(Fusion.peek(Theme.StrokeThickness["3"]))
  33 | 				else
  34 | 					RingThickness:set(Fusion.peek(Theme.StrokeThickness["2"]))
  35 | 				end
  36 | 			end
  37 | 		end)
  38 | 
  39 | 		Scope:innerScope({
  40 | 			function()
  41 | 				task.cancel(RandomizerThread)
  42 | 			end,
  43 | 		})
  44 | 
  45 | 		Scope:Frame {
  46 | 			Parent = Props.target,
  47 | 			Padding = {
  48 | 				All = Scope:UDim(0, Theme.StrokeThickness["4"]),
  49 | 			},
  50 | 			List = {
  51 | 				Padding = Scope:UDim(0, Theme.Spacing["1"]),
  52 | 				FillDirection = Enum.FillDirection.Horizontal,
  53 | 			},
  54 | 
  55 | 			[Children] = {
  56 | 				Scope:Avatar {
  57 | 					Image = "rbxthumb://type=AvatarHeadShot&id=144146784&w=150&h=150",
  58 | 				},
  59 | 				Scope:Avatar {
  60 | 					Image = "rbxthumb://type=AvatarHeadShot&id=144146784&w=150&h=150",
  61 | 					Corner = {
  62 | 						Radius = Scope:UDim(0, Theme.CornerRadius.Full),
  63 | 					},
  64 | 				},
  65 | 				Scope:Avatar {
  66 | 					Image = "rbxthumb://type=AvatarHeadShot&id=144146784&w=150&h=150",
  67 | 					Corner = {
  68 | 						Radius = Scope:UDim(0, Theme.CornerRadius.Full),
  69 | 					},
  70 | 					RingEnabled = true,
  71 | 					RingColor = IndicatorColor,
  72 | 				},
  73 | 				Scope:Avatar {
  74 | 					Image = "rbxthumb://type=AvatarHeadShot&id=144146784&w=150&h=150",
  75 | 					Corner = {
  76 | 						Radius = Scope:UDim(0, Theme.CornerRadius.Full),
  77 | 					},
  78 | 					IndicatorEnabled = true,
  79 | 					IndicatorColor = IndicatorColor,
  80 | 				},
  81 | 				Scope:Avatar {
  82 | 					Image = "rbxthumb://type=AvatarHeadShot&id=144146784&w=150&h=150",
  83 | 					Corner = {
  84 | 						Radius = Scope:UDim(0, Theme.CornerRadius.Full),
  85 | 					},
  86 | 					RingEnabled = true,
  87 | 					RingColor = Util.Colors.Green["400"],
  88 | 					RingThickness = RingThickness,
  89 | 				},
  90 | 				Scope:Avatar {
  91 | 					Image = "rbxthumb://type=AvatarHeadShot&id=144146784&w=150&h=150",
  92 | 					Corner = {
  93 | 						Radius = Scope:UDim(0, Theme.CornerRadius.Full),
  94 | 					},
  95 | 					IndicatorEnabled = true,
  96 | 					IndicatorColor = Util.Colors.Sky["500"],
  97 | 					IndicatorIcon = "rbxassetid://13805569043",
  98 | 				},
  99 | 			},
 100 | 		}
 101 | 	end,
 102 | 	fusion = Fusion,
 103 | }
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Components/Badge.luau`
<details>
<summary>View Source (93 lines)</summary>

```lua
   1 | --[=[
   2 | 		@class Badge
   3 | 		
   4 | 		Used to inform the user of something's status. E.g. a notification indicator or discount tag.
   5 | 
   6 | ]=]
   7 | 
   8 | --[=[
   9 | 	@interface BadgeProps
  10 | 	@within Badge
  11 | 
  12 | 	. ... FrameProps -- All Frame properties are accepted.
  13 | 	.Content {string}? -- The content to display inside the badge.
  14 | 	.ContentWrapped boolean? -- Whether the content should wrap if it overflows.
  15 | 	.Color Color3? -- The background color of the badge.
  16 | 	.ContentColor Color3? -- The color of the content inside the badge.
  17 | 	.ContentSize number? -- The size of the content inside the badge.
  18 | ]=]
  19 | 
  20 | local OnyxUI = script.Parent.Parent
  21 | local Fusion = require(OnyxUI.Parent.Fusion)
  22 | local Util = require(OnyxUI.Util)
  23 | local Themer = require(OnyxUI.Themer)
  24 | 
  25 | local Children = Fusion.Children
  26 | 
  27 | local Frame = require(script.Parent.Frame)
  28 | local IconText = require(script.Parent.IconText)
  29 | local Components = {
  30 | 	Frame = Frame,
  31 | 	IconText = IconText,
  32 | }
  33 | 
  34 | export type Props = Frame.Props & {
  35 | 	Content: Fusion.UsedAs<{ string }>?,
  36 | 	ContentWrapped: Fusion.UsedAs<boolean>?,
  37 | 	Color: Fusion.UsedAs<Color3>?,
  38 | 	ContentColor: Fusion.UsedAs<Color3>?,
  39 | 	ContentSize: Fusion.UsedAs<number>?,
  40 | }
  41 | 
  42 | return function(Scope: Fusion.Scope<any>, Props: Props)
  43 | 	local Scope = Fusion.innerScope(Scope, Fusion, Util, Components)
  44 | 	local Theme = Themer.Theme:now()
  45 | 
  46 | 	local Content = Util.Fallback(Props.Content, {})
  47 | 	local ContentWrapped = Util.Fallback(Props.ContentWrapped, true)
  48 | 	local Color = Util.Fallback(Props.Color, Theme.Colors.Base.Main)
  49 | 	local ContentColor = Util.Fallback(
  50 | 		Props.ContentColor,
  51 | 
  52 | 		Scope:Computed(function(Use)
  53 | 			return Util.Emphasize(Use(Color), Use(Theme.Emphasis.Contrast))
  54 | 		end)
  55 | 	)
  56 | 	local ContentSize = Util.Fallback(Props.ContentSize, Theme.TextSize["1"])
  57 | 
  58 | 	return Scope:Frame(Util.CombineProps(Props, {
  59 | 		Name = script.Name,
  60 | 		BackgroundColor3 = Color,
  61 | 		BackgroundTransparency = 0,
  62 | 		Padding = {
  63 | 			All = Scope:UDim(0, Theme.Padding["0"]),
  64 | 			Left = Scope:UDim(0, Theme.Padding["0.25"]),
  65 | 			Right = Scope:UDim(0, Theme.Padding["0.25"]),
  66 | 		},
  67 | 		Corner = {
  68 | 			Radius = Scope:UDim(0, Theme.CornerRadius["2"]),
  69 | 		},
  70 | 		List = {
  71 | 			Padding = Scope:UDim(0, Theme.Spacing["0.25"]),
  72 | 			FillDirection = Enum.FillDirection.Horizontal,
  73 | 			HorizontalAlignment = Enum.HorizontalAlignment.Center,
  74 | 			VerticalAlignment = Enum.VerticalAlignment.Center,
  75 | 			Wraps = ContentWrapped,
  76 | 		},
  77 | 		Stroke = {},
  78 | 
  79 | 		[Children] = {
  80 | 			Scope:IconText {
  81 | 				Content = Content,
  82 | 				ContentColor = ContentColor,
  83 | 				ContentSize = ContentSize,
  84 | 				ContentWrapped = ContentWrapped,
  85 | 				List = {
  86 | 					HorizontalAlignment = Enum.HorizontalAlignment.Center,
  87 | 					VerticalAlignment = Enum.VerticalAlignment.Center,
  88 | 					Padding = Scope:UDim(0, Theme.Spacing["0.25"]),
  89 | 				},
  90 | 			},
  91 | 		},
  92 | 	}))
  93 | end
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Components/Badge.story.luau`
<details>
<summary>View Source (91 lines)</summary>

```lua
   1 | local OnyxUI = script.Parent.Parent
   2 | 
   3 | local Fusion = require(OnyxUI.Parent.Fusion)
   4 | local Themer = require(OnyxUI.Themer)
   5 | local Util = require(OnyxUI.Util)
   6 | 
   7 | local Children = Fusion.Children
   8 | 
   9 | local Frame = require(OnyxUI.Components.Frame)
  10 | local Badge = require(OnyxUI.Components.Badge)
  11 | local Text = require(OnyxUI.Components.Text)
  12 | local Components = {
  13 | 	Frame = Frame,
  14 | 	Badge = Badge,
  15 | 	Text = Text,
  16 | }
  17 | 
  18 | return {
  19 | 	story = function(Props)
  20 | 		local Scope = Fusion.innerScope(Props.scope, Fusion, Util, Components)
  21 | 		local Theme = Themer.Theme:now()
  22 | 
  23 | 		local NotificationCount = Scope:Value(0)
  24 | 
  25 | 		local CountThread = task.spawn(function()
  26 | 			while task.wait(0.08) do
  27 | 				if Fusion.peek(NotificationCount) == 100 then
  28 | 					task.wait(3)
  29 | 					NotificationCount:set(1)
  30 | 				else
  31 | 					NotificationCount:set(Fusion.peek(NotificationCount) + 1)
  32 | 				end
  33 | 			end
  34 | 		end)
  35 | 
  36 | 		Scope:innerScope({
  37 | 			function()
  38 | 				task.cancel(CountThread)
  39 | 			end,
  40 | 		})
  41 | 
  42 | 		Scope:Frame {
  43 | 			Parent = Props.target,
  44 | 			List = {
  45 | 				Padding = Scope:UDim(0, Theme.Spacing["0.5"]),
  46 | 			},
  47 | 
  48 | 			[Children] = {
  49 | 				Scope:Badge {
  50 | 					Content = { "Badge" },
  51 | 				},
  52 | 				Scope:Badge {
  53 | 					Content = { "rbxassetid://103798699021677", "-50%" },
  54 | 					Color = Util.Colors.Red["500"],
  55 | 				},
  56 | 				Scope:Badge {
  57 | 					Content = { "rbxassetid://140490867216758", "LIMITED" },
  58 | 					Color = Util.Colors.Red["500"],
  59 | 				},
  60 | 				Scope:Badge {
  61 | 					Content = Scope:Computed(function(Use)
  62 | 						if Use(NotificationCount) >= 100 then
  63 | 							return { "99+" }
  64 | 						else
  65 | 							return { Use(NotificationCount) }
  66 | 						end
  67 | 					end),
  68 | 					Color = Theme.Colors.Primary.Main,
  69 | 				},
  70 | 				Scope:Frame {
  71 | 					List = {
  72 | 						HorizontalAlignment = Enum.HorizontalAlignment.Center,
  73 | 						FillDirection = Enum.FillDirection.Horizontal,
  74 | 						Padding = Scope:UDim(0, Theme.Spacing["0.25"]),
  75 | 					},
  76 | 
  77 | 					[Children] = {
  78 | 						Scope:Text {
  79 | 							Text = "It's also proportional alongside text.",
  80 | 						},
  81 | 						Scope:Badge {
  82 | 							Content = { "rbxassetid://137979359742656", "TRUE" },
  83 | 							Color = Util.Colors.Green["500"],
  84 | 						},
  85 | 					},
  86 | 				},
  87 | 			},
  88 | 		}
  89 | 	end,
  90 | 	fusion = Fusion,
  91 | }
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Components/Base.luau`
<details>
<summary>View Source (725 lines)</summary>

```lua
   1 | --[=[
   2 | 		@class Base
   3 | 
   4 | 		The foundational component of OnyxUI, from which all other components are built off of. Props supported here typically work in all other components.
   5 | ]=]
   6 | 
   7 | --[=[
   8 | 	@interface GradientProps
   9 | 	@within Base
  10 | 
  11 | 	.Enabled boolean? -- Whether the gradient is enabled.
  12 | 	.Color ColorSequence? -- The color sequence of the gradient.
  13 | 	.Offset UDim? -- The offset of the gradient.
  14 | 	.Rotation number? -- The rotation of the gradient.
  15 | 	.Transparency NumberSequence? -- The transparency sequence of the gradient.
  16 | ]=]
  17 | 
  18 | --[=[
  19 | 	@interface PaddingProps
  20 | 	@within Base
  21 | 
  22 | 	.Enabled boolean? -- Whether the padding is enabled.
  23 | 	.All UDim? -- The padding applied to all sides.
  24 | 	.Top UDim? -- The padding applied to the top side.
  25 | 	.Left UDim? -- The padding applied to the left side.
  26 | 	.Right UDim? -- The padding applied to the right side.
  27 | 	.Bottom UDim? -- The padding applied to the bottom side.
  28 | ]=]
  29 | 
  30 | --[=[
  31 | 	@interface CornerProps
  32 | 	@within Base
  33 | 
  34 | 	.Enabled boolean? -- Whether the corner is enabled.
  35 | 	.Radius UDim? -- The radius of the corner.
  36 | ]=]
  37 | 
  38 | --[=[
  39 | 	@interface StrokeProps
  40 | 	@within Base
  41 | 
  42 | 	.Enabled boolean? -- Whether the stroke is enabled.
  43 | 	.Thickness number? -- The thickness of the stroke.
  44 | 	.Color Color3? -- The color of the stroke.
  45 | 	.Transparency number? -- The transparency of the stroke.
  46 | 	.LineJoinMode Enum.LineJoinMode? -- The line join mode of the stroke.
  47 | 	.ApplyStrokeMode Enum.ApplyStrokeMode? -- The apply stroke mode of the stroke.
  48 | 	.Offset UDim? -- The offset of the stroke's position, relative to the parent's minimum height or width.
  49 | 	.Position Enum.BorderStrokePosition? -- The stroke's position on its parent's border.
  50 | 	.SizingMode Enum.StrokeSizingMode? -- The sizing mode of the stroke.
  51 | 	.ZIndex number? -- The render order of the stroke relative to sibling stroke instances.
  52 | 	.Gradient GradientProps? -- The gradient applied to the stroke.
  53 | ]=]
  54 | 
  55 | --[=[
  56 | 	@interface AspectProps
  57 | 	@within Base
  58 | 
  59 | 	.Enabled boolean? -- Whether the aspect ratio constraint is enabled.
  60 | 	.Ratio number? -- The aspect ratio.
  61 | 	.Type Enum.AspectType? -- The aspect type.
  62 | 	.DominantAxis Enum.DominantAxis? -- The dominant axis.
  63 | ]=]
  64 | 
  65 | --[=[
  66 | 	@interface ScaleProps
  67 | 	@within Base
  68 | 
  69 | 	.Enabled boolean? -- Whether the scale is enabled.
  70 | 	.Scale number? -- The scale factor.
  71 | ]=]
  72 | 
  73 | --[=[
  74 | 	@interface FlexProps
  75 | 	@within Base
  76 | 
  77 | 	.Enabled boolean? -- Whether the flex item is enabled.
  78 | 	.Mode Enum.UIFlexMode? -- The flex mode.
  79 | 	.ItemLineAlignment Enum.ItemLineAlignment? -- The alignment of items along the line.
  80 | 	.GrowRatio number? -- The grow ratio of the flex item.
  81 | 	.ShrinkRatio number? -- The shrink ratio of the flex item.
  82 | ]=]
  83 | 
  84 | --[=[
  85 | 	@interface ListProps
  86 | 	@within Base
  87 | 
  88 | 	.Enabled boolean? -- Whether the list layout is enabled.
  89 | 	.Padding UDim? -- The padding between items in the list.
  90 | 	.FillDirection Enum.FillDirection? -- The fill direction of the list.
  91 | 	.SortOrder Enum.SortOrder? -- The sort order of the list.
  92 | 	.Wraps boolean? -- Whether the list wraps.
  93 | 	.HorizontalAlignment Enum.HorizontalAlignment? -- The horizontal alignment of the list.
  94 | 	.HorizontalFlex boolean? -- Whether horizontal flex is enabled.
  95 | 	.VerticalAlignment Enum.VerticalAlignment? -- The vertical alignment of the list.
  96 | 	.VerticalFlex boolean? -- Whether vertical flex is enabled.
  97 | 	.ItemLineAlignment Enum.ItemLineAlignment? -- The alignment of items along the line.
  98 | ]=]
  99 | 
 100 | --[=[
 101 | 	@interface GridProps
 102 | 	@within Base
 103 | 
 104 | 	.Enabled boolean? -- Whether the grid layout is enabled.
 105 | 	.CellPadding UDim2? -- The padding between cells in the grid.
 106 | 	.CellSize UDim2? -- The size of each cell in the grid.
 107 | 	.FillDirection Enum.FillDirection? -- The fill direction of the grid.
 108 | 	.FillDirectionMaxCells number? -- The maximum number of cells in the fill direction.
 109 | 	.SortOrder Enum.SortOrder? -- The sort order of the grid.
 110 | 	.StartCorner Enum.StartCorner? -- The starting corner of the grid.
 111 | 	.HorizontalAlignment Enum.HorizontalAlignment? -- The horizontal alignment of the grid.
 112 | 	.VerticalAlignment Enum.VerticalAlignment? -- The vertical alignment of the grid.
 113 | ]=]
 114 | 
 115 | --[=[
 116 | 	@interface TableProps
 117 | 	@within Base
 118 | 
 119 | 	.Enabled boolean? -- Whether the table layout is enabled.
 120 | 	.Padding UDim? -- The padding between items in the table.
 121 | 	.FillEmptySpaceColumns boolean? -- Whether empty space in columns is filled.
 122 | 	.FillEmptySpaceRows boolean? -- Whether empty space in rows is filled.
 123 | 	.FillDirection Enum.FillDirection? -- The fill direction of the table.
 124 | 	.SortOrder Enum.SortOrder? -- The sort order of the table.
 125 | 	.MajorAxis Enum.TableMajorAxis? -- The major axis of the table.
 126 | 	.HorizontalAlignment Enum.HorizontalAlignment? -- The horizontal alignment of the table.
 127 | 	.VerticalAlignment Enum.VerticalAlignment? -- The vertical alignment of the table.
 128 | ]=]
 129 | 
 130 | --[=[
 131 | 	@interface PageProps
 132 | 	@within Base
 133 | 
 134 | 	.Enabled boolean? -- Whether the page layout is enabled.
 135 | 	.Animated boolean? -- Whether the page transitions are animated.
 136 | 	.Circular boolean? -- Whether the pages are circular.
 137 | 	.EasingDirection Enum.EasingDirection? -- The easing direction for transitions.
 138 | 	.EasingStyle Enum.EasingStyle? -- The easing style for transitions.
 139 | 	.Padding UDim? -- The padding between pages.
 140 | 	.TweenTime number? -- The time for page transitions.
 141 | 	.FillDirection Enum.FillDirection? -- The fill direction of the pages.
 142 | 	.SortOrder Enum.SortOrder? -- The sort order of the pages.
 143 | 	.HorizontalAlignment Enum.HorizontalAlignment? -- The horizontal alignment of the pages.
 144 | 	.VerticalAlignment Enum.VerticalAlignment? -- The vertical alignment of the pages.
 145 | 	.GamepadInputEnabled boolean? -- Whether gamepad input is enabled.
 146 | 	.ScrollWheelInputEnabled boolean? -- Whether scroll wheel input is enabled.
 147 | 	.TouchInputEnabled boolean? -- Whether touch input is enabled.
 148 | ]=]
 149 | 
 150 | --[=[
 151 | 	@interface SizeLimitProps
 152 | 	@within Base
 153 | 
 154 | 	.Enabled boolean? -- Whether the size constraint is enabled.
 155 | 	.Max Vector2? -- The maximum size.
 156 | 	.Min Vector2? -- The minimum size.
 157 | ]=]
 158 | 
 159 | --[=[
 160 | 	@interface TextSizeLimitProps
 161 | 	@within Base
 162 | 
 163 | 	.Enabled boolean? -- Whether the text size constraint is enabled.
 164 | 	.Max number? -- The maximum text size.
 165 | 	.Min number? -- The minimum text size.
 166 | ]=]
 167 | 
 168 | --[=[
 169 | 	@interface BaseProps
 170 | 	@within Base
 171 | 
 172 | 	.ClassName string? -- The class name of the component.
 173 | 	.Name string? -- The name of the component.
 174 | 	.Parent Instance? -- The parent instance of the component.
 175 | 	.Position UDim2? -- The position of the component.
 176 | 	.Rotation number? -- The rotation of the component.
 177 | 	.AnchorPoint Vector2? -- The anchor point of the component.
 178 | 	.Size UDim2? -- The size of the component.
 179 | 	.AutomaticSize Enum.AutomaticSize? -- The automatic size of the component.
 180 | 	.Visible boolean? -- Whether the component is visible.
 181 | 	.ZIndex number? -- The ZIndex of the component.
 182 | 	.LayoutOrder number? -- The layout order of the component.
 183 | 	.ClipsDescendants boolean? -- Whether the component clips its descendants.
 184 | 	.Active boolean? -- Whether the component is active.
 185 | 	.Selectable boolean? -- Whether the component is selectable.
 186 | 	.Interactable boolean? -- Whether the component is interactable.
 187 | 	.BackgroundColor3 Color3? -- The background color of the component.
 188 | 	.BackgroundTransparency number? -- The background transparency of the component.
 189 | 	.NextSelectionDown GuiObject? -- The next selection down.
 190 | 	.NextSelectionUp GuiObject? -- The next selection up.
 191 | 	.NextSelectionRight GuiObject? -- The next selection right.
 192 | 	.NextSelectionLeft GuiObject? -- The next selection left.
 193 | 	.SelectionImageObject GuiObject? -- The selection image object.
 194 | 	.SelectionOrder number? -- The selection order.
 195 | 	.SizeConstraint Enum.SizeConstraint? -- The size constraint of the component.
 196 | 	.AutoLocalize boolean? -- Whether the component auto-localizes.
 197 | 	.RootLocalizationTable LocalizationTable? -- The root localization table.
 198 | 	.SelectionBehaviorDown Enum.SelectionBehavior? -- The selection behavior down.
 199 | 	.SelectionBehaviorUp Enum.SelectionBehavior? -- The selection behavior up.
 200 | 	.SelectionBehaviorRight Enum.SelectionBehavior? -- The selection behavior right.
 201 | 	.SelectionBehaviorLeft Enum.SelectionBehavior? -- The selection behavior left.
 202 | 	.SelectionGroup boolean? -- Whether the component is part of a selection group.
 203 | 
 204 | 	.Corner CornerProps? -- The corner properties.
 205 | 	.Padding PaddingProps? -- The padding properties.
 206 | 	.Stroke StrokeProps? -- The stroke properties.
 207 | 	.Gradient GradientProps? -- The gradient properties.
 208 | 	.Aspect AspectProps? -- The aspect ratio properties.
 209 | 	.Scale ScaleProps? -- The scale properties.
 210 | 
 211 | 	.List ListProps? -- The list layout properties.
 212 | 	.Grid GridProps? -- The grid layout properties.
 213 | 	.Table TableProps? -- The table layout properties.
 214 | 	.Page PageProps? -- The page layout properties.
 215 | 
 216 | 	.Flex FlexProps? -- The flex layout properties.
 217 | 	.SizeLimit SizeLimitProps? -- The size limit properties.
 218 | 	.TextSizeLimit TextSizeLimitProps? -- The text size limit properties.
 219 | ]=]
 220 | 
 221 | local OnyxUI = script.Parent.Parent
 222 | local Fusion = require(OnyxUI.Parent.Fusion)
 223 | local Util = require(OnyxUI.Util)
 224 | local Themer = require(OnyxUI.Themer)
 225 | 
 226 | local Children = Fusion.Children
 227 | 
 228 | export type GradientProps = {
 229 | 	Enabled: Fusion.UsedAs<boolean>?,
 230 | 	Color: Fusion.UsedAs<ColorSequence>?,
 231 | 	Offset: Fusion.UsedAs<UDim>?,
 232 | 	Rotation: Fusion.UsedAs<number>?,
 233 | 	Transparency: Fusion.UsedAs<NumberSequence>?,
 234 | }
 235 | export type PaddingProps = {
 236 | 	Enabled: Fusion.UsedAs<boolean>?,
 237 | 	All: Fusion.UsedAs<UDim>?,
 238 | 	Top: Fusion.UsedAs<UDim>?,
 239 | 	Left: Fusion.UsedAs<UDim>?,
 240 | 	Right: Fusion.UsedAs<UDim>?,
 241 | 	Bottom: Fusion.UsedAs<UDim>?,
 242 | }
 243 | export type CornerProps = {
 244 | 	Enabled: Fusion.UsedAs<boolean>?,
 245 | 	Radius: Fusion.UsedAs<UDim>?,
 246 | }
 247 | export type StrokeProps = {
 248 | 	Enabled: Fusion.UsedAs<boolean>?,
 249 | 	Thickness: Fusion.UsedAs<number>?,
 250 | 	Color: Fusion.UsedAs<Color3>?,
 251 | 	Transparency: Fusion.UsedAs<number>?,
 252 | 	LineJoinMode: Fusion.UsedAs<Enum.LineJoinMode>?,
 253 | 	ApplyStrokeMode: Fusion.UsedAs<Enum.ApplyStrokeMode>?,
 254 | 	Offset: Fusion.UsedAs<UDim>?,
 255 | 	Position: Fusion.UsedAs<Enum.BorderStrokePosition>?,
 256 | 	SizingMode: Fusion.UsedAs<Enum.StrokeSizingMode>?,
 257 | 	ZIndex: Fusion.UsedAs<number>?,
 258 | 
 259 | 	Gradient: Fusion.UsedAs<GradientProps>?,
 260 | }
 261 | export type AspectProps = {
 262 | 	Enabled: Fusion.UsedAs<boolean>?,
 263 | 	Ratio: Fusion.UsedAs<number>?,
 264 | 	Type: Fusion.UsedAs<Enum.AspectType>?,
 265 | 	DominantAxis: Fusion.UsedAs<Enum.DominantAxis>?,
 266 | }
 267 | export type ScaleProps = {
 268 | 	Enabled: Fusion.UsedAs<boolean>?,
 269 | 	Scale: Fusion.UsedAs<number>?,
 270 | }
 271 | export type FlexProps = {
 272 | 	Enabled: Fusion.UsedAs<boolean>?,
 273 | 	Mode: Fusion.UsedAs<Enum.UIFlexMode>?,
 274 | 	ItemLineAlignment: Fusion.UsedAs<Enum.ItemLineAlignment>?,
 275 | 	GrowRatio: Fusion.UsedAs<number>?,
 276 | 	ShrinkRatio: Fusion.UsedAs<number>?,
 277 | }
 278 | export type ListProps = {
 279 | 	Enabled: Fusion.UsedAs<boolean>?,
 280 | 	Padding: Fusion.UsedAs<UDim>?,
 281 | 	FillDirection: Fusion.UsedAs<Enum.FillDirection>?,
 282 | 	SortOrder: Fusion.UsedAs<Enum.SortOrder>?,
 283 | 	Wraps: Fusion.UsedAs<boolean>?,
 284 | 	HorizontalAlignment: Fusion.UsedAs<Enum.HorizontalAlignment>?,
 285 | 	HorizontalFlex: Fusion.UsedAs<boolean>?,
 286 | 	VerticalAlignment: Fusion.UsedAs<Enum.VerticalAlignment>?,
 287 | 	VerticalFlex: Fusion.UsedAs<boolean>?,
 288 | 	ItemLineAlignment: Fusion.UsedAs<Enum.ItemLineAlignment>?,
 289 | }
 290 | export type GridProps = {
 291 | 	Enabled: Fusion.UsedAs<boolean>?,
 292 | 	CellPadding: Fusion.UsedAs<UDim>?,
 293 | 	CellSize: Fusion.UsedAs<UDim2>?,
 294 | 	FillDirection: Fusion.UsedAs<Enum.FillDirection>?,
 295 | 	FillDirectionMaxCells: Fusion.UsedAs<number>?,
 296 | 	SortOrder: Fusion.UsedAs<Enum.SortOrder>?,
 297 | 	StartCorner: Fusion.UsedAs<Enum.StartCorner>?,
 298 | 	HorizontalAlignment: Fusion.UsedAs<Enum.HorizontalAlignment>?,
 299 | 	VerticalAlignment: Fusion.UsedAs<Enum.VerticalAlignment>?,
 300 | }
 301 | export type TableProps = {
 302 | 	Enabled: Fusion.UsedAs<boolean>?,
 303 | 	Padding: Fusion.UsedAs<UDim>?,
 304 | 	FillEmptySpaceColumns: Fusion.UsedAs<boolean>?,
 305 | 	FillEmptySpaceRows: Fusion.UsedAs<boolean>?,
 306 | 	FillDirection: Fusion.UsedAs<Enum.FillDirection>?,
 307 | 	SortOrder: Fusion.UsedAs<Enum.SortOrder>?,
 308 | 	MajorAxis: Fusion.UsedAs<Enum.TableMajorAxis>?,
 309 | 	HorizontalAlignment: Fusion.UsedAs<Enum.HorizontalAlignment>?,
 310 | 	VerticalAlignment: Fusion.UsedAs<Enum.VerticalAlignment>?,
 311 | }
 312 | export type PageProps = {
 313 | 	Enabled: Fusion.UsedAs<boolean>?,
 314 | 	Animated: Fusion.UsedAs<boolean>?,
 315 | 	Circular: Fusion.UsedAs<boolean>?,
 316 | 	EasingDirection: Fusion.UsedAs<Enum.EasingDirection>?,
 317 | 	EasingStyle: Fusion.UsedAs<Enum.EasingStyle>?,
 318 | 	Padding: Fusion.UsedAs<UDim>?,
 319 | 	TweenTime: Fusion.UsedAs<number>?,
 320 | 	FillDirection: Fusion.UsedAs<Enum.FillDirection>?,
 321 | 	SortOrder: Fusion.UsedAs<Enum.SortOrder>?,
 322 | 	HorizontalAlignment: Fusion.UsedAs<Enum.HorizontalAlignment>?,
 323 | 	VerticalAlignment: Fusion.UsedAs<Enum.VerticalAlignment>?,
 324 | 	GamepadInputEnabled: Fusion.UsedAs<boolean>?,
 325 | 	ScrollWheelInputEnabled: Fusion.UsedAs<boolean>?,
 326 | 	TouchInputEnabled: Fusion.UsedAs<boolean>?,
 327 | }
 328 | export type SizeLimitProps = {
 329 | 	Enabled: Fusion.UsedAs<boolean>?,
 330 | 	Max: Fusion.UsedAs<Vector2>?,
 331 | 	Min: Fusion.UsedAs<Vector2>?,
 332 | }
 333 | export type TextSizeLimitProps = {
 334 | 	Enabled: Fusion.UsedAs<boolean>?,
 335 | 	Max: Fusion.UsedAs<number>?,
 336 | 	Min: Fusion.UsedAs<number>?,
 337 | }
 338 | export type Props = {
 339 | 	ClassName: string?,
 340 | 
 341 | 	Name: Fusion.UsedAs<string>?,
 342 | 	Parent: Fusion.UsedAs<Instance>?,
 343 | 	Position: Fusion.UsedAs<UDim2>?,
 344 | 	Rotation: Fusion.UsedAs<number>?,
 345 | 	AnchorPoint: Fusion.UsedAs<Vector2>?,
 346 | 	Size: Fusion.UsedAs<UDim2>?,
 347 | 	AutomaticSize: Fusion.UsedAs<Enum.AutomaticSize>?,
 348 | 	Visible: Fusion.UsedAs<boolean>?,
 349 | 	ZIndex: Fusion.UsedAs<number>?,
 350 | 	LayoutOrder: Fusion.UsedAs<number>?,
 351 | 	ClipsDescendants: Fusion.UsedAs<boolean>?,
 352 | 	Active: Fusion.UsedAs<boolean>?,
 353 | 	Selectable: Fusion.UsedAs<boolean>?,
 354 | 	Interactable: Fusion.UsedAs<boolean>?,
 355 | 	BackgroundColor3: Fusion.UsedAs<Color3>?,
 356 | 	BackgroundTransparency: Fusion.UsedAs<number>?,
 357 | 	NextSelectionDown: Fusion.UsedAs<GuiObject>?,
 358 | 	NextSelectionUp: Fusion.UsedAs<GuiObject>?,
 359 | 	NextSelectionRight: Fusion.UsedAs<GuiObject>?,
 360 | 	NextSelectionLeft: Fusion.UsedAs<GuiObject>?,
 361 | 	SelectionImageObject: Fusion.UsedAs<GuiObject>?,
 362 | 	SelectionOrder: Fusion.UsedAs<number>?,
 363 | 	SizeConstraint: Fusion.UsedAs<Enum.SizeConstraint>?,
 364 | 	AutoLocalize: Fusion.UsedAs<boolean>?,
 365 | 	RootLocalizationTable: Fusion.UsedAs<LocalizationTable>?,
 366 | 	SelectionBehaviorDown: Fusion.UsedAs<Enum.SelectionBehavior>?,
 367 | 	SelectionBehaviorUp: Fusion.UsedAs<Enum.SelectionBehavior>?,
 368 | 	SelectionBehaviorRight: Fusion.UsedAs<Enum.SelectionBehavior>?,
 369 | 	SelectionBehaviorLeft: Fusion.UsedAs<Enum.SelectionBehavior>?,
 370 | 	SelectionGroup: Fusion.UsedAs<boolean>?,
 371 | 
 372 | 	Corner: CornerProps?,
 373 | 	Padding: PaddingProps?,
 374 | 	Stroke: StrokeProps?,
 375 | 	Gradient: GradientProps?,
 376 | 	Aspect: AspectProps?,
 377 | 	Scale: ScaleProps?,
 378 | 
 379 | 	List: ListProps?,
 380 | 	Grid: GridProps?,
 381 | 	Table: TableProps?,
 382 | 	Page: PageProps?,
 383 | 	Flex: FlexProps?,
 384 | 
 385 | 	SizeLimit: SizeLimitProps?,
 386 | 	TextSizeLimit: TextSizeLimitProps?,
 387 | }
 388 | 
 389 | return function(Scope: Fusion.Scope<any>, Props: Props): Instance
 390 | 	local Scope = Fusion.innerScope(Scope, Fusion, Util)
 391 | 	local Theme = Themer.Theme:now()
 392 | 
 393 | 	local ClassName = Util.Fallback(Props.ClassName, "Frame")
 394 | 	local Name = Util.Fallback(Props.Name, "Base")
 395 | 	local AutomaticSize = Util.Fallback(Props.AutomaticSize, Enum.AutomaticSize.XY)
 396 | 	local BackgroundColor3 = Util.Fallback(Props.BackgroundColor3, Theme.Colors.Base.Main)
 397 | 	local Corner = Util.Fallback(Props.Corner, {
 398 | 		Radius = Scope:UDim(Scope, 0, Theme.CornerRadius["1"]),
 399 | 	})
 400 | 	local Stroke = Util.Fallback(Props.Stroke, {
 401 | 		Thickness = Theme.StrokeThickness["1"],
 402 | 		Color = Scope:Computed(function(Use)
 403 | 			return Util.Emphasize(Use(BackgroundColor3), Use(Theme.StrokeEmphasis["Regular"]))
 404 | 		end),
 405 | 		ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
 406 | 		LineJoinMode = Scope:Computed(function(Use)
 407 | 			local CornerRadiusValue = Use(Use(Corner).Radius)
 408 | 
 409 | 			if (CornerRadiusValue ~= nil) and ((CornerRadiusValue.Offset > 1) or (CornerRadiusValue.Scale > 1)) then
 410 | 				return Enum.LineJoinMode.Round
 411 | 			else
 412 | 				return Enum.LineJoinMode.Miter
 413 | 			end
 414 | 		end),
 415 | 	})
 416 | 	local Padding = Util.Fallback(Props.Padding, {
 417 | 		All = Scope:UDim(0, Theme.Padding["1"]),
 418 | 	})
 419 | 	local List = Util.Fallback(Props.List, {
 420 | 		Padding = Scope:UDim(0, Theme.Padding["1"]),
 421 | 		SortOrder = Enum.SortOrder.LayoutOrder,
 422 | 	})
 423 | 	local Grid = Util.Fallback(Props.Grid, {
 424 | 		CellPadding = Scope:UDim2Offset(Theme.Padding["1"], Theme.Padding["1"]),
 425 | 		SortOrder = Enum.SortOrder.LayoutOrder,
 426 | 	})
 427 | 	local Table = Util.Fallback(Props.Table, {
 428 | 		Padding = Scope:UDim2Offset(Theme.Padding["1"], Theme.Padding["1"]),
 429 | 		SortOrder = Enum.SortOrder.LayoutOrder,
 430 | 	})
 431 | 	local Page = Util.Fallback(Props.Page, {
 432 | 		Padding = Scope:UDim(0, Theme.Padding["1"]),
 433 | 		SortOrder = Enum.SortOrder.LayoutOrder,
 434 | 	})
 435 | 
 436 | 	local PaddingActive = Scope:Computed(function(Use)
 437 | 		local InProps = Use(Props.Padding) ~= nil
 438 | 		local PaddingValue = Use(Padding) or {}
 439 | 		local Paddings =
 440 | 			{ PaddingValue.All, PaddingValue.Top, PaddingValue.Left, PaddingValue.Right, PaddingValue.Bottom }
 441 | 
 442 | 		if InProps then
 443 | 			for _, PaddingProp in Paddings do
 444 | 				local PaddingPropValue = Use(PaddingProp)
 445 | 
 446 | 				if typeof(PaddingPropValue) == "UDim" then
 447 | 					return true
 448 | 				end
 449 | 			end
 450 | 		end
 451 | 
 452 | 		return false
 453 | 	end)
 454 | 
 455 | 	return Scope:New(ClassName) {
 456 | 		Name = Name,
 457 | 		AutomaticSize = AutomaticSize,
 458 | 
 459 | 		Parent = Props.Parent,
 460 | 		Position = Props.Position,
 461 | 		Rotation = Props.Rotation,
 462 | 		AnchorPoint = Props.AnchorPoint,
 463 | 		Size = Props.Size,
 464 | 		Visible = Props.Visible,
 465 | 		ZIndex = Props.ZIndex,
 466 | 		LayoutOrder = Props.LayoutOrder,
 467 | 		ClipsDescendants = Props.ClipsDescendants,
 468 | 		Active = Props.Active,
 469 | 		Selectable = Props.Selectable,
 470 | 		Interactable = Props.Interactable,
 471 | 		BackgroundColor3 = Props.BackgroundColor3,
 472 | 		BackgroundTransparency = Props.BackgroundTransparency,
 473 | 		NextSelectionDown = Props.NextSelectionDown,
 474 | 		NextSelectionUp = Props.NextSelectionUp,
 475 | 		NextSelectionRight = Props.NextSelectionRight,
 476 | 		NextSelectionLeft = Props.NextSelectionLeft,
 477 | 		SelectionImageObject = Props.SelectionImageObject,
 478 | 		SelectionOrder = Props.SelectionOrder,
 479 | 		SizeConstraint = Props.SizeConstraint,
 480 | 		AutoLocalize = Props.AutoLocalize,
 481 | 		RootLocalizationTable = Props.RootLocalizationTable,
 482 | 		SelectionBehaviorDown = Props.SelectionBehaviorDown,
 483 | 		SelectionBehaviorUp = Props.SelectionBehaviorUp,
 484 | 		SelectionBehaviorRight = Props.SelectionBehaviorRight,
 485 | 		SelectionBehaviorLeft = Props.SelectionBehaviorLeft,
 486 | 		SelectionGroup = Props.SelectionGroup,
 487 | 
 488 | 		[Children] = {
 489 | 			-- Styling
 490 | 			Scope:Computed(function(Use)
 491 | 				local CornerValue: CornerProps = Use(Corner) or {}
 492 | 				local InProps = Use(Props.Corner) ~= nil
 493 | 
 494 | 				if InProps and (Use(CornerValue.Enabled) ~= false) then
 495 | 					return Scope:New "UICorner" {
 496 | 						CornerRadius = CornerValue.Radius,
 497 | 					}
 498 | 				end
 499 | 			end),
 500 | 			Scope:Computed(function(Use)
 501 | 				local PaddingActiveValue = Use(PaddingActive)
 502 | 				local PaddingValue: PaddingProps = Use(Padding) or {}
 503 | 
 504 | 				if PaddingActiveValue == true then
 505 | 					return Scope:New "UIPadding" {
 506 | 						PaddingTop = Scope:Computed(function(Use)
 507 | 							local PaddingAllValue = Use(PaddingValue.All)
 508 | 							local PaddingTopValue = Use(PaddingValue.Top)
 509 | 
 510 | 							return PaddingTopValue or PaddingAllValue or UDim.new()
 511 | 						end),
 512 | 						PaddingBottom = Scope:Computed(function(Use)
 513 | 							local PaddingAllValue = Use(PaddingValue.All)
 514 | 							local PaddingBottomValue = Use(PaddingValue.Bottom)
 515 | 
 516 | 							return PaddingBottomValue or PaddingAllValue or UDim.new()
 517 | 						end),
 518 | 						PaddingLeft = Scope:Computed(function(Use)
 519 | 							local PaddingAllValue = Use(PaddingValue.All)
 520 | 							local PaddingLeftValue = Use(PaddingValue.Left)
 521 | 
 522 | 							return PaddingLeftValue or PaddingAllValue or UDim.new()
 523 | 						end),
 524 | 						PaddingRight = Scope:Computed(function(Use)
 525 | 							local PaddingAllValue = Use(PaddingValue.All)
 526 | 							local PaddingRightValue = Use(PaddingValue.Right)
 527 | 
 528 | 							return PaddingRightValue or PaddingAllValue or UDim.new()
 529 | 						end),
 530 | 					}
 531 | 				end
 532 | 			end),
 533 | 			Scope:Computed(function(Use)
 534 | 				local StrokeValue: StrokeProps = Use(Stroke) or {}
 535 | 				local InProps = Use(Props.Stroke) ~= nil
 536 | 
 537 | 				if InProps and (Use(StrokeValue.Enabled) ~= false) then
 538 | 					return Scope:New "UIStroke" {
 539 | 						Enabled = StrokeValue.Enabled,
 540 | 						Thickness = StrokeValue.Thickness,
 541 | 						Color = StrokeValue.Color,
 542 | 						Transparency = StrokeValue.Transparency,
 543 | 						ApplyStrokeMode = StrokeValue.ApplyStrokeMode,
 544 | 						LineJoinMode = StrokeValue.LineJoinMode,
 545 | 						BorderOffset = StrokeValue.Offset,
 546 | 						BorderStrokePosition = StrokeValue.Position,
 547 | 						StrokeSizingMode = StrokeValue.SizingMode,
 548 | 						ZIndex = StrokeValue.ZIndex,
 549 | 
 550 | 						[Children] = {
 551 | 							Scope:Computed(function(Use)
 552 | 								local GradientValue: GradientProps = Use(StrokeValue.Gradient) or {}
 553 | 								local GradientInProps = StrokeValue.Gradient ~= nil
 554 | 
 555 | 								if GradientInProps and (Use(GradientValue.Enabled) ~= false) then
 556 | 									return Scope:New "UIGradient" {
 557 | 										Enabled = GradientValue.Enabled,
 558 | 										Color = GradientValue.Color,
 559 | 										Offset = GradientValue.Offset,
 560 | 										Rotation = GradientValue.Rotation,
 561 | 										Transparency = GradientValue.Transparency,
 562 | 									}
 563 | 								end
 564 | 							end),
 565 | 						},
 566 | 					}
 567 | 				end
 568 | 			end),
 569 | 			Scope:Computed(function(Use)
 570 | 				local GradientValue: GradientProps = Use(Props.Gradient) or {}
 571 | 				local InProps = Use(Props.Gradient) ~= nil
 572 | 
 573 | 				if InProps and (Use(GradientValue.Enabled) ~= false) then
 574 | 					return Scope:New "UIGradient" {
 575 | 						Enabled = GradientValue.Enabled,
 576 | 						Color = GradientValue.Color,
 577 | 						Offset = GradientValue.Offset,
 578 | 						Rotation = GradientValue.Rotation,
 579 | 						Transparency = GradientValue.Transparency,
 580 | 					}
 581 | 				end
 582 | 			end),
 583 | 
 584 | 			-- Sizing
 585 | 			Scope:Computed(function(Use)
 586 | 				local ScaleValue: ScaleProps = Use(Props.Scale) or {}
 587 | 				local InProps = Use(Props.Scale) ~= nil
 588 | 
 589 | 				if InProps and (Use(ScaleValue.Enabled) ~= false) then
 590 | 					return Scope:New "UIScale" {
 591 | 						Scale = ScaleValue.Scale,
 592 | 					}
 593 | 				end
 594 | 			end),
 595 | 			Scope:Computed(function(Use)
 596 | 				local AspectValue: AspectProps = Use(Props.Aspect) or {}
 597 | 				local InProps = Use(Props.Aspect) ~= nil
 598 | 
 599 | 				if InProps and (Use(AspectValue.Enabled) ~= false) then
 600 | 					return Scope:New "UIAspectRatioConstraint" {
 601 | 						AspectRatio = AspectValue.Ratio,
 602 | 						DominantAxis = AspectValue.DominantAxis,
 603 | 						AspectType = AspectValue.Type,
 604 | 					}
 605 | 				end
 606 | 			end),
 607 | 			Scope:Computed(function(Use)
 608 | 				local SizeLimitValue: SizeLimitProps = Use(Props.SizeLimit) or {}
 609 | 
 610 | 				if
 611 | 					(Use(SizeLimitValue.Enabled) ~= false) and (Use(SizeLimitValue.Max) ~= nil)
 612 | 					or (Use(SizeLimitValue.Min) ~= nil)
 613 | 				then
 614 | 					return Scope:New "UISizeConstraint" {
 615 | 						MaxSize = SizeLimitValue.Max,
 616 | 						MinSize = SizeLimitValue.Min,
 617 | 					}
 618 | 				end
 619 | 			end),
 620 | 			Scope:Computed(function(Use)
 621 | 				local TextSizeLimitValue: TextSizeLimitProps = Use(Props.TextSizeLimit) or {}
 622 | 
 623 | 				if (Use(TextSizeLimitValue.Max) ~= nil) or (Use(TextSizeLimitValue.Min) ~= nil) then
 624 | 					return Scope:New "UITextSizeConstraint" {
 625 | 						MaxTextSize = TextSizeLimitValue.Max,
 626 | 						MinTextSize = TextSizeLimitValue.Min,
 627 | 					}
 628 | 				end
 629 | 			end),
 630 | 
 631 | 			-- Layout
 632 | 			Scope:Computed(function(Use)
 633 | 				local ListValue: ListProps = Use(List) or {}
 634 | 				local InProps = Use(Props.List) ~= nil
 635 | 
 636 | 				if InProps and (Use(ListValue.Enabled) ~= false) then
 637 | 					return Scope:New "UIListLayout" {
 638 | 						Padding = ListValue.Padding,
 639 | 						FillDirection = ListValue.FillDirection,
 640 | 						SortOrder = ListValue.SortOrder,
 641 | 						Wraps = ListValue.Wraps,
 642 | 						HorizontalAlignment = ListValue.HorizontalAlignment,
 643 | 						HorizontalFlex = ListValue.HorizontalFlex,
 644 | 						ItemLineAlignment = ListValue.ItemLineAlignment,
 645 | 						VerticalAlignment = ListValue.VerticalAlignment,
 646 | 						VerticalFlex = ListValue.VerticalFlex,
 647 | 					}
 648 | 				end
 649 | 			end),
 650 | 			Scope:Computed(function(Use)
 651 | 				local GridValue = Use(Grid) or {}
 652 | 				local InProps = Use(Props.Grid) ~= nil
 653 | 
 654 | 				if InProps and (Use(GridValue.Enabled) ~= false) then
 655 | 					return Scope:New "UIGridLayout" {
 656 | 						CellPadding = GridValue.CellPadding,
 657 | 						CellSize = GridValue.CellSize,
 658 | 						FillDirection = GridValue.FillDirection,
 659 | 						FillDirectionMaxCells = GridValue.FillDirectionMaxCells,
 660 | 						SortOrder = GridValue.SortOrder,
 661 | 						StartCorner = GridValue.StartCorner,
 662 | 						HorizontalAlignment = GridValue.HorizontalAlignment,
 663 | 						VerticalAlignment = GridValue.VerticalAlignment,
 664 | 					}
 665 | 				end
 666 | 			end),
 667 | 			Scope:Computed(function(Use)
 668 | 				local TableValue = Use(Table) or {}
 669 | 				local InProps = Use(Props.Table) ~= nil
 670 | 
 671 | 				if InProps and (Use(TableValue.Enabled) ~= false) then
 672 | 					return Scope:New "UITableLayout" {
 673 | 						Padding = TableValue.Padding,
 674 | 						FillEmptySpaceColumns = TableValue.FillEmptySpaceColumns,
 675 | 						FillEmptySpaceRows = TableValue.FillEmptySpaceRows,
 676 | 						FillDirection = TableValue.FillDirection,
 677 | 						SortOrder = TableValue.SortOrder,
 678 | 						MajorAxis = TableValue.MajorAxis,
 679 | 						HorizontalAlignment = TableValue.HorizontalAlignment,
 680 | 						VerticalAlignment = TableValue.VerticalAlignment,
 681 | 					}
 682 | 				else
 683 | 					return
 684 | 				end
 685 | 			end),
 686 | 			Scope:Computed(function(Use)
 687 | 				local PageValue = Use(Page) or {}
 688 | 				local InProps = Use(Props.Page) ~= nil
 689 | 
 690 | 				if InProps and (Use(PageValue.Enabled) ~= false) then
 691 | 					return Scope:New "UIPageLayout" {
 692 | 						Animated = PageValue.Animated,
 693 | 						Circular = PageValue.Circular,
 694 | 						EasingDirection = PageValue.EasingDirection,
 695 | 						EasingStyle = PageValue.EasingStyle,
 696 | 						Padding = PageValue.Padding,
 697 | 						TweenTime = PageValue.TweenTime,
 698 | 						FillDirection = PageValue.FillDirection,
 699 | 						SortOrder = PageValue.SortOrder,
 700 | 						HorizontalAlignment = PageValue.HorizontalAlignment,
 701 | 						VerticalAlignment = PageValue.VerticalAlignment,
 702 | 						GamepadInputEnabled = PageValue.GamepadInputEnabled,
 703 | 						ScrollWheelInputEnabled = PageValue.ScrollWheelInputEnabled,
 704 | 						TouchInputEnabled = PageValue.TouchInputEnabled,
 705 | 					}
 706 | 				end
 707 | 			end),
 708 | 			Scope:Computed(function(Use)
 709 | 				local FlexValue = Use(Props.Flex) or {}
 710 | 				local InProps = Use(Props.Flex) ~= nil
 711 | 
 712 | 				if InProps and (Use(FlexValue.Mode) ~= Enum.UIFlexMode.None) then
 713 | 					return Scope:New "UIFlexItem" {
 714 | 						FlexMode = FlexValue.Mode,
 715 | 						FlexItemLineAlignment = FlexValue.ItemLineAlignment,
 716 | 						FlexGrowRatio = FlexValue.GrowRatio,
 717 | 						FlexShrinkRatio = FlexValue.ShrinkRatio,
 718 | 					}
 719 | 				end
 720 | 			end),
 721 | 
 722 | 			Props[Children],
 723 | 		},
 724 | 	}
 725 | end
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Components/Base.story.luau`
<details>
<summary>View Source (146 lines)</summary>

```lua
   1 | local OnyxUI = script.Parent.Parent
   2 | local Fusion = require(OnyxUI.Parent.Fusion)
   3 | local Themer = require(OnyxUI.Themer)
   4 | local Util = require(OnyxUI.Util)
   5 | local Components = require(OnyxUI.Components)
   6 | 
   7 | local Children = Fusion.Children
   8 | 
   9 | return {
  10 | 	story = function(Props)
  11 | 		local Theme = Themer.Theme:now()
  12 | 		local Scope = Fusion.innerScope(Props.scope, Fusion, Util, Components)
  13 | 
  14 | 		Scope:Base {
  15 | 			Parent = Props.target,
  16 | 			BackgroundTransparency = 1,
  17 | 			List = {},
  18 | 			Padding = {
  19 | 				All = Scope:UDim(0, Theme.StrokeThickness["1"]),
  20 | 			},
  21 | 
  22 | 			[Children] = {
  23 | 				Scope:Base {
  24 | 					ClassName = "Frame",
  25 | 					Size = UDim2.fromOffset(100, 100),
  26 | 					Corner = {
  27 | 						-- Enabled = false,
  28 | 						Radius = UDim.new(0, 100),
  29 | 					},
  30 | 					Padding = {
  31 | 						Left = UDim.new(0, 50),
  32 | 					},
  33 | 					Stroke = {
  34 | 						Thickness = 5,
  35 | 						Color = Color3.fromRGB(255, 0, 0),
  36 | 						Offset = UDim.new(0, 5),
  37 | 						Position = Enum.BorderStrokePosition.Outer,
  38 | 						SizingMode = Enum.StrokeSizingMode.FixedSize,
  39 | 						ZIndex = 34,
  40 | 					},
  41 | 				},
  42 | 				Scope:Base {
  43 | 					ClassName = "Frame",
  44 | 					AutomaticSize = Enum.AutomaticSize.XY,
  45 | 					Padding = {
  46 | 						All = UDim.new(0, 30),
  47 | 						Left = UDim.new(0, 10),
  48 | 					},
  49 | 					List = {
  50 | 						Padding = UDim.new(0, 15),
  51 | 					},
  52 | 
  53 | 					[Children] = {
  54 | 						Scope:Base {
  55 | 							ClassName = "TextButton",
  56 | 							Size = UDim2.fromOffset(200, 50),
  57 | 							BackgroundColor3 = Color3.fromRGB(255, 0, 0),
  58 | 							Stroke = {
  59 | 								Thickness = 3,
  60 | 								ApplyMode = Enum.ApplyStrokeMode.Border,
  61 | 								Transparency = 0.5,
  62 | 								LineJoinMode = Enum.LineJoinMode.Miter,
  63 | 							},
  64 | 						},
  65 | 						Scope:Base {
  66 | 							ClassName = "TextButton",
  67 | 							Size = UDim2.fromOffset(200, 50),
  68 | 							BackgroundColor3 = Color3.fromRGB(255, 0, 0),
  69 | 							Text = "Button",
  70 | 							Scale = {
  71 | 								Scale = 0.95,
  72 | 							},
  73 | 							Stroke = {
  74 | 								Thickness = 3,
  75 | 								Color = Color3.fromRGB(0, 0, 0),
  76 | 								ApplyMode = Enum.ApplyStrokeMode.Border,
  77 | 							},
  78 | 							Corner = {
  79 | 								Radius = UDim.new(0, 15),
  80 | 							},
  81 | 							Gradient = {
  82 | 								Color = ColorSequence.new({
  83 | 									ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
  84 | 									ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 0, 0)),
  85 | 								}),
  86 | 								Rotation = 90,
  87 | 								Transparency = NumberSequence.new(0, 0.5),
  88 | 							},
  89 | 						},
  90 | 						Scope:Base {
  91 | 							ClassName = "TextButton",
  92 | 							Size = UDim2.fromOffset(200, 50),
  93 | 							BackgroundColor3 = Color3.fromRGB(255, 0, 0),
  94 | 							Stroke = {
  95 | 								Thickness = 3,
  96 | 								ApplyMode = Enum.ApplyStrokeMode.Border,
  97 | 							},
  98 | 							Aspect = {
  99 | 								Ratio = 1,
 100 | 								DominantAxis = Enum.DominantAxis.Height,
 101 | 								AspectType = Enum.AspectType.ScaleWithParentSize,
 102 | 							},
 103 | 						},
 104 | 					},
 105 | 				},
 106 | 				Scope:Base {
 107 | 					ClassName = "Frame",
 108 | 					Size = UDim2.fromOffset(200, 200),
 109 | 					BackgroundColor3 = Color3.fromRGB(255, 0, 0),
 110 | 					Grid = {
 111 | 						CellSize = UDim2.fromOffset(50, 50),
 112 | 					},
 113 | 					Padding = {
 114 | 						All = UDim.new(0, 10),
 115 | 					},
 116 | 					Corner = {
 117 | 						Radius = UDim.new(0, 10),
 118 | 					},
 119 | 
 120 | 					[Children] = {
 121 | 						Scope:Base {
 122 | 							ClassName = "Frame",
 123 | 						},
 124 | 						Scope:Base {
 125 | 							ClassName = "Frame",
 126 | 							Stroke = {
 127 | 								Color = Color3.fromRGB(0, 0, 255),
 128 | 								Thickness = 2,
 129 | 							},
 130 | 						},
 131 | 						Scope:Base {
 132 | 							ClassName = "Frame",
 133 | 						},
 134 | 						Scope:Base {
 135 | 							ClassName = "Frame",
 136 | 						},
 137 | 						Scope:Base {
 138 | 							ClassName = "Frame",
 139 | 						},
 140 | 					},
 141 | 				},
 142 | 			},
 143 | 		}
 144 | 	end,
 145 | 	fusion = Fusion,
 146 | }
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Components/BaseButton.luau`
<details>
<summary>View Source (143 lines)</summary>

```lua
   1 | --[=[
   2 | 		@class BaseButton
   3 | 		
   4 | 		A barebones button component, like if Roblox had a "`Button`" class rather than only a `TextButton`.
   5 | ]=]
   6 | 
   7 | --[=[
   8 | 	@interface BaseButtonProps
   9 | 	@within BaseButton
  10 | 
  11 | 	. ... BaseProps -- All Base properties are accepted.
  12 | 	.Disabled boolean? -- Whether the button is disabled.
  13 | 	.OnActivate (() -> ())? -- Callback for when the button is activated.
  14 | 	.OnHover (() -> ())? -- Callback for when the button is hovered over.
  15 | 	.OnHoverEnd (() -> ())? -- Callback for when the hover ends.
  16 | 	.OnHold (() -> ())? -- Callback for when the button is held.
  17 | 	.OnHoldEnd (() -> ())? -- Callback for when the hold ends.
  18 | 	.Hovering boolean? -- Whether the button is currently being hovered over.
  19 | 	.Holding boolean? -- Whether the button is currently being held.
  20 | 	.HoverSound Sound? -- The sound to play when the button is hovered over.
  21 | 	.ClickSound Sound? -- The sound to play when the button is clicked.
  22 | ]=]
  23 | 
  24 | local SoundService = game:GetService("SoundService")
  25 | 
  26 | local OnyxUI = script.Parent.Parent
  27 | local Fusion = require(OnyxUI.Parent.Fusion)
  28 | local Util = require(OnyxUI.Util)
  29 | local Themer = require(OnyxUI.Themer)
  30 | 
  31 | local OnEvent = Fusion.OnEvent
  32 | 
  33 | local Base = require(script.Parent.Base)
  34 | local Components = {
  35 | 	Base = Base,
  36 | }
  37 | 
  38 | export type Props = Base.Props & {
  39 | 	Disabled: Fusion.UsedAs<boolean>?,
  40 | 
  41 | 	OnActivate: Fusion.UsedAs<() -> ()>?,
  42 | 	OnHover: Fusion.UsedAs<() -> ()>?,
  43 | 	OnHoverEnd: Fusion.UsedAs<() -> ()>?,
  44 | 	OnHold: Fusion.UsedAs<() -> ()>?,
  45 | 	OnHoldEnd: Fusion.UsedAs<() -> ()>?,
  46 | 
  47 | 	Hovering: Fusion.UsedAs<boolean>?,
  48 | 	Holding: Fusion.UsedAs<boolean>?,
  49 | 
  50 | 	HoverSound: Fusion.UsedAs<Sound>?,
  51 | 	ClickSound: Fusion.UsedAs<Sound>?,
  52 | }
  53 | 
  54 | return function(Scope: Fusion.Scope<any>, Props: Props)
  55 | 	local Scope = Fusion.innerScope(Scope, Fusion, Util, Components)
  56 | 	local Theme = Themer.Theme:now()
  57 | 
  58 | 	local Disabled = Util.Fallback(Props.Disabled, false)
  59 | 	local OnActivate = Util.Fallback(Props.OnActivate, function() end)
  60 | 	local OnHover = Util.Fallback(Props.OnHover, function() end)
  61 | 	local OnHoverEnd = Util.Fallback(Props.OnHoverEnd, function() end)
  62 | 	local OnHold = Util.Fallback(Props.OnHold, function() end)
  63 | 	local OnHoldEnd = Util.Fallback(Props.OnHoldEnd, function() end)
  64 | 	local HoverSound = Util.Fallback(Props.HoverSound, Theme.Sound.Hover)
  65 | 	local ClickSound = Util.Fallback(Props.ClickSound, Theme.Sound.Click)
  66 | 	local Active = Util.Fallback(
  67 | 		Props.Active,
  68 | 		Scope:Computed(function(Use)
  69 | 			return not Use(Disabled)
  70 | 		end)
  71 | 	)
  72 | 	local Selectable = Util.Fallback(
  73 | 		Props.Selectable,
  74 | 		Scope:Computed(function(Use)
  75 | 			return not Use(Disabled)
  76 | 		end)
  77 | 	)
  78 | 
  79 | 	local Hovering = Scope:EnsureValue(Util.Fallback(Props.Hovering, false))
  80 | 	local Holding = Scope:EnsureValue(Util.Fallback(Props.Holding, false))
  81 | 
  82 | 	return Scope:Hydrate(Scope:Base(Util.CombineProps(Props, {
  83 | 		ClassName = "TextButton",
  84 | 		Name = script.Name,
  85 | 		AutomaticSize = Enum.AutomaticSize.XY,
  86 | 		Selectable = Selectable,
  87 | 		BackgroundTransparency = 1,
  88 | 	}))) {
  89 | 		Text = "",
  90 | 		RichText = false,
  91 | 		TextSize = 0,
  92 | 
  93 | 		[OnEvent "Activated"] = function()
  94 | 			if not Fusion.peek(Disabled) then
  95 | 				SoundService:PlayLocalSound(Fusion.peek(ClickSound))
  96 | 
  97 | 				Fusion.peek(OnActivate)()
  98 | 			end
  99 | 		end,
 100 | 		[OnEvent "MouseEnter"] = function()
 101 | 			if Fusion.peek(Active) then
 102 | 				SoundService:PlayLocalSound(Fusion.peek(HoverSound))
 103 | 			end
 104 | 
 105 | 			Hovering:set(true)
 106 | 
 107 | 			Fusion.peek(OnHover)()
 108 | 		end,
 109 | 		[OnEvent "SelectionGained"] = function()
 110 | 			if Fusion.peek(Active) then
 111 | 				SoundService:PlayLocalSound(Fusion.peek(HoverSound))
 112 | 			end
 113 | 
 114 | 			Hovering:set(true)
 115 | 
 116 | 			Fusion.peek(OnHover)()
 117 | 		end,
 118 | 		[OnEvent "SelectionLost"] = function()
 119 | 			Hovering:set(false)
 120 | 			Holding:set(false)
 121 | 
 122 | 			Fusion.peek(OnHoverEnd)()
 123 | 		end,
 124 | 		[OnEvent "MouseLeave"] = function()
 125 | 			Hovering:set(false)
 126 | 			Holding:set(false)
 127 | 
 128 | 			Fusion.peek(OnHoverEnd)()
 129 | 		end,
 130 | 		[OnEvent "MouseButton1Down"] = function()
 131 | 			if not Fusion.peek(Disabled) then
 132 | 				Holding:set(true)
 133 | 
 134 | 				Fusion.peek(OnHold)()
 135 | 			end
 136 | 		end,
 137 | 		[OnEvent "MouseButton1Up"] = function()
 138 | 			Holding:set(false)
 139 | 
 140 | 			Fusion.peek(OnHoldEnd)()
 141 | 		end,
 142 | 	}
 143 | end
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Components/Button.luau`
<details>
<summary>View Source (229 lines)</summary>

```lua
   1 | --[=[
   2 | 		@class Button
   3 | 		
   4 | 		A robust button component, supporting text and icons, and multiple variants.
   5 | ]=]
   6 | 
   7 | --[=[
   8 | 	@interface ButtonProps
   9 | 	@within Button
  10 | 
  11 | 	. ... BaseButtonProps -- All BaseButton properties are accepted.
  12 | 	.Disabled boolean? -- Whether the button is disabled.
  13 | 	.Style string? -- The style of the button (e.g., "Filled", "Outlined", "Ghost").
  14 | 	.Color Color3? -- The background color of the button.
  15 | 	.Content {string}? -- The content of the button (e.g., text or icons).
  16 | 	.ContentColor Color3? -- The color of the button's content.
  17 | 	.ContentSize number? -- The size of the button's content.
  18 | 	.ContentWrapped boolean? -- Whether the content should wrap.
  19 | 	.SizeVariant "ExtraSmall" | "Small" | "Medium" | "Large" | "ExtraLarge"? -- The size variant of the button.
  20 | 	.Holding boolean? -- Whether the button is being held.
  21 | 	.Hovering boolean? -- Whether the button is being hovered over.
  22 | ]=]
  23 | 
  24 | local OnyxUI = script.Parent.Parent
  25 | local Fusion = require(OnyxUI.Parent.Fusion)
  26 | local Util = require(OnyxUI.Util)
  27 | local Themer = require(OnyxUI.Themer)
  28 | local ColorUtils = require(OnyxUI.Parent.ColorUtils)
  29 | 
  30 | local Children = Fusion.Children
  31 | 
  32 | local BaseButton = require(script.Parent.BaseButton)
  33 | local IconText = require(script.Parent.IconText)
  34 | local Components = {
  35 | 	BaseButton = BaseButton,
  36 | 	IconText = IconText,
  37 | }
  38 | 
  39 | local DISABLED_BACKGROUND_TRANSPARENCY = 0.925
  40 | local DISABLED_CONTENT_TRANSPARENCY = 0.75
  41 | 
  42 | export type Props = BaseButton.Props & {
  43 | 	Disabled: Fusion.UsedAs<boolean>?,
  44 | 	Style: Fusion.UsedAs<string>?,
  45 | 	Color: Fusion.UsedAs<Color3>?,
  46 | 	Content: Fusion.UsedAs<{ string }>?,
  47 | 	ContentColor: Fusion.UsedAs<Color3>?,
  48 | 	ContentSize: Fusion.UsedAs<number>?,
  49 | 	ContentWrapped: Fusion.UsedAs<boolean>?,
  50 | 	SizeVariant: Fusion.UsedAs<"ExtraSmall" | "Small" | "Medium" | "Large" | "ExtraLarge">?,
  51 | 	Holding: Fusion.UsedAs<boolean>?,
  52 | }
  53 | 
  54 | return function(Scope: Fusion.Scope<any>, Props: Props)
  55 | 	local Scope = Fusion.innerScope(Scope, Fusion, Util, Components)
  56 | 	local Theme = Themer.Theme:now()
  57 | 
  58 | 	local SizeVariant = Util.Fallback(Props.SizeVariant, "Medium")
  59 | 	local Disabled = Util.Fallback(Props.Disabled, false)
  60 | 	local Content = Util.Fallback(Props.Content, {})
  61 | 	local Style = Util.Fallback(Props.Style, "Filled")
  62 | 	local Color = Util.Fallback(Props.Color, Theme.Colors.Neutral.Main)
  63 | 	local ContentColor = Util.Fallback(
  64 | 		Props.ContentColor,
  65 | 		Scope:Computed(function(Use)
  66 | 			return Util.Emphasize(Use(Color), Use(Theme.Emphasis.Contrast))
  67 | 		end)
  68 | 	)
  69 | 	local ContentSize = Util.Fallback(
  70 | 		Props.ContentSize,
  71 | 		Scope:Computed(function(Use)
  72 | 			local VariantSizes = {
  73 | 				ExtraSmall = Use(Theme.TextSize["0.875"]),
  74 | 				Small = Use(Theme.TextSize["1"]),
  75 | 				Medium = Use(Theme.TextSize["1"]),
  76 | 				Large = Use(Theme.TextSize["1.25"]),
  77 | 				ExtraLarge = Use(Theme.TextSize["1.25"]),
  78 | 			}
  79 | 
  80 | 			return VariantSizes[Use(SizeVariant)]
  81 | 		end)
  82 | 	)
  83 | 	local ContentWrapped = Util.Fallback(Props.ContentWrapped, false)
  84 | 
  85 | 	local Hovering = Scope:EnsureValue(Util.Fallback(Props.Hovering, false))
  86 | 	local Holding = Scope:EnsureValue(Util.Fallback(Props.Holding, false))
  87 | 
  88 | 	local EffectiveColor = Scope:Computed(function(Use)
  89 | 		if Use(Disabled) then
  90 | 			return Use(Theme.Colors.BaseContent.Main)
  91 | 		else
  92 | 			local BaseColor = Use(Color)
  93 | 
  94 | 			if Use(Holding) then
  95 | 				return Util.Emphasize(BaseColor, Use(Theme.Emphasis.Regular))
  96 | 			elseif Use(Hovering) then
  97 | 				return Util.Emphasize(BaseColor, Use(Theme.Emphasis.Light))
  98 | 			else
  99 | 				return BaseColor
 100 | 			end
 101 | 		end
 102 | 	end)
 103 | 	local EffectiveContentColor = Scope:Computed(function(Use)
 104 | 		if Use(Disabled) then
 105 | 			return Use(Theme.Colors.BaseContent.Main)
 106 | 		else
 107 | 			if Use(Style) == "Filled" then
 108 | 				return Use(ContentColor)
 109 | 			elseif Use(Style) == "Outlined" then
 110 | 				return Use(EffectiveColor)
 111 | 			elseif Use(Style) == "Ghost" then
 112 | 				return Use(EffectiveColor)
 113 | 			else
 114 | 				return Use(ContentColor)
 115 | 			end
 116 | 		end
 117 | 	end)
 118 | 	local EffectiveStrokeEmphasis = Scope:Computed(function(Use)
 119 | 		local StrokeEmphasis = Use(Theme.StrokeEmphasis.Regular)
 120 | 
 121 | 		if (Use(Style) ~= "Filled") or Use(Disabled) or Use(Hovering) or Use(Holding) then
 122 | 			return 0
 123 | 		else
 124 | 			return StrokeEmphasis
 125 | 		end
 126 | 	end)
 127 | 	local EffectiveContentTransparency = Scope:Computed(function(Use)
 128 | 		if Use(Disabled) then
 129 | 			return DISABLED_CONTENT_TRANSPARENCY
 130 | 		else
 131 | 			return 0
 132 | 		end
 133 | 	end)
 134 | 	local PaddingX = Scope:Computed(function(Use)
 135 | 		local VariantSizes = {
 136 | 			ExtraSmall = Use(Theme.Padding["0.25"]),
 137 | 			Small = Use(Theme.Padding["0.5"]),
 138 | 			Medium = Use(Theme.Padding["0.75"]),
 139 | 			Large = Use(Theme.Padding["1"]),
 140 | 			ExtraLarge = Use(Theme.Padding["1.5"]),
 141 | 		}
 142 | 
 143 | 		return UDim.new(0, VariantSizes[Use(SizeVariant)])
 144 | 	end)
 145 | 	local PaddingY = Scope:Computed(function(Use)
 146 | 		local VariantSizes = {
 147 | 			ExtraSmall = 0.5,
 148 | 			Small = 0.75,
 149 | 			Medium = 1.25,
 150 | 			Large = 1.5,
 151 | 			ExtraLarge = 2,
 152 | 		}
 153 | 
 154 | 		return UDim.new(0, Use(Theme.Padding["0.25"]) * VariantSizes[Use(SizeVariant)])
 155 | 	end)
 156 | 
 157 | 	return Scope:BaseButton(Util.CombineProps(Props, {
 158 | 		Name = script.Name,
 159 | 		BackgroundTransparency = Scope:Computed(function(Use)
 160 | 			if Use(Style) == "Filled" then
 161 | 				if Use(Disabled) then
 162 | 					return DISABLED_BACKGROUND_TRANSPARENCY
 163 | 				else
 164 | 					return 0
 165 | 				end
 166 | 			else
 167 | 				return 1
 168 | 			end
 169 | 		end),
 170 | 		BackgroundColor3 = Scope:Spring(EffectiveColor, Theme.SpringSpeed["1"], Theme.SpringDampening["1"]),
 171 | 		Padding = {
 172 | 			Left = PaddingX,
 173 | 			Right = PaddingX,
 174 | 			Top = PaddingY,
 175 | 			Bottom = PaddingY,
 176 | 		},
 177 | 		Corner = {
 178 | 			Radius = Scope:UDim(0, Theme.CornerRadius["1"]),
 179 | 		},
 180 | 		List = {
 181 | 			FillDirection = Enum.FillDirection.Horizontal,
 182 | 			HorizontalAlignment = Enum.HorizontalAlignment.Center,
 183 | 			VerticalAlignment = Enum.VerticalAlignment.Center,
 184 | 			Wraps = false,
 185 | 		},
 186 | 		Stroke = {
 187 | 			Color = Color3.fromRGB(255, 255, 255),
 188 | 			Gradient = {
 189 | 				Color = Scope:Computed(function(Use)
 190 | 					return ColorSequence.new({
 191 | 						ColorSequenceKeypoint.new(
 192 | 							0,
 193 | 							ColorUtils.Lighten(Use(EffectiveColor), Use(EffectiveStrokeEmphasis))
 194 | 						),
 195 | 						ColorSequenceKeypoint.new(1, Use(EffectiveColor)),
 196 | 					})
 197 | 				end),
 198 | 				Rotation = 90,
 199 | 			},
 200 | 			Transparency = Scope:Computed(function(Use)
 201 | 				if Use(Style) == "Ghost" then
 202 | 					return 1
 203 | 				elseif Use(Disabled) then
 204 | 					return DISABLED_BACKGROUND_TRANSPARENCY
 205 | 				else
 206 | 					return 0
 207 | 				end
 208 | 			end),
 209 | 		},
 210 | 
 211 | 		Holding = Holding,
 212 | 		Hovering = Hovering,
 213 | 
 214 | 		[Children] = {
 215 | 			Scope:IconText {
 216 | 				Content = Content,
 217 | 				ContentColor = EffectiveContentColor,
 218 | 				ContentTransparency = EffectiveContentTransparency,
 219 | 				ContentSize = ContentSize,
 220 | 				ContentWrapped = ContentWrapped,
 221 | 				List = {
 222 | 					Padding = Scope:UDim(0, Theme.Spacing["0.25"]),
 223 | 					VerticalAlignment = Enum.VerticalAlignment.Center,
 224 | 					HorizontalAlignment = Enum.HorizontalAlignment.Center,
 225 | 				},
 226 | 			},
 227 | 		},
 228 | 	}))
 229 | end
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Components/Button.story.luau`
<details>
<summary>View Source (115 lines)</summary>

```lua
   1 | local OnyxUI = script.Parent.Parent
   2 | local Fusion = require(OnyxUI.Parent.Fusion)
   3 | local Util = require(OnyxUI.Util)
   4 | local Themer = require(OnyxUI.Themer)
   5 | 
   6 | local Children = Fusion.Children
   7 | 
   8 | local Button = require(script.Parent.Button)
   9 | local Frame = require(script.Parent.Frame)
  10 | local Divider = require(script.Parent.Divider)
  11 | local Components = {
  12 | 	Button = Button,
  13 | 	Frame = Frame,
  14 | 	Divider = Divider,
  15 | }
  16 | 
  17 | return {
  18 | 	story = function(Props)
  19 | 		local Scope = Fusion.innerScope(Props.scope, Fusion, Util, Components)
  20 | 		local Theme = Themer.Theme:now()
  21 | 
  22 | 		Scope:Frame {
  23 | 			Parent = Props.target,
  24 | 			List = {
  25 | 				Padding = Scope:UDim(0, Theme.Spacing["0.5"]),
  26 | 			},
  27 | 			Padding = {
  28 | 				All = Scope:UDim(0, Theme.StrokeThickness["1"]),
  29 | 			},
  30 | 
  31 | 			[Children] = {
  32 | 				Scope:Button {
  33 | 					Content = { "Button" },
  34 | 				},
  35 | 				Scope:Button {
  36 | 					Content = { "Button" },
  37 | 					Color = Theme.Colors.BaseContent.Main,
  38 | 				},
  39 | 				Scope:Button {
  40 | 					Content = { "Button" },
  41 | 					Color = Theme.Colors.Primary.Main,
  42 | 				},
  43 | 				Scope:Button {
  44 | 					Content = { "Button" },
  45 | 					Style = "Outlined",
  46 | 					Color = Theme.Colors.Primary.Main,
  47 | 				},
  48 | 				Scope:Button {
  49 | 					Content = { "rbxassetid://11560341132", "Purchase" },
  50 | 					Color = Color3.fromRGB(86, 255, 70),
  51 | 				},
  52 | 				Scope:Button {
  53 | 					Content = { "rbxassetid://13405228418", "Delete" },
  54 | 					Style = "Outlined",
  55 | 					Color = Theme.Colors.Error.Main,
  56 | 				},
  57 | 				Scope:Button {
  58 | 					Content = { "Ghost" },
  59 | 					Style = "Ghost",
  60 | 					Color = Theme.Colors.BaseContent.Main,
  61 | 				},
  62 | 				Scope:Button {
  63 | 					Content = { "rbxassetid://11560341132", "Bobux" },
  64 | 					Color = Color3.fromRGB(86, 255, 70),
  65 | 					Disabled = true,
  66 | 				},
  67 | 				Scope:Button {
  68 | 					Content = { "Testing" },
  69 | 					Color = Color3.fromRGB(86, 255, 70),
  70 | 					Disabled = true,
  71 | 					Style = "Outlined",
  72 | 				},
  73 | 				Scope:Divider {},
  74 | 				Scope:Frame {
  75 | 					List = {
  76 | 						FillDirection = Enum.FillDirection.Horizontal,
  77 | 						VerticalAlignment = Enum.VerticalAlignment.Center,
  78 | 					},
  79 | 					Padding = {
  80 | 						All = Scope:UDim(0, Theme.Padding["1"]),
  81 | 					},
  82 | 
  83 | 					[Children] = {
  84 | 						Scope:Button {
  85 | 							Content = { "Button (xs)" },
  86 | 							SizeVariant = "ExtraSmall",
  87 | 							Color = Theme.Colors.Primary.Main,
  88 | 						},
  89 | 						Scope:Button {
  90 | 							Content = { "Button (sm)" },
  91 | 							SizeVariant = "Small",
  92 | 							Color = Theme.Colors.Primary.Main,
  93 | 						},
  94 | 						Scope:Button {
  95 | 							Content = { "Button (md)" },
  96 | 							SizeVariant = "Medium",
  97 | 							Color = Theme.Colors.Primary.Main,
  98 | 						},
  99 | 						Scope:Button {
 100 | 							Content = { "Button (lg)" },
 101 | 							SizeVariant = "Large",
 102 | 							Color = Theme.Colors.Primary.Main,
 103 | 						},
 104 | 						Scope:Button {
 105 | 							Content = { "Button (xl)" },
 106 | 							SizeVariant = "ExtraLarge",
 107 | 							Color = Theme.Colors.Primary.Main,
 108 | 						},
 109 | 					},
 110 | 				},
 111 | 			},
 112 | 		}
 113 | 	end,
 114 | 	fusion = Fusion,
 115 | }
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Components/Card.luau`
<details>
<summary>View Source (48 lines)</summary>

```lua
   1 | --[=[
   2 | 		@class Card
   3 | 		
   4 | 		Useful for grouping and displaying Content in a user friendly way.
   5 | ]=]
   6 | 
   7 | --[=[
   8 | 		@within Card
   9 | 		@interface CardProps
  10 | 
  11 | 		. ... FrameProps -- All Frame properties are accepted.
  12 | ]=]
  13 | 
  14 | local OnyxUI = script.Parent.Parent
  15 | local Fusion = require(OnyxUI.Parent.Fusion)
  16 | local Themer = require(OnyxUI.Themer)
  17 | local Util = require(OnyxUI.Util)
  18 | 
  19 | local Frame = require(script.Parent.Frame)
  20 | local Components = {
  21 | 	Frame = Frame,
  22 | }
  23 | 
  24 | export type Props = Frame.Props & {}
  25 | 
  26 | return function(Scope: Fusion.Scope<any>, Props: Props)
  27 | 	local Scope = Fusion.innerScope(Scope, Fusion, Util, Components)
  28 | 	local Theme = Themer.Theme:now()
  29 | 
  30 | 	local BackgroundColor3 = Util.Fallback(Props.BackgroundColor3, Theme.Colors.Base.Main)
  31 | 
  32 | 	return Scope:Frame(Util.CombineProps(Props, {
  33 | 		Name = script.Name,
  34 | 		BackgroundColor3 = BackgroundColor3,
  35 | 		BackgroundTransparency = 0,
  36 | 		Corner = {
  37 | 			Radius = Scope:UDim(0, Theme.CornerRadius["1"]),
  38 | 		},
  39 | 		Padding = {
  40 | 			All = Scope:UDim(0, Theme.Padding["1"]),
  41 | 		},
  42 | 		Stroke = {
  43 | 			Color = Scope:Computed(function(Use)
  44 | 				return Util.Emphasize(Use(BackgroundColor3), Use(Theme.StrokeEmphasis.Light))
  45 | 			end),
  46 | 		},
  47 | 	}))
  48 | end
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Components/Card.story.luau`
<details>
<summary>View Source (61 lines)</summary>

```lua
   1 | local OnyxUI = script.Parent.Parent
   2 | local Fusion = require(OnyxUI.Parent.Fusion)
   3 | local Themer = require(OnyxUI.Themer)
   4 | local Util = require(OnyxUI.Util)
   5 | 
   6 | local Children = Fusion.Children
   7 | 
   8 | local Frame = require(OnyxUI.Components.Frame)
   9 | local Card = require(OnyxUI.Components.Card)
  10 | local Text = require(OnyxUI.Components.Text)
  11 | local Divider = require(OnyxUI.Components.Divider)
  12 | local Components = {
  13 | 	Frame = Frame,
  14 | 	Divider = Divider,
  15 | 	Text = Text,
  16 | 	Card = Card,
  17 | }
  18 | 
  19 | return {
  20 | 	story = function(Props)
  21 | 		local Scope = Fusion.innerScope(Props.scope, Fusion, Util, Components)
  22 | 		local Theme = Themer.Theme:now()
  23 | 
  24 | 		Scope:Frame {
  25 | 			Parent = Props.target,
  26 | 			Size = UDim2.fromOffset(300, 0),
  27 | 			AutomaticSize = Enum.AutomaticSize.Y,
  28 | 			List = {
  29 | 				FillDirection = Enum.FillDirection.Vertical,
  30 | 				Padding = Scope:UDim(0, Theme.Spacing["0.75"]),
  31 | 			},
  32 | 
  33 | 			[Children] = {
  34 | 				Scope:Card {
  35 | 					Size = UDim2.new(UDim.new(1, 0), UDim.new(0, 75)),
  36 | 					AutomaticSize = Enum.AutomaticSize.None,
  37 | 				},
  38 | 				Scope:Card {
  39 | 					Size = UDim2.fromScale(1, 0),
  40 | 					AutomaticSize = Enum.AutomaticSize.Y,
  41 | 					List = {
  42 | 						Padding = Scope:UDim(0, Theme.Spacing["0.5"]),
  43 | 					},
  44 | 
  45 | 					[Children] = {
  46 | 						Scope:Text {
  47 | 							Text = "Title",
  48 | 							TextSize = Theme.TextSize["1.25"],
  49 | 							FontFace = Scope:Font(Theme.Font.Heading, Theme.FontWeight.Heading),
  50 | 						},
  51 | 						Scope:Divider {},
  52 | 						Scope:Text {
  53 | 							Text = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.",
  54 | 						},
  55 | 					},
  56 | 				},
  57 | 			},
  58 | 		}
  59 | 	end,
  60 | 	fusion = Fusion,
  61 | }
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Components/Checkbox.luau`
<details>
<summary>View Source (160 lines)</summary>

```lua
   1 | --[=[
   2 | 		@class Checkbox
   3 | 		
   4 | 		Useful for settings, to-do lists, and anything needing a "Check!"
   5 | ]=]
   6 | 
   7 | --[=[
   8 | 	@interface CheckboxProps
   9 | 	@within Checkbox
  10 | 
  11 | 	. ... BaseButtonProps -- All BaseButton properties are accepted.
  12 | 	.Checked boolean? -- Whether the checkbox is checked.
  13 | 	.Icon string? -- The icon to display inside the checkbox.
  14 | 	.Color Color3? -- The color of the checkbox.
  15 | ]=]
  16 | 
  17 | local OnyxUI = script.Parent.Parent
  18 | local Fusion = require(OnyxUI.Parent.Fusion)
  19 | local Util = require(OnyxUI.Util)
  20 | local Themer = require(OnyxUI.Themer)
  21 | local ColorUtils = require(OnyxUI.Parent.ColorUtils)
  22 | 
  23 | local Children = Fusion.Children
  24 | 
  25 | local BaseButton = require(script.Parent.BaseButton)
  26 | local Icon = require(script.Parent.Icon)
  27 | local Components = {
  28 | 	BaseButton = BaseButton,
  29 | 	Icon = Icon,
  30 | }
  31 | 
  32 | export type Props = BaseButton.Props & {
  33 | 	Checked: Fusion.UsedAs<boolean>?,
  34 | 	Icon: Fusion.UsedAs<string>?,
  35 | 	Color: Fusion.UsedAs<Color3>?,
  36 | }
  37 | 
  38 | local DISABLED_BACKGROUND_TRANSPARENCY = 0.925
  39 | local DISABLED_CONTENT_TRANSPARENCY = 0.75
  40 | 
  41 | return function(Scope: Fusion.Scope<any>, Props: Props)
  42 | 	local Scope = Fusion.innerScope(Scope, Fusion, Util, Components)
  43 | 	local Theme = Themer.Theme:now()
  44 | 
  45 | 	local Checked = Scope:EnsureValue(Util.Fallback(Props.Checked, false))
  46 | 	local Disabled = Util.Fallback(Props.Disabled, false)
  47 | 	local Color = Util.Fallback(Props.Color, Theme.Colors.Primary.Main)
  48 | 	local IconId = Util.Fallback(Props.Icon, "rbxassetid://13858821963")
  49 | 
  50 | 	local Hovering = Scope:EnsureValue(Util.Fallback(Props.Hovering, false))
  51 | 	local Holding = Scope:EnsureValue(Util.Fallback(Props.Holding, false))
  52 | 
  53 | 	local EffectiveColor = Scope:Computed(function(Use)
  54 | 		if Use(Disabled) then
  55 | 			return Use(Theme.Colors.BaseContent.Main)
  56 | 		else
  57 | 			if Use(Holding) then
  58 | 				return Util.Emphasize(Use(Color), Use(Theme.Emphasis.Regular))
  59 | 			elseif Use(Hovering) then
  60 | 				return Util.Emphasize(Use(Color), Use(Theme.Emphasis.Light))
  61 | 			else
  62 | 				return Use(Color)
  63 | 			end
  64 | 		end
  65 | 	end)
  66 | 	local EffectiveStrokeEmphasis = Scope:Computed(function(Use)
  67 | 		local StrokeEmphasis = Use(Theme.StrokeEmphasis.Regular)
  68 | 
  69 | 		if Use(Disabled) or (not Use(Checked)) or Use(Hovering) or Use(Holding) then
  70 | 			return 0
  71 | 		else
  72 | 			return StrokeEmphasis
  73 | 		end
  74 | 	end)
  75 | 
  76 | 	return Scope:BaseButton(Util.CombineProps(Props, {
  77 | 		Name = script.Name,
  78 | 		BackgroundColor3 = EffectiveColor,
  79 | 		BackgroundTransparency = Scope:Spring(
  80 | 			Scope:Computed(function(Use)
  81 | 				if Use(Disabled) then
  82 | 					return DISABLED_BACKGROUND_TRANSPARENCY
  83 | 				else
  84 | 					if Use(Checked) then
  85 | 						return 0
  86 | 					else
  87 | 						return 1
  88 | 					end
  89 | 				end
  90 | 			end),
  91 | 			Theme.SpringSpeed["1"],
  92 | 			Theme.SpringDampening["1"]
  93 | 		),
  94 | 		Disabled = Disabled,
  95 | 		Corner = {
  96 | 			Radius = Scope:UDim(0, Theme.CornerRadius["0.5"]),
  97 | 		},
  98 | 		Stroke = {
  99 | 			Color = Color3.fromRGB(255, 255, 255),
 100 | 			Gradient = {
 101 | 				Color = Scope:Computed(function(Use)
 102 | 					return ColorSequence.new({
 103 | 						ColorSequenceKeypoint.new(
 104 | 							0,
 105 | 							ColorUtils.Lighten(Use(EffectiveColor), Use(EffectiveStrokeEmphasis))
 106 | 						),
 107 | 						ColorSequenceKeypoint.new(1, Use(EffectiveColor)),
 108 | 					})
 109 | 				end),
 110 | 				Rotation = 90,
 111 | 			},
 112 | 			Transparency = Scope:Computed(function(Use)
 113 | 				if Use(Disabled) then
 114 | 					return DISABLED_BACKGROUND_TRANSPARENCY
 115 | 				else
 116 | 					return 0
 117 | 				end
 118 | 			end),
 119 | 		},
 120 | 
 121 | 		Hovering = Hovering,
 122 | 		Holding = Holding,
 123 | 
 124 | 		OnActivate = function()
 125 | 			Checked:set(not Fusion.peek(Checked))
 126 | 		end,
 127 | 
 128 | 		[Children] = {
 129 | 			Scope:Icon {
 130 | 				Name = "Checkmark",
 131 | 				Image = IconId,
 132 | 				ImageTransparency = Scope:Spring(
 133 | 					Scope:Computed(function(Use)
 134 | 						if Use(Checked) then
 135 | 							if Use(Disabled) then
 136 | 								return DISABLED_CONTENT_TRANSPARENCY
 137 | 							else
 138 | 								return 0
 139 | 							end
 140 | 						else
 141 | 							return 1
 142 | 						end
 143 | 					end),
 144 | 					Theme.SpringSpeed["1"],
 145 | 					Theme.SpringDampening["1"]
 146 | 				),
 147 | 				ImageColor3 = Scope:Computed(function(Use)
 148 | 					return Util.Emphasize(Use(Color), Use(Theme.Emphasis.Contrast))
 149 | 				end),
 150 | 				Rotation = Scope:Spring(
 151 | 					Scope:Computed(function(Use)
 152 | 						return (Use(Checked) and 0) or -30
 153 | 					end),
 154 | 					Theme.SpringSpeed["1"],
 155 | 					Theme.SpringDampening["1"]
 156 | 				),
 157 | 			},
 158 | 		},
 159 | 	}))
 160 | end
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Components/Checkbox.story.luau`
<details>
<summary>View Source (51 lines)</summary>

```lua
   1 | local OnyxUI = script.Parent.Parent
   2 | local Fusion = require(OnyxUI.Parent.Fusion)
   3 | local Themer = require(OnyxUI.Themer)
   4 | local Util = require(OnyxUI.Util)
   5 | 
   6 | local Children = Fusion.Children
   7 | 
   8 | local Frame = require(OnyxUI.Components.Frame)
   9 | local Checkbox = require(OnyxUI.Components.Checkbox)
  10 | local Components = {
  11 | 	Frame = Frame,
  12 | 	Checkbox = Checkbox,
  13 | }
  14 | 
  15 | return {
  16 | 	story = function(Props)
  17 | 		local Scope = Fusion.innerScope(Props.scope, Fusion, Util, Components)
  18 | 		local Theme = Themer.Theme:now()
  19 | 
  20 | 		Scope:Frame {
  21 | 			Parent = Props.target,
  22 | 			Padding = {
  23 | 				All = Scope:UDim(0, Theme.StrokeThickness["1"]),
  24 | 			},
  25 | 			List = {
  26 | 				FillDirection = Enum.FillDirection.Horizontal,
  27 | 				Padding = Scope:UDim(0, Theme.Spacing["0.5"]),
  28 | 			},
  29 | 
  30 | 			[Children] = {
  31 | 				Scope:Checkbox {},
  32 | 				Scope:Checkbox {
  33 | 					Checked = true,
  34 | 				},
  35 | 				Scope:Checkbox {
  36 | 					Disabled = true,
  37 | 				},
  38 | 				Scope:Checkbox {
  39 | 					Disabled = true,
  40 | 					Checked = true,
  41 | 				},
  42 | 				Scope:Checkbox {
  43 | 					Icon = "rbxassetid://16743550373",
  44 | 					Color = Util.Colors.Red["500"],
  45 | 					Checked = true,
  46 | 				},
  47 | 			},
  48 | 		}
  49 | 	end,
  50 | 	fusion = Fusion,
  51 | }
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Components/Divider.luau`
<details>
<summary>View Source (103 lines)</summary>

```lua
   1 | --[=[
   2 | 		@class Divider
   3 | 		
   4 | 		Useful for separating UI into sections.
   5 | ]=]
   6 | 
   7 | --[=[
   8 | 	@interface DividerProps
   9 | 	@within Divider
  10 | 	
  11 | 	. ... FrameProps -- All Frame properties are accepted.
  12 | 	.Length UDim -- The length of the divider.
  13 | 	.FillDirection Enum.FillDirection -- The direction in which the divider fills (Horizontal or Vertical).
  14 | 	.Color Color3 -- The color of the divider.
  15 | 	.Transparency number -- The transparency of the divider.
  16 | 	.Spacing UDim -- The spacing around the divider.
  17 | ]=]
  18 | 
  19 | local OnyxUI = script.Parent.Parent
  20 | local Fusion = require(OnyxUI.Parent.Fusion)
  21 | local Util = require(OnyxUI.Util)
  22 | local Themer = require(OnyxUI.Themer)
  23 | 
  24 | local Children = Fusion.Children
  25 | 
  26 | local Frame = require(script.Parent.Frame)
  27 | local Components = {
  28 | 	Frame = Frame,
  29 | }
  30 | 
  31 | export type Props = Frame.Props & {
  32 | 	Length: Fusion.UsedAs<UDim>?,
  33 | 	FillDirection: Fusion.UsedAs<Enum.FillDirection>?,
  34 | 	Color: Fusion.UsedAs<Color3>?,
  35 | 	Transparency: Fusion.UsedAs<number>?,
  36 | 	Spacing: Fusion.UsedAs<UDim>?,
  37 | }
  38 | 
  39 | return function(Scope: Fusion.Scope<any>, Props: Props)
  40 | 	local Scope = Fusion.innerScope(Scope, Fusion, Util, Components)
  41 | 	local Theme = Themer.Theme:now()
  42 | 
  43 | 	local Length = Util.Fallback(Props.Length, UDim.new(1, 0))
  44 | 	local FillDirection = Util.Fallback(Props.FillDirection, Enum.FillDirection.Horizontal)
  45 | 	local Color = Util.Fallback(Props.Color, Theme.Colors.BaseContent.Main)
  46 | 	local Transparency = Util.Fallback(Props.Transparency, 0.9)
  47 | 	local Spacing = Util.Fallback(Props.Spacing, Scope:UDim(0, Theme.Spacing["0.5"]))
  48 | 
  49 | 	local VerticalPadding = Scope:Computed(function(Use)
  50 | 		if Use(FillDirection) == Enum.FillDirection.Horizontal then
  51 | 			return Use(Spacing)
  52 | 		else
  53 | 			return UDim.new()
  54 | 		end
  55 | 	end)
  56 | 	local HorizontalPadding = Scope:Computed(function(Use)
  57 | 		if Use(FillDirection) == Enum.FillDirection.Vertical then
  58 | 			return Use(Spacing)
  59 | 		else
  60 | 			return UDim.new()
  61 | 		end
  62 | 	end)
  63 | 
  64 | 	return Scope:Frame(Util.CombineProps(Props, {
  65 | 		Name = script.Name,
  66 | 		Size = Scope:Computed(function(Use)
  67 | 			if Use(FillDirection) == Enum.FillDirection.Horizontal then
  68 | 				return UDim2.new(Length, UDim.new(0, 0))
  69 | 			else
  70 | 				return UDim2.new(UDim.new(0, 0), Use(Length))
  71 | 			end
  72 | 		end),
  73 | 		AutomaticSize = Scope:Computed(function(Use)
  74 | 			if Use(FillDirection) == Enum.FillDirection.Horizontal then
  75 | 				return Enum.AutomaticSize.Y
  76 | 			else
  77 | 				return Enum.AutomaticSize.X
  78 | 			end
  79 | 		end),
  80 | 		Padding = {
  81 | 			Top = VerticalPadding,
  82 | 			Bottom = VerticalPadding,
  83 | 			Left = HorizontalPadding,
  84 | 			Right = HorizontalPadding,
  85 | 		},
  86 | 
  87 | 		[Children] = {
  88 | 			Scope:Frame {
  89 | 				Name = "DividingLine",
  90 | 				Size = Scope:Computed(function(Use)
  91 | 					if Use(FillDirection) == Enum.FillDirection.Horizontal then
  92 | 						return UDim2.new(UDim.new(1, 0), UDim.new(0, Use(Theme.StrokeThickness["1"])))
  93 | 					else
  94 | 						return UDim2.new(UDim.new(0, Use(Theme.StrokeThickness["1"])), UDim.new(1, 0))
  95 | 					end
  96 | 				end),
  97 | 				AutomaticSize = Enum.AutomaticSize.None,
  98 | 				BackgroundColor3 = Color,
  99 | 				BackgroundTransparency = Transparency,
 100 | 			},
 101 | 		},
 102 | 	}))
 103 | end
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Components/Divider.story.luau`
<details>
<summary>View Source (45 lines)</summary>

```lua
   1 | local OnyxUI = script.Parent.Parent
   2 | local Util = require(OnyxUI.Util)
   3 | local Fusion = require(OnyxUI.Parent.Fusion)
   4 | local Themer = require(OnyxUI.Themer)
   5 | 
   6 | local Children = Fusion.Children
   7 | 
   8 | local Frame = require(OnyxUI.Components.Frame)
   9 | local Divider = require(OnyxUI.Components.Divider)
  10 | local Text = require(OnyxUI.Components.Text)
  11 | local Components = {
  12 | 	Frame = Frame,
  13 | 	Text = Text,
  14 | 	Divider = Divider,
  15 | }
  16 | 
  17 | return {
  18 | 	story = function(Props)
  19 | 		local Scope = Fusion.innerScope(Props.scope, Fusion, Util, Components)
  20 | 		local Theme = Themer.Theme:now()
  21 | 
  22 | 		Scope:Frame {
  23 | 			Parent = Props.target,
  24 | 			Size = UDim2.fromOffset(300, 0),
  25 | 			AutomaticSize = Enum.AutomaticSize.Y,
  26 | 			List = {
  27 | 				FillDirection = Enum.FillDirection.Vertical,
  28 | 				Padding = Scope:UDim(0, Theme.Spacing["0.5"]),
  29 | 			},
  30 | 
  31 | 			[Children] = {
  32 | 				Scope:Text {
  33 | 					Text = "Some top content..",
  34 | 				},
  35 | 				Scope:Divider {
  36 | 					FillDirection = Enum.FillDirection.Horizontal,
  37 | 				},
  38 | 				Scope:Text {
  39 | 					Text = "And some bottom content too.",
  40 | 				},
  41 | 			},
  42 | 		}
  43 | 	end,
  44 | 	fusion = Fusion,
  45 | }
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Components/Frame.luau`
<details>
<summary>View Source (34 lines)</summary>

```lua
   1 | --[=[
   2 | 		@class Frame
   3 | 		
   4 | 		A barebones container object. Unlike Roblox's `Frame`, it is transparent by default.
   5 | ]=]
   6 | 
   7 | --[=[
   8 | 		@within Frame
   9 | 		@interface FrameProps
  10 | 
  11 | 		. ... BaseProps -- All Base properties are accepted.
  12 | ]=]
  13 | 
  14 | local OnyxUI = script.Parent.Parent
  15 | local Fusion = require(OnyxUI.Parent.Fusion)
  16 | local Util = require(OnyxUI.Util)
  17 | 
  18 | local Base = require(script.Parent.Base)
  19 | local Components = {
  20 | 	Base = Base,
  21 | }
  22 | 
  23 | export type Props = Base.Props & {}
  24 | 
  25 | return function(Scope: Fusion.Scope<any>, Props: Props)
  26 | 	local Scope = Fusion.innerScope(Scope, Fusion, Util, Components)
  27 | 
  28 | 	return Scope:Base(Util.CombineProps(Props, {
  29 | 		ClassName = "Frame",
  30 | 		Name = script.Name,
  31 | 		BackgroundTransparency = 1,
  32 | 		AutomaticSize = Enum.AutomaticSize.XY,
  33 | 	}))
  34 | end
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Components/Group.luau`
<details>
<summary>View Source (42 lines)</summary>

```lua
   1 | --[=[
   2 | 		@class Group
   3 | 		
   4 | 		Equivalent to Roblox's `CanvasGroup` instance.
   5 | ]=]
   6 | 
   7 | --[=[
   8 | 		@within Group
   9 | 		@interface GroupProps
  10 | 
  11 | 		@field ... BaseProps -- All Base properties are accepted.
  12 | 		@field GroupTransparency Fusion.UsedAs<number>?
  13 | 		@field GroupColor3 Fusion.UsedAs<Color3>?
  14 | ]=]
  15 | 
  16 | local OnyxUI = script.Parent.Parent
  17 | local Util = require(OnyxUI.Util)
  18 | local Fusion = require(OnyxUI.Parent.Fusion)
  19 | 
  20 | local Base = require(script.Parent.Base)
  21 | local Components = {
  22 | 	Base = Base,
  23 | }
  24 | 
  25 | export type Props = Base.Props & {
  26 | 	GroupTransparency: Fusion.UsedAs<number>?,
  27 | 	GroupColor3: Fusion.UsedAs<Color3>?,
  28 | }
  29 | 
  30 | return function(Scope: Fusion.Scope<any>, Props: Props)
  31 | 	local Scope = Fusion.innerScope(Scope, Fusion, Util, Components)
  32 | 
  33 | 	return Scope:Hydrate(Scope:Base(Util.CombineProps(Props, {
  34 | 		ClassName = "CanvasGroup",
  35 | 		Name = script.Name,
  36 | 		BackgroundTransparency = 1,
  37 | 		AutomaticSize = Enum.AutomaticSize.XY,
  38 | 	}))) {
  39 | 		GroupTransparency = Props.GroupTransparency,
  40 | 		GroupColor3 = Props.GroupColor3,
  41 | 	}
  42 | end
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Components/Heading.luau`
<details>
<summary>View Source (48 lines)</summary>

```lua
   1 | --[=[
   2 | 		@class Heading
   3 | 		
   4 | 		For sectioning bodies of text or content, like for a menu title.
   5 | ]=]
   6 | 
   7 | --[=[
   8 | 	@interface HeadingProps
   9 | 	@within Heading
  10 | 
  11 | 	. ... TextProps -- All Text properties are accepted.
  12 | 	.HeadingSize number? -- Multiplier for the text size, default is 1.75.
  13 | 	.TextSize number? -- Base text size, default is Theme.TextSize["1"].
  14 | ]=]
  15 | 
  16 | local OnyxUI = script.Parent.Parent
  17 | local Util = require(OnyxUI.Util)
  18 | local Fusion = require(OnyxUI.Parent.Fusion)
  19 | local Themer = require(OnyxUI.Themer)
  20 | 
  21 | local Text = require(OnyxUI.Components.Text)
  22 | local Components = {
  23 | 	Text = Text,
  24 | }
  25 | 
  26 | export type Props = Text.Props & {
  27 | 	HeadingSize: Fusion.UsedAs<number>?,
  28 | 	TextSize: Fusion.UsedAs<number>?,
  29 | }
  30 | 
  31 | return function(Scope: Fusion.Scope<any>, Props: Props)
  32 | 	local Scope = Fusion.innerScope(Scope, Fusion, Util, Components)
  33 | 	local Theme = Themer.Theme:now()
  34 | 
  35 | 	local HeadingSize = Util.Fallback(Props.HeadingSize, 1.75)
  36 | 	local TextSize = Util.Fallback(Props.TextSize, Theme.TextSize["1"])
  37 | 
  38 | 	return Scope:Text(Util.CombineProps(Props, {
  39 | 		Name = script.Name,
  40 | 		TextSize = Scope:Computed(function(Use)
  41 | 			local HeadingSizeValue = Use(HeadingSize)
  42 | 			local TextSizeValue = Use(TextSize)
  43 | 
  44 | 			return TextSizeValue * HeadingSizeValue
  45 | 		end),
  46 | 		FontFace = Scope:Font(Theme.Font.Heading, Theme.FontWeight.Heading),
  47 | 	}))
  48 | end
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Components/Heading.story.luau`
<details>
<summary>View Source (40 lines)</summary>

```lua
   1 | local OnyxUI = script.Parent.Parent
   2 | local Util = require(OnyxUI.Util)
   3 | local Fusion = require(OnyxUI.Parent.Fusion)
   4 | local Themer = require(OnyxUI.Themer)
   5 | 
   6 | local Children = Fusion.Children
   7 | 
   8 | local Heading = require(script.Parent.Heading)
   9 | local Frame = require(script.Parent.Frame)
  10 | local Text = require(script.Parent.Text)
  11 | local Components = {
  12 | 	Heading = Heading,
  13 | 	Text = Text,
  14 | 	Frame = Frame,
  15 | }
  16 | 
  17 | return {
  18 | 	story = function(Props)
  19 | 		local Scope = Fusion.innerScope(Props.scope, Fusion, Util, Components)
  20 | 		local Theme = Themer.Theme:now()
  21 | 
  22 | 		Scope:Frame {
  23 | 			Parent = Props.target,
  24 | 			List = {
  25 | 				Padding = Scope:UDim(0, Theme.Spacing["0.5"]),
  26 | 			},
  27 | 
  28 | 			[Children] = {
  29 | 				Scope:Heading {
  30 | 					Parent = Props.target,
  31 | 					Text = "Heading",
  32 | 				},
  33 | 				Scope:Text {
  34 | 					Text = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.",
  35 | 				},
  36 | 			},
  37 | 		}
  38 | 	end,
  39 | 	fusion = Fusion,
  40 | }
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Components/Icon.luau`
<details>
<summary>View Source (35 lines)</summary>

```lua
   1 | --[=[
   2 | 		@class Icon
   3 | 		
   4 | 		It's an icon, what else can I say?
   5 | ]=]
   6 | 
   7 | --[=[
   8 | 		@within Icon
   9 | 		@interface IconProps
  10 | 
  11 | 		. ... ImageProps -- All Image properties are accepted.
  12 | ]=]
  13 | 
  14 | local OnyxUI = script.Parent.Parent
  15 | local Util = require(OnyxUI.Util)
  16 | local Fusion = require(OnyxUI.Parent.Fusion)
  17 | local Themer = require(script.Parent.Parent.Themer)
  18 | 
  19 | local Image = require(script.Parent.Image)
  20 | local Components = {
  21 | 	Image = Image,
  22 | }
  23 | 
  24 | export type Props = Image.Props & {}
  25 | 
  26 | return function(Scope: Fusion.Scope<any>, Props: Props)
  27 | 	local Scope = Fusion.innerScope(Scope, Fusion, Util, Components)
  28 | 	local Theme = Themer.Theme:now()
  29 | 
  30 | 	return Scope:Image(Util.CombineProps(Props, {
  31 | 		Name = script.Name,
  32 | 		Size = Scope:UDim2Offset(Theme.TextSize["1"], Theme.TextSize["1"]),
  33 | 		BackgroundTransparency = 1,
  34 | 	}))
  35 | end
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Components/Icon.story.luau`
<details>
<summary>View Source (20 lines)</summary>

```lua
   1 | local OnyxUI = script.Parent.Parent
   2 | local Fusion = require(OnyxUI.Parent.Fusion)
   3 | local Util = require(OnyxUI.Util)
   4 | 
   5 | local Icon = require(script.Parent.Icon)
   6 | local Components = {
   7 | 	Icon = Icon,
   8 | }
   9 | 
  10 | return {
  11 | 	story = function(Props)
  12 | 		local Scope = Fusion.innerScope(Props.scope, Fusion, Util, Components)
  13 | 
  14 | 		Scope:Icon {
  15 | 			Parent = Props.target,
  16 | 			Image = "rbxassetid://11560341132",
  17 | 		}
  18 | 	end,
  19 | 	fusion = Fusion,
  20 | }
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Components/IconButton.luau`
<details>
<summary>View Source (49 lines)</summary>

```lua
   1 | --[=[
   2 | 		@class IconButton
   3 | 		
   4 | 		Like [`Button`](/api/Button), but for a single [`Icon`](/api/Icon).
   5 | ]=]
   6 | 
   7 | --[=[
   8 | 		@within IconButton
   9 | 		@interface IconButtonProps
  10 | 
  11 | 		. ... ButtonProps -- All Button properties are accepted.
  12 | 		. Image string?
  13 | ]=]
  14 | 
  15 | local OnyxUI = script.Parent.Parent
  16 | local Fusion = require(OnyxUI.Parent.Fusion)
  17 | local Util = require(OnyxUI.Util)
  18 | local Themer = require(OnyxUI.Themer)
  19 | 
  20 | local Button = require(script.Parent.Button)
  21 | local Components = {
  22 | 	Button = Button,
  23 | }
  24 | 
  25 | export type Props = Button.Props & {
  26 | 	Image: Fusion.UsedAs<string>?,
  27 | }
  28 | 
  29 | return function(Scope: Fusion.Scope<any>, Props: Props)
  30 | 	local Scope = Fusion.innerScope(Scope, Fusion, Util, Components)
  31 | 	local Theme = Themer.Theme:now()
  32 | 
  33 | 	local Image = Util.Fallback(Props.Image, "")
  34 | 
  35 | 	local Padding = Scope:UDim(0, Theme.Spacing["0.25"])
  36 | 
  37 | 	return Scope:Button(Util.CombineProps(Props, {
  38 | 		Name = script.Name,
  39 | 		Padding = {
  40 | 			Left = Padding,
  41 | 			Right = Padding,
  42 | 			Top = Padding,
  43 | 			Bottom = Padding,
  44 | 		},
  45 | 		Content = Scope:Computed(function(Use)
  46 | 			return { Use(Image) }
  47 | 		end),
  48 | 	}))
  49 | end
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Components/IconButton.story.luau`
<details>
<summary>View Source (66 lines)</summary>

```lua
   1 | local OnyxUI = script.Parent.Parent
   2 | 
   3 | local Fusion = require(OnyxUI.Parent.Fusion)
   4 | local Themer = require(OnyxUI.Themer)
   5 | local Util = require(OnyxUI.Util)
   6 | 
   7 | local Children = Fusion.Children
   8 | 
   9 | local IconButton = require(script.Parent.IconButton)
  10 | local Frame = require(script.Parent.Frame)
  11 | local Components = {
  12 | 	IconButton = IconButton,
  13 | 	Frame = Frame,
  14 | }
  15 | 
  16 | return {
  17 | 	story = function(Props)
  18 | 		local Scope = Fusion.innerScope(Props.scope, Fusion, Util, Components)
  19 | 		local Theme = Themer.Theme:now()
  20 | 
  21 | 		Scope:Frame {
  22 | 			Parent = Props.target,
  23 | 			Padding = {
  24 | 				All = Scope:UDim(0, Theme.StrokeThickness["1"]),
  25 | 			},
  26 | 			List = {
  27 | 				FillDirection = Enum.FillDirection.Horizontal,
  28 | 				Padding = Scope:UDim(0, Theme.Spacing["0.5"]),
  29 | 			},
  30 | 
  31 | 			[Children] = {
  32 | 				Scope:IconButton {
  33 | 					Image = "rbxassetid://10814531047",
  34 | 				},
  35 | 				Scope:IconButton {
  36 | 					Image = "rbxassetid://10814531047",
  37 | 					Color = Theme.Colors.Primary.Main,
  38 | 				},
  39 | 				Scope:IconButton {
  40 | 					Image = "rbxassetid://11560341132",
  41 | 					Color = Util.Colors.Amber["500"],
  42 | 				},
  43 | 				Scope:IconButton {
  44 | 					Image = "rbxassetid://13405228418",
  45 | 					Color = Util.Colors.Red["500"],
  46 | 					Style = "Outlined",
  47 | 				},
  48 | 				Scope:IconButton {
  49 | 					Image = "rbxassetid://13405228418",
  50 | 					Color = Util.Colors.Red["500"],
  51 | 					Style = "Ghost",
  52 | 				},
  53 | 				Scope:IconButton {
  54 | 					Image = "rbxassetid://10814531047",
  55 | 					Disabled = true,
  56 | 				},
  57 | 				Scope:IconButton {
  58 | 					Image = "rbxassetid://10814531047",
  59 | 					Style = "Ghost",
  60 | 					Disabled = true,
  61 | 				},
  62 | 			},
  63 | 		}
  64 | 	end,
  65 | 	fusion = Fusion,
  66 | }
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Components/IconSwap.luau`
<details>
<summary>View Source (69 lines)</summary>

```lua
   1 | --[=[
   2 | 		@class IconSwap
   3 | 		
   4 | 		Swap between an array of icons.
   5 | ]=]
   6 | 
   7 | --[=[
   8 | 	@interface IconSwapProps
   9 | 	@within IconSwap
  10 | 	
  11 | 	. ... IconButtonProps -- All IconButton properties are accepted.
  12 | 	.Options {string}? -- Array of image strings to swap between
  13 | 	.Selection number? -- The currently selected option index
  14 | ]=]
  15 | 
  16 | local OnyxUI = script.Parent.Parent
  17 | local Util = require(OnyxUI.Util)
  18 | local Themer = require(OnyxUI.Themer)
  19 | local Fusion = require(OnyxUI.Parent.Fusion)
  20 | 
  21 | local IconButton = require(script.Parent.IconButton)
  22 | 
  23 | export type Props = IconButton.Props & {
  24 | 	Options: Fusion.UsedAs<{ string }>?,
  25 | 	Selection: Fusion.UsedAs<number>?,
  26 | 	OnSwap: Fusion.UsedAs<(number) -> ()>?,
  27 | }
  28 | 
  29 | return function(Scope: Fusion.Scope<any>, Props: Props)
  30 | 	local Scope = Fusion.innerScope(Scope, Fusion, Util, {
  31 | 		IconButton = IconButton,
  32 | 	})
  33 | 	local Theme = Themer.Theme:now()
  34 | 
  35 | 	local Options = Util.Fallback(Props.Options, {})
  36 | 	local Selection = Scope:EnsureValue(Util.Fallback(Props.Selection, 1))
  37 | 	local OnSwap = Util.Fallback(Props.OnSwap, function() end)
  38 | 
  39 | 	local function RotateSelection(Increment: number)
  40 | 		local OptionsValue = Fusion.peek(Options)
  41 | 		local SelectionValue = Fusion.peek(Selection)
  42 | 		local NewSelection = SelectionValue + Increment
  43 | 
  44 | 		if NewSelection > #OptionsValue then
  45 | 			NewSelection = 1
  46 | 		elseif NewSelection < 1 then
  47 | 			NewSelection = #OptionsValue
  48 | 		end
  49 | 
  50 | 		Selection:set(NewSelection)
  51 | 	end
  52 | 
  53 | 	return Scope:IconButton(Util.CombineProps(Props, {
  54 | 		Name = script.Name,
  55 | 		Style = "Ghost",
  56 | 		Color = Theme.Colors.BaseContent.Main,
  57 | 		Image = Scope:Computed(function(Use)
  58 | 			return Use(Options)[Use(Selection)]
  59 | 		end),
  60 | 
  61 | 		OnActivate = function()
  62 | 			local SelectionValue = Fusion.peek(Selection)
  63 | 			local OnSwapValue = Fusion.peek(OnSwap)
  64 | 
  65 | 			RotateSelection(1)
  66 | 			OnSwapValue(SelectionValue, SelectionValue + 1)
  67 | 		end,
  68 | 	}))
  69 | end
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Components/IconSwap.story.luau`
<details>
<summary>View Source (36 lines)</summary>

```lua
   1 | local OnyxUI = script.Parent.Parent
   2 | local Fusion = require(OnyxUI.Parent.Fusion)
   3 | local Util = require(OnyxUI.Util)
   4 | local Themer = require(OnyxUI.Themer)
   5 | 
   6 | local Children = Fusion.Children
   7 | 
   8 | local IconSwap = require(script.Parent.IconSwap)
   9 | local Frame = require(script.Parent.Frame)
  10 | 
  11 | return {
  12 | 	story = function(Props)
  13 | 		local Scope = Fusion.innerScope(Props.scope, Fusion, Util, {
  14 | 			IconSwap = IconSwap,
  15 | 			Frame = Frame,
  16 | 		})
  17 | 		local Theme = Themer.Theme:now()
  18 | 
  19 | 		Scope:Frame {
  20 | 			Parent = Props.target,
  21 | 			List = {
  22 | 				Padding = Scope:UDim(0, Theme.Spacing["0.75"]),
  23 | 			},
  24 | 			Padding = {
  25 | 				All = Scope:UDim(0, Theme.StrokeThickness["1"]),
  26 | 			},
  27 | 
  28 | 			[Children] = {
  29 | 				Scope:IconSwap {
  30 | 					Options = { "rbxassetid://13852158988", "rbxassetid://13852161637" },
  31 | 				},
  32 | 			},
  33 | 		}
  34 | 	end,
  35 | 	fusion = Fusion,
  36 | }
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Components/IconText.luau`
<details>
<summary>View Source (92 lines)</summary>

```lua
   1 | --[=[
   2 | 		@class IconText
   3 | 		
   4 | 		For displaying both text and icons alongside each other as one seamless body.
   5 | ]=]
   6 | 
   7 | --[=[
   8 | 	@interface IconTextProps
   9 | 	@within IconText
  10 | 	
  11 | 	. ... FrameProps -- All Frame properties are accepted.
  12 | 	.Content {string}? -- The content to display, can include both text and icons.
  13 | 	.ContentColor Color3? -- The color of the content.
  14 | 	.ContentSize number? -- The size of the content.
  15 | 	.ContentTransparency number? -- The transparency of the content.
  16 | 	.ContentWrapped boolean? -- Whether the text content should wrap.
  17 | 	.ContentRichText boolean? -- Whether the text content supports rich text.
  18 | 	.ContentFontFace Font? -- The font face of the text content.
  19 | ]=]
  20 | 
  21 | local OnyxUI = script.Parent.Parent
  22 | local Util = require(OnyxUI.Util)
  23 | local Fusion = require(OnyxUI.Parent.Fusion)
  24 | local Themer = require(OnyxUI.Themer)
  25 | 
  26 | local Children = Fusion.Children
  27 | 
  28 | local Frame = require(OnyxUI.Components.Frame)
  29 | local Text = require(OnyxUI.Components.Text)
  30 | local Icon = require(OnyxUI.Components.Icon)
  31 | local Components = {
  32 | 	Text = Text,
  33 | 	Icon = Icon,
  34 | 	Frame = Frame,
  35 | }
  36 | 
  37 | export type Props = Frame.Props & {
  38 | 	Content: Fusion.UsedAs<{ string }>?,
  39 | 	ContentColor: Fusion.UsedAs<Color3>?,
  40 | 	ContentSize: Fusion.UsedAs<number>?,
  41 | 	ContentTransparency: Fusion.UsedAs<number>?,
  42 | 	ContentWrapped: Fusion.UsedAs<boolean>?,
  43 | 	ContentRichText: Fusion.UsedAs<boolean>?,
  44 | 	ContentFontFace: Fusion.UsedAs<Font>?,
  45 | }
  46 | 
  47 | return function(Scope: Fusion.Scope<any>, Props: Props)
  48 | 	local Scope = Fusion.innerScope(Scope, Fusion, Util, Components)
  49 | 	local Theme = Themer.Theme:now()
  50 | 
  51 | 	local Content = Util.Fallback(Props.Content, {})
  52 | 	local ContentSize = Util.Fallback(Props.ContentSize, Theme.TextSize["1"])
  53 | 	local ContentColor = Util.Fallback(Props.ContentColor, Theme.Colors.BaseContent.Main)
  54 | 	local ContentTransparency = Util.Fallback(Props.ContentTransparency, 0)
  55 | 	local ContentWrapped = Util.Fallback(Props.ContentWrapped, true)
  56 | 	local ContentRichText = Util.Fallback(Props.ContentRichText, true)
  57 | 	local ContentFontFace = Util.Fallback(Props.ContentFontFace, Scope:Font(Theme.Font.Body, Theme.FontWeight.Body))
  58 | 
  59 | 	return Scope:Frame(Util.CombineProps(Props, {
  60 | 		Name = script.Name,
  61 | 		List = {
  62 | 			FillDirection = Enum.FillDirection.Horizontal,
  63 | 			Padding = Scope:UDim(0, Theme.Spacing["0"]),
  64 | 		},
  65 | 
  66 | 		[Children] = {
  67 | 			Scope:ForPairs(Content, function(Use, Scope, Index: number, ContentString: string)
  68 | 				return Index,
  69 | 					Themer.Theme:is(Theme):during(function()
  70 | 						if string.find(ContentString, "rbxassetid://", 1, true) then
  71 | 							return Scope:Icon {
  72 | 								Image = ContentString,
  73 | 								ImageColor3 = ContentColor,
  74 | 								Size = Scope:UDim2Offset(ContentSize, ContentSize),
  75 | 								ImageTransparency = ContentTransparency,
  76 | 							}
  77 | 						else
  78 | 							return Scope:Text {
  79 | 								Text = ContentString,
  80 | 								TextColor3 = ContentColor,
  81 | 								TextSize = ContentSize,
  82 | 								TextTransparency = ContentTransparency,
  83 | 								TextWrapped = ContentWrapped,
  84 | 								RichText = ContentRichText,
  85 | 								FontFace = ContentFontFace,
  86 | 							}
  87 | 						end
  88 | 					end)
  89 | 			end),
  90 | 		},
  91 | 	}))
  92 | end
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Components/IconText.story.luau`
<details>
<summary>View Source (27 lines)</summary>

```lua
   1 | local OnyxUI = script.Parent.Parent
   2 | local Fusion = require(OnyxUI.Parent.Fusion)
   3 | local Util = require(OnyxUI.Util)
   4 | 
   5 | local IconText = require(script.Parent.IconText)
   6 | local Components = {
   7 | 	IconText = IconText,
   8 | }
   9 | 
  10 | return {
  11 | 	story = function(Props)
  12 | 		local Scope = Fusion.innerScope(Props.scope, Fusion, Util, Components)
  13 | 
  14 | 		Scope:IconText {
  15 | 			Parent = Props.target,
  16 | 			Content = {
  17 | 				"Here's a shop icon: ",
  18 | 				"rbxassetid://75029721407761",
  19 | 				".",
  20 | 				" And also the Loneka logo: ",
  21 | 				"rbxassetid://16735398592",
  22 | 				". Now you can easily have both text and icons!",
  23 | 			},
  24 | 		}
  25 | 	end,
  26 | 	fusion = Fusion,
  27 | }
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Components/Image.luau`
<details>
<summary>View Source (79 lines)</summary>

```lua
   1 | --[=[
   2 | 		@class Image
   3 | 		
   4 | 		Equivalent to Roblox's `ImageLabel`.
   5 | ]=]
   6 | 
   7 | --[=[
   8 | 	@interface ImageProps
   9 | 	@within Image
  10 | 	
  11 | 	. ... BaseProps -- All Base properties are accepted.
  12 | 	.Image string? -- The image asset ID to display.
  13 | 	.FallbackImage string? -- The fallback image asset ID to display if `Image` is not provided.
  14 | 	.ImageColor3 Color3? -- The color to apply to the image.
  15 | 	.ImageTransparency number? -- The transparency of the image.
  16 | 	.ImageRectOffset Vector2? -- The offset of the image rectangle.
  17 | 	.ImageRectSize Vector2? -- The size of the image rectangle.
  18 | 	.ResampleMode Enum.ResamplerMode? -- The resampling mode for the image.
  19 | 	.ScaleType Enum.ScaleType? -- The scaling mode for the image.
  20 | 	.SliceCenter Rect? -- The center rectangle for 9-slice scaling.
  21 | 	.SliceScale number? -- The scale factor for 9-slice scaling.
  22 | 	.TileSize UDim2? -- The size of the tile for tiled images.
  23 | ]=]
  24 | 
  25 | local OnyxUI = script.Parent.Parent
  26 | local Fusion = require(OnyxUI.Parent.Fusion)
  27 | local Util = require(OnyxUI.Util)
  28 | 
  29 | local Base = require(script.Parent.Base)
  30 | local Components = {
  31 | 	Base = Base,
  32 | }
  33 | 
  34 | export type Props = Base.Props & {
  35 | 	Image: Fusion.UsedAs<string>?,
  36 | 	FallbackImage: Fusion.UsedAs<string>?,
  37 | 	ImageColor3: Fusion.UsedAs<Color3>?,
  38 | 	ImageTransparency: Fusion.UsedAs<number>?,
  39 | 	ImageRectOffset: Fusion.UsedAs<Vector2>?,
  40 | 	ImageRectSize: Fusion.UsedAs<Vector2>?,
  41 | 	ResampleMode: Fusion.UsedAs<Enum.ResamplerMode>?,
  42 | 	ScaleType: Fusion.UsedAs<Enum.ScaleType>?,
  43 | 	SliceCenter: Fusion.UsedAs<Rect>?,
  44 | 	SliceScale: Fusion.UsedAs<number>?,
  45 | 	TileSize: Fusion.UsedAs<UDim2>?,
  46 | }
  47 | 
  48 | return function(Scope: Fusion.Scope<any>, Props: Props)
  49 | 	local Scope = Fusion.innerScope(Scope, Fusion, Util, Components)
  50 | 
  51 | 	local FallbackImage = Util.Fallback(Props.FallbackImage, "rbxasset://textures/ui/GuiImagePlaceholder.png")
  52 | 	local Image = Util.Fallback(Props.Image, nil)
  53 | 
  54 | 	local ImageInUse = Scope:Computed(function(Use)
  55 | 		if Use(Image) then
  56 | 			return Use(Image)
  57 | 		else
  58 | 			return Use(FallbackImage)
  59 | 		end
  60 | 	end)
  61 | 
  62 | 	return Scope:Hydrate(Scope:Base(Util.CombineProps(Props, {
  63 | 		ClassName = "ImageLabel",
  64 | 		Name = script.Name,
  65 | 		Size = UDim2.fromOffset(100, 100),
  66 | 		AutomaticSize = Enum.AutomaticSize.None,
  67 | 	}))) {
  68 | 		Image = ImageInUse,
  69 | 		ImageColor3 = Props.ImageColor3,
  70 | 		ImageTransparency = Props.ImageTransparency,
  71 | 		ImageRectOffset = Props.ImageRectOffset,
  72 | 		ImageRectSize = Props.ImageRectSize,
  73 | 		ResampleMode = Props.ResampleMode,
  74 | 		ScaleType = Props.ScaleType,
  75 | 		SliceCenter = Props.SliceCenter,
  76 | 		SliceScale = Props.SliceScale,
  77 | 		TileSize = Props.TileSize,
  78 | 	}
  79 | end
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Components/Image.story.luau`
<details>
<summary>View Source (40 lines)</summary>

```lua
   1 | local OnyxUI = script.Parent.Parent
   2 | local Util = require(OnyxUI.Util)
   3 | local Fusion = require(OnyxUI.Parent.Fusion)
   4 | local Themer = require(OnyxUI.Themer)
   5 | 
   6 | local Children = Fusion.Children
   7 | 
   8 | local Frame = require(OnyxUI.Components.Frame)
   9 | local Image = require(OnyxUI.Components.Image)
  10 | local Components = {
  11 | 	Frame = Frame,
  12 | 	Image = Image,
  13 | }
  14 | 
  15 | return {
  16 | 	story = function(Props)
  17 | 		local Scope = Fusion.innerScope(Props.scope, Fusion, Util, Components)
  18 | 		local Theme = Themer.Theme:now()
  19 | 
  20 | 		Scope:Frame {
  21 | 			Parent = Props.target,
  22 | 			AutomaticSize = Enum.AutomaticSize.XY,
  23 | 			List = {
  24 | 				FillDirection = Enum.FillDirection.Horizontal,
  25 | 				Padding = Scope:UDim(0, Theme.Spacing["0.75"]),
  26 | 			},
  27 | 
  28 | 			[Children] = {
  29 | 				Scope:Image {
  30 | 					Image = "rbxassetid://15307540148",
  31 | 				},
  32 | 				Scope:Image {},
  33 | 				Scope:Image {
  34 | 					FallbackImage = "rbxassetid://13193902400",
  35 | 				},
  36 | 			},
  37 | 		}
  38 | 	end,
  39 | 	fusion = Fusion,
  40 | }
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Components/init.luau`
<details>
<summary>View Source (51 lines)</summary>

```lua
   1 | local STORY_EXTENSION = ".story"
   2 | 
   3 | local Components = {
   4 | 	Base = require(script.Base),
   5 | 	Text = require(script.Text),
   6 | 	Frame = require(script.Frame),
   7 | 	Badge = require(script.Badge),
   8 | 	Avatar = require(script.Avatar),
   9 | 	AutoScaler = require(script.AutoScaler),
  10 | 	BaseButton = require(script.BaseButton),
  11 | 	Button = require(script.Button),
  12 | 	Card = require(script.Card),
  13 | 	Checkbox = require(script.Checkbox),
  14 | 	Divider = require(script.Divider),
  15 | 	Group = require(script.Group),
  16 | 	Heading = require(script.Heading),
  17 | 	Icon = require(script.Icon),
  18 | 	IconButton = require(script.IconButton),
  19 | 	IconText = require(script.IconText),
  20 | 	Image = require(script.Image),
  21 | 	ProgressBar = require(script.ProgressBar),
  22 | 	Scroller = require(script.Scroller),
  23 | 	Switch = require(script.Switch),
  24 | 	TextInput = require(script.TextInput),
  25 | 	TextArea = require(script.TextArea),
  26 | 	TitleBar = require(script.TitleBar),
  27 | 	TextSwap = require(script.TextSwap),
  28 | 	Slider = require(script.Slider),
  29 | 	Tabs = require(script.Tabs),
  30 | 	IconSwap = require(script.IconSwap),
  31 | }
  32 | 
  33 | task.spawn(function()
  34 | 	for _, Child in ipairs(script:GetChildren()) do
  35 | 		local LastCharacters = string.sub(Child.Name, -string.len(STORY_EXTENSION))
  36 | 		if LastCharacters ~= STORY_EXTENSION then
  37 | 			local Success, Result = pcall(function()
  38 | 				return require(Child)
  39 | 			end)
  40 | 			if Success then
  41 | 				if Components[Child.Name] ~= Result then
  42 | 					assert(false, `Component {Child} is not listed.`)
  43 | 				end
  44 | 			else
  45 | 				assert(false, `{Child} errored during require.`)
  46 | 			end
  47 | 		end
  48 | 	end
  49 | end)
  50 | 
  51 | return Components
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Components/ProgressBar.luau`
<details>
<summary>View Source (138 lines)</summary>

```lua
   1 | --[=[
   2 | 		@class ProgressBar
   3 | 		
   4 | 		Useful for communicating progress towards goals.
   5 | ]=]
   6 | 
   7 | --[=[
   8 | 	@interface ProgressBarProps
   9 | 	@within ProgressBar
  10 | 	
  11 | 	. ... FrameProps -- All Frame properties are accepted.
  12 | 	.Inverted boolean? -- Whether the progress bar is inverted.
  13 | 	.Progress number? -- The progress value, ranging from 0 to 1.
  14 | 	.Color Color3? -- The color of the progress fill.
  15 | 	.Direction Enum.FillDirection? -- The direction of the progress bar (Horizontal or Vertical).
  16 | 	.Length UDim? -- The length of the progress bar.
  17 | ]=]
  18 | 
  19 | local OnyxUI = script.Parent.Parent
  20 | 
  21 | local Fusion = require(OnyxUI.Parent.Fusion)
  22 | local Util = require(OnyxUI.Util)
  23 | local Themer = require(OnyxUI.Themer)
  24 | local ColorUtils = require(OnyxUI.Parent.ColorUtils)
  25 | 
  26 | local Children = Fusion.Children
  27 | 
  28 | local Frame = require(script.Parent.Frame)
  29 | local Components = {
  30 | 	Frame = Frame,
  31 | }
  32 | 
  33 | export type Props = Frame.Props & {
  34 | 	Progress: Fusion.UsedAs<number>?,
  35 | 	Color: Fusion.UsedAs<Color3>?,
  36 | 	Direction: Fusion.UsedAs<Enum.FillDirection>?,
  37 | 	Inverted: Fusion.UsedAs<boolean>?,
  38 | 	Length: Fusion.UsedAs<UDim>?,
  39 | }
  40 | 
  41 | return function(Scope: Fusion.Scope<any>, Props: Props)
  42 | 	local Scope = Fusion.innerScope(Scope, Fusion, Util, Components)
  43 | 	local Theme = Themer.Theme:now()
  44 | 
  45 | 	local Progress = Util.Fallback(Props.Progress, 0)
  46 | 	local Color = Util.Fallback(Props.Color, Theme.Colors.Primary.Main)
  47 | 	local Direction = Util.Fallback(Props.Direction, Enum.FillDirection.Horizontal)
  48 | 	local Inverted = Util.Fallback(Props.Inverted, false)
  49 | 	local Length = Util.Fallback(Props.Length, Scope:UDim(0, Theme.Sizing["6"]))
  50 | 	local Stroke = Util.Fallback(Props.Stroke, {
  51 | 		Thickness = Theme.StrokeThickness["1"],
  52 | 	})
  53 | 
  54 | 	return Scope:Frame(Util.CombineProps(Props, {
  55 | 		Name = script.Name,
  56 | 		Size = Scope:Computed(function(Use)
  57 | 			local DirectionValue = Use(Direction)
  58 | 			local LengthValue = Use(Length)
  59 | 			if DirectionValue == Enum.FillDirection.Horizontal then
  60 | 				return UDim2.new(LengthValue, UDim.new(0, Use(Theme.TextSize["0.75"])))
  61 | 			else
  62 | 				return UDim2.new(UDim.new(0, Use(Theme.TextSize["0.75"])), LengthValue)
  63 | 			end
  64 | 		end),
  65 | 		AutomaticSize = Enum.AutomaticSize.None,
  66 | 		BackgroundTransparency = 0,
  67 | 		BackgroundColor3 = Theme.Colors.Neutral.Dark,
  68 | 		Corner = {
  69 | 			Radius = Scope:UDim(0, Theme.CornerRadius["Full"]),
  70 | 		},
  71 | 		Padding = {
  72 | 			All = Scope:Computed(function(Use)
  73 | 				return UDim.new(0, Use(Use(Stroke).Thickness))
  74 | 			end),
  75 | 		},
  76 | 
  77 | 		[Children] = {
  78 | 			Scope:Frame {
  79 | 				Name = "ProgressFill",
  80 | 				Selectable = false,
  81 | 				Size = Scope:Spring(
  82 | 					Scope:Computed(function(Use)
  83 | 						if Use(Direction) == Enum.FillDirection.Horizontal then
  84 | 							return UDim2.fromScale(Use(Progress), 1)
  85 | 						else
  86 | 							return UDim2.fromScale(1, Use(Progress))
  87 | 						end
  88 | 					end),
  89 | 					Theme.SpringSpeed["0.5"],
  90 | 					Theme.SpringDampening["1"]
  91 | 				),
  92 | 				AnchorPoint = Scope:Computed(function(Use)
  93 | 					if Use(Inverted) then
  94 | 						if Use(Direction) == Enum.FillDirection.Horizontal then
  95 | 							return Vector2.new(1, 0)
  96 | 						else
  97 | 							return Vector2.new(0, 1)
  98 | 						end
  99 | 					else
 100 | 						return Vector2.new(0, 0)
 101 | 					end
 102 | 				end),
 103 | 				Position = Scope:Computed(function(Use)
 104 | 					if Use(Inverted) then
 105 | 						if Use(Direction) == Enum.FillDirection.Horizontal then
 106 | 							return UDim2.fromScale(1, 0)
 107 | 						else
 108 | 							return UDim2.fromScale(0, 1)
 109 | 						end
 110 | 					else
 111 | 						return UDim2.fromScale(0, 0)
 112 | 					end
 113 | 				end),
 114 | 				AutomaticSize = Enum.AutomaticSize.None,
 115 | 				BackgroundTransparency = 0,
 116 | 				BackgroundColor3 = Color,
 117 | 				Stroke = {
 118 | 					Color = Color3.fromRGB(255, 255, 255),
 119 | 					Gradient = {
 120 | 						Color = Scope:Computed(function(Use)
 121 | 							return ColorSequence.new({
 122 | 								ColorSequenceKeypoint.new(
 123 | 									0,
 124 | 									ColorUtils.Lighten(Use(Color), Use(Theme.StrokeEmphasis.Regular))
 125 | 								),
 126 | 								ColorSequenceKeypoint.new(1, Use(Color)),
 127 | 							})
 128 | 						end),
 129 | 						Rotation = 90,
 130 | 					},
 131 | 				},
 132 | 				Corner = {
 133 | 					Radius = Scope:UDim(0, Theme.CornerRadius["Full"]),
 134 | 				},
 135 | 			},
 136 | 		},
 137 | 	}))
 138 | end
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Components/ProgressBar.story.luau`
<details>
<summary>View Source (194 lines)</summary>

```lua
   1 | local OnyxUI = script.Parent.Parent
   2 | 
   3 | local Fusion = require(OnyxUI.Parent.Fusion)
   4 | local ColorUtils = require(OnyxUI.Parent.ColorUtils)
   5 | local Themer = require(OnyxUI.Themer)
   6 | local Util = require(OnyxUI.Util)
   7 | 
   8 | local Children = Fusion.Children
   9 | 
  10 | local Frame = require(script.Parent.Frame)
  11 | local ProgressBar = require(script.Parent.ProgressBar)
  12 | local Text = require(script.Parent.Text)
  13 | local Components = {
  14 | 	Frame = Frame,
  15 | 	ProgressBar = ProgressBar,
  16 | 	Text = Text,
  17 | }
  18 | 
  19 | return {
  20 | 	story = function(Props)
  21 | 		local Scope = Fusion.innerScope(Props.scope, Fusion, Util, Components)
  22 | 		local Theme = Themer.Theme:now()
  23 | 
  24 | 		local Progress = Scope:Value(0)
  25 | 		local Color = Scope:Value(Color3.fromRGB(255, 0, 0))
  26 | 
  27 | 		local ColorThread = task.spawn(function()
  28 | 			while task.wait(1) do
  29 | 				Progress:set(math.random(0, 1000) / 1000)
  30 | 				Color:set(ColorUtils.Rotate(Fusion.peek(Color), 100))
  31 | 			end
  32 | 		end)
  33 | 
  34 | 		Scope:innerScope({
  35 | 			function()
  36 | 				task.cancel(ColorThread)
  37 | 			end,
  38 | 		})
  39 | 
  40 | 		Scope:Frame {
  41 | 			Parent = Props.target,
  42 | 			List = {
  43 | 				HorizontalFlex = Enum.UIFlexAlignment.Fill,
  44 | 				Padding = Scope:UDim(0, Theme.Spacing["1.5"]),
  45 | 			},
  46 | 
  47 | 			[Children] = {
  48 | 				Scope:Frame {
  49 | 					List = {
  50 | 						HorizontalFlex = Enum.UIFlexAlignment.Fill,
  51 | 						Padding = Scope:UDim(0, Theme.Spacing["0.5"]),
  52 | 					},
  53 | 
  54 | 					[Children] = {
  55 | 						Scope:Text {
  56 | 							Text = "Horizontal",
  57 | 						},
  58 | 						Scope:ProgressBar {
  59 | 							Progress = 0.75,
  60 | 						},
  61 | 						Scope:ProgressBar {
  62 | 							Progress = Progress,
  63 | 							Color = Color,
  64 | 						},
  65 | 					},
  66 | 				},
  67 | 				Scope:Frame {
  68 | 					List = {
  69 | 						HorizontalFlex = Enum.UIFlexAlignment.Fill,
  70 | 						Padding = Scope:UDim(0, Theme.Spacing["0.5"]),
  71 | 					},
  72 | 
  73 | 					[Children] = {
  74 | 						Scope:Text {
  75 | 							Text = "With text",
  76 | 						},
  77 | 						Scope:Frame {
  78 | 							List = {
  79 | 								FillDirection = Enum.FillDirection.Horizontal,
  80 | 								VerticalAlignment = Enum.VerticalAlignment.Center,
  81 | 								Padding = Scope:UDim(0, Theme.Spacing["0.5"]),
  82 | 							},
  83 | 
  84 | 							[Children] = {
  85 | 								Scope:Text {
  86 | 									Text = "HP",
  87 | 								},
  88 | 								Scope:ProgressBar {
  89 | 									Progress = Progress,
  90 | 									Color = Util.Colors.Red["500"],
  91 | 									FlexMode = Enum.UIFlexMode.Fill,
  92 | 								},
  93 | 							},
  94 | 						},
  95 | 					},
  96 | 				},
  97 | 				Scope:Frame {
  98 | 					List = {
  99 | 						HorizontalFlex = Enum.UIFlexAlignment.Fill,
 100 | 						Padding = Scope:UDim(0, Theme.Spacing["0.5"]),
 101 | 					},
 102 | 
 103 | 					[Children] = {
 104 | 						Scope:Text {
 105 | 							Text = "Inverted",
 106 | 						},
 107 | 						Scope:ProgressBar {
 108 | 							Progress = Progress,
 109 | 							Inverted = true,
 110 | 						},
 111 | 					},
 112 | 				},
 113 | 				Scope:Frame {
 114 | 					List = {
 115 | 						HorizontalFlex = Enum.UIFlexAlignment.Fill,
 116 | 						Padding = Scope:UDim(0, Theme.Spacing["0.75"]),
 117 | 					},
 118 | 
 119 | 					[Children] = {
 120 | 						Scope:Text {
 121 | 							Text = "Vertical",
 122 | 						},
 123 | 						Scope:Frame {
 124 | 							List = {
 125 | 								FillDirection = Enum.FillDirection.Horizontal,
 126 | 								Padding = Scope:UDim(0, Theme.Spacing["0.5"]),
 127 | 							},
 128 | 
 129 | 							[Children] = {
 130 | 
 131 | 								Scope:ProgressBar {
 132 | 									Direction = Enum.FillDirection.Vertical,
 133 | 									Progress = Progress,
 134 | 									Color = Color,
 135 | 								},
 136 | 								Scope:ProgressBar {
 137 | 									Direction = Enum.FillDirection.Vertical,
 138 | 									Progress = Progress,
 139 | 									Inverted = true,
 140 | 									Color = Color,
 141 | 								},
 142 | 								Scope:ProgressBar {
 143 | 									Direction = Enum.FillDirection.Vertical,
 144 | 									Progress = Progress,
 145 | 									Color = Color,
 146 | 								},
 147 | 								Scope:ProgressBar {
 148 | 									Direction = Enum.FillDirection.Vertical,
 149 | 									Progress = Progress,
 150 | 									Inverted = true,
 151 | 									Color = Color,
 152 | 								},
 153 | 								Scope:ProgressBar {
 154 | 									Direction = Enum.FillDirection.Vertical,
 155 | 									Progress = Progress,
 156 | 									Color = Color,
 157 | 								},
 158 | 								Scope:ProgressBar {
 159 | 									Direction = Enum.FillDirection.Vertical,
 160 | 									Progress = Progress,
 161 | 									Inverted = true,
 162 | 									Color = Color,
 163 | 								},
 164 | 								Scope:ProgressBar {
 165 | 									Direction = Enum.FillDirection.Vertical,
 166 | 									Progress = Progress,
 167 | 									Color = Color,
 168 | 								},
 169 | 								Scope:ProgressBar {
 170 | 									Direction = Enum.FillDirection.Vertical,
 171 | 									Progress = Progress,
 172 | 									Inverted = true,
 173 | 									Color = Color,
 174 | 								},
 175 | 								Scope:ProgressBar {
 176 | 									Direction = Enum.FillDirection.Vertical,
 177 | 									Progress = Progress,
 178 | 									Color = Color,
 179 | 								},
 180 | 								Scope:ProgressBar {
 181 | 									Direction = Enum.FillDirection.Vertical,
 182 | 									Progress = Progress,
 183 | 									Inverted = true,
 184 | 									Color = Color,
 185 | 								},
 186 | 							},
 187 | 						},
 188 | 					},
 189 | 				},
 190 | 			},
 191 | 		}
 192 | 	end,
 193 | 	fusion = Fusion,
 194 | }
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Components/Scroller.luau`
<details>
<summary>View Source (111 lines)</summary>

```lua
   1 | --[=[
   2 | 		@class Scroller
   3 | 		
   4 | 		For making Content scrollable. Equivalent to Roblox's `Scroller` instance.
   5 | ]=]
   6 | 
   7 | --[=[
   8 | 	@interface ScrollerProps
   9 | 	@within Scroller
  10 | 	
  11 | 	. ... BaseProps -- All Base properties are accepted.
  12 | 	.AutomaticCanvasSize Enum.AutomaticSize? -- Determines whether the canvas size is automatically adjusted.
  13 | 	.BottomImage string? -- The image used for the bottom scroll bar.
  14 | 	.CanvasPosition Vector2? -- The position of the canvas.
  15 | 	.CanvasSize UDim2? -- The size of the canvas.
  16 | 	.ElasticBehavior Enum.ElasticBehavior? -- Determines the elastic behavior of the scrolling frame.
  17 | 	.HorizontalScrollBarInset Enum.ScrollBarInset? -- Determines the inset behavior of the horizontal scroll bar.
  18 | 	.MidImage string? -- The image used for the middle scroll bar.
  19 | 	.ScrollBarImageColor3 Color3? -- The color of the scroll bar image.
  20 | 	.ScrollBarImageTransparency number? -- The transparency of the scroll bar image.
  21 | 	.ScrollBarThickness number? -- The thickness of the scroll bar.
  22 | 	.ScrollingDirection Enum.ScrollingDirection? -- The direction in which scrolling is allowed.
  23 | 	.ScrollingEnabled boolean? -- Determines whether scrolling is enabled.
  24 | 	.TopImage string? -- The image used for the top scroll bar.
  25 | 	.VerticalScrollBarInset Enum.ScrollBarInset? -- Determines the inset behavior of the vertical scroll bar.
  26 | 	.VerticalScrollBarPosition Enum.VerticalScrollBarPosition? -- Determines the position of the vertical scroll bar.
  27 | ]=]
  28 | 
  29 | local OnyxUI = script.Parent.Parent
  30 | local Fusion = require(OnyxUI.Parent.Fusion)
  31 | local Themer = require(OnyxUI.Themer)
  32 | local Util = require(OnyxUI.Util)
  33 | 
  34 | local Base = require(script.Parent.Base)
  35 | local Components = {
  36 | 	Base = Base,
  37 | }
  38 | 
  39 | export type Props = Base.Props & {
  40 | 	AutomaticCanvasSize: Fusion.UsedAs<Enum.AutomaticSize>?,
  41 | 	BottomImage: Fusion.UsedAs<string>?,
  42 | 	CanvasPosition: Fusion.UsedAs<Vector2>?,
  43 | 	CanvasSize: Fusion.UsedAs<UDim2>?,
  44 | 	ElasticBehavior: Fusion.UsedAs<Enum.ElasticBehavior>?,
  45 | 	HorizontalScrollBarInset: Fusion.UsedAs<Enum.ScrollBarInset>?,
  46 | 	MidImage: Fusion.UsedAs<string>?,
  47 | 	ScrollBarImageColor3: Fusion.UsedAs<Color3>?,
  48 | 	ScrollBarImageTransparency: Fusion.UsedAs<number>?,
  49 | 	ScrollBarThickness: Fusion.UsedAs<number>?,
  50 | 	ScrollingDirection: Fusion.UsedAs<Enum.ScrollingDirection>?,
  51 | 	ScrollingEnabled: Fusion.UsedAs<boolean>?,
  52 | 	TopImage: Fusion.UsedAs<string>?,
  53 | 	VerticalScrollBarInset: Fusion.UsedAs<Enum.ScrollBarInset>?,
  54 | 	VerticalScrollBarPosition: Fusion.UsedAs<Enum.VerticalScrollBarPosition>?,
  55 | }
  56 | 
  57 | return function(Scope: Fusion.Scope<any>, Props: Props): Instance
  58 | 	local Scope = Fusion.innerScope(Scope, Fusion, Util, Components)
  59 | 	local Theme = Themer.Theme:now()
  60 | 
  61 | 	local BottomImage = Util.Fallback(
  62 | 		Props.BottomImage,
  63 | 		Scope:Computed(function(Use)
  64 | 			if Use(Theme.CornerRadius["1"]) >= 3 then
  65 | 				return "rbxassetid://16547643439"
  66 | 			else
  67 | 				return "rbxassetid://16547330984"
  68 | 			end
  69 | 		end)
  70 | 	)
  71 | 	local TopImage = Util.Fallback(
  72 | 		Props.TopImage,
  73 | 		Scope:Computed(function(Use)
  74 | 			if Use(Theme.CornerRadius["1"]) >= 3 then
  75 | 				return "rbxassetid://16547667444"
  76 | 			else
  77 | 				return "rbxassetid://16547330984"
  78 | 			end
  79 | 		end)
  80 | 	)
  81 | 	local MidImage = Util.Fallback(Props.MidImage, "rbxassetid://16547330984")
  82 | 	local ScrollBarImageColor3 = Util.Fallback(Props.ScrollBarImageColor3, Theme.Colors.NeutralContent.Dark)
  83 | 	local ScrollBarImageTransparency = Util.Fallback(Props.ScrollBarImageTransparency, 0)
  84 | 	local ScrollBarThickness = Util.Fallback(Props.ScrollBarThickness, 8)
  85 | 	local AutomaticCanvasSize = Util.Fallback(Props.AutomaticCanvasSize, Enum.AutomaticSize.Y)
  86 | 	local ScrollingDirection = Util.Fallback(Props.ScrollingDirection, Enum.ScrollingDirection.Y)
  87 | 
  88 | 	return Scope:Hydrate(Scope:Base(Util.CombineProps(Props, {
  89 | 		ClassName = "ScrollingFrame",
  90 | 		Name = script.Name,
  91 | 		Selectable = false,
  92 | 		BackgroundTransparency = 1,
  93 | 		AutomaticSize = Enum.AutomaticSize.None,
  94 | 	}))) {
  95 | 		BottomImage = BottomImage,
  96 | 		TopImage = TopImage,
  97 | 		MidImage = MidImage,
  98 | 		ScrollBarImageColor3 = ScrollBarImageColor3,
  99 | 		ScrollBarImageTransparency = ScrollBarImageTransparency,
 100 | 		ScrollBarThickness = ScrollBarThickness,
 101 | 		AutomaticCanvasSize = AutomaticCanvasSize,
 102 | 		ScrollingDirection = ScrollingDirection,
 103 | 		CanvasPosition = Props.CanvasPosition,
 104 | 		CanvasSize = Props.CanvasSize,
 105 | 		ElasticBehavior = Props.ElasticBehavior,
 106 | 		HorizontalScrollBarInset = Props.HorizontalScrollBarInset,
 107 | 		ScrollingEnabled = Props.ScrollingEnabled,
 108 | 		VerticalScrollBarInset = Props.VerticalScrollBarInset,
 109 | 		VerticalScrollBarPosition = Props.VerticalScrollBarPosition,
 110 | 	}
 111 | end
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Components/Scroller.story.luau`
<details>
<summary>View Source (22 lines)</summary>

```lua
   1 | local OnyxUI = script.Parent.Parent
   2 | local Fusion = require(OnyxUI.Parent.Fusion)
   3 | local Util = require(OnyxUI.Util)
   4 | 
   5 | local Scroller = require(script.Parent.Scroller)
   6 | local Components = {
   7 | 	Scroller = Scroller,
   8 | }
   9 | 
  10 | return {
  11 | 	story = function(Props)
  12 | 		local Scope = Fusion.innerScope(Props.scope, Fusion, Util, Components)
  13 | 
  14 | 		Scope:Scroller {
  15 | 			Parent = Props.target,
  16 | 			Size = UDim2.fromOffset(200, 200),
  17 | 			CanvasSize = UDim2.new(UDim.new(1, 0), UDim.new(0, 1000)),
  18 | 			AutomaticCanvasSize = Enum.AutomaticSize.None,
  19 | 		}
  20 | 	end,
  21 | 	fusion = Fusion,
  22 | }
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Components/Slider.luau`
<details>
<summary>View Source (255 lines)</summary>

```lua
   1 | --[=[
   2 | 		@class Slider
   3 | 		
   4 | 		For draggable linear selection.
   5 | ]=]
   6 | 
   7 | --[=[
   8 | 	@interface SliderProps
   9 | 	@within Slider
  10 | 	
  11 | 	. ... BaseButtonProps -- All BaseButton properties are accepted.
  12 | 	.Value number? -- The current value of the slider (0 to 1).
  13 | 	.Disabled boolean? -- Whether the slider is disabled.
  14 | 	.Unit number? -- The step size for the slider value.
  15 | 	.Color Color3? -- The color of the slider.
  16 | ]=]
  17 | 
  18 | local OnyxUI = script.Parent.Parent
  19 | 
  20 | local Fusion = require(OnyxUI.Parent.Fusion)
  21 | local Themer = require(OnyxUI.Themer)
  22 | local Util = require(OnyxUI.Util)
  23 | local ColorUtils = require(OnyxUI.Parent.ColorUtils)
  24 | 
  25 | local Children = Fusion.Children
  26 | local Out = Fusion.Out
  27 | local OnEvent = Fusion.OnEvent
  28 | 
  29 | local BaseButton = require(script.Parent.BaseButton)
  30 | local Components = {
  31 | 	BaseButton = BaseButton,
  32 | }
  33 | 
  34 | function RoundByUnit(Number, Factor)
  35 | 	return math.floor(Number / Factor + 0.5) * Factor
  36 | end
  37 | 
  38 | local DISABLED_BACKGROUND_TRANSPARENCY = 0.925
  39 | 
  40 | export type Props = BaseButton.Props & {
  41 | 	Value: Fusion.UsedAs<number>?,
  42 | 	Disabled: Fusion.UsedAs<boolean>?,
  43 | 	Unit: Fusion.UsedAs<number>?,
  44 | 	Color: Fusion.UsedAs<Color3>?,
  45 | }
  46 | 
  47 | return function(Scope: Fusion.Scope<any>, Props: Props)
  48 | 	local Scope = Fusion.innerScope(Scope, Fusion, Util, Components)
  49 | 	local Theme = Themer.Theme:now()
  50 | 
  51 | 	local Unit = Util.Fallback(Props.Unit, 1 / 100)
  52 | 	local Value = Scope:EnsureValue(Util.Fallback(Props.Value, 1))
  53 | 	local Color = Util.Fallback(Props.Color, Theme.Colors.Primary.Main)
  54 | 	local Disabled = Util.Fallback(Props.Disabled, false)
  55 | 
  56 | 	local Hovering = Scope:EnsureValue(Util.Fallback(Props.Hovering, false))
  57 | 	local Holding = Scope:EnsureValue(Util.Fallback(Props.Holding, false))
  58 | 
  59 | 	local DragDetector = Scope:Value(nil)
  60 | 	local AbsoluteSize = Scope:Value(Vector2.new())
  61 | 	local AbsolutePosition = Scope:Value(Vector2.new())
  62 | 
  63 | 	local EffectiveColor = Scope:Computed(function(Use)
  64 | 		if Use(Disabled) then
  65 | 			return Use(Theme.Colors.BaseContent.Main)
  66 | 		else
  67 | 			if Use(Holding) then
  68 | 				return Util.Emphasize(Use(Color), Use(Theme.Emphasis.Regular))
  69 | 			elseif Use(Hovering) then
  70 | 				return Util.Emphasize(Use(Color), Use(Theme.Emphasis.Light))
  71 | 			else
  72 | 				return Use(Color)
  73 | 			end
  74 | 		end
  75 | 	end)
  76 | 	local EffectiveStrokeEmphasis = Scope:Computed(function(Use)
  77 | 		local StrokeEmphasis = Use(Theme.StrokeEmphasis.Regular)
  78 | 
  79 | 		if Use(Disabled) or Use(Hovering) or Use(Holding) then
  80 | 			return 0
  81 | 		else
  82 | 			return StrokeEmphasis
  83 | 		end
  84 | 	end)
  85 | 
  86 | 	local function ProcessDrag(Position: Vector2)
  87 | 		local AbsoluteSizeValue = Fusion.peek(AbsoluteSize)
  88 | 		local AbsolutePositionValue = Fusion.peek(AbsolutePosition)
  89 | 		local UnitValue = Fusion.peek(Unit)
  90 | 
  91 | 		local RelativePosition = Position.X - AbsolutePositionValue.X
  92 | 
  93 | 		Value:set(RoundByUnit(math.clamp(RelativePosition / AbsoluteSizeValue.X, 0, 1), UnitValue))
  94 | 	end
  95 | 
  96 | 	local Slider = Scope:BaseButton(Util.CombineProps(Props, {
  97 | 		Name = script.Name,
  98 | 		Corner = {
  99 | 			Radius = Scope:UDim(0, Theme.CornerRadius.Full),
 100 | 		},
 101 | 		Size = Scope:UDim2Offset(0, Theme.TextSize["1"]),
 102 | 		AutomaticSize = Enum.AutomaticSize.Y,
 103 | 
 104 | 		Disabled = Disabled,
 105 | 		Hovering = Hovering,
 106 | 		Holding = Holding,
 107 | 
 108 | 		[Children] = {
 109 | 			DragDetector,
 110 | 			Scope:Hydrate(Scope:Frame {
 111 | 				Name = "Progress",
 112 | 				Selectable = false,
 113 | 				BackgroundTransparency = 0,
 114 | 				BackgroundColor3 = Theme.Colors.Neutral.Main,
 115 | 				Size = Scope:UDim2(1, 0, 0, Theme.TextSize["0.75"]),
 116 | 				Corner = {
 117 | 					Radius = Scope:UDim(0, Theme.CornerRadius.Full),
 118 | 				},
 119 | 				Flex = {
 120 | 					Mode = Enum.UIFlexMode.Fill,
 121 | 				},
 122 | 
 123 | 				[Children] = {
 124 | 					Scope:Frame {
 125 | 						Name = "Progress",
 126 | 						Selectable = false,
 127 | 						Size = Scope:Computed(function(Use)
 128 | 							local ValueValue = Use(Value)
 129 | 							return UDim2.fromScale(ValueValue, 1)
 130 | 						end),
 131 | 						BackgroundTransparency = Scope:Computed(function(Use)
 132 | 							if Use(Disabled) then
 133 | 								return DISABLED_BACKGROUND_TRANSPARENCY
 134 | 							else
 135 | 								return 0
 136 | 							end
 137 | 						end),
 138 | 						BackgroundColor3 = Scope:Spring(
 139 | 							EffectiveColor,
 140 | 							Theme.SpringSpeed["1"],
 141 | 							Theme.SpringDampening["1"]
 142 | 						),
 143 | 						AutomaticSize = Enum.AutomaticSize.None,
 144 | 						Corner = {
 145 | 							Radius = Scope:UDim(0, Theme.CornerRadius.Full),
 146 | 						},
 147 | 						Stroke = {
 148 | 							Color = Color3.fromRGB(255, 255, 255),
 149 | 							Gradient = {
 150 | 								Color = Scope:Computed(function(Use)
 151 | 									return ColorSequence.new({
 152 | 										ColorSequenceKeypoint.new(
 153 | 											0,
 154 | 											ColorUtils.Lighten(Use(EffectiveColor), Use(EffectiveStrokeEmphasis))
 155 | 										),
 156 | 										ColorSequenceKeypoint.new(1, Use(EffectiveColor)),
 157 | 									})
 158 | 								end),
 159 | 								Rotation = 90,
 160 | 							},
 161 | 							Transparency = Scope:Computed(function(Use)
 162 | 								if Use(Disabled) then
 163 | 									return DISABLED_BACKGROUND_TRANSPARENCY
 164 | 								else
 165 | 									return 0
 166 | 								end
 167 | 							end),
 168 | 						},
 169 | 
 170 | 						[Children] = {
 171 | 							Scope:Frame {
 172 | 								Name = "Ball",
 173 | 								Selectable = false,
 174 | 								AnchorPoint = Scope:Vector2(Value, 0.5),
 175 | 								Position = UDim2.fromScale(1, 0.5),
 176 | 								Size = Scope:UDim2Offset(Theme.TextSize["1"], Theme.TextSize["1"]),
 177 | 								BackgroundTransparency = 0,
 178 | 								BackgroundColor3 = Scope:Computed(function(Use)
 179 | 									if Use(Disabled) then
 180 | 										return Use(Theme.Colors.Neutral.Main)
 181 | 									else
 182 | 										return Use(Theme.Colors.BaseContent.Main)
 183 | 									end
 184 | 								end),
 185 | 								AutomaticSize = Enum.AutomaticSize.None,
 186 | 								Corner = {
 187 | 									Radius = Scope:UDim(0, Theme.CornerRadius.Full),
 188 | 								},
 189 | 								Stroke = {
 190 | 									Color = Theme.Colors.Neutral.Main,
 191 | 									Thickness = Theme.StrokeThickness["1"],
 192 | 								},
 193 | 								Aspect = {
 194 | 									Ratio = 1,
 195 | 								},
 196 | 
 197 | 								[Children] = {
 198 | 									Scope:Frame {
 199 | 										Name = "SmallBall",
 200 | 										Selectable = false,
 201 | 										AspectRatio = 1,
 202 | 										AnchorPoint = Vector2.new(0.5, 0.5),
 203 | 										Position = UDim2.fromScale(0.5, 0.5),
 204 | 										Size = Scope:UDim2Offset(Theme.TextSize["0.75"], Theme.TextSize["0.75"]),
 205 | 										BackgroundTransparency = 0,
 206 | 										BackgroundColor3 = Scope:Spring(
 207 | 											Scope:Computed(function(Use)
 208 | 												if Use(Disabled) then
 209 | 													return Use(Theme.Colors.Neutral.Dark)
 210 | 												else
 211 | 													return Use(EffectiveColor)
 212 | 												end
 213 | 											end),
 214 | 											Theme.SpringSpeed["1"],
 215 | 											Theme.SpringDampening["1"]
 216 | 										),
 217 | 										AutomaticSize = Enum.AutomaticSize.None,
 218 | 										Corner = {
 219 | 											Radius = Scope:UDim(0, Theme.CornerRadius.Full),
 220 | 										},
 221 | 									},
 222 | 								},
 223 | 							},
 224 | 						},
 225 | 					},
 226 | 				},
 227 | 			}) {
 228 | 				[Out "AbsoluteSize"] = AbsoluteSize,
 229 | 				[Out "AbsolutePosition"] = AbsolutePosition,
 230 | 			},
 231 | 		},
 232 | 	}))
 233 | 
 234 | 	DragDetector:set(Scope:New "UIDragDetector" {
 235 | 		DragStyle = Enum.UIDragDetectorDragStyle.Scriptable,
 236 | 		DragAxis = Vector2.new(1, 0),
 237 | 		BoundingUI = Slider,
 238 | 		Enabled = Scope:Computed(function(Use)
 239 | 			return not Use(Disabled)
 240 | 		end),
 241 | 
 242 | 		[OnEvent "DragContinue"] = function(Position: Vector2)
 243 | 			ProcessDrag(Position)
 244 | 		end,
 245 | 		[OnEvent "DragStart"] = function(Position: Vector2)
 246 | 			ProcessDrag(Position)
 247 | 			Holding:set(true)
 248 | 		end,
 249 | 		[OnEvent "DragEnd"] = function()
 250 | 			Holding:set(false)
 251 | 		end,
 252 | 	})
 253 | 
 254 | 	return Slider
 255 | end
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Components/Slider.story.luau`
<details>
<summary>View Source (49 lines)</summary>

```lua
   1 | local OnyxUI = script.Parent.Parent
   2 | local Fusion = require(OnyxUI.Parent.Fusion)
   3 | local Util = require(OnyxUI.Util)
   4 | local Themer = require(OnyxUI.Themer)
   5 | 
   6 | local Children = Fusion.Children
   7 | 
   8 | local Components = {
   9 | 	Slider = require(OnyxUI.Components.Slider),
  10 | 	Frame = require(OnyxUI.Components.Frame),
  11 | }
  12 | 
  13 | return {
  14 | 	story = function(Props)
  15 | 		local Scope = Fusion.scoped(Fusion, Util, Components)
  16 | 		local Theme = Themer.Theme:now()
  17 | 
  18 | 		Scope:Frame {
  19 | 			Parent = Props.target,
  20 | 			Size = Scope:UDim2Offset(Theme.Sizing["16"], 0),
  21 | 			AutomaticSize = Enum.AutomaticSize.Y,
  22 | 			Padding = {
  23 | 				All = Scope:UDim(0, Theme.StrokeThickness["1"]),
  24 | 			},
  25 | 			List = {
  26 | 				Padding = Scope:UDim(0, Theme.Spacing["1"]),
  27 | 				HorizontalFlex = Enum.UIFlexAlignment.Fill,
  28 | 			},
  29 | 
  30 | 			[Children] = {
  31 | 				Scope:Slider {},
  32 | 				Scope:Slider {
  33 | 					Value = 1 / 10,
  34 | 					Unit = 1 / 10,
  35 | 					Color = Util.Colors.Cyan["500"],
  36 | 				},
  37 | 				Scope:Slider {
  38 | 					Value = 1 / 4,
  39 | 					Unit = 1 / 4,
  40 | 					Color = Util.Colors.Fuchsia["500"],
  41 | 				},
  42 | 				Scope:Slider {
  43 | 					Disabled = true,
  44 | 				},
  45 | 			},
  46 | 		}
  47 | 	end,
  48 | 	fusion = Fusion,
  49 | }
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Components/Switch.luau`
<details>
<summary>View Source (258 lines)</summary>

```lua
   1 | --[=[
   2 | 		@class Switch
   3 | 		
   4 | 		Useful for letting the user switch things on / off.
   5 | ]=]
   6 | 
   7 | --[=[
   8 | 		@interface SwitchProps
   9 | 		@within Switch
  10 | 
  11 | 		. ... BaseButtonProps -- All BaseButton properties are accepted.
  12 | 		.Switched boolean? -- Whether the switch is toggled on or off
  13 | 		.Disabled boolean? -- Whether the switch is disabled
  14 | 		.Color Color3? -- The color of the switch when toggled on
  15 | ]=]
  16 | 
  17 | local OnyxUI = script.Parent.Parent
  18 | 
  19 | local Fusion = require(OnyxUI.Parent.Fusion)
  20 | local Util = require(OnyxUI.Util)
  21 | local Themer = require(OnyxUI.Themer)
  22 | local ColorUtils = require(OnyxUI.Parent.ColorUtils)
  23 | 
  24 | local Children = Fusion.Children
  25 | 
  26 | local Frame = require(script.Parent.Frame)
  27 | local BaseButton = require(script.Parent.BaseButton)
  28 | local Components = {
  29 | 	Frame = Frame,
  30 | 	BaseButton = BaseButton,
  31 | }
  32 | 
  33 | export type Props = BaseButton.Props & {
  34 | 	Switched: Fusion.UsedAs<boolean>?,
  35 | 	Color: Fusion.UsedAs<Color3>?,
  36 | }
  37 | 
  38 | return function(Scope: Fusion.Scope<any>, Props: Props)
  39 | 	local Scope = Fusion.innerScope(Scope, Fusion, Util, Components)
  40 | 	local Theme = Themer.Theme:now()
  41 | 
  42 | 	local Switched = Scope:EnsureValue(Util.Fallback(Props.Switched, false))
  43 | 	local Disabled = Scope:EnsureValue(Util.Fallback(Props.Disabled, false))
  44 | 	local Color = Util.Fallback(Props.Color, Theme.Colors.Primary.Main)
  45 | 	local Size = Util.Fallback(
  46 | 		Props.Size,
  47 | 		Scope:Computed(function(Use)
  48 | 			return UDim2.fromOffset(Use(Theme.TextSize["1"]) * 2, Use(Theme.TextSize["1"]))
  49 | 		end)
  50 | 	)
  51 | 	local AutomaticSize = Util.Fallback(Props.AutomaticSize, Enum.AutomaticSize.None)
  52 | 	local Corner = Util.Fallback(Props.Corner, {
  53 | 		Radius = Scope:UDim(0, Theme.CornerRadius["Full"]),
  54 | 	})
  55 | 
  56 | 	local Hovering = Scope:EnsureValue(Util.Fallback(Props.Hovering, false))
  57 | 	local Holding = Scope:EnsureValue(Util.Fallback(Props.Holding, false))
  58 | 
  59 | 	local EffectiveColor = Scope:Computed(function(Use)
  60 | 		local ActiveColor
  61 | 		if Use(Switched) then
  62 | 			ActiveColor = Use(Color)
  63 | 		else
  64 | 			ActiveColor = Use(Theme.Colors.NeutralContent.Dark)
  65 | 		end
  66 | 
  67 | 		if not Use(Disabled) then
  68 | 			if Use(Holding) then
  69 | 				return Util.Emphasize(Use(ActiveColor), Use(Theme.Emphasis.Regular))
  70 | 			elseif Use(Hovering) then
  71 | 				return Util.Emphasize(Use(ActiveColor), Use(Theme.Emphasis.Light))
  72 | 			end
  73 | 		end
  74 | 
  75 | 		return ActiveColor
  76 | 	end)
  77 | 	local EffectiveBallColor = Scope:Computed(function(Use): any
  78 | 		local ActiveColor
  79 | 		if Use(Switched) then
  80 | 			ActiveColor = Use(Theme.Colors.Base.Main)
  81 | 		else
  82 | 			ActiveColor = Use(Theme.Colors.NeutralContent.Dark)
  83 | 		end
  84 | 
  85 | 		if not Use(Disabled) then
  86 | 			if Use(Holding) then
  87 | 				if not Use(Switched) then
  88 | 					return Util.Emphasize(Use(ActiveColor), Use(Theme.Emphasis.Regular))
  89 | 				else
  90 | 					return ActiveColor
  91 | 				end
  92 | 			elseif Use(Hovering) then
  93 | 				if not Use(Switched) then
  94 | 					return Util.Emphasize(Use(ActiveColor), Use(Theme.Emphasis.Light))
  95 | 				else
  96 | 					return ActiveColor
  97 | 				end
  98 | 			end
  99 | 		end
 100 | 
 101 | 		return ActiveColor
 102 | 	end)
 103 | 	local EffectiveStrokeEmphasis = Scope:Computed(function(Use)
 104 | 		local StrokeEmphasis = Use(Theme.StrokeEmphasis.Regular)
 105 | 
 106 | 		if Use(Disabled) or Use(Hovering) or Use(Holding) then
 107 | 			return 0
 108 | 		else
 109 | 			return StrokeEmphasis
 110 | 		end
 111 | 	end)
 112 | 
 113 | 	return Scope:BaseButton(Util.CombineProps(Props, {
 114 | 		Name = script.Name,
 115 | 		Size = Size,
 116 | 		AutomaticSize = AutomaticSize,
 117 | 		Disabled = Disabled,
 118 | 		Stroke = {
 119 | 			Color = Color3.fromRGB(255, 255, 255),
 120 | 			Gradient = {
 121 | 				Color = Scope:Computed(function(Use)
 122 | 					return ColorSequence.new({
 123 | 						ColorSequenceKeypoint.new(
 124 | 							0,
 125 | 							ColorUtils.Lighten(Use(EffectiveColor), Use(EffectiveStrokeEmphasis))
 126 | 						),
 127 | 						ColorSequenceKeypoint.new(1, Use(EffectiveColor)),
 128 | 					})
 129 | 				end),
 130 | 				Rotation = 90,
 131 | 			},
 132 | 			Transparency = Scope:Spring(
 133 | 				Scope:Computed(function(Use)
 134 | 					if Use(Disabled) then
 135 | 						return 0.8
 136 | 					end
 137 | 					if Use(Switched) then
 138 | 						return 0
 139 | 					else
 140 | 						return 0.6
 141 | 					end
 142 | 				end),
 143 | 				Theme.SpringSpeed["1"],
 144 | 				Theme.SpringDampening["1"]
 145 | 			),
 146 | 		},
 147 | 		Corner = Corner,
 148 | 
 149 | 		Hovering = Hovering,
 150 | 		Holding = Holding,
 151 | 
 152 | 		ClickSound = Theme.Sound.Switch,
 153 | 
 154 | 		OnActivate = function()
 155 | 			Switched:set(not Fusion.peek(Switched))
 156 | 		end,
 157 | 
 158 | 		[Children] = {
 159 | 			Scope:Frame {
 160 | 				Name = "Switch",
 161 | 				Size = Size,
 162 | 				AutomaticSize = AutomaticSize,
 163 | 				BackgroundColor3 = Scope:Spring(EffectiveColor, Theme.SpringSpeed["1"], Theme.SpringDampening["1"]),
 164 | 				BackgroundTransparency = Scope:Spring(
 165 | 					Scope:Computed(function(Use)
 166 | 						if Use(Switched) then
 167 | 							return 0
 168 | 						else
 169 | 							return 1
 170 | 						end
 171 | 					end),
 172 | 					Theme.SpringSpeed["1"],
 173 | 					Theme.SpringDampening["1"]
 174 | 				),
 175 | 				Padding = {
 176 | 					All = UDim.new(0, 2),
 177 | 				},
 178 | 				Corner = Corner,
 179 | 
 180 | 				[Children] = {
 181 | 					Scope:Frame {
 182 | 						Name = "Ball",
 183 | 						AnchorPoint = Scope:Spring(
 184 | 							Scope:Computed(function(Use)
 185 | 								if Use(Switched) then
 186 | 									return Vector2.new(1, 0.5)
 187 | 								else
 188 | 									return Vector2.new(0, 0.5)
 189 | 								end
 190 | 							end),
 191 | 							Theme.SpringSpeed["1"],
 192 | 							Theme.SpringDampening["1"]
 193 | 						),
 194 | 						Position = Scope:Spring(
 195 | 							Scope:Computed(function(Use)
 196 | 								if Use(Switched) then
 197 | 									return UDim2.fromScale(1, 0.5)
 198 | 								else
 199 | 									return UDim2.fromScale(0, 0.5)
 200 | 								end
 201 | 							end),
 202 | 							Theme.SpringSpeed["1"],
 203 | 							Theme.SpringDampening["1"]
 204 | 						),
 205 | 						Size = Scope:Spring(
 206 | 							Scope:Computed(function(Use)
 207 | 								local Scale = 0.85
 208 | 								if Use(Hovering) then
 209 | 									Scale *= 1.1
 210 | 								end
 211 | 
 212 | 								return UDim2.fromScale(0, Scale)
 213 | 							end),
 214 | 							Theme.SpringSpeed["1"],
 215 | 							Theme.SpringDampening["1"]
 216 | 						),
 217 | 						AutomaticSize = Enum.AutomaticSize.None,
 218 | 						BackgroundTransparency = Scope:Spring(
 219 | 							Scope:Computed(function(Use)
 220 | 								if Use(Disabled) then
 221 | 									return 0.7
 222 | 								end
 223 | 								if Use(Switched) then
 224 | 									return 0
 225 | 								else
 226 | 									return 0
 227 | 								end
 228 | 							end),
 229 | 							Theme.SpringSpeed["1"],
 230 | 							Theme.SpringDampening["1"]
 231 | 						),
 232 | 						BackgroundColor3 = Scope:Spring(
 233 | 							EffectiveBallColor,
 234 | 							Theme.SpringSpeed["1"],
 235 | 							Theme.SpringDampening["1"]
 236 | 						),
 237 | 						Aspect = {
 238 | 							Ratio = Scope:Spring(
 239 | 								Scope:Computed(function(Use)
 240 | 									if Use(Holding) then
 241 | 										return 1.2
 242 | 									else
 243 | 										return 1
 244 | 									end
 245 | 								end),
 246 | 								Theme.SpringSpeed["1"],
 247 | 								Theme.SpringDampening["1"]
 248 | 							),
 249 | 							Type = Enum.AspectType.ScaleWithParentSize,
 250 | 							DominantAxis = Enum.DominantAxis.Height,
 251 | 						},
 252 | 						Corner = Corner,
 253 | 					},
 254 | 				},
 255 | 			},
 256 | 		},
 257 | 	}, { "Size", "AutomaticSize" }))
 258 | end
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Components/Switch.story.luau`
<details>
<summary>View Source (38 lines)</summary>

```lua
   1 | local OnyxUI = script.Parent.Parent
   2 | local Util = require(OnyxUI.Util)
   3 | local Fusion = require(OnyxUI.Parent.Fusion)
   4 | local Themer = require(OnyxUI.Themer)
   5 | 
   6 | local Children = Fusion.Children
   7 | 
   8 | local Switch = require(script.Parent.Switch)
   9 | local Frame = require(script.Parent.Frame)
  10 | local Components = {
  11 | 	Switch = Switch,
  12 | 	Frame = Frame,
  13 | }
  14 | 
  15 | return {
  16 | 	story = function(Props)
  17 | 		local Scope = Fusion.innerScope(Props.scope, Fusion, Util, Components)
  18 | 		local Theme = Themer.Theme:now()
  19 | 
  20 | 		Scope:Frame {
  21 | 			Parent = Props.target,
  22 | 			Padding = {
  23 | 				All = Scope:UDim(0, Theme.StrokeThickness["1"]),
  24 | 			},
  25 | 			List = {
  26 | 				Padding = Scope:UDim(0, Theme.Spacing["0.5"]),
  27 | 			},
  28 | 
  29 | 			[Children] = {
  30 | 				Scope:Switch {},
  31 | 				Scope:Switch {
  32 | 					Disabled = true,
  33 | 				},
  34 | 			},
  35 | 		}
  36 | 	end,
  37 | 	fusion = Fusion,
  38 | }
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Components/Tabs.luau`
<details>
<summary>View Source (87 lines)</summary>

```lua
   1 | --[=[
   2 | 		@class Tabs
   3 | 		
   4 | 		For tabbing between things.
   5 | ]=]
   6 | 
   7 | --[=[
   8 | 	@interface TabsProps
   9 | 	@within Tabs
  10 | 
  11 | 	. ... ButtonProps -- All Button properties are accepted.
  12 | 	.Tabs { { string } }? -- List of tabs
  13 | 	.Tab number? -- The currently active tab
  14 | 	.Disabled boolean? -- Whether the tabs are disabled
  15 | 	.Color Color3? -- Color of the active tab
  16 | 	.ButtonProps Button.Props? -- Property overrides for child buttons
  17 | ]=]
  18 | 
  19 | local OnyxUI = script.Parent.Parent
  20 | local Fusion = require(OnyxUI.Parent.Fusion)
  21 | local Themer = require(OnyxUI.Themer)
  22 | local Util = require(OnyxUI.Util)
  23 | 
  24 | local Children = Fusion.Children
  25 | 
  26 | local Frame = require(script.Parent.Frame)
  27 | local Button = require(script.Parent.Button)
  28 | 
  29 | export type Props = Frame.Props & {
  30 | 	Tabs: Fusion.UsedAs<{ { string } }>?,
  31 | 	Tab: Fusion.UsedAs<number>?,
  32 | 	Disabled: Fusion.UsedAs<boolean>?,
  33 | 	Color: Fusion.UsedAs<Color3>?,
  34 | 	ButtonProps: Button.Props?,
  35 | }
  36 | 
  37 | return function(Scope: Fusion.Scope<any>, Props: Props)
  38 | 	local Scope = Fusion.innerScope(Scope, Fusion, Util, {
  39 | 		Frame = Frame,
  40 | 		Button = Button,
  41 | 	})
  42 | 	local Theme = Themer.Theme:now()
  43 | 
  44 | 	local Tabs = Util.Fallback(Props.Tabs, {})
  45 | 	local Disabled = Util.Fallback(Props.Disabled, false)
  46 | 	local Color = Util.Fallback(Props.Color, Theme.Colors.Primary.Main)
  47 | 	local Corner = Util.Fallback(Props.Corner, {
  48 | 		Radius = Scope:UDim(0, Theme.CornerRadius["1"]),
  49 | 	})
  50 | 	local ButtonProps = Util.Fallback(Props.ButtonProps, {})
  51 | 
  52 | 	local Tab = Scope:EnsureValue(Util.Fallback(Props.Tab, 1))
  53 | 
  54 | 	return Scope:Frame(Util.CombineProps(Props, {
  55 | 		Name = script.Name,
  56 | 		Corner = Corner,
  57 | 		List = {
  58 | 			FillDirection = Enum.FillDirection.Horizontal,
  59 | 			Padding = Scope:UDim(0, Theme.Spacing["0.5"]),
  60 | 		},
  61 | 
  62 | 		[Children] = {
  63 | 			Scope:ForPairs(Tabs, function(Use, Scope, Index: number, TabContent: { string })
  64 | 				return Index,
  65 | 					Themer.Theme:is(Theme):during(function()
  66 | 						return Scope:Button(Util.CombineProps(ButtonProps, {
  67 | 							Name = "Tab",
  68 | 							Content = TabContent,
  69 | 							Disabled = Disabled,
  70 | 							Color = Scope:Computed(function(Use)
  71 | 								if Index == Use(Tab) then
  72 | 									return Use(Color)
  73 | 								else
  74 | 									return Use(Theme.Colors.Neutral.Main)
  75 | 								end
  76 | 							end),
  77 | 							Corner = Corner,
  78 | 
  79 | 							OnActivate = function()
  80 | 								Tab:set(Index)
  81 | 							end,
  82 | 						}))
  83 | 					end)
  84 | 			end),
  85 | 		},
  86 | 	}))
  87 | end
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Components/Tabs.story.luau`
<details>
<summary>View Source (51 lines)</summary>

```lua
   1 | local OnyxUI = script.Parent.Parent
   2 | local Fusion = require(OnyxUI.Parent.Fusion)
   3 | local Util = require(OnyxUI.Util)
   4 | local Themer = require(OnyxUI.Themer)
   5 | 
   6 | local Children = Fusion.Children
   7 | 
   8 | local Tabs = require(script.Parent.Tabs)
   9 | local Frame = require(script.Parent.Frame)
  10 | local Components = {
  11 | 	Tabs = Tabs,
  12 | 	Frame = Frame,
  13 | }
  14 | 
  15 | return {
  16 | 	story = function(Props)
  17 | 		local Scope = Fusion.innerScope(Props.scope, Fusion, Util, Components)
  18 | 		local Theme = Themer.Theme:now()
  19 | 
  20 | 		Scope:Frame {
  21 | 			Parent = Props.target,
  22 | 			List = {
  23 | 				Padding = Scope:UDim(0, Theme.Spacing["0.75"]),
  24 | 			},
  25 | 			Padding = {
  26 | 				All = Scope:UDim(0, Theme.StrokeThickness["1"]),
  27 | 			},
  28 | 
  29 | 			[Children] = {
  30 | 				Scope:Tabs {
  31 | 					Tabs = { { "Tab 1" }, { "Tab 2" } },
  32 | 				},
  33 | 				Scope:Tabs {
  34 | 					Tabs = { { "Tab 1" }, { "Tab 2" } },
  35 | 					Disabled = true,
  36 | 				},
  37 | 				Scope:Tabs {
  38 | 					Tabs = { { "1" }, { "2" }, { "3" } },
  39 | 					Color = Theme.Colors.BaseContent.Main,
  40 | 					Corner = {
  41 | 						Radius = Scope:UDim(0, Theme.CornerRadius["0"]),
  42 | 					},
  43 | 					List = {
  44 | 						Padding = Scope:UDim(0, Theme.Spacing["0"]),
  45 | 					},
  46 | 				},
  47 | 			},
  48 | 		}
  49 | 	end,
  50 | 	fusion = Fusion,
  51 | }
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Components/Text.luau`
<details>
<summary>View Source (93 lines)</summary>

```lua
   1 | --[=[
   2 | 		@class Text
   3 | 		
   4 | 		For displaying text. *Lorem ipsum dolo..*
   5 | ]=]
   6 | 
   7 | --[=[
   8 | 	@interface TextProps
   9 | 	@within Text
  10 | 	
  11 | 	. ... BaseProps -- All Base properties are accepted.
  12 | 	.Text string? -- The text to display.
  13 | 	.TextColor3 Color3? -- The color of the text.
  14 | 	.TextSize number? -- The size of the text.
  15 | 	.RichText boolean? -- Whether the text supports rich text formatting.
  16 | 	.FontFace Font? -- The font face of the text.
  17 | 	.TextWrapped boolean? -- Whether the text should wrap when it exceeds the label's width.
  18 | 	.TextXAlignment Enum.TextXAlignment? -- The horizontal alignment of the text.
  19 | 	.TextYAlignment Enum.TextYAlignment? -- The vertical alignment of the text.
  20 | 	.Font Enum.Font? -- The font of the text (deprecated, use FontFace instead).
  21 | 	.TextScaled boolean? -- Whether the text should scale to fit the label.
  22 | 	.TextTruncate boolean? -- Whether the text should truncate when it exceeds the label's width.
  23 | 	.LineHeight number? -- The line height of the text.
  24 | 	.LocalizedText string? -- The localized text to display.
  25 | 	.MaxVisibleGraphemes number? -- The maximum number of visible graphemes.
  26 | 	.TextTransparency number? -- The transparency of the text.
  27 | ]=]
  28 | 
  29 | local OnyxUI = script.Parent.Parent
  30 | local Fusion = require(OnyxUI.Parent.Fusion)
  31 | local Util = require(OnyxUI.Util)
  32 | local Themer = require(OnyxUI.Themer)
  33 | 
  34 | local Base = require(script.Parent.Base)
  35 | local Components = {
  36 | 	Base = Base,
  37 | }
  38 | 
  39 | export type Props = Base.Props & {
  40 | 	Text: Fusion.UsedAs<string>?,
  41 | 	TextColor3: Fusion.UsedAs<Color3>?,
  42 | 	TextSize: Fusion.UsedAs<number>?,
  43 | 	RichText: Fusion.UsedAs<boolean>?,
  44 | 	FontFace: Fusion.UsedAs<Font>?,
  45 | 	TextWrapped: Fusion.UsedAs<boolean>?,
  46 | 	TextXAlignment: Fusion.UsedAs<Enum.TextXAlignment>?,
  47 | 	TextYAlignment: Fusion.UsedAs<Enum.TextYAlignment>?,
  48 | 	Font: Fusion.UsedAs<Enum.Font>?,
  49 | 	TextScaled: Fusion.UsedAs<boolean>?,
  50 | 	TextTruncate: Fusion.UsedAs<boolean>?,
  51 | 	LineHeight: Fusion.UsedAs<number>?,
  52 | 	LocalizedText: Fusion.UsedAs<string>?,
  53 | 	MaxVisibleGraphemes: Fusion.UsedAs<number>?,
  54 | 	TextTransparency: Fusion.UsedAs<number>?,
  55 | }
  56 | 
  57 | return function(Scope: Fusion.Scope<any>, Props: Props): Instance
  58 | 	local Scope = Fusion.innerScope(Scope, Fusion, Util, Components)
  59 | 	local Theme = Themer.Theme:now()
  60 | 
  61 | 	local TextColor3 = Util.Fallback(Props.TextColor3, Theme.Colors.BaseContent.Main)
  62 | 	local TextSize = Util.Fallback(Props.TextSize, Theme.TextSize["1"])
  63 | 	local RichText = Util.Fallback(Props.RichText, true)
  64 | 	local FontFace = Util.Fallback(Props.FontFace, Scope:Font(Theme.Font.Body, Theme.FontWeight.Body))
  65 | 	local TextWrapped = Util.Fallback(Props.TextWrapped, true)
  66 | 	local TextXAlignment = Util.Fallback(Props.TextXAlignment, Enum.TextXAlignment.Left)
  67 | 	local TextYAlignment = Util.Fallback(Props.TextYAlignment, Enum.TextYAlignment.Top)
  68 | 
  69 | 	return Scope:Hydrate(Scope:Base(Util.CombineProps(Props, {
  70 | 		ClassName = "TextLabel",
  71 | 		Name = script.Name,
  72 | 		AutomaticSize = Enum.AutomaticSize.XY,
  73 | 		ClipsDescendants = false,
  74 | 		BackgroundTransparency = 1,
  75 | 	}))) {
  76 | 		TextColor3 = TextColor3,
  77 | 		TextSize = TextSize,
  78 | 		RichText = RichText,
  79 | 		FontFace = FontFace,
  80 | 		TextWrapped = TextWrapped,
  81 | 		TextXAlignment = TextXAlignment,
  82 | 		TextYAlignment = TextYAlignment,
  83 | 
  84 | 		Text = Props.Text,
  85 | 		TextTransparency = Props.TextTransparency,
  86 | 		MaxVisibleGraphemes = Props.MaxVisibleGraphemes,
  87 | 		LocalizedText = Props.LocalizedText,
  88 | 		LineHeight = Props.LineHeight,
  89 | 		TextTruncate = Props.TextTruncate,
  90 | 		TextScaled = Props.TextScaled,
  91 | 		Font = Props.Font,
  92 | 	}
  93 | end
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Components/Text.story.luau`
<details>
<summary>View Source (19 lines)</summary>

```lua
   1 | local OnyxUI = script.Parent.Parent
   2 | local Fusion = require(OnyxUI.Parent.Fusion)
   3 | local Util = require(OnyxUI.Util)
   4 | 
   5 | local Components = {
   6 | 	Text = require(OnyxUI.Components.Text),
   7 | }
   8 | 
   9 | return {
  10 | 	story = function(Props)
  11 | 		local Scope = Fusion.scoped(Fusion, Util, Components)
  12 | 
  13 | 		Scope:Text {
  14 | 			Parent = Props.target,
  15 | 			Text = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.",
  16 | 		}
  17 | 	end,
  18 | 	fusion = Fusion,
  19 | }
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Components/TextArea.luau`
<details>
<summary>View Source (33 lines)</summary>

```lua
   1 | --[=[
   2 | 		@class TextArea
   3 | 		
   4 | 		Like [`TextInput`](/api/TextInput), but dedicated for multi-line use-cases.
   5 | ]=]
   6 | 
   7 | --[=[
   8 | 		@within TextArea
   9 | 		@interface TextAreaProps
  10 | 
  11 | 		. ... TextInputProps -- All TextInput properties are accepted.
  12 | ]=]
  13 | 
  14 | local OnyxUI = script.Parent.Parent
  15 | local Util = require(OnyxUI.Util)
  16 | local Fusion = require(OnyxUI.Parent.Fusion)
  17 | 
  18 | local TextInput = require(OnyxUI.Components.TextInput)
  19 | local Components = {
  20 | 	TextInput = TextInput,
  21 | }
  22 | 
  23 | export type Props = TextInput.Props & {}
  24 | 
  25 | return function(Scope: Fusion.Scope<any>, Props: Props)
  26 | 	local Scope = Fusion.innerScope(Scope, Fusion, Util, Components)
  27 | 
  28 | 	return Scope:TextInput(Util.CombineProps(Props, {
  29 | 		AutomaticSize = Enum.AutomaticSize.None,
  30 | 		TextWrapped = true,
  31 | 		MultiLine = true,
  32 | 	}))
  33 | end
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Components/TextArea.story.luau`
<details>
<summary>View Source (54 lines)</summary>

```lua
   1 | local OnyxUI = script.Parent.Parent
   2 | local Util = require(OnyxUI.Util)
   3 | local Fusion = require(OnyxUI.Parent.Fusion)
   4 | local Themer = require(OnyxUI.Themer)
   5 | 
   6 | local Children = Fusion.Children
   7 | 
   8 | local TextArea = require(script.Parent.TextArea)
   9 | local Frame = require(script.Parent.Frame)
  10 | local Components = {
  11 | 	TextArea = TextArea,
  12 | 	Frame = Frame,
  13 | }
  14 | 
  15 | return {
  16 | 	story = function(Props)
  17 | 		local Scope = Fusion.innerScope(Props.scope, Fusion, Util, Components)
  18 | 		local Theme = Themer.Theme:now()
  19 | 
  20 | 		Scope:Frame {
  21 | 			Parent = Props.target,
  22 | 			Size = UDim2.fromOffset(250, 0),
  23 | 			AutomaticSize = Enum.AutomaticSize.Y,
  24 | 			List = {
  25 | 				Padding = Scope:UDim(0, Theme.Spacing["0.5"]),
  26 | 			},
  27 | 			Padding = {
  28 | 				All = Scope:UDim(0, Theme.StrokeThickness["1"]),
  29 | 			},
  30 | 
  31 | 			[Children] = {
  32 | 				Scope:TextArea {
  33 | 					Size = Scope:Computed(function(Use)
  34 | 						return UDim2.new(
  35 | 							UDim.new(1, 0),
  36 | 							UDim.new(0, (Use(Theme.TextSize["1"]) * 2) + (Use(Theme.Spacing["0.5"]) * 2))
  37 | 						)
  38 | 					end),
  39 | 				},
  40 | 				Scope:TextArea {
  41 | 					Size = UDim2.new(UDim.new(1, 0), UDim.new(0, 100)),
  42 | 					CharacterLimit = 60,
  43 | 					PlaceholderText = "This TextArea has a character limit.",
  44 | 				},
  45 | 				Scope:TextArea {
  46 | 					Size = UDim2.new(UDim.new(1, 0), UDim.new(0, 0)),
  47 | 					AutomaticSize = Enum.AutomaticSize.Y,
  48 | 					PlaceholderText = "This one will expand as you type.",
  49 | 				},
  50 | 			},
  51 | 		}
  52 | 	end,
  53 | 	fusion = Fusion,
  54 | }
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Components/TextInput.luau`
<details>
<summary>View Source (259 lines)</summary>

```lua
   1 | --[=[
   2 | 		@class TextInput
   3 | 		
   4 | 		For letting the user input text.
   5 | ]=]
   6 | 
   7 | --[=[
   8 | 	@interface TextInputProps
   9 | 	@within TextInput
  10 | 
  11 | 	. ... BaseProps -- All Base properties are accepted.
  12 | 	.Disabled boolean? -- Whether the text input is disabled.
  13 | 	.CharacterLimit number? -- The maximum number of characters allowed in the text input.
  14 | 	.Color Color3? -- The color of the text input's border when focused.
  15 | 	.PlaceholderText string? -- The placeholder text displayed when the input is empty.
  16 | 	.Text string? -- The current text in the text input.
  17 | 	.ClearTextOnFocus boolean? -- Whether the text should be cleared when the input gains focus.
  18 | 	.TextWrapped boolean? -- Whether the text should wrap within the input.
  19 | 	.TextEditable boolean? -- Whether the text input is editable.
  20 | 	.MultiLine boolean? -- Whether the text input supports multiple lines.
  21 | 	.TextSize number? -- The size of the text.
  22 | 	.TextColor3 Color3? -- The color of the text.
  23 | 	.FontFace Font? -- The font face of the text.
  24 | 	.PlaceholderColor3 Color3? -- The color of the placeholder text.
  25 | 	.TextXAlignment Enum.TextXAlignment? -- The horizontal alignment of the text.
  26 | 	.TextYAlignment Enum.TextYAlignment? -- The vertical alignment of the text.
  27 | 	.TextTransparency number? -- The transparency of the text.
  28 | 	.TextProcessor (string) -> string? -- A function to process the text input, and return new text.
  29 | 	.Focusing boolean? -- Whether the text input is currently focused.
  30 | 	.Hovering boolean? -- Whether the mouse is hovering over the text input.
  31 | 	.OnFocus () -> ()? -- A callback function triggered when the text input gains focus.
  32 | 	.OnFocusEnd () -> ()? -- A callback function triggered when the text input loses focus.
  33 | ]=]
  34 | 
  35 | local SoundService = game:GetService("SoundService")
  36 | 
  37 | local OnyxUI = script.Parent.Parent
  38 | local Fusion = require(OnyxUI.Parent.Fusion)
  39 | local Util = require(OnyxUI.Util)
  40 | local Themer = require(OnyxUI.Themer)
  41 | 
  42 | local OnEvent = Fusion.OnEvent
  43 | 
  44 | local Base = require(script.Parent.Base)
  45 | local Components = {
  46 | 	Base = Base,
  47 | }
  48 | 
  49 | export type Props = Base.Props & {
  50 | 	Disabled: Fusion.UsedAs<boolean>?,
  51 | 	CharacterLimit: Fusion.UsedAs<number>?,
  52 | 	Color: Fusion.UsedAs<Color3>?,
  53 | 	PlaceholderText: Fusion.UsedAs<string>?,
  54 | 	Text: Fusion.UsedAs<string>?,
  55 | 	ClearTextOnFocus: Fusion.UsedAs<boolean>?,
  56 | 	TextWrapped: Fusion.UsedAs<boolean>?,
  57 | 	TextEditable: Fusion.UsedAs<boolean>?,
  58 | 	MultiLine: Fusion.UsedAs<boolean>?,
  59 | 	TextSize: Fusion.UsedAs<number>?,
  60 | 	TextColor3: Fusion.UsedAs<Color3>?,
  61 | 	FontFace: Fusion.UsedAs<Font>?,
  62 | 	PlaceholderColor3: Fusion.UsedAs<Color3>?,
  63 | 	TextXAlignment: Fusion.UsedAs<Enum.TextXAlignment>?,
  64 | 	TextYAlignment: Fusion.UsedAs<Enum.TextYAlignment>?,
  65 | 	TextTransparency: Fusion.UsedAs<number>?,
  66 | 	TextProcessor: Fusion.UsedAs<(string) -> string>?,
  67 | 
  68 | 	Focusing: Fusion.UsedAs<boolean>?,
  69 | 	Hovering: Fusion.UsedAs<boolean>?,
  70 | 
  71 | 	OnFocus: Fusion.UsedAs<() -> ()>?,
  72 | 	OnFocusEnd: Fusion.UsedAs<() -> ()>?,
  73 | }
  74 | 
  75 | return function(Scope: Fusion.Scope<any>, Props: Props)
  76 | 	local Scope = Fusion.innerScope(Scope, Fusion, Util, Components)
  77 | 	local Theme = Themer.Theme:now()
  78 | 
  79 | 	local Text = Scope:EnsureValue(Util.Fallback(Props.Text, ""))
  80 | 	local Focusing = Scope:EnsureValue(Util.Fallback(Props.Focusing, false))
  81 | 	local Hovering = Scope:EnsureValue(Util.Fallback(Props.Hovering, false))
  82 | 
  83 | 	local Disabled = Util.Fallback(Props.Disabled, false)
  84 | 	local OnFocus = Util.Fallback(Props.OnFocus, function() end)
  85 | 	local OnFocusEnd = Util.Fallback(Props.OnFocusEnd, function() end)
  86 | 	local Color = Util.Fallback(Props.Color, Theme.Colors.Primary.Main)
  87 | 	local CharacterLimit = Util.Fallback(Props.CharacterLimit, -1)
  88 | 	local ClearTextOnFocus = Util.Fallback(Props.ClearTextOnFocus, false)
  89 | 	local PlaceholderText = Util.Fallback(Props.PlaceholderText, "")
  90 | 	local TextSize = Util.Fallback(Props.TextSize, Theme.TextSize["1"])
  91 | 	local PlaceholderColor3 = Util.Fallback(Props.PlaceholderColor3, Theme.Colors.NeutralContent.Dark)
  92 | 	local TextColor3 = Util.Fallback(
  93 | 		Props.TextColor3,
  94 | 		Scope:Computed(function(Use)
  95 | 			return Use(Theme.Colors.BaseContent.Main)
  96 | 		end)
  97 | 	)
  98 | 	local FontFace = Util.Fallback(Props.FontFace, Scope:Font(Theme.Font.Body, Theme.FontWeight.Body))
  99 | 	local TextXAlignment = Util.Fallback(Props.TextXAlignment, Enum.TextXAlignment.Left)
 100 | 	local TextYAlignment = Util.Fallback(Props.TextYAlignment, Enum.TextYAlignment.Top)
 101 | 	local TextTransparency = Util.Fallback(
 102 | 		Props.TextTransparency,
 103 | 
 104 | 		Scope:Computed(function(Use)
 105 | 			if Use(Disabled) then
 106 | 				return 0.75
 107 | 			elseif Use(Focusing) then
 108 | 				return 0
 109 | 			else
 110 | 				return 0.5
 111 | 			end
 112 | 		end)
 113 | 	)
 114 | 	local TextProcessor = Util.Fallback(Props.TextProcessor, function(NewText)
 115 | 		return NewText
 116 | 	end)
 117 | 	local TextEditable = Util.Fallback(
 118 | 		Props.TextEditable,
 119 | 		Scope:Computed(function(Use)
 120 | 			return not Use(Disabled)
 121 | 		end)
 122 | 	)
 123 | 
 124 | 	local InvalidInputActive = Scope:Value(false)
 125 | 
 126 | 	local function ProcessText(NewText: string)
 127 | 		local CharacterLimitValue = Fusion.peek(CharacterLimit)
 128 | 		local TextProcessorValue = Fusion.peek(TextProcessor)
 129 | 		local LimitedText = NewText:sub(1, utf8.offset(NewText, CharacterLimitValue))
 130 | 		local FullyProcessedText = TextProcessorValue(LimitedText)
 131 | 
 132 | 		return FullyProcessedText
 133 | 	end
 134 | 
 135 | 	local Object = Scope:Hydrate(Scope:Base(Util.CombineProps(Props, {
 136 | 		ClassName = "TextBox",
 137 | 		Name = script.Name,
 138 | 		Corner = {
 139 | 			Radius = Scope:UDim(0, Theme.CornerRadius["1"]),
 140 | 		},
 141 | 		Padding = {
 142 | 			All = Scope:UDim(0, Theme.Padding["0.5"]),
 143 | 		},
 144 | 		Stroke = {
 145 | 			Color = Scope:Spring(
 146 | 				Scope:Computed(function(Use)
 147 | 					if Use(InvalidInputActive) then
 148 | 						return Use(Theme.Colors.Error.Main)
 149 | 					elseif Use(Focusing) then
 150 | 						return Use(Color)
 151 | 					else
 152 | 						return Use(Theme.Colors.NeutralContent.Dark)
 153 | 					end
 154 | 				end),
 155 | 				Theme.SpringSpeed["1"],
 156 | 				Theme.SpringDampening["1"]
 157 | 			),
 158 | 			Transparency = Scope:Spring(
 159 | 				Scope:Computed(function(Use)
 160 | 					if Use(Disabled) then
 161 | 						return 0.8
 162 | 					end
 163 | 					if Use(Focusing) then
 164 | 						return 0
 165 | 					else
 166 | 						return 0.6
 167 | 					end
 168 | 				end),
 169 | 				Theme.SpringSpeed["1"],
 170 | 				Theme.SpringDampening["1"]
 171 | 			),
 172 | 		},
 173 | 		AutomaticSize = Enum.AutomaticSize.XY,
 174 | 		AutoLocalize = false,
 175 | 		Active = Scope:Computed(function(Use)
 176 | 			return not Use(Disabled)
 177 | 		end),
 178 | 		BackgroundTransparency = 1,
 179 | 		ClipsDescendants = true,
 180 | 	}))) {
 181 | 		Text = Text,
 182 | 		TextColor3 = Scope:Spring(
 183 | 			Scope:Computed(function(Use)
 184 | 				if Use(InvalidInputActive) then
 185 | 					return Use(Theme.Colors.Error.Main)
 186 | 				else
 187 | 					return Use(TextColor3)
 188 | 				end
 189 | 			end),
 190 | 			Theme.SpringSpeed.Immediate,
 191 | 			Theme.SpringDampening["1"]
 192 | 		),
 193 | 		TextSize = TextSize,
 194 | 		FontFace = FontFace,
 195 | 		PlaceholderColor3 = PlaceholderColor3,
 196 | 		PlaceholderText = PlaceholderText,
 197 | 		TextXAlignment = TextXAlignment,
 198 | 		TextYAlignment = TextYAlignment,
 199 | 		ClearTextOnFocus = ClearTextOnFocus,
 200 | 		TextTransparency = Scope:Spring(TextTransparency, Theme.SpringSpeed["1"], Theme.SpringDampening["1"]),
 201 | 		TextEditable = TextEditable,
 202 | 
 203 | 		MultiLine = Props.MultiLine,
 204 | 		TextWrapped = Props.TextWrapped,
 205 | 
 206 | 		[OnEvent "Focused"] = function()
 207 | 			if (not Fusion.peek(Disabled)) and Fusion.peek(TextEditable) then
 208 | 				Focusing:set(true)
 209 | 
 210 | 				SoundService:PlayLocalSound(Fusion.peek(Theme.Sound.Focus))
 211 | 
 212 | 				Fusion.peek(OnFocus)()
 213 | 			end
 214 | 		end,
 215 | 		[OnEvent "FocusLost"] = function()
 216 | 			Focusing:set(false)
 217 | 
 218 | 			Fusion.peek(OnFocusEnd)()
 219 | 		end,
 220 | 		[OnEvent "MouseEnter"] = function()
 221 | 			if not Fusion.peek(Disabled) then
 222 | 				Hovering:set(true)
 223 | 
 224 | 				SoundService:PlayLocalSound(Fusion.peek(Theme.Sound.Hover))
 225 | 			end
 226 | 		end,
 227 | 		[OnEvent "MouseLeave"] = function()
 228 | 			if not Fusion.peek(Disabled) then
 229 | 				Hovering:set(false)
 230 | 			end
 231 | 		end,
 232 | 		[OnEvent "SelectionGained"] = function()
 233 | 			if (not Fusion.peek(Disabled)) and Fusion.peek(TextEditable) then
 234 | 				SoundService:PlayLocalSound(Fusion.peek(Theme.Sound.Hover))
 235 | 			end
 236 | 		end,
 237 | 	}
 238 | 
 239 | 	table.insert(
 240 | 		Scope,
 241 | 		Object:GetPropertyChangedSignal("Text"):Connect(function()
 242 | 			local NewText = Object.Text
 243 | 			local ProcessedText = ProcessText(NewText)
 244 | 
 245 | 			Text:set(ProcessedText)
 246 | 			if Object.Text ~= ProcessedText then
 247 | 				Object.Text = ProcessedText
 248 | 			end
 249 | 
 250 | 			if utf8.len(NewText) ~= utf8.len(ProcessedText) then
 251 | 				InvalidInputActive:set(true)
 252 | 				task.wait(0.075)
 253 | 				InvalidInputActive:set(false)
 254 | 			end
 255 | 		end)
 256 | 	)
 257 | 
 258 | 	return Object
 259 | end
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Components/TextInput.story.luau`
<details>
<summary>View Source (50 lines)</summary>

```lua
   1 | local OnyxUI = script.Parent.Parent
   2 | local Util = require(OnyxUI.Util)
   3 | local Fusion = require(OnyxUI.Parent.Fusion)
   4 | local Themer = require(OnyxUI.Themer)
   5 | 
   6 | local Children = Fusion.Children
   7 | 
   8 | local TextInput = require(script.Parent.TextInput)
   9 | local Frame = require(script.Parent.Frame)
  10 | local Components = {
  11 | 	Frame = Frame,
  12 | 	TextInput = TextInput,
  13 | }
  14 | 
  15 | return {
  16 | 	story = function(Props)
  17 | 		local Scope = Fusion.innerScope(Props.scope, Fusion, Util, Components)
  18 | 		local Theme = Themer.Theme:now()
  19 | 
  20 | 		Scope:Frame {
  21 | 			Parent = Props.target,
  22 | 			Size = UDim2.fromOffset(250, 0),
  23 | 			AutomaticSize = Enum.AutomaticSize.Y,
  24 | 			List = {
  25 | 				Padding = Scope:UDim(0, Theme.Spacing["0.5"]),
  26 | 				HorizontalFlex = Enum.UIFlexAlignment.Fill,
  27 | 			},
  28 | 			Padding = {
  29 | 				All = Scope:UDim(0, Theme.StrokeThickness["1"]),
  30 | 			},
  31 | 
  32 | 			[Children] = {
  33 | 				Scope:TextInput {},
  34 | 				Scope:TextInput {
  35 | 					PlaceholderText = "Disabled TextInput.",
  36 | 					Disabled = true,
  37 | 				},
  38 | 				Scope:TextInput {
  39 | 					PlaceholderText = "Twenty characters only!",
  40 | 					CharacterLimit = 20,
  41 | 				},
  42 | 				Scope:TextInput {
  43 | 					PlaceholderText = "Something dangerous!",
  44 | 					Color = Theme.Colors.Error.Main,
  45 | 				},
  46 | 			},
  47 | 		}
  48 | 	end,
  49 | 	fusion = Fusion,
  50 | }
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Components/TextSwap.luau`
<details>
<summary>View Source (228 lines)</summary>

```lua
   1 | --[=[
   2 | 		@class TextSwap
   3 | 		
   4 | 		Swap between an array values.
   5 | ]=]
   6 | 
   7 | --[=[
   8 | 	@interface TextSwapProps
   9 | 	@within TextSwap
  10 | 	
  11 | 	. ... BaseButtonProps -- All BaseButton properties are accepted.
  12 | 	.Options {string}? -- Array of string options to swap between
  13 | 	.Selection number? -- The currently selected option index
  14 | 	.Disabled boolean? -- Whether the TextSwap is disabled
  15 | 	.Color Color3? -- The color of the content
  16 | 	.ContentSize number? -- The size of the content
  17 | ]=]
  18 | 
  19 | local OnyxUI = script.Parent.Parent
  20 | local Fusion = require(OnyxUI.Parent.Fusion)
  21 | local Util = require(OnyxUI.Util)
  22 | local Themer = require(OnyxUI.Themer)
  23 | 
  24 | local Children = Fusion.Children
  25 | 
  26 | local BaseButton = require(script.Parent.BaseButton)
  27 | local Components = {
  28 | 	BaseButton = BaseButton,
  29 | 	Text = require(script.Parent.Text),
  30 | 	IconButton = require(script.Parent.IconButton),
  31 | }
  32 | 
  33 | export type Props = BaseButton.Props & {
  34 | 	Options: Fusion.UsedAs<{ string }>?,
  35 | 	Selection: Fusion.UsedAs<number>?,
  36 | 	Disabled: Fusion.UsedAs<boolean>?,
  37 | 	Color: Fusion.UsedAs<Color3>?,
  38 | 	ContentSize: Fusion.UsedAs<number>?,
  39 | }
  40 | 
  41 | return function(Scope: Fusion.Scope<any>, Props: Props)
  42 | 	local Scope = Fusion.innerScope(Scope, Fusion, Util, Components)
  43 | 	local Theme = Themer.Theme:now()
  44 | 
  45 | 	local Options = Util.Fallback(Props.Options, {})
  46 | 	local Selection = Scope:EnsureValue(Util.Fallback(Props.Selection, 1))
  47 | 	local Color = Util.Fallback(Props.Color, Theme.Colors.BaseContent.Main)
  48 | 	local Disabled = Util.Fallback(Props.Disabled, false)
  49 | 	local ContentSize = Util.Fallback(Props.ContentSize, Theme.TextSize["1"])
  50 | 
  51 | 	local Holding = Scope:Value(false)
  52 | 	local Hovering = Scope:Value(false)
  53 | 	local ShownIncrement = Scope:Value(0)
  54 | 
  55 | 	local SelectionContent = Scope:Computed(function(Use)
  56 | 		local OptionsValue = Use(Options)
  57 | 		local SelectionValue = Use(Selection)
  58 | 
  59 | 		return OptionsValue[SelectionValue]
  60 | 	end)
  61 | 	local EffectiveContentColor = Scope:Computed(function(Use)
  62 | 		if Use(Disabled) then
  63 | 			return Use(Theme.Colors.BaseContent.Main)
  64 | 		else
  65 | 			if Use(Holding) then
  66 | 				return Util.Emphasize(Use(Color), Use(Theme.Emphasis.Regular))
  67 | 			elseif Use(Hovering) then
  68 | 				return Util.Emphasize(Use(Color), Use(Theme.Emphasis.Light))
  69 | 			else
  70 | 				return Use(Color)
  71 | 			end
  72 | 		end
  73 | 	end)
  74 | 
  75 | 	Scope:Observer(Options):onChange(function()
  76 | 		Selection:set(1)
  77 | 	end)
  78 | 
  79 | 	local function RotateSelection(Increment: number)
  80 | 		local OptionsValue = Fusion.peek(Options)
  81 | 		local SelectionValue = Fusion.peek(Selection)
  82 | 		local NewSelection = SelectionValue + Increment
  83 | 
  84 | 		if NewSelection > #OptionsValue then
  85 | 			NewSelection = 1
  86 | 		elseif NewSelection < 1 then
  87 | 			NewSelection = #OptionsValue
  88 | 		end
  89 | 
  90 | 		Selection:set(NewSelection)
  91 | 	end
  92 | 
  93 | 	local OldSelectionValue = Fusion.peek(Props.Selection) or 1
  94 | 	Scope:Observer(Selection):onChange(function()
  95 | 		local SelectionValue = Fusion.peek(Selection)
  96 | 
  97 | 		local SelectionIncreased = SelectionValue > OldSelectionValue
  98 | 		ShownIncrement:set((SelectionIncreased and 1) or -1)
  99 | 		task.wait(0.1)
 100 | 		ShownIncrement:set(0)
 101 | 	end)
 102 | 
 103 | 	local NoPadding = Scope:UDim(0, Theme.Spacing["0"])
 104 | 
 105 | 	return Scope:BaseButton(Util.CombineProps(Props, {
 106 | 		Name = script.Name,
 107 | 		List = {
 108 | 			HorizontalFlex = Enum.UIFlexAlignment.SpaceBetween,
 109 | 			FillDirection = Enum.FillDirection.Horizontal,
 110 | 			VerticalAlignment = Enum.VerticalAlignment.Center,
 111 | 		},
 112 | 		Padding = {
 113 | 			All = Scope:UDim(0, Theme.Padding["0.5"]),
 114 | 		},
 115 | 		Stroke = {
 116 | 			Color = Color,
 117 | 			Transparency = Scope:Spring(
 118 | 				Scope:Computed(function(Use)
 119 | 					if Use(Disabled) then
 120 | 						return 0.9
 121 | 					else
 122 | 						return 0.8
 123 | 					end
 124 | 				end),
 125 | 				Theme.SpringSpeed["1"],
 126 | 				Theme.SpringDampening["1"]
 127 | 			),
 128 | 		},
 129 | 		Corner = {
 130 | 			Radius = Scope:UDim(0, Theme.CornerRadius["1"]),
 131 | 		},
 132 | 
 133 | 		Disabled = Disabled,
 134 | 
 135 | 		Holding = Holding,
 136 | 		Hovering = Hovering,
 137 | 
 138 | 		OnActivate = function()
 139 | 			RotateSelection(1)
 140 | 		end,
 141 | 
 142 | 		[Children] = {
 143 | 			Scope:IconButton {
 144 | 				Name = "LeftArrow",
 145 | 				Image = "rbxassetid://136326079088976",
 146 | 				Style = "Ghost",
 147 | 				Color = Color,
 148 | 				Disabled = Disabled,
 149 | 				ContentSize = Scope:Spring(
 150 | 					Scope:Computed(function(Use)
 151 | 						local ShownIncrementValue = Use(ShownIncrement)
 152 | 						local ContentSizeValue = Use(ContentSize)
 153 | 
 154 | 						if ShownIncrementValue < 0 then
 155 | 							return ContentSizeValue * (1 - Use(Theme.Emphasis.Regular))
 156 | 						else
 157 | 							return Use(ContentSizeValue)
 158 | 						end
 159 | 					end),
 160 | 					Theme.SpringSpeed["1"],
 161 | 					Theme.SpringDampening["1"]
 162 | 				),
 163 | 				Padding = {
 164 | 					Top = NoPadding,
 165 | 					Left = NoPadding,
 166 | 					Right = NoPadding,
 167 | 					Bottom = NoPadding,
 168 | 				},
 169 | 
 170 | 				OnActivate = function()
 171 | 					RotateSelection(-1)
 172 | 				end,
 173 | 			},
 174 | 			Scope:Text {
 175 | 				Text = Scope:Computed(function(Use)
 176 | 					local SelectionContentValue = Use(SelectionContent)
 177 | 					if SelectionContentValue ~= nil then
 178 | 						return SelectionContentValue
 179 | 					else
 180 | 						return ""
 181 | 					end
 182 | 				end),
 183 | 				TextColor3 = EffectiveContentColor,
 184 | 				TextTransparency = Scope:Computed(function(Use)
 185 | 					if Use(Disabled) then
 186 | 						return 0.75
 187 | 					else
 188 | 						return 0
 189 | 					end
 190 | 				end),
 191 | 				SizeLimit = {
 192 | 					Min = Scope:Vector2(0, ContentSize),
 193 | 				},
 194 | 			},
 195 | 			Scope:IconButton {
 196 | 				Name = "RightArrow",
 197 | 				Image = "rbxassetid://85293585205481",
 198 | 				Style = "Ghost",
 199 | 				Color = Color,
 200 | 				Disabled = Disabled,
 201 | 				ContentSize = Scope:Spring(
 202 | 					Scope:Computed(function(Use)
 203 | 						local ShownIncrementValue = Use(ShownIncrement)
 204 | 						local ContentSizeValue = Use(ContentSize)
 205 | 
 206 | 						if ShownIncrementValue > 0 then
 207 | 							return Use(ContentSizeValue * (1 - Use(Theme.Emphasis.Regular)))
 208 | 						else
 209 | 							return Use(ContentSizeValue)
 210 | 						end
 211 | 					end),
 212 | 					Theme.SpringSpeed["1"],
 213 | 					Theme.SpringDampening["1"]
 214 | 				),
 215 | 				Padding = {
 216 | 					Top = NoPadding,
 217 | 					Left = NoPadding,
 218 | 					Right = NoPadding,
 219 | 					Bottom = NoPadding,
 220 | 				},
 221 | 
 222 | 				OnActivate = function()
 223 | 					RotateSelection(1)
 224 | 				end,
 225 | 			},
 226 | 		},
 227 | 	}))
 228 | end
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Components/TextSwap.story.luau`
<details>
<summary>View Source (46 lines)</summary>

```lua
   1 | local OnyxUI = script.Parent.Parent
   2 | local Fusion = require(OnyxUI.Parent.Fusion)
   3 | local Util = require(OnyxUI.Util)
   4 | local Themer = require(OnyxUI.Themer)
   5 | 
   6 | local Children = Fusion.Children
   7 | 
   8 | local Components = {
   9 | 	TextSwap = require(OnyxUI.Components.TextSwap),
  10 | 	Frame = require(OnyxUI.Components.Frame),
  11 | }
  12 | 
  13 | return {
  14 | 	story = function(Props)
  15 | 		local Scope = Fusion.scoped(Fusion, Util, Components)
  16 | 		local Theme = Themer.Theme:now()
  17 | 
  18 | 		Scope:Frame {
  19 | 			Parent = Props.target,
  20 | 			Size = Scope:UDim2Offset(Theme.Sizing["16"], 0),
  21 | 			AutomaticSize = Enum.AutomaticSize.Y,
  22 | 			Padding = {
  23 | 				All = Scope:UDim(0, Theme.StrokeThickness["1"]),
  24 | 			},
  25 | 			List = {
  26 | 				Padding = Scope:UDim(0, Theme.Spacing["0.5"]),
  27 | 				HorizontalFlex = Enum.UIFlexAlignment.Fill,
  28 | 			},
  29 | 
  30 | 			[Children] = {
  31 | 				Scope:TextSwap {
  32 | 					Options = { "Hamburger", "Pizza", "Ice Cream" },
  33 | 				},
  34 | 				Scope:TextSwap {
  35 | 					Options = { "Disabled" },
  36 | 					Disabled = true,
  37 | 				},
  38 | 				Scope:TextSwap {
  39 | 					Options = { "Cats", "Dogs", "Zebras" },
  40 | 					Color = Theme.Colors.Primary.Main,
  41 | 				},
  42 | 			},
  43 | 		}
  44 | 	end,
  45 | 	fusion = Fusion,
  46 | }
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Components/TitleBar.luau`
<details>
<summary>View Source (106 lines)</summary>

```lua
   1 | --[=[
   2 | 		@class TitleBar
   3 | 		
   4 | 		For displaying a title, and an optional close button.
   5 | ]=]
   6 | 
   7 | --[=[
   8 | 	@interface TitleBarProps
   9 | 	@within TitleBar
  10 | 
  11 | 	. ... FrameProps -- All Frame properties are accepted.
  12 | 	.Content {string}? -- The content of the title bar.
  13 | 	.ContentSize number? -- The size of the content text.
  14 | 	.ContentColor Color3? -- The color of the content text.
  15 | 	.ContentFontFace Font? -- The font face of the content text.
  16 | 	.CloseButtonIcon string? -- The icon for the close button.
  17 | 	.CloseButtonDisabled boolean? -- Whether the close button is disabled.
  18 | 	.OnClose (() -> ())? -- The callback function when the close button is clicked.
  19 | ]=]
  20 | 
  21 | local OnyxUI = script.Parent.Parent
  22 | 
  23 | local Fusion = require(OnyxUI.Parent.Fusion)
  24 | local Util = require(OnyxUI.Util)
  25 | local Themer = require(OnyxUI.Themer)
  26 | 
  27 | local Children = Fusion.Children
  28 | 
  29 | local Frame = require(script.Parent.Frame)
  30 | local IconButton = require(script.Parent.IconButton)
  31 | local IconText = require(script.Parent.IconText)
  32 | local Components = {
  33 | 	Frame = Frame,
  34 | 	IconButton = IconButton,
  35 | 	IconText = IconText,
  36 | }
  37 | 
  38 | export type Props = Frame.Props & {
  39 | 	Content: Fusion.UsedAs<{ string }>?,
  40 | 	ContentSize: Fusion.UsedAs<number>?,
  41 | 	ContentColor: Fusion.UsedAs<Color3>?,
  42 | 	ContentFontFace: Fusion.UsedAs<Font>?,
  43 | 	CloseButtonIcon: Fusion.UsedAs<string>?,
  44 | 	CloseButtonDisabled: Fusion.UsedAs<boolean>?,
  45 | 	OnClose: Fusion.UsedAs<() -> ()>?,
  46 | }
  47 | 
  48 | return function(Scope: Fusion.Scope<any>, Props: Props)
  49 | 	local Scope = Fusion.innerScope(Scope, Fusion, Util, Components)
  50 | 	local Theme = Themer.Theme:now()
  51 | 
  52 | 	local Content = Util.Fallback(Props.Content, {})
  53 | 	local ContentSize = Util.Fallback(Props.ContentSize, Theme.TextSize["1"])
  54 | 	local ContentColor = Util.Fallback(Props.ContentColor, Theme.Colors.BaseContent.Main)
  55 | 	local ContentFontFace =
  56 | 		Util.Fallback(Props.ContentFontFace, Scope:Font(Theme.Font.Heading, Theme.FontWeight.Heading))
  57 | 	local CloseButtonDisabled = Util.Fallback(Props.CloseButtonDisabled, false)
  58 | 	local CloseButtonIcon = Util.Fallback(Props.CloseButtonIcon, "rbxassetid://80218226919142")
  59 | 	local OnClose = Util.Fallback(Props.OnClose, function() end)
  60 | 
  61 | 	return Scope:Frame(Util.CombineProps(Props, {
  62 | 		Name = script.Name,
  63 | 		Size = UDim2.fromScale(1, 0),
  64 | 		AutomaticSize = Enum.AutomaticSize.Y,
  65 | 
  66 | 		[Children] = {
  67 | 			Scope:IconText {
  68 | 				Name = "Title",
  69 | 				AnchorPoint = Vector2.new(0.5, 0),
  70 | 				Position = UDim2.fromScale(0.5, 0),
  71 | 				Content = Content,
  72 | 				ContentColor = ContentColor,
  73 | 				ContentSize = ContentSize,
  74 | 				ContentFontFace = ContentFontFace,
  75 | 				ContentWrapped = false,
  76 | 				List = {
  77 | 					Padding = Scope:UDim(0, Theme.Spacing["0.5"]),
  78 | 				},
  79 | 			},
  80 | 			Scope:Computed(function(Use)
  81 | 				if Use(CloseButtonDisabled) == false then
  82 | 					return Themer.Theme:is(Theme):during(function()
  83 | 						return Scope:IconButton {
  84 | 							Name = "CloseButton",
  85 | 							Image = CloseButtonIcon,
  86 | 							ContentSize = ContentSize,
  87 | 							ContentColor = ContentColor,
  88 | 							Color = ContentColor,
  89 | 							Style = "Ghost",
  90 | 							AnchorPoint = Vector2.new(1, 0.5),
  91 | 							Position = UDim2.fromScale(1, 0.5),
  92 | 
  93 | 							OnActivate = function()
  94 | 								if Use(OnClose) then
  95 | 									Use(OnClose)()
  96 | 								end
  97 | 							end,
  98 | 						}
  99 | 					end)
 100 | 				else
 101 | 					return
 102 | 				end
 103 | 			end),
 104 | 		},
 105 | 	}))
 106 | end
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Components/TitleBar.story.luau`
<details>
<summary>View Source (42 lines)</summary>

```lua
   1 | local OnyxUI = script.Parent.Parent
   2 | local Util = require(OnyxUI.Util)
   3 | local Fusion = require(OnyxUI.Parent.Fusion)
   4 | local Themer = require(OnyxUI.Themer)
   5 | 
   6 | local Children = Fusion.Children
   7 | 
   8 | local TitleBar = require(OnyxUI.Components.TitleBar)
   9 | local Frame = require(OnyxUI.Components.Frame)
  10 | local Components = {
  11 | 	Frame = Frame,
  12 | 	TitleBar = TitleBar,
  13 | }
  14 | 
  15 | return {
  16 | 	story = function(Props)
  17 | 		local Scope = Fusion.innerScope(Props.scope, Fusion, Util, Components)
  18 | 		local Theme = Themer.Theme:now()
  19 | 
  20 | 		Scope:Frame {
  21 | 			Parent = Props.target,
  22 | 			Size = Scope:UDim2Offset(Theme.Sizing["16"], 0),
  23 | 			AutomaticSize = Enum.AutomaticSize.Y,
  24 | 			Padding = {
  25 | 				All = Scope:UDim(0, Theme.StrokeThickness["1"]),
  26 | 			},
  27 | 			List = {
  28 | 				HorizontalFlex = Enum.UIFlexAlignment.Fill,
  29 | 			},
  30 | 
  31 | 			[Children] = {
  32 | 				Scope:TitleBar {
  33 | 					Content = { "Title" },
  34 | 				},
  35 | 				Scope:TitleBar {
  36 | 					Content = { "rbxassetid://75029721407761", "Shop" },
  37 | 				},
  38 | 			},
  39 | 		}
  40 | 	end,
  41 | 	fusion = Fusion,
  42 | }
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/init.luau`
<details>
<summary>View Source (84 lines)</summary>

```lua
   1 | local Components = require(script.Components)
   2 | local Util = require(script.Util)
   3 | local Themer = require(script.Themer)
   4 | 
   5 | local Base = require(script.Components.Base)
   6 | local Text = require(script.Components.Text)
   7 | local Frame = require(script.Components.Frame)
   8 | local Badge = require(script.Components.Badge)
   9 | local Avatar = require(script.Components.Avatar)
  10 | local AutoScaler = require(script.Components.AutoScaler)
  11 | local BaseButton = require(script.Components.BaseButton)
  12 | local Button = require(script.Components.Button)
  13 | local Card = require(script.Components.Card)
  14 | local Checkbox = require(script.Components.Checkbox)
  15 | local Divider = require(script.Components.Divider)
  16 | local Group = require(script.Components.Group)
  17 | local Heading = require(script.Components.Heading)
  18 | local Icon = require(script.Components.Icon)
  19 | local IconButton = require(script.Components.IconButton)
  20 | local IconText = require(script.Components.IconText)
  21 | local Image = require(script.Components.Image)
  22 | local ProgressBar = require(script.Components.ProgressBar)
  23 | local Scroller = require(script.Components.Scroller)
  24 | local Switch = require(script.Components.Switch)
  25 | local TextInput = require(script.Components.TextInput)
  26 | local TextArea = require(script.Components.TextArea)
  27 | local TitleBar = require(script.Components.TitleBar)
  28 | local TextSwap = require(script.Components.TextSwap)
  29 | local Slider = require(script.Components.Slider)
  30 | local IconSwap = require(script.Components.IconSwap)
  31 | local Tabs = require(script.Components.Tabs)
  32 | 
  33 | export type Theme = Themer.Theme
  34 | export type ThemeSpec = Themer.ThemeSpec
  35 | 
  36 | export type BaseProps = Base.Props
  37 | export type TextProps = Text.Props
  38 | export type FrameProps = Frame.Props
  39 | export type BadgeProps = Badge.Props
  40 | export type AvatarProps = Avatar.Props
  41 | export type AutoScalerProps = AutoScaler.Props
  42 | export type BaseButtonProps = BaseButton.Props
  43 | export type ButtonProps = Button.Props
  44 | export type CardProps = Card.Props
  45 | export type CheckboxProps = Checkbox.Props
  46 | export type DividerProps = Divider.Props
  47 | export type GroupProps = Group.Props
  48 | export type HeadingProps = Heading.Props
  49 | export type IconProps = Icon.Props
  50 | export type IconButtonProps = IconButton.Props
  51 | export type IconTextProps = IconText.Props
  52 | export type ImageProps = Image.Props
  53 | export type ProgressBarProps = ProgressBar.Props
  54 | export type ScrollerProps = Scroller.Props
  55 | export type SwitchProps = Switch.Props
  56 | export type TextInputProps = TextInput.Props
  57 | export type TextAreaProps = TextArea.Props
  58 | export type TitleBarProps = TitleBar.Props
  59 | export type TextSwapProps = TextSwap.Props
  60 | export type IconSwapProps = IconSwap.Props
  61 | export type SliderProps = Slider.Props
  62 | export type TabsProps = Tabs.Props
  63 | 
  64 | export type CornerProps = Base.CornerProps
  65 | export type PaddingProps = Base.PaddingProps
  66 | export type StrokeProps = Base.StrokeProps
  67 | export type GradientProps = Base.GradientProps
  68 | export type AspectProps = Base.AspectProps
  69 | export type ScaleProps = Base.ScaleProps
  70 | 
  71 | export type ListProps = Base.ListProps
  72 | export type GridProps = Base.GridProps
  73 | export type TableProps = Base.TableProps
  74 | export type PageProps = Base.PageProps
  75 | export type FlexProps = Base.FlexProps
  76 | 
  77 | export type SizeLimitProps = Base.SizeLimitProps
  78 | export type TextSizeLimitProps = Base.TextSizeLimitProps
  79 | 
  80 | return {
  81 | 	Util = Util,
  82 | 	Components = Components,
  83 | 	Themer = Themer,
  84 | }
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/OnyxUI.storybook.luau`
<details>
<summary>View Source (6 lines)</summary>

```lua
   1 | return {
   2 | 	name = "OnyxUI",
   3 | 	storyRoots = {
   4 | 		script.Parent.Components,
   5 | 	},
   6 | }
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Themer/init.luau`
<details>
<summary>View Source (56 lines)</summary>

```lua
   1 | --[=[
   2 | 	@class Themer
   3 | 	
   4 | 	Themer allows you to customize components throughout OnyxUI, with support for things like colors, corner radiuses, paddings, etc. You'll also probably want to reference it within your own UI for a more consistent design.
   5 | ]=]
   6 | --[=[
   7 | 		@within Themer
   8 | 		@type ThemeSpec table
   9 | 
  10 | 		A specification table for theme properties. Check out [ThemeSpec.luau](https://github.com/ImAvafe/OnyxUI/blob/main/src/Themer/ThemeSpec.luau) for a full reference of available theme properties.
  11 | ]=]
  12 | --[=[
  13 | 		@within Themer
  14 | 		@type Theme table
  15 | 
  16 | 		An active theme to be referenced in UI.
  17 | ]=]
  18 | 
  19 | local OnyxUI = script.Parent
  20 | local OnyxNightTheme = require(script.OnyxNight)
  21 | local NewTheme = require(script.NewTheme)
  22 | local ThemeSpec = require(script.ThemeSpec)
  23 | local Fusion = require(OnyxUI.Parent.Fusion)
  24 | 
  25 | local Contextual = Fusion.Contextual
  26 | 
  27 | export type ThemeSpec = ThemeSpec.ThemeSpec
  28 | 
  29 | local Themer = {}
  30 | 
  31 | --[=[
  32 | 	@function NewTheme
  33 | 	@within Themer
  34 | 
  35 | 	@param Scope Fusion.Scope<any>
  36 | 	@param ThemeSpec ThemeSpec
  37 | 	@return Theme
  38 | 
  39 | 	Creates the specified theme.
  40 | ]=]
  41 | function Themer.NewTheme(Scope: Fusion.Scope<any>, ThemeSpec: ThemeSpec)
  42 | 	return NewTheme(Scope, ThemeSpec)
  43 | end
  44 | 
  45 | --[=[
  46 | 	@prop Theme Fusion.Contextual<Theme>
  47 | 	@within Themer
  48 | 
  49 | 	The currently active theme. Use `Themer.Theme:now()` to get the active theme, and `Themer.Theme:is(MyTheme):during()` to make code use another theme. See [Fusion Contextuals](https://elttob.uk/Fusion/0.3/tutorials/best-practices/sharing-values/?h=contextuals#contextuals) for more information.
  50 | ]=]
  51 | local Theme: Fusion.Contextual<Theme> = Contextual(OnyxNightTheme)
  52 | Themer.Theme = Theme
  53 | 
  54 | export type Theme = typeof(Themer.NewTheme(Fusion.scoped(), {}))
  55 | 
  56 | return Themer
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Themer/NewTheme.luau`
<details>
<summary>View Source (339 lines)</summary>

```lua
   1 | local OnyxUI = script.Parent.Parent
   2 | local Fusion = require(OnyxUI.Parent.Fusion)
   3 | local ThemeSpec = require(script.Parent.ThemeSpec)
   4 | local ColorUtils = require(OnyxUI.Parent.ColorUtils)
   5 | local Util = require(OnyxUI.Util)
   6 | 
   7 | export type ThemeSpec = ThemeSpec.ThemeSpec
   8 | 
   9 | local function ReconcileValues(Target: { [string]: Fusion.UsedAs<any> }, Source: { [string]: any })
  10 | 	for Key, Value in pairs(Target) do
  11 | 		if typeof(Value) == "table" and Value.set then
  12 | 			if typeof(Source[Key]) == "table" and Source[Key].get then
  13 | 				Value:set(Fusion.peek(Source[Key]))
  14 | 			elseif Source[Key] ~= nil then
  15 | 				Value:set(Source[Key])
  16 | 			end
  17 | 		elseif typeof(Value) == "table" then
  18 | 			if typeof(Source[Key]) == "table" then
  19 | 				ReconcileValues(Value, Source[Key])
  20 | 			end
  21 | 		end
  22 | 	end
  23 | end
  24 | 
  25 | local function ProcessColors(ThemeObject)
  26 | 	for _, ColorObject in pairs(ThemeObject.Colors) do
  27 | 		local MainValue = Fusion.peek(ColorObject.Main)
  28 | 		if MainValue ~= nil then
  29 | 			if Fusion.peek(ColorObject.Contrast) == nil then
  30 | 				ColorObject.Contrast:set(Util.Emphasize(MainValue, Fusion.peek(ThemeObject.Emphasis.Contrast)))
  31 | 			end
  32 | 
  33 | 			if Fusion.peek(ColorObject.Dark) == nil then
  34 | 				ColorObject.Dark:set(ColorUtils.Darken(MainValue, Fusion.peek(ThemeObject.Emphasis.Strong)))
  35 | 			end
  36 | 
  37 | 			if Fusion.peek(ColorObject.Light) == nil then
  38 | 				ColorObject.Light:set(ColorUtils.Lighten(MainValue, Fusion.peek(ThemeObject.Emphasis.Strong)))
  39 | 			end
  40 | 		end
  41 | 	end
  42 | end
  43 | 
  44 | local function ProcessEmphasis(Objects)
  45 | 	local BaseEmphasis = Fusion.peek(Objects.Regular)
  46 | 
  47 | 	Objects.Light:set(BaseEmphasis * 2 / 3)
  48 | 	Objects.Strong:set(BaseEmphasis * 2)
  49 | end
  50 | 
  51 | local function ProcessMultipliers(Objects: {
  52 | 	Base: Fusion.Value<Fusion.Scope<any>, number>,
  53 | 	[string]: Fusion.Value<Fusion.Scope<any>, number>,
  54 | })
  55 | 	local Base = Fusion.peek(Objects.Base)
  56 | 	for Key, Value in pairs(Objects) do
  57 | 		if Fusion.peek(Value) == nil then
  58 | 			local Multiplier = tonumber(Key)
  59 | 			if Multiplier ~= nil then
  60 | 				Value:set(Base * Multiplier)
  61 | 			end
  62 | 		end
  63 | 	end
  64 | 
  65 | 	if Objects.Full ~= nil then
  66 | 		Objects.Full:set(Base * 10000)
  67 | 	end
  68 | end
  69 | 
  70 | local function NewTheme(Scope: Fusion.Scope<any>, ThemeSpec: ThemeSpec)
  71 | 	local Scope = Fusion.innerScope(Scope, Fusion)
  72 | 
  73 | 	local ThemeObject = {
  74 | 		Colors = {
  75 | 			Primary = {
  76 | 				Main = Scope:Value(Util.Colors.Black),
  77 | 				Dark = Scope:Value(nil),
  78 | 				Light = Scope:Value(nil),
  79 | 				Contrast = Scope:Value(nil),
  80 | 			},
  81 | 			Secondary = {
  82 | 				Main = Scope:Value(Util.Colors.Black),
  83 | 				Dark = Scope:Value(nil),
  84 | 				Light = Scope:Value(nil),
  85 | 				Contrast = Scope:Value(nil),
  86 | 			},
  87 | 			Accent = {
  88 | 				Main = Scope:Value(Util.Colors.Black),
  89 | 				Dark = Scope:Value(nil),
  90 | 				Light = Scope:Value(nil),
  91 | 				Contrast = Scope:Value(nil),
  92 | 			},
  93 | 
  94 | 			Neutral = {
  95 | 				Main = Scope:Value(Util.Colors.Gray["300"]),
  96 | 				Dark = Scope:Value(nil),
  97 | 				Light = Scope:Value(nil),
  98 | 				Contrast = Scope:Value(nil),
  99 | 			},
 100 | 			NeutralContent = {
 101 | 				Main = Scope:Value(Util.Colors.Gray["800"]),
 102 | 				Dark = Scope:Value(nil),
 103 | 				Light = Scope:Value(nil),
 104 | 				Contrast = Scope:Value(nil),
 105 | 			},
 106 | 
 107 | 			Base = {
 108 | 				Main = Scope:Value(Util.Colors.White),
 109 | 				Dark = Scope:Value(nil),
 110 | 				Light = Scope:Value(nil),
 111 | 				Contrast = Scope:Value(nil),
 112 | 			},
 113 | 			BaseContent = {
 114 | 				Main = Scope:Value(Util.Colors.Black),
 115 | 				Dark = Scope:Value(nil),
 116 | 				Light = Scope:Value(nil),
 117 | 				Contrast = Scope:Value(nil),
 118 | 			},
 119 | 
 120 | 			Success = {
 121 | 				Main = Scope:Value(Util.Colors.Green["400"]),
 122 | 				Dark = Scope:Value(nil),
 123 | 				Light = Scope:Value(nil),
 124 | 				Contrast = Scope:Value(nil),
 125 | 			},
 126 | 			Error = {
 127 | 				Main = Scope:Value(Util.Colors.Red["400"]),
 128 | 				Dark = Scope:Value(nil),
 129 | 				Light = Scope:Value(nil),
 130 | 				Contrast = Scope:Value(nil),
 131 | 			},
 132 | 			Warning = {
 133 | 				Main = Scope:Value(Util.Colors.Orange["400"]),
 134 | 				Dark = Scope:Value(nil),
 135 | 				Light = Scope:Value(nil),
 136 | 				Contrast = Scope:Value(nil),
 137 | 			},
 138 | 			Info = {
 139 | 				Main = Scope:Value(Util.Colors.Blue["400"]),
 140 | 				Dark = Scope:Value(nil),
 141 | 				Light = Scope:Value(nil),
 142 | 				Contrast = Scope:Value(nil),
 143 | 			},
 144 | 		},
 145 | 		Font = {
 146 | 			Body = Scope:Value("GothamSsm"),
 147 | 			Heading = Scope:Value("GothamSsm"),
 148 | 			Monospace = Scope:Value("GothamSsm"),
 149 | 		},
 150 | 		FontWeight = {
 151 | 			Body = Scope:Value(Enum.FontWeight.Regular),
 152 | 			Bold = Scope:Value(Enum.FontWeight.Bold),
 153 | 			Heading = Scope:Value(Enum.FontWeight.Bold),
 154 | 		},
 155 | 		TextSize = {
 156 | 			Base = Scope:Value(16),
 157 | 			["0.75"] = Scope:Value(nil),
 158 | 			["0.875"] = Scope:Value(nil),
 159 | 			["1"] = Scope:Value(nil),
 160 | 			["1.125"] = Scope:Value(nil),
 161 | 			["1.25"] = Scope:Value(nil),
 162 | 			["1.5"] = Scope:Value(nil),
 163 | 			["1.875"] = Scope:Value(nil),
 164 | 			["2.25"] = Scope:Value(nil),
 165 | 			["3"] = Scope:Value(nil),
 166 | 			["3.75"] = Scope:Value(nil),
 167 | 			["4.5"] = Scope:Value(nil),
 168 | 		},
 169 | 		Padding = {
 170 | 			Base = Scope:Value(16),
 171 | 			["0"] = Scope:Value(0),
 172 | 			["0.25"] = Scope:Value(nil),
 173 | 			["0.5"] = Scope:Value(nil),
 174 | 			["0.75"] = Scope:Value(nil),
 175 | 			["1"] = Scope:Value(nil),
 176 | 			["1.5"] = Scope:Value(nil),
 177 | 			["2"] = Scope:Value(nil),
 178 | 			["3"] = Scope:Value(nil),
 179 | 			["4"] = Scope:Value(nil),
 180 | 			["6"] = Scope:Value(nil),
 181 | 			["8"] = Scope:Value(nil),
 182 | 			["12"] = Scope:Value(nil),
 183 | 			["16"] = Scope:Value(nil),
 184 | 			["20"] = Scope:Value(nil),
 185 | 			["24"] = Scope:Value(nil),
 186 | 			["28"] = Scope:Value(nil),
 187 | 			["32"] = Scope:Value(nil),
 188 | 			["36"] = Scope:Value(nil),
 189 | 			["40"] = Scope:Value(nil),
 190 | 			["44"] = Scope:Value(nil),
 191 | 			["48"] = Scope:Value(nil),
 192 | 		},
 193 | 		Spacing = {
 194 | 			Base = Scope:Value(22),
 195 | 			["0"] = Scope:Value(0),
 196 | 			["0.25"] = Scope:Value(nil),
 197 | 			["0.5"] = Scope:Value(nil),
 198 | 			["0.75"] = Scope:Value(nil),
 199 | 			["1"] = Scope:Value(nil),
 200 | 			["1.5"] = Scope:Value(nil),
 201 | 			["2"] = Scope:Value(nil),
 202 | 			["3"] = Scope:Value(nil),
 203 | 			["4"] = Scope:Value(nil),
 204 | 			["6"] = Scope:Value(nil),
 205 | 			["8"] = Scope:Value(nil),
 206 | 			["12"] = Scope:Value(nil),
 207 | 			["16"] = Scope:Value(nil),
 208 | 			["20"] = Scope:Value(nil),
 209 | 			["24"] = Scope:Value(nil),
 210 | 			["28"] = Scope:Value(nil),
 211 | 			["32"] = Scope:Value(nil),
 212 | 			["36"] = Scope:Value(nil),
 213 | 			["40"] = Scope:Value(nil),
 214 | 			["44"] = Scope:Value(nil),
 215 | 			["48"] = Scope:Value(nil),
 216 | 		},
 217 | 		Sizing = {
 218 | 			Base = Scope:Value(22),
 219 | 			["0"] = Scope:Value(0),
 220 | 			["0.25"] = Scope:Value(nil),
 221 | 			["0.5"] = Scope:Value(nil),
 222 | 			["0.75"] = Scope:Value(nil),
 223 | 			["1"] = Scope:Value(nil),
 224 | 			["1.5"] = Scope:Value(nil),
 225 | 			["2"] = Scope:Value(nil),
 226 | 			["3"] = Scope:Value(nil),
 227 | 			["4"] = Scope:Value(nil),
 228 | 			["6"] = Scope:Value(nil),
 229 | 			["8"] = Scope:Value(nil),
 230 | 			["12"] = Scope:Value(nil),
 231 | 			["16"] = Scope:Value(nil),
 232 | 			["20"] = Scope:Value(nil),
 233 | 			["24"] = Scope:Value(nil),
 234 | 			["28"] = Scope:Value(nil),
 235 | 			["32"] = Scope:Value(nil),
 236 | 			["36"] = Scope:Value(nil),
 237 | 			["40"] = Scope:Value(nil),
 238 | 			["44"] = Scope:Value(nil),
 239 | 			["48"] = Scope:Value(nil),
 240 | 		},
 241 | 		CornerRadius = {
 242 | 			Base = Scope:Value(4),
 243 | 			["0"] = Scope:Value(0),
 244 | 			["0.5"] = Scope:Value(nil),
 245 | 			["1"] = Scope:Value(nil),
 246 | 			["1.5"] = Scope:Value(nil),
 247 | 			["2"] = Scope:Value(nil),
 248 | 			["3"] = Scope:Value(nil),
 249 | 			["4"] = Scope:Value(nil),
 250 | 			["6"] = Scope:Value(nil),
 251 | 			Full = Scope:Value(nil),
 252 | 		},
 253 | 		StrokeThickness = {
 254 | 			Base = Scope:Value(2),
 255 | 			["0"] = Scope:Value(0),
 256 | 			["1"] = Scope:Value(nil),
 257 | 			["2"] = Scope:Value(nil),
 258 | 			["3"] = Scope:Value(nil),
 259 | 			["4"] = Scope:Value(nil),
 260 | 			["8"] = Scope:Value(nil),
 261 | 		},
 262 | 		StrokeEmphasis = {
 263 | 			Regular = Scope:Value(0.1),
 264 | 			Light = Scope:Value(nil),
 265 | 			Strong = Scope:Value(nil),
 266 | 			Contrast = Scope:Value(1),
 267 | 		},
 268 | 		SpringSpeed = {
 269 | 			Base = Scope:Value(40),
 270 | 			["0.1"] = Scope:Value(nil),
 271 | 			["0.175"] = Scope:Value(nil),
 272 | 			["0.25"] = Scope:Value(nil),
 273 | 			["0.375"] = Scope:Value(nil),
 274 | 			["0.5"] = Scope:Value(nil),
 275 | 			["0.75"] = Scope:Value(nil),
 276 | 			["1"] = Scope:Value(nil),
 277 | 			["1.5"] = Scope:Value(nil),
 278 | 			["2"] = Scope:Value(nil),
 279 | 			Immediate = Scope:Value(1000),
 280 | 		},
 281 | 		SpringDampening = {
 282 | 			Base = Scope:Value(1),
 283 | 			["0.1"] = Scope:Value(nil),
 284 | 			["0.175"] = Scope:Value(nil),
 285 | 			["0.25"] = Scope:Value(nil),
 286 | 			["0.375"] = Scope:Value(nil),
 287 | 			["0.5"] = Scope:Value(nil),
 288 | 			["0.75"] = Scope:Value(nil),
 289 | 			["1"] = Scope:Value(nil),
 290 | 			["1.5"] = Scope:Value(nil),
 291 | 			["2"] = Scope:Value(nil),
 292 | 			["5"] = Scope:Value(nil),
 293 | 			["10"] = Scope:Value(nil),
 294 | 			Full = Scope:Value(1000),
 295 | 		},
 296 | 		Sound = {
 297 | 			Hover = Scope:Value(Scope:New "Sound" {
 298 | 				SoundId = "rbxassetid://10066936758",
 299 | 				Volume = 0.05,
 300 | 			}),
 301 | 			Click = Scope:Value(Scope:New "Sound" {
 302 | 				SoundId = "rbxassetid://16480549841",
 303 | 				Volume = 0.5,
 304 | 			}),
 305 | 			Focus = Scope:Value(Scope:New "Sound" {
 306 | 				SoundId = "rbxassetid://16480549841",
 307 | 				Volume = 0.5,
 308 | 			}),
 309 | 			Switch = Scope:Value(Scope:New "Sound" {
 310 | 				SoundId = "rbxassetid://9119713951",
 311 | 				Volume = 0.5,
 312 | 			}),
 313 | 		},
 314 | 		Emphasis = {
 315 | 			Regular = Scope:Value(0.2),
 316 | 			Light = Scope:Value(nil),
 317 | 			Strong = Scope:Value(nil),
 318 | 			Contrast = Scope:Value(1),
 319 | 		},
 320 | 	}
 321 | 
 322 | 	ReconcileValues(ThemeObject, ThemeSpec)
 323 | 
 324 | 	ProcessEmphasis(ThemeObject.Emphasis)
 325 | 	ProcessEmphasis(ThemeObject.StrokeEmphasis)
 326 | 	ProcessColors(ThemeObject)
 327 | 	ProcessMultipliers(ThemeObject.Padding)
 328 | 	ProcessMultipliers(ThemeObject.Spacing)
 329 | 	ProcessMultipliers(ThemeObject.Sizing)
 330 | 	ProcessMultipliers(ThemeObject.TextSize)
 331 | 	ProcessMultipliers(ThemeObject.CornerRadius)
 332 | 	ProcessMultipliers(ThemeObject.StrokeThickness)
 333 | 	ProcessMultipliers(ThemeObject.SpringSpeed)
 334 | 	ProcessMultipliers(ThemeObject.SpringDampening)
 335 | 
 336 | 	return ThemeObject
 337 | end
 338 | 
 339 | return NewTheme
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Themer/OnyxNight.luau`
<details>
<summary>View Source (88 lines)</summary>

```lua
   1 | local OnyxUI = script.Parent.Parent
   2 | local Util = require(OnyxUI.Util)
   3 | local NewTheme = require(script.Parent.NewTheme)
   4 | local Fusion = require(OnyxUI.Parent.Fusion)
   5 | 
   6 | local Scope = Fusion.scoped(Fusion)
   7 | 
   8 | local OnyxNight = NewTheme(Scope, {
   9 | 	Colors = {
  10 | 		Primary = {
  11 | 			Main = Util.Colors.Violet["500"],
  12 | 		},
  13 | 		Secondary = {
  14 | 			Main = Util.Colors.White,
  15 | 		},
  16 | 		Accent = {
  17 | 			Main = Util.Colors.White,
  18 | 		},
  19 | 
  20 | 		Neutral = {
  21 | 			Main = Util.Colors.Stone["800"],
  22 | 		},
  23 | 		NeutralContent = {
  24 | 			Main = Util.Colors.Stone["300"],
  25 | 		},
  26 | 
  27 | 		Base = {
  28 | 			Main = Util.Colors.Stone["900"],
  29 | 		},
  30 | 		BaseContent = {
  31 | 			Main = Util.Colors.White,
  32 | 		},
  33 | 
  34 | 		Success = {
  35 | 			Main = Util.Colors.Green["500"],
  36 | 		},
  37 | 		Error = {
  38 | 			Main = Util.Colors.Red["500"],
  39 | 		},
  40 | 		Warning = {
  41 | 			Main = Util.Colors.Amber["500"],
  42 | 		},
  43 | 		Info = {
  44 | 			Main = Util.Colors.Cyan["400"],
  45 | 		},
  46 | 	},
  47 | 	Font = {
  48 | 		Body = "rbxasset://fonts/families/Montserrat.json",
  49 | 		Heading = "rbxasset://fonts/families/Montserrat.json",
  50 | 		Monospace = "rbxasset://fonts/families/Montserrat.json",
  51 | 	},
  52 | 	FontWeight = {
  53 | 		Body = Enum.FontWeight.SemiBold,
  54 | 		Bold = Enum.FontWeight.Bold,
  55 | 		Heading = Enum.FontWeight.Bold,
  56 | 	},
  57 | 	TextSize = {
  58 | 		Base = 19,
  59 | 	},
  60 | 	CornerRadius = {
  61 | 		Base = 8,
  62 | 	},
  63 | 	StrokeThickness = {
  64 | 		Base = 1,
  65 | 	},
  66 | 	StrokeEmphasis = {
  67 | 		Regular = 0.2,
  68 | 	},
  69 | 	Spacing = {
  70 | 		Base = 22,
  71 | 	},
  72 | 	Sizing = {
  73 | 		Base = 22,
  74 | 	},
  75 | 	Padding = {
  76 | 		Base = 24,
  77 | 	},
  78 | 	SpringSpeed = {
  79 | 		Base = 50,
  80 | 	},
  81 | 	SpringDampening = {
  82 | 		Base = 1,
  83 | 	},
  84 | 	Sound = {},
  85 | 	Emphasis = {},
  86 | })
  87 | 
  88 | return OnyxNight
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Themer/ThemeSpec.luau`
<details>
<summary>View Source (221 lines)</summary>

```lua
   1 | type ThemeColor = {
   2 | 	Main: Color3?,
   3 | 	Dark: Color3?,
   4 | 	Light: Color3?,
   5 | 	Contrast: Color3?,
   6 | 
   7 | 	[string]: Color3?,
   8 | }
   9 | export type ThemeSpec = {
  10 | 	Colors: {
  11 | 		Primary: ThemeColor?,
  12 | 		Secondary: ThemeColor?,
  13 | 		Accent: ThemeColor?,
  14 | 
  15 | 		Neutral: ThemeColor?,
  16 | 		NeutralContent: ThemeColor?,
  17 | 
  18 | 		Base: ThemeColor?,
  19 | 		BaseContent: ThemeColor?,
  20 | 
  21 | 		Success: ThemeColor?,
  22 | 		Error: ThemeColor?,
  23 | 		Warning: ThemeColor?,
  24 | 		Info: ThemeColor?,
  25 | 
  26 | 		[string]: ThemeColor?,
  27 | 	}?,
  28 | 	Font: {
  29 | 		Body: string?,
  30 | 		Heading: string?,
  31 | 		Monospace: string?,
  32 | 
  33 | 		[string]: string?,
  34 | 	}?,
  35 | 	FontWeight: {
  36 | 		Body: Enum.FontWeight?,
  37 | 		Bold: Enum.FontWeight?,
  38 | 		Heading: Enum.FontWeight?,
  39 | 
  40 | 		[string]: Enum.FontWeight?,
  41 | 	}?,
  42 | 	TextSize: {
  43 | 		Base: number?,
  44 | 		["0.75"]: number?,
  45 | 		["0.875"]: number?,
  46 | 		["1"]: number?,
  47 | 		["1.125"]: number?,
  48 | 		["1.25"]: number?,
  49 | 		["1.5"]: number?,
  50 | 		["1.875"]: number?,
  51 | 		["2.25"]: number?,
  52 | 		["3"]: number?,
  53 | 		["3.75"]: number?,
  54 | 		["4.5"]: number?,
  55 | 
  56 | 		[string]: number?,
  57 | 	}?,
  58 | 	Padding: {
  59 | 		Base: number?,
  60 | 		["0"]: number?,
  61 | 		["0.25"]: number?,
  62 | 		["0.5"]: number?,
  63 | 		["0.75"]: number?,
  64 | 		["1"]: number?,
  65 | 		["1.5"]: number?,
  66 | 		["2"]: number?,
  67 | 		["3"]: number?,
  68 | 		["4"]: number?,
  69 | 		["6"]: number?,
  70 | 		["8"]: number?,
  71 | 		["12"]: number?,
  72 | 		["16"]: number?,
  73 | 		["20"]: number?,
  74 | 		["24"]: number?,
  75 | 		["28"]: number?,
  76 | 		["32"]: number?,
  77 | 		["36"]: number?,
  78 | 		["40"]: number?,
  79 | 		["44"]: number?,
  80 | 		["48"]: number?,
  81 | 
  82 | 		[string]: number?,
  83 | 	}?,
  84 | 	Spacing: {
  85 | 		Base: number?,
  86 | 		["0"]: number?,
  87 | 		["0.25"]: number?,
  88 | 		["0.5"]: number?,
  89 | 		["0.75"]: number?,
  90 | 		["1"]: number?,
  91 | 		["1.5"]: number?,
  92 | 		["2"]: number?,
  93 | 		["3"]: number?,
  94 | 		["4"]: number?,
  95 | 		["6"]: number?,
  96 | 		["8"]: number?,
  97 | 		["12"]: number?,
  98 | 		["16"]: number?,
  99 | 		["20"]: number?,
 100 | 		["24"]: number?,
 101 | 		["28"]: number?,
 102 | 		["32"]: number?,
 103 | 		["36"]: number?,
 104 | 		["40"]: number?,
 105 | 		["44"]: number?,
 106 | 		["48"]: number?,
 107 | 
 108 | 		[string]: number?,
 109 | 	}?,
 110 | 	Sizing: {
 111 | 		Base: number?,
 112 | 		["0"]: number?,
 113 | 		["0.25"]: number?,
 114 | 		["0.5"]: number?,
 115 | 		["0.75"]: number?,
 116 | 		["1"]: number?,
 117 | 		["1.5"]: number?,
 118 | 		["2"]: number?,
 119 | 		["3"]: number?,
 120 | 		["4"]: number?,
 121 | 		["6"]: number?,
 122 | 		["8"]: number?,
 123 | 		["12"]: number?,
 124 | 		["16"]: number?,
 125 | 		["20"]: number?,
 126 | 		["24"]: number?,
 127 | 		["28"]: number?,
 128 | 		["32"]: number?,
 129 | 		["36"]: number?,
 130 | 		["40"]: number?,
 131 | 		["44"]: number?,
 132 | 		["48"]: number?,
 133 | 
 134 | 		[string]: number?,
 135 | 	}?,
 136 | 	CornerRadius: {
 137 | 		Base: number?,
 138 | 		["0"]: number?,
 139 | 		["0.5"]: number?,
 140 | 		["1"]: number?,
 141 | 		["1.5"]: number?,
 142 | 		["2"]: number?,
 143 | 		["3"]: number?,
 144 | 		["4"]: number?,
 145 | 		["6"]: number?,
 146 | 		Full: number?,
 147 | 
 148 | 		[string]: number?,
 149 | 	}?,
 150 | 	StrokeEmphasis: {
 151 | 		Light: number?,
 152 | 		Regular: number?,
 153 | 		Strong: number?,
 154 | 		Contrast: number?,
 155 | 
 156 | 		[string]: number?,
 157 | 	}?,
 158 | 	StrokeThickness: {
 159 | 		Base: number?,
 160 | 		["0"]: number?,
 161 | 		["1"]: number?,
 162 | 		["2"]: number?,
 163 | 		["3"]: number?,
 164 | 		["4"]: number?,
 165 | 		["8"]: number?,
 166 | 
 167 | 		[string]: number?,
 168 | 	}?,
 169 | 	SpringSpeed: {
 170 | 		Base: number?,
 171 | 		["0.1"]: number?,
 172 | 		["0.175"]: number?,
 173 | 		["0.25"]: number?,
 174 | 		["0.375"]: number?,
 175 | 		["0.5"]: number?,
 176 | 		["0.75"]: number?,
 177 | 		["1"]: number?,
 178 | 		["1.5"]: number?,
 179 | 		["2"]: number?,
 180 | 		Immediate: number?,
 181 | 
 182 | 		[string]: number?,
 183 | 	}?,
 184 | 	SpringDampening: {
 185 | 		Base: number?,
 186 | 		["0.1"]: number?,
 187 | 		["0.175"]: number?,
 188 | 		["0.25"]: number?,
 189 | 		["0.375"]: number?,
 190 | 		["0.5"]: number?,
 191 | 		["0.75"]: number?,
 192 | 		["1"]: number?,
 193 | 		["1.5"]: number?,
 194 | 		["2"]: number?,
 195 | 		["5"]: number?,
 196 | 		["10"]: number?,
 197 | 		Full: number?,
 198 | 
 199 | 		[string]: number?,
 200 | 	}?,
 201 | 	Emphasis: {
 202 | 		Light: number?,
 203 | 		Regular: number?,
 204 | 		Strong: number?,
 205 | 		Contrast: number?,
 206 | 
 207 | 		[string]: number?,
 208 | 	}?,
 209 | 	Sound: {
 210 | 		Hover: Sound?,
 211 | 		Click: Sound?,
 212 | 		Focus: Sound?,
 213 | 		Switch: Sound?,
 214 | 
 215 | 		[string]: Sound?,
 216 | 	}?,
 217 | 
 218 | 	[string]: any?,
 219 | }
 220 | 
 221 | return nil
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Util/Colors.luau`
<details>
<summary>View Source (298 lines)</summary>

```lua
   1 | --[=[
   2 | 		@prop Colors table
   3 | 		@within Util
   4 | 		@readonly
   5 | 		
   6 | 		Colors imported from [TailwindCSS's color palette](https://tailwindcss.com/docs/customizing-colors#default-color-palette).
   7 | ]=]
   8 | 
   9 | return {
  10 | 	Black = Color3.fromHex("#000"),
  11 | 	White = Color3.fromHex("#fff"),
  12 | 	Slate = {
  13 | 		["50"] = Color3.fromHex("#f8fafc"),
  14 | 		["100"] = Color3.fromHex("#f1f5f9"),
  15 | 		["200"] = Color3.fromHex("#e2e8f0"),
  16 | 		["300"] = Color3.fromHex("#cbd5e1"),
  17 | 		["400"] = Color3.fromHex("#94a3b8"),
  18 | 		["500"] = Color3.fromHex("#64748b"),
  19 | 		["600"] = Color3.fromHex("#475569"),
  20 | 		["700"] = Color3.fromHex("#334155"),
  21 | 		["800"] = Color3.fromHex("#1e293b"),
  22 | 		["900"] = Color3.fromHex("#0f172a"),
  23 | 		["950"] = Color3.fromHex("#020617"),
  24 | 	},
  25 | 	Gray = {
  26 | 		["50"] = Color3.fromHex("#f9fafb"),
  27 | 		["100"] = Color3.fromHex("#f3f4f6"),
  28 | 		["200"] = Color3.fromHex("#e5e7eb"),
  29 | 		["300"] = Color3.fromHex("#d1d5db"),
  30 | 		["400"] = Color3.fromHex("#9ca3af"),
  31 | 		["500"] = Color3.fromHex("#6b7280"),
  32 | 		["600"] = Color3.fromHex("#4b5563"),
  33 | 		["700"] = Color3.fromHex("#374151"),
  34 | 		["800"] = Color3.fromHex("#1f2937"),
  35 | 		["900"] = Color3.fromHex("#111827"),
  36 | 		["950"] = Color3.fromHex("#030712"),
  37 | 	},
  38 | 	Zinc = {
  39 | 		["50"] = Color3.fromHex("#fafafa"),
  40 | 		["100"] = Color3.fromHex("#f4f4f5"),
  41 | 		["200"] = Color3.fromHex("#e4e4e7"),
  42 | 		["300"] = Color3.fromHex("#d4d4d8"),
  43 | 		["400"] = Color3.fromHex("#a1a1aa"),
  44 | 		["500"] = Color3.fromHex("#71717a"),
  45 | 		["600"] = Color3.fromHex("#52525b"),
  46 | 		["700"] = Color3.fromHex("#3f3f46"),
  47 | 		["800"] = Color3.fromHex("#27272a"),
  48 | 		["900"] = Color3.fromHex("#18181b"),
  49 | 		["950"] = Color3.fromHex("#09090b"),
  50 | 	},
  51 | 	Neutral = {
  52 | 		["50"] = Color3.fromHex("#fafafa"),
  53 | 		["100"] = Color3.fromHex("#f5f5f5"),
  54 | 		["200"] = Color3.fromHex("#e5e5e5"),
  55 | 		["300"] = Color3.fromHex("#d4d4d4"),
  56 | 		["400"] = Color3.fromHex("#a3a3a3"),
  57 | 		["500"] = Color3.fromHex("#737373"),
  58 | 		["600"] = Color3.fromHex("#525252"),
  59 | 		["700"] = Color3.fromHex("#404040"),
  60 | 		["800"] = Color3.fromHex("#262626"),
  61 | 		["900"] = Color3.fromHex("#171717"),
  62 | 		["950"] = Color3.fromHex("#0a0a0a"),
  63 | 	},
  64 | 	Stone = {
  65 | 		["50"] = Color3.fromHex("#fafaf9"),
  66 | 		["100"] = Color3.fromHex("#f5f5f4"),
  67 | 		["200"] = Color3.fromHex("#e7e5e4"),
  68 | 		["300"] = Color3.fromHex("#d6d3d1"),
  69 | 		["400"] = Color3.fromHex("#a8a29e"),
  70 | 		["500"] = Color3.fromHex("#78716c"),
  71 | 		["600"] = Color3.fromHex("#57534e"),
  72 | 		["700"] = Color3.fromHex("#44403c"),
  73 | 		["800"] = Color3.fromHex("#292524"),
  74 | 		["900"] = Color3.fromHex("#1c1917"),
  75 | 		["950"] = Color3.fromHex("#0c0a09"),
  76 | 	},
  77 | 	Red = {
  78 | 		["50"] = Color3.fromHex("#fef2f2"),
  79 | 		["100"] = Color3.fromHex("#fee2e2"),
  80 | 		["200"] = Color3.fromHex("#fecaca"),
  81 | 		["300"] = Color3.fromHex("#fca5a5"),
  82 | 		["400"] = Color3.fromHex("#f87171"),
  83 | 		["500"] = Color3.fromHex("#ef4444"),
  84 | 		["600"] = Color3.fromHex("#dc2626"),
  85 | 		["700"] = Color3.fromHex("#b91c1c"),
  86 | 		["800"] = Color3.fromHex("#991b1b"),
  87 | 		["900"] = Color3.fromHex("#7f1d1d"),
  88 | 		["950"] = Color3.fromHex("#450a0a"),
  89 | 	},
  90 | 	Orange = {
  91 | 		["50"] = Color3.fromHex("#fff7ed"),
  92 | 		["100"] = Color3.fromHex("#ffedd5"),
  93 | 		["200"] = Color3.fromHex("#fed7aa"),
  94 | 		["300"] = Color3.fromHex("#fdba74"),
  95 | 		["400"] = Color3.fromHex("#fb923c"),
  96 | 		["500"] = Color3.fromHex("#f97316"),
  97 | 		["600"] = Color3.fromHex("#ea580c"),
  98 | 		["700"] = Color3.fromHex("#c2410c"),
  99 | 		["800"] = Color3.fromHex("#9a3412"),
 100 | 		["900"] = Color3.fromHex("#7c2d12"),
 101 | 		["950"] = Color3.fromHex("#431407"),
 102 | 	},
 103 | 	Amber = {
 104 | 		["50"] = Color3.fromHex("#fffbeb"),
 105 | 		["100"] = Color3.fromHex("#fef3c7"),
 106 | 		["200"] = Color3.fromHex("#fde68a"),
 107 | 		["300"] = Color3.fromHex("#fcd34d"),
 108 | 		["400"] = Color3.fromHex("#fbbf24"),
 109 | 		["500"] = Color3.fromHex("#f59e0b"),
 110 | 		["600"] = Color3.fromHex("#d97706"),
 111 | 		["700"] = Color3.fromHex("#b45309"),
 112 | 		["800"] = Color3.fromHex("#92400e"),
 113 | 		["900"] = Color3.fromHex("#78350f"),
 114 | 		["950"] = Color3.fromHex("#451a03"),
 115 | 	},
 116 | 	Yellow = {
 117 | 		["50"] = Color3.fromHex("#fefce8"),
 118 | 		["100"] = Color3.fromHex("#fef9c3"),
 119 | 		["200"] = Color3.fromHex("#fef08a"),
 120 | 		["300"] = Color3.fromHex("#fde047"),
 121 | 		["400"] = Color3.fromHex("#facc15"),
 122 | 		["500"] = Color3.fromHex("#eab308"),
 123 | 		["600"] = Color3.fromHex("#ca8a04"),
 124 | 		["700"] = Color3.fromHex("#a16207"),
 125 | 		["800"] = Color3.fromHex("#854d0e"),
 126 | 		["900"] = Color3.fromHex("#713f12"),
 127 | 		["950"] = Color3.fromHex("#422006"),
 128 | 	},
 129 | 	Lime = {
 130 | 		["50"] = Color3.fromHex("#f7fee7"),
 131 | 		["100"] = Color3.fromHex("#ecfccb"),
 132 | 		["200"] = Color3.fromHex("#d9f99d"),
 133 | 		["300"] = Color3.fromHex("#bef264"),
 134 | 		["400"] = Color3.fromHex("#a3e635"),
 135 | 		["500"] = Color3.fromHex("#84cc16"),
 136 | 		["600"] = Color3.fromHex("#65a30d"),
 137 | 		["700"] = Color3.fromHex("#4d7c0f"),
 138 | 		["800"] = Color3.fromHex("#3f6212"),
 139 | 		["900"] = Color3.fromHex("#365314"),
 140 | 		["950"] = Color3.fromHex("#1a2e05"),
 141 | 	},
 142 | 	Green = {
 143 | 		["50"] = Color3.fromHex("#f0fdf4"),
 144 | 		["100"] = Color3.fromHex("#dcfce7"),
 145 | 		["200"] = Color3.fromHex("#bbf7d0"),
 146 | 		["300"] = Color3.fromHex("#86efac"),
 147 | 		["400"] = Color3.fromHex("#4ade80"),
 148 | 		["500"] = Color3.fromHex("#22c55e"),
 149 | 		["600"] = Color3.fromHex("#16a34a"),
 150 | 		["700"] = Color3.fromHex("#15803d"),
 151 | 		["800"] = Color3.fromHex("#166534"),
 152 | 		["900"] = Color3.fromHex("#14532d"),
 153 | 		["950"] = Color3.fromHex("#052e16"),
 154 | 	},
 155 | 	Emerald = {
 156 | 		["50"] = Color3.fromHex("#ecfdf5"),
 157 | 		["100"] = Color3.fromHex("#d1fae5"),
 158 | 		["200"] = Color3.fromHex("#a7f3d0"),
 159 | 		["300"] = Color3.fromHex("#6ee7b7"),
 160 | 		["400"] = Color3.fromHex("#34d399"),
 161 | 		["500"] = Color3.fromHex("#10b981"),
 162 | 		["600"] = Color3.fromHex("#059669"),
 163 | 		["700"] = Color3.fromHex("#047857"),
 164 | 		["800"] = Color3.fromHex("#065f46"),
 165 | 		["900"] = Color3.fromHex("#064e3b"),
 166 | 		["950"] = Color3.fromHex("#022c22"),
 167 | 	},
 168 | 	Teal = {
 169 | 		["50"] = Color3.fromHex("#f0fdfa"),
 170 | 		["100"] = Color3.fromHex("#ccfbf1"),
 171 | 		["200"] = Color3.fromHex("#99f6e4"),
 172 | 		["300"] = Color3.fromHex("#5eead4"),
 173 | 		["400"] = Color3.fromHex("#2dd4bf"),
 174 | 		["500"] = Color3.fromHex("#14b8a6"),
 175 | 		["600"] = Color3.fromHex("#0d9488"),
 176 | 		["700"] = Color3.fromHex("#0f766e"),
 177 | 		["800"] = Color3.fromHex("#115e59"),
 178 | 		["900"] = Color3.fromHex("#134e4a"),
 179 | 		["950"] = Color3.fromHex("#042f2e"),
 180 | 	},
 181 | 	Cyan = {
 182 | 		["50"] = Color3.fromHex("#ecfeff"),
 183 | 		["100"] = Color3.fromHex("#cffafe"),
 184 | 		["200"] = Color3.fromHex("#a5f3fc"),
 185 | 		["300"] = Color3.fromHex("#67e8f9"),
 186 | 		["400"] = Color3.fromHex("#22d3ee"),
 187 | 		["500"] = Color3.fromHex("#06b6d4"),
 188 | 		["600"] = Color3.fromHex("#0891b2"),
 189 | 		["700"] = Color3.fromHex("#0e7490"),
 190 | 		["800"] = Color3.fromHex("#155e75"),
 191 | 		["900"] = Color3.fromHex("#164e63"),
 192 | 		["950"] = Color3.fromHex("#083344"),
 193 | 	},
 194 | 	Sky = {
 195 | 		["50"] = Color3.fromHex("#f0f9ff"),
 196 | 		["100"] = Color3.fromHex("#e0f2fe"),
 197 | 		["200"] = Color3.fromHex("#bae6fd"),
 198 | 		["300"] = Color3.fromHex("#7dd3fc"),
 199 | 		["400"] = Color3.fromHex("#38bdf8"),
 200 | 		["500"] = Color3.fromHex("#0ea5e9"),
 201 | 		["600"] = Color3.fromHex("#0284c7"),
 202 | 		["700"] = Color3.fromHex("#0369a1"),
 203 | 		["800"] = Color3.fromHex("#075985"),
 204 | 		["900"] = Color3.fromHex("#0c4a6e"),
 205 | 		["950"] = Color3.fromHex("#082f49"),
 206 | 	},
 207 | 	Blue = {
 208 | 		["50"] = Color3.fromHex("#eff6ff"),
 209 | 		["100"] = Color3.fromHex("#dbeafe"),
 210 | 		["200"] = Color3.fromHex("#bfdbfe"),
 211 | 		["300"] = Color3.fromHex("#93c5fd"),
 212 | 		["400"] = Color3.fromHex("#60a5fa"),
 213 | 		["500"] = Color3.fromHex("#3b82f6"),
 214 | 		["600"] = Color3.fromHex("#2563eb"),
 215 | 		["700"] = Color3.fromHex("#1d4ed8"),
 216 | 		["800"] = Color3.fromHex("#1e40af"),
 217 | 		["900"] = Color3.fromHex("#1e3a8a"),
 218 | 		["950"] = Color3.fromHex("#172554"),
 219 | 	},
 220 | 	Indigo = {
 221 | 		["50"] = Color3.fromHex("#eef2ff"),
 222 | 		["100"] = Color3.fromHex("#e0e7ff"),
 223 | 		["200"] = Color3.fromHex("#c7d2fe"),
 224 | 		["300"] = Color3.fromHex("#a5b4fc"),
 225 | 		["400"] = Color3.fromHex("#818cf8"),
 226 | 		["500"] = Color3.fromHex("#6366f1"),
 227 | 		["600"] = Color3.fromHex("#4f46e5"),
 228 | 		["700"] = Color3.fromHex("#4338ca"),
 229 | 		["800"] = Color3.fromHex("#3730a3"),
 230 | 		["900"] = Color3.fromHex("#312e81"),
 231 | 		["950"] = Color3.fromHex("#1e1b4b"),
 232 | 	},
 233 | 	Violet = {
 234 | 		["50"] = Color3.fromHex("#f5f3ff"),
 235 | 		["100"] = Color3.fromHex("#ede9fe"),
 236 | 		["200"] = Color3.fromHex("#ddd6fe"),
 237 | 		["300"] = Color3.fromHex("#c4b5fd"),
 238 | 		["400"] = Color3.fromHex("#a78bfa"),
 239 | 		["500"] = Color3.fromHex("#8b5cf6"),
 240 | 		["600"] = Color3.fromHex("#7c3aed"),
 241 | 		["700"] = Color3.fromHex("#6d28d9"),
 242 | 		["800"] = Color3.fromHex("#5b21b6"),
 243 | 		["900"] = Color3.fromHex("#4c1d95"),
 244 | 		["950"] = Color3.fromHex("#2e1065"),
 245 | 	},
 246 | 	Purple = {
 247 | 		["50"] = Color3.fromHex("#faf5ff"),
 248 | 		["100"] = Color3.fromHex("#f3e8ff"),
 249 | 		["200"] = Color3.fromHex("#e9d5ff"),
 250 | 		["300"] = Color3.fromHex("#d8b4fe"),
 251 | 		["400"] = Color3.fromHex("#c084fc"),
 252 | 		["500"] = Color3.fromHex("#a855f7"),
 253 | 		["600"] = Color3.fromHex("#9333ea"),
 254 | 		["700"] = Color3.fromHex("#7e22ce"),
 255 | 		["800"] = Color3.fromHex("#6b21a8"),
 256 | 		["900"] = Color3.fromHex("#581c87"),
 257 | 		["950"] = Color3.fromHex("#3b0764"),
 258 | 	},
 259 | 	Fuchsia = {
 260 | 		["50"] = Color3.fromHex("#fdf4ff"),
 261 | 		["100"] = Color3.fromHex("#fae8ff"),
 262 | 		["200"] = Color3.fromHex("#f5d0fe"),
 263 | 		["300"] = Color3.fromHex("#f0abfc"),
 264 | 		["400"] = Color3.fromHex("#e879f9"),
 265 | 		["500"] = Color3.fromHex("#d946ef"),
 266 | 		["600"] = Color3.fromHex("#c026d3"),
 267 | 		["700"] = Color3.fromHex("#a21caf"),
 268 | 		["800"] = Color3.fromHex("#86198f"),
 269 | 		["900"] = Color3.fromHex("#701a75"),
 270 | 		["950"] = Color3.fromHex("#4a044e"),
 271 | 	},
 272 | 	Pink = {
 273 | 		["50"] = Color3.fromHex("#fdf2f8"),
 274 | 		["100"] = Color3.fromHex("#fce7f3"),
 275 | 		["200"] = Color3.fromHex("#fbcfe8"),
 276 | 		["300"] = Color3.fromHex("#f9a8d4"),
 277 | 		["400"] = Color3.fromHex("#f472b6"),
 278 | 		["500"] = Color3.fromHex("#ec4899"),
 279 | 		["600"] = Color3.fromHex("#db2777"),
 280 | 		["700"] = Color3.fromHex("#be185d"),
 281 | 		["800"] = Color3.fromHex("#9d174d"),
 282 | 		["900"] = Color3.fromHex("#831843"),
 283 | 		["950"] = Color3.fromHex("#500724"),
 284 | 	},
 285 | 	Rose = {
 286 | 		["50"] = Color3.fromHex("#fff1f2"),
 287 | 		["100"] = Color3.fromHex("#ffe4e6"),
 288 | 		["200"] = Color3.fromHex("#fecdd3"),
 289 | 		["300"] = Color3.fromHex("#fda4af"),
 290 | 		["400"] = Color3.fromHex("#fb7185"),
 291 | 		["500"] = Color3.fromHex("#f43f5e"),
 292 | 		["600"] = Color3.fromHex("#e11d48"),
 293 | 		["700"] = Color3.fromHex("#be123c"),
 294 | 		["800"] = Color3.fromHex("#9f1239"),
 295 | 		["900"] = Color3.fromHex("#881337"),
 296 | 		["950"] = Color3.fromHex("#4c0519"),
 297 | 	},
 298 | }
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Util/CombineProps.luau`
<details>
<summary>View Source (36 lines)</summary>

```lua
   1 | --[=[
   2 | 		@function CombineProps
   3 | 		@within Util
   4 | 
   5 | 		@param Source Fusion.PropertyTable
   6 | 		@param Target Fusion.PropertyTable
   7 | 		@param ExcludedKeys { any }?
   8 | 		@return Fusion.PropertyTable
   9 | 		
  10 | 		Combines two sets of props for easy passthrough, adding `Source`'s props to `Target`. If a prop is already in `Target`, it will be overridden.
  11 | ]=]
  12 | 
  13 | local OnyxUI = script.Parent.Parent
  14 | local Fusion = require(OnyxUI.Parent.Fusion)
  15 | 
  16 | local function CombineProps(
  17 | 	Source: Fusion.PropertyTable,
  18 | 	Target: Fusion.PropertyTable,
  19 | 	ExcludedKeys: { any }?
  20 | ): Fusion.PropertyTable
  21 | 	for Key, Value in pairs(Source) do
  22 | 		if (typeof(Value) == "table") and (Value.kind == nil) and (typeof(Target[Key]) == "table") then
  23 | 			Target[Key] = CombineProps(Value, Target[Key])
  24 | 		else
  25 | 			if (ExcludedKeys ~= nil) and (table.find(ExcludedKeys, Key) ~= nil) then
  26 | 				continue
  27 | 			end
  28 | 
  29 | 			Target[Key] = Value
  30 | 		end
  31 | 	end
  32 | 
  33 | 	return Target
  34 | end
  35 | 
  36 | return CombineProps
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Util/Emphasize.luau`
<details>
<summary>View Source (21 lines)</summary>

```lua
   1 | --[=[
   2 |   @function Emphasize
   3 |   @within Util
   4 | 
   5 |   @param Color Color3
   6 |   @param Emphasis number
   7 |   @return Color3
   8 | 
   9 |   Lightens/darkens the given color, with respect to "true" (perceived) brightness.
  10 | 
  11 |   Check out [ColorUtils](https://github.com/cxmeel/colour-utils) for a more comprehensive set of color utilities.
  12 | ]=]
  13 | 
  14 | local OnyxUI = script.Parent.Parent
  15 | local ColorUtils = require(OnyxUI.Parent.ColorUtils)
  16 | 
  17 | local function Emphasize(Color: Color3, Emphasis: number): Color3
  18 | 	return ColorUtils.Emphasize(Color, Emphasis * (1 + ColorUtils.GetPerceivedBrightness(Color)))
  19 | end
  20 | 
  21 | return Emphasize
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Util/EnsureValue.luau`
<details>
<summary>View Source (21 lines)</summary>

```lua
   1 | --[=[
   2 | 	@function EnsureValue
   3 | 	@within Util
   4 | 
   5 | 	@param Scope Fusion.Scope<any>
   6 | 	@param Value Fusion.UsedAs<any>
   7 | 	@return Fusion.Value<Fusion.Scope<any>, any>
   8 | 	
   9 | 	Converts the `Value` argument to a `Fusion.Value` object, if it is not one already.
  10 | ]=]
  11 | 
  12 | local OnyxUI = script.Parent.Parent
  13 | local Fusion = require(OnyxUI.Parent.Fusion)
  14 | 
  15 | return function(Scope: Fusion.Scope<any>, Value: Fusion.UsedAs<any>): Fusion.Value<Fusion.Scope<any>, any>
  16 | 	if (typeof(Value) == "table") and (Value.kind == "Value") then
  17 | 		return Value
  18 | 	else
  19 | 		return Fusion.Value(Scope, Fusion.peek(Value))
  20 | 	end
  21 | end
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Util/Fallback.luau`
<details>
<summary>View Source (44 lines)</summary>

```lua
   1 | --[=[
   2 | 	@function Fallback
   3 | 	@within Util
   4 | 
   5 | 	@param Value Fusion.UsedAs<any>
   6 | 	@param Fallback any
   7 | 	@return any
   8 | 	
   9 | 	Defaults the given `Value` to `Fallback` if nil.
  10 | ]=]
  11 | 
  12 | local OnyxUI = script.Parent.Parent
  13 | local Fusion = require(OnyxUI.Parent.Fusion)
  14 | 
  15 | export type Any = Fusion.UsedAs<any>
  16 | export type AnyDictionary = Any | { [any]: Any | AnyDictionary }
  17 | 
  18 | local function IsReactive(Value: Any)
  19 | 	return (typeof(Value) == "table") and (Value.scope ~= nil)
  20 | end
  21 | 
  22 | local function FallbackUtil(Preferred: Any, Fallback: Any)
  23 | 	if Preferred == nil then
  24 | 		return Fallback
  25 | 	end
  26 | 
  27 | 	return Preferred
  28 | end
  29 | 
  30 | local function FallbackDictionary(Preferred: AnyDictionary, Fallback: AnyDictionary)
  31 | 	if (not IsReactive(Preferred)) and (not IsReactive(Fallback)) then
  32 | 		if (typeof(Preferred) == "table") and (typeof(Fallback) == "table") then
  33 | 			for Key, Value in pairs(Fallback) do
  34 | 				Preferred[Key] = FallbackUtil(Preferred[Key], Value)
  35 | 			end
  36 | 
  37 | 			return Preferred
  38 | 		end
  39 | 	end
  40 | 
  41 | 	return FallbackUtil(Preferred, Fallback)
  42 | end
  43 | 
  44 | return FallbackDictionary
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Util/init.luau`
<details>
<summary>View Source (27 lines)</summary>

```lua
   1 | --[=[
   2 | 		@class Util
   3 | 		
   4 | 		Important utilities for UI development.
   5 | ]=]
   6 | 
   7 | local Colors = require(script.Colors)
   8 | local EnsureValue = require(script.EnsureValue)
   9 | local CombineProps = require(script.CombineProps)
  10 | local Fallback = require(script.Fallback)
  11 | local Emphasize = require(script.Emphasize)
  12 | local Unit = require(script.Unit)
  13 | 
  14 | return {
  15 | 	Colors = Colors,
  16 | 	EnsureValue = EnsureValue,
  17 | 	CombineProps = CombineProps,
  18 | 	Fallback = Fallback,
  19 | 	Emphasize = Emphasize,
  20 | 
  21 | 	Vector2 = Unit.Vector2,
  22 | 	UDim = Unit.UDim,
  23 | 	UDim2 = Unit.UDim2,
  24 | 	UDim2Offset = Unit.UDim2Offset,
  25 | 	UDim2Scale = Unit.UDim2Scale,
  26 | 	Font = Unit.Font,
  27 | }
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Util/Unit.luau`
<details>
<summary>View Source (121 lines)</summary>

```lua
   1 | local OnyxUI = script.Parent.Parent
   2 | local Fusion = require(OnyxUI.Parent.Fusion)
   3 | 
   4 | local Unit = {}
   5 | 
   6 | --[=[
   7 | 	@function Vector2
   8 | 	@within Util
   9 | 
  10 | 	@param Scope Fusion.Scope(typeof(Fusion))
  11 | 	@param X Fusion.UsedAs<number>
  12 | 	@param Y Fusion.UsedAs<number>
  13 | 	@return Fusion.Computed<Vector2>
  14 | ]=]
  15 | function Unit.Vector2(
  16 | 	Scope: Fusion.Scope<typeof(Fusion)>,
  17 | 	X: Fusion.UsedAs<number>,
  18 | 	Y: Fusion.UsedAs<number>
  19 | ): Fusion.Computed<Vector2>
  20 | 	return Scope:Computed(function(Use)
  21 | 		return Vector2.new(Use(X), Use(Y))
  22 | 	end)
  23 | end
  24 | 
  25 | --[=[
  26 | 	@function UDim
  27 | 	@within Util
  28 | 
  29 | 	@param Scope Fusion.Scope<typeof(Fusion)>
  30 | 	@param Scale Fusion.UsedAs<number>
  31 | 	@param Offset Fusion.UsedAs<number>
  32 | 	@return Fusion.Computed<UDim>
  33 | ]=]
  34 | function Unit.UDim(
  35 | 	Scope: Fusion.Scope<typeof(Fusion)>,
  36 | 	Scale: Fusion.UsedAs<number>,
  37 | 	Offset: Fusion.UsedAs<number>
  38 | ): Fusion.Computed<UDim>
  39 | 	return Scope:Computed(function(Use)
  40 | 		return UDim.new(Use(Scale), Use(Offset))
  41 | 	end)
  42 | end
  43 | 
  44 | --[=[
  45 | 	@function UDim2
  46 | 	@within Util
  47 | 
  48 | 	@param Scope Fusion.Scope<typeof(Fusion)>
  49 | 	@param XScale Fusion.UsedAs<number>
  50 | 	@param XOffset Fusion.UsedAs<number>
  51 | 	@param YScale Fusion.UsedAs<number>
  52 | 	@param YOffset Fusion.UsedAs<number>
  53 | 	@return Fusion.Computed<UDim2>
  54 | ]=]
  55 | function Unit.UDim2(
  56 | 	Scope: Fusion.Scope<typeof(Fusion)>,
  57 | 	XScale: Fusion.UsedAs<number>,
  58 | 	XOffset: Fusion.UsedAs<number>,
  59 | 	YScale: Fusion.UsedAs<number>,
  60 | 	YOffset: Fusion.UsedAs<number>
  61 | ): Fusion.Computed<UDim2>
  62 | 	return Scope:Computed(function(Use)
  63 | 		return UDim2.new(Use(XScale), Use(XOffset), Use(YScale), Use(YOffset))
  64 | 	end)
  65 | end
  66 | 
  67 | --[=[
  68 | 	@function UDim2Offset
  69 | 	@within Util
  70 | 
  71 | 	@param Scope Fusion.Scope<typeof(Fusion)>
  72 | 	@param X Fusion.UsedAs<number>
  73 | 	@param Y Fusion.UsedAs<number>
  74 | 	@return Fusion.Computed<UDim2>
  75 | ]=]
  76 | function Unit.UDim2Offset(
  77 | 	Scope: Fusion.Scope<typeof(Fusion)>,
  78 | 	X: Fusion.UsedAs<number>,
  79 | 	Y: Fusion.UsedAs<number>
  80 | ): Fusion.Computed<UDim2>
  81 | 	return Unit.UDim2(Scope, 0, X, 0, Y)
  82 | end
  83 | 
  84 | --[=[
  85 | 	@function UDim2Scale
  86 | 	@within Util
  87 | 
  88 | 	@param Scope Fusion.Scope<typeof(Fusion)>
  89 | 	@param X Fusion.UsedAs<number>
  90 | 	@param Y Fusion.UsedAs<number>
  91 | 	@return Fusion.Computed<UDim2>
  92 | ]=]
  93 | function Unit.UDim2Scale(
  94 | 	Scope: Fusion.Scope<typeof(Fusion)>,
  95 | 	X: Fusion.UsedAs<number>,
  96 | 	Y: Fusion.UsedAs<number>
  97 | ): Fusion.Computed<UDim2>
  98 | 	return Unit.UDim2(Scope, X, 0, Y, 0)
  99 | end
 100 | 
 101 | --[=[
 102 | 	@function Font
 103 | 	@within Util
 104 | 
 105 | 	@param Scope Fusion.Scope<typeof(Fusion)>
 106 | 	@param X Fusion.UsedAs<number>
 107 | 	@param Y Fusion.UsedAs<number>
 108 | 	@return Fusion.Computed<Font>
 109 | ]=]
 110 | function Unit.Font(
 111 | 	Scope: Fusion.Scope<typeof(Fusion)>,
 112 | 	Family: Fusion.UsedAs<string>,
 113 | 	Weight: Fusion.UsedAs<Enum.FontWeight>?,
 114 | 	Style: Fusion.UsedAs<Enum.FontStyle>?
 115 | ): Fusion.Computed<Font>
 116 | 	return Scope:Computed(function(Use)
 117 | 		return Font.new(Use(Family), Use(Weight), Use(Style) or Enum.FontStyle.Normal)
 118 | 	end)
 119 | end
 120 | 
 121 | return Unit
```
</details>

## ğŸŒ™ `Packages/_Index/imavafe_onyx-ui@1.0.2/onyx-ui/src/Util/ViewportSize.luau`
<details>
<summary>View Source (40 lines)</summary>

```lua
   1 | local Workspace = game:GetService("Workspace")
   2 | 
   3 | local ViewportSize = {
   4 | 	Size = Vector2.new(),
   5 | 	SizeListener = nil,
   6 | 	Observers = {},
   7 | }
   8 | 
   9 | function ViewportSize:Observe(Callback: (Vector2) -> ())
  10 | 	table.insert(ViewportSize.Observers, Callback)
  11 | 	Callback(ViewportSize.Size)
  12 | end
  13 | 
  14 | function ViewportSize:_SetSize(Size: Vector2)
  15 | 	ViewportSize.Size = Size
  16 | 
  17 | 	for _, Callback in ViewportSize.Observers do
  18 | 		Callback(Size)
  19 | 	end
  20 | end
  21 | 
  22 | function ViewportSize:_SetCamera(Camera: Camera)
  23 | 	if ViewportSize.SizeListener ~= nil then
  24 | 		ViewportSize.SizeListener:Disconnect()
  25 | 	end
  26 | 
  27 | 	ViewportSize:_SetSize(Camera.ViewportSize)
  28 | 
  29 | 	ViewportSize.SizeListener = Camera:GetPropertyChangedSignal("ViewportSize"):Connect(function()
  30 | 		ViewportSize:_SetSize(Camera.ViewportSize)
  31 | 	end)
  32 | end
  33 | 
  34 | Workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
  35 | 	ViewportSize:_SetCamera(Workspace.CurrentCamera)
  36 | end)
  37 | 
  38 | ViewportSize:_SetCamera(Workspace.CurrentCamera)
  39 | 
  40 | return ViewportSize
```
</details>

## ğŸŒ™ `Packages/Fusion.lua`
<details>
<summary>View Source (1 lines)</summary>

```lua
   1 | return require(script.Parent._Index["elttob_fusion@0.3.0"]["fusion"])
```
</details>

## ğŸŒ™ `Packages/onyx-ui.lua`
<details>
<summary>View Source (1 lines)</summary>

```lua
   1 | return require(script.Parent._Index["imavafe_onyx-ui@1.0.2"]["onyx-ui"])
```
</details>

## ğŸŒ™ `Packages/Promise.lua`
<details>
<summary>View Source (1 lines)</summary>

```lua
   1 | return require(script.Parent._Index["evaera_promise@4.0.0"]["promise"])
```
</details>

## ğŸŒ™ `Packages/topbarplus.lua`
<details>
<summary>View Source (1 lines)</summary>

```lua
   1 | return require(script.Parent._Index["1foreverhd_topbarplus@3.4.0"]["topbarplus"])
```
</details>

